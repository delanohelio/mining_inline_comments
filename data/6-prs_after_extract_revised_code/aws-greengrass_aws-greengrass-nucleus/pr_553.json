{"pr_number": 553, "pr_title": "in-meory-spooler with publish request", "pr_createdAt": "2020-10-21T08:24:12Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2MTQyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509361428", "bodyText": "undo this change, it isn't helping anything", "author": "MikeDombo", "createdAt": "2020-10-21T14:57:44Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -122,11 +122,13 @@ public void onConnectionResumed(boolean sessionPresent) {\n     }\n \n     CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        return connect().thenCompose((b) -> {\n+        CompletableFuture<Integer> future = new CompletableFuture();", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex 4add7883af..b96ac9a3e2 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -121,14 +121,12 @@ class AwsIotMqttClient implements Closeable {\n \n     }\n \n-    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        CompletableFuture<Integer> future = new CompletableFuture();\n-        future = connect().thenCompose((b) -> {\n+    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain)      {\n+        return connect().thenCompose((b) -> {\n             logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n                     .log(\"Publishing message\");\n             return connection.publish(message, qos, retain);\n         });\n-        return future;\n     }\n \n     void reconnect() throws TimeoutException, ExecutionException, InterruptedException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTQwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365407", "bodyText": "either return a future which completes when we actually send the message, or else return an already completed future.", "author": "MikeDombo", "createdAt": "2020-10-21T15:02:36Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTkwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365901", "bodyText": "return spool.add(request)", "author": "MikeDombo", "createdAt": "2020-10-21T15:03:12Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjExMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366113", "bodyText": "remove this log", "author": "MikeDombo", "createdAt": "2020-10-21T15:03:30Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjQ2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366463", "bodyText": "log the exception", "author": "MikeDombo", "createdAt": "2020-10-21T15:03:56Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+                            spool.pop();\n+                        }\n+                    } catch (Throwable t) {\n+                        isSpoolingMessages.compareAndSet(true, false);\n+                        logger.atError().log(\"Caught exception while spooling the message\");", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NzgwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509367805", "bodyText": "you need to make sure that we only ever have 1 instance of this thread. Right now this isn't very safe", "author": "MikeDombo", "createdAt": "2020-10-21T15:05:39Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODM1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368353", "bodyText": "this is going to queue all the messages for publishing all at once. You would need to wait for the publish to complete otherwise", "author": "MikeDombo", "createdAt": "2020-10-21T15:06:21Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368643", "bodyText": "synchronized", "author": "MikeDombo", "createdAt": "2020-10-21T15:06:43Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4ODM2OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512288368", "bodyText": "The spool should use thread safe data structures, so let's try to avoid making this synchronized, if we can avoid it.", "author": "jbutler", "createdAt": "2020-10-26T21:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MDA0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512290048", "bodyText": "This isn't the spooler and it isn't threadsafe and throughput doesn't matter", "author": "MikeDombo", "createdAt": "2020-10-26T21:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2NDA2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513064062", "bodyText": "You're right.\nOn second look, this should actually just be private though. The public interface is publish().", "author": "jbutler", "createdAt": "2020-10-27T22:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTA4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369086", "bodyText": "make this an enum", "author": "MikeDombo", "createdAt": "2020-10-21T15:07:17Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex f430aac1c5..f98c38dfba 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -6,11 +6,10 @@ import lombok.Getter;\n \n @Builder\n @AllArgsConstructor\n+@Getter\n public class SpoolerConfig {\n-    @Getter\n-    final String spoolStorageType;\n-    @Getter\n-    final int spoolMaxMessageQueueSizeInBytes;\n-    @Getter\n-    final boolean keepQos0WhenOffline;\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;\n+    public int maxRetried;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTIyMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369222", "bodyText": "make this a long", "author": "MikeDombo", "createdAt": "2020-10-21T15:07:26Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;\n+    @Getter\n+    final int spoolMaxMessageQueueSizeInBytes;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex f430aac1c5..f98c38dfba 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -6,11 +6,10 @@ import lombok.Getter;\n \n @Builder\n @AllArgsConstructor\n+@Getter\n public class SpoolerConfig {\n-    @Getter\n-    final String spoolStorageType;\n-    @Getter\n-    final int spoolMaxMessageQueueSizeInBytes;\n-    @Getter\n-    final boolean keepQos0WhenOffline;\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;\n+    public int maxRetried;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTQ3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369478", "bodyText": "what is this ID used for?", "author": "MikeDombo", "createdAt": "2020-10-21T15:07:45Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import javax.validation.constraints.NotNull;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+public class SpoolMessage {\n+    @NotNull @Getter\n+    private final Long MessageID;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\nindex 257bf9fd19..1ea2dfdbe4 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n\n@@ -1,14 +1,24 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.mqttclient.PublishRequest;\n-import javax.validation.constraints.NotNull;\n import lombok.Builder;\n import lombok.Getter;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n @Builder\n public class SpoolMessage {\n-    @NotNull @Getter\n-    private final Long MessageID;\n-    @NotNull @Getter\n-    private final PublishRequest publishRequest;\n+    @NotNull\n+    public  PublishRequest publishRequest;\n+    @Builder.Default\n+    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @Builder.Default\n+    public AtomicInteger retried = new AtomicInteger(0);\n+\n+    public SpoolMessage(PublishRequest request) {\n+        publishRequest = request;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MDU3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509370578", "bodyText": "enum", "author": "MikeDombo", "createdAt": "2020-10-21T15:09:06Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MTE5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509371196", "bodyText": "we can get rid of the minimum", "author": "MikeDombo", "createdAt": "2020-10-21T15:09:45Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MjM2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509372367", "bodyText": "Seems unused, remove it.", "author": "MikeDombo", "createdAt": "2020-10-21T15:11:10Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDEwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509374106", "bodyText": "this error message is not accurate for this exception. Don't log anything, just do Thread.currentThread().interrupt(), or, let this method throw InterruptedException", "author": "MikeDombo", "createdAt": "2020-10-21T15:13:24Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509374459", "bodyText": "why is this public?", "author": "MikeDombo", "createdAt": "2020-10-21T15:13:52Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;\n+        } catch (InterruptedException e) {\n+            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n+                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n+        }\n+        return truncated;\n+    }\n+\n+    public int messageCount() {\n+        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n+    }\n+\n+    @Override\n+    public int curSpoolerSizeInBytes() {\n+        return curMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public int maxSpoolerSizeInBytes() {\n+        return maxMessageQueueSizeInBytes;\n+    }\n+\n+    public PublishRequest removeOldestMessage() throws InterruptedException {", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTI2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509375263", "bodyText": "let this method throw interruptedexception", "author": "MikeDombo", "createdAt": "2020-10-21T15:14:53Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;\n+        } catch (InterruptedException e) {\n+            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjQwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376401", "bodyText": "curMessageQueueSizeInBytes must be an AtomicLong", "author": "MikeDombo", "createdAt": "2020-10-21T15:16:17Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjU3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376579", "bodyText": "do not log the payload", "author": "MikeDombo", "createdAt": "2020-10-21T15:16:32Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3Njk0OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376949", "bodyText": "I'm not sure about info, this may be more like debug, but I'd want to know what others think", "author": "MikeDombo", "createdAt": "2020-10-21T15:16:59Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDEyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380125", "bodyText": "this logic doesn't make much sense. You should be checking if the queue that you are taking from is empty or not. takeFirst is a blocking call, so it will wait forever, until it gets a value, which I don't think this is what you intend because you need to read from 2 queues, you cannot just block on one of them", "author": "MikeDombo", "createdAt": "2020-10-21T15:20:53Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 938395955f..55d5c8d987 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -1,122 +1,27 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import java.util.concurrent.BlockingDeque;\n-import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n public class InMemorySpool implements CloudMessageSpool {\n \n-    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n-\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n-    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n-    private int curMessageQueueSizeInBytes = 0;\n-    private int maxMessageQueueSizeInBytes;\n-\n-    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n-        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n-    }\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n \n     @Override\n-    public void pop() {\n-        try {\n-            if (messageQueueOfQos0.isEmpty()) {\n-                messageQueueOfQos1And2.takeFirst();\n-                return;\n-            }\n-            if (messageQueueOfQos1And2.isEmpty()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-\n-            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n-                messageQueueOfQos0.takeFirst();\n-                return;\n-            }\n-            messageQueueOfQos1And2.takeFirst();\n-        } catch (InterruptedException e) {\n-            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n-        }\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n     }\n \n     @Override\n-    public PublishRequest peek() {\n-        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n-        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n-        }\n-        if (!messageQueueOfQos1And2.isEmpty()) {\n-            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {\n+            messages.remove(messageId);\n         }\n-\n-        if (spooledMessageFromQueueOfQos0 == null) {\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        if (spooledMessageFromQueueOfQos0 != null) {\n-            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n-                return spooledMessageFromQueueOfQos0.getPublishRequest();\n-            }\n-            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n-        }\n-        return null;\n     }\n \n     @Override\n-    public boolean add(Long messageId, PublishRequest request) {\n-        SpoolMessage message = new SpoolMessage(messageId, request);\n-        int qos = request.getQos().getValue();\n-        int messageSizeInBytes = request.getPayload().length;\n-        boolean truncated = false;\n-        try {\n-            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n-                truncated = true;\n-                PublishRequest removedRequest = removeOldestMessage();\n-                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n-                        .kv(\"qos\", removedRequest.getQos())\n-                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n-            }\n-            if (qos == 0) {\n-                messageQueueOfQos0.putLast(message);\n-            } else {\n-                messageQueueOfQos1And2.putLast(message);\n-            }\n-            curMessageQueueSizeInBytes += messageSizeInBytes;\n-        } catch (InterruptedException e) {\n-            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n-                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n-        }\n-        return truncated;\n-    }\n-\n-    public int messageCount() {\n-        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n-    }\n-\n-    @Override\n-    public int curSpoolerSizeInBytes() {\n-        return curMessageQueueSizeInBytes;\n-    }\n-\n-    @Override\n-    public int maxSpoolerSizeInBytes() {\n-        return maxMessageQueueSizeInBytes;\n-    }\n-\n-    public PublishRequest removeOldestMessage() throws InterruptedException {\n-        PublishRequest removedRequest = null;\n-        // if request has to be dropped when the queue is full, drop the ones with lower qos first.\n-        if (!messageQueueOfQos0.isEmpty()) {\n-            removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-        } else {\n-            if(!messageQueueOfQos1And2.isEmpty()){\n-                removedRequest =  messageQueueOfQos0.takeFirst().getPublishRequest();\n-            }\n-        }\n-        curMessageQueueSizeInBytes -= removedRequest.getPayload().length;\n-        return removedRequest;\n+    public void add(Long id, SpoolMessage message) {\n+        messages.put(id, message);\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTc5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365790", "bodyText": "MessageID -> id", "author": "fengwang666", "createdAt": "2020-10-21T15:03:04Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import javax.validation.constraints.NotNull;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+public class SpoolMessage {\n+    @NotNull @Getter\n+    private final Long MessageID;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\nindex 257bf9fd19..1ea2dfdbe4 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n\n@@ -1,14 +1,24 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.mqttclient.PublishRequest;\n-import javax.validation.constraints.NotNull;\n import lombok.Builder;\n import lombok.Getter;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n @Builder\n public class SpoolMessage {\n-    @NotNull @Getter\n-    private final Long MessageID;\n-    @NotNull @Getter\n-    private final PublishRequest publishRequest;\n+    @NotNull\n+    public  PublishRequest publishRequest;\n+    @Builder.Default\n+    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @Builder.Default\n+    public AtomicInteger retried = new AtomicInteger(0);\n+\n+    public SpoolMessage(PublishRequest request) {\n+        publishRequest = request;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTk2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365960", "bodyText": "Use enum", "author": "fengwang666", "createdAt": "2020-10-21T15:03:17Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex f430aac1c5..f98c38dfba 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -6,11 +6,10 @@ import lombok.Getter;\n \n @Builder\n @AllArgsConstructor\n+@Getter\n public class SpoolerConfig {\n-    @Getter\n-    final String spoolStorageType;\n-    @Getter\n-    final int spoolMaxMessageQueueSizeInBytes;\n-    @Getter\n-    final boolean keepQos0WhenOffline;\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;\n+    public int maxRetried;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjcwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366708", "bodyText": "Move @Getter above the class definition.", "author": "fengwang666", "createdAt": "2020-10-21T15:04:14Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex f430aac1c5..f98c38dfba 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -6,11 +6,10 @@ import lombok.Getter;\n \n @Builder\n @AllArgsConstructor\n+@Getter\n public class SpoolerConfig {\n-    @Getter\n-    final String spoolStorageType;\n-    @Getter\n-    final int spoolMaxMessageQueueSizeInBytes;\n-    @Getter\n-    final boolean keepQos0WhenOffline;\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;\n+    public int maxRetried;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODM4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368389", "bodyText": "Use enum", "author": "fengwang666", "createdAt": "2020-10-21T15:06:24Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTMzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369338", "bodyText": "Remove commented code.", "author": "fengwang666", "createdAt": "2020-10-21T15:07:35Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369686", "bodyText": "Define them as Enum.", "author": "fengwang666", "createdAt": "2020-10-21T15:08:01Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTg2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369863", "bodyText": "add final", "author": "fengwang666", "createdAt": "2020-10-21T15:08:14Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NzkwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509377903", "bodyText": "What's this messageQueue for?", "author": "fengwang666", "createdAt": "2020-10-21T15:18:06Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDA1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380053", "bodyText": "Curious why change this?", "author": "fengwang666", "createdAt": "2020-10-21T15:20:48Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -122,11 +122,13 @@ public void onConnectionResumed(boolean sessionPresent) {\n     }\n \n     CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        return connect().thenCompose((b) -> {\n+        CompletableFuture<Integer> future = new CompletableFuture();\n+        future = connect().thenCompose((b) -> {\n             logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n                     .log(\"Publishing message\");\n             return connection.publish(message, qos, retain);\n         });\n+        return future;\n     }", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1NDg2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509854869", "bodyText": "This is indeed unnecessary change.", "author": "awszztt", "createdAt": "2020-10-22T03:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex 4add7883af..b96ac9a3e2 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -121,14 +121,12 @@ class AwsIotMqttClient implements Closeable {\n \n     }\n \n-    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        CompletableFuture<Integer> future = new CompletableFuture();\n-        future = connect().thenCompose((b) -> {\n+    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain)      {\n+        return connect().thenCompose((b) -> {\n             logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n                     .log(\"Publishing message\");\n             return connection.publish(message, qos, retain);\n         });\n-        return future;\n     }\n \n     void reconnect() throws TimeoutException, ExecutionException, InterruptedException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDg3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380875", "bodyText": "Why is default false? Is this V1 behavior?", "author": "fengwang666", "createdAt": "2020-10-21T15:21:51Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -96,6 +101,9 @@\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private AtomicBoolean isSpoolingMessages = new AtomicBoolean(false);", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1NjkyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509856921", "bodyText": "I planed to have a thread to regularly check whether the queue of the spooler is empty. In case that thread is accidentally interrupted, I create a flag to track whether that thread is still working.", "author": "awszztt", "createdAt": "2020-10-22T03:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1NzM1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509857351", "bodyText": "That's not really a solution. The thread should be able to take care of itself. It needs to handle all possible errors.", "author": "MikeDombo", "createdAt": "2020-10-22T03:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -103,7 +102,6 @@ public class MqttClient implements Closeable {\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n     private final Spool spool;\n     private final ScheduledExecutorService ses;\n-    private AtomicBoolean isSpoolingMessages = new AtomicBoolean(false);\n \n     //\n     // TODO: Handle timeouts and retries\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NjI5MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509386290", "bodyText": "Seems a very busy loop. Is this V1 behavior?", "author": "fengwang666", "createdAt": "2020-10-21T15:28:39Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+                            spool.pop();\n+                        }\n+                    } catch (Throwable t) {\n+                        isSpoolingMessages.compareAndSet(true, false);\n+                        logger.atError().log(\"Caught exception while spooling the message\");\n+                    }\n+                }, 0 , 5 , TimeUnit.SECONDS);", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5NzQxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509397412", "bodyText": "This loop should stop if the spooler is empty.", "author": "fengwang666", "createdAt": "2020-10-21T15:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NjI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 57d04eff23..6bdf3ab65d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -349,41 +349,56 @@ public class MqttClient implements Closeable {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n         boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n-        if (!willDropTheRequest) {\n-            Long messageId = addPublishRequestToSpool(request);\n-            if (isSpoolingMessages.compareAndSet(false, true)){\n-                spoolMessage();\n-            }\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n         }\n-        // TODO-ztong: check whether we need to return a defined future\n-        return new CompletableFuture<Integer>();\n-    }\n \n-    private Long addPublishRequestToSpool(PublishRequest request) {\n-        Long messageId = spool.add(request);\n-        return messageId;\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n     }\n \n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n     public void spoolMessage() {\n         boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n \n         ScheduledFuture<?> handler =\n                 ses.scheduleWithFixedDelay(() -> {\n                     try {\n-                        while(onlineFlag && spool.messageCount() > 0) {\n-                            // TODO : add retry\n-                            PublishRequest request = spool.peek();\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n                             getConnection(false)\n                                     .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-                            spool.pop();\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n                         }\n                     } catch (Throwable t) {\n-                        isSpoolingMessages.compareAndSet(true, false);\n-                        logger.atError().log(\"Caught exception while spooling the message\");\n+                        logger.atError().log(\"Caught exception while spooling the message\", t);\n                     }\n-                }, 0 , 5 , TimeUnit.SECONDS);\n+                }, 0, 5, TimeUnit.SECONDS);\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NzA3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509387078", "bodyText": "You also need to think about the cases when these configurations are dynamically updated during deployment? How would you update them?", "author": "fengwang666", "createdAt": "2020-10-21T15:29:42Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setupSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n+        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n+            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+        }", "originalCommit": "828a6f3681b98d96c8d41f6340511ab47e635f17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM5MTA5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509391097", "bodyText": "hmmm...let me clarify. If any of these parameters change, do we expect to restart the nucleus? If not, then we need to handle the change in the runtime.", "author": "fengwang666", "createdAt": "2020-10-21T15:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NzA3OA=="}], "type": "inlineReview", "revised_code": {"commit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5fc4520c12..5abdd3f715 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,92 +1,212 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n \n public class Spool {\n-    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n \n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private CloudMessageSpool spooler;\n-    // should provide all the customer settings for the spooler\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n     private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n-    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n-    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n-    //private static String GG_SPOOL_STORAGE_TYPE;\n-    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n-    private AtomicLong nextId = new AtomicLong(0);\n-    private SpoolerConfig config;\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n \n-    // Memory storage type specification\n-    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n-    // FileSystem storage type specification\n-    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n     public Spool(Topics mqttTopics) {\n-        config = setupSpoolerConfig(mqttTopics);\n+        config = setSpoolerConfig(mqttTopics);\n         spooler = setupSpooler(config);\n     }\n \n-    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n-        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n-        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n                 .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n                         GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n-        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n-            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n-        }\n-        boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE = Coerce.toBoolean(mqttTopics\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n                 .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n \n-        return new SpoolerConfig(GG_SPOOL_STORAGE_TYPE, GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES\n-                , GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE);\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n     }\n \n     private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n-        if (config.getSpoolStorageType().equals(GG_IN_MEMORY_SPOOL)) {\n-            return new InMemorySpool(config.getSpoolMaxMessageQueueSizeInBytes());\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n         }\n         return null;\n-        //return new PersistentSpool(config.getMaxMessageQueueSizeInBytes());\n+        //return new PersistentSpool();\n     }\n \n-    public Long add(PublishRequest request) {\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n         Long id = nextId.getAndIncrement();\n-        spooler.add(id, request);\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n         return id;\n     }\n \n-    public int maxSpoolerSizeInBytes() {\n-        return spooler.maxSpoolerSizeInBytes();\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n     }\n \n-    public PublishRequest peek() {\n-        return spooler.peek();\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n     }\n \n-    public int messageCount() {\n-        return spooler.messageCount();\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n     }\n \n-    public void pop() {\n-        spooler.pop();\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        curMessageCount.getAndDecrement();\n+        return removedMessageId;\n+    }\n+\n+    public Long messageCount() {\n+        return curMessageCount.get();\n     }\n \n     public SpoolerConfig getSpoolConfig() {\n         return config;\n     }\n+\n }\n \n"}}, {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "message": "in-meory-spooler with publish request", "committedDate": "2020-10-23T09:33:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNTI0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511025243", "bodyText": "reformat.", "author": "MikeDombo", "createdAt": "2020-10-23T17:13:41Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -121,7 +121,7 @@ public void onConnectionResumed(boolean sessionPresent) {\n \n     }\n \n-    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n+    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain)      {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex b96ac9a3e2..f4b22460c7 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -121,10 +126,12 @@ class AwsIotMqttClient implements Closeable {\n \n     }\n \n-    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain)      {\n+    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n+        System.out.println(\"**** hahah 9 ****\");\n         return connect().thenCompose((b) -> {\n             logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n                     .log(\"Publishing message\");\n+            System.out.println(\"**** hahah 10 ****\");\n             return connection.publish(message, qos, retain);\n         });\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNjU3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511026574", "bodyText": "the initial value of hasCalledback is false. So this can't possibly work.", "author": "MikeDombo", "createdAt": "2020-10-23T17:16:15Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NDI1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511044250", "bodyText": "Oh, yes. I think the result needs to be flipped.", "author": "awszztt", "createdAt": "2020-10-23T17:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzQzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511047435", "bodyText": "No, it doesn't", "author": "MikeDombo", "createdAt": "2020-10-23T17:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNjU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzY5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511047697", "bodyText": "You need a separate flag for the online status. hasCalledback cannot be used for that.", "author": "MikeDombo", "createdAt": "2020-10-23T17:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNjU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNzc1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511027756", "bodyText": "definitely log that we're dropping the request at debug", "author": "MikeDombo", "createdAt": "2020-10-23T17:18:28Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTE2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511171169", "bodyText": "Nit: I think I'd prefer to complete this exceptionally instead of using 0 as a sentinel value. We also need to handle the scenario where the spool is full", "author": "jbutler", "createdAt": "2020-10-23T21:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNzc1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTAwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029000", "bodyText": "packetId", "author": "MikeDombo", "createdAt": "2020-10-23T17:20:58Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTEzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029139", "bodyText": "probably should log the throwable if the publish failed.", "author": "MikeDombo", "createdAt": "2020-10-23T17:21:13Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTUxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029516", "bodyText": "you don't need this check. Just call remove", "author": "MikeDombo", "createdAt": "2020-10-23T17:21:56Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n+    }\n+\n+    @Override\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\nindex 55d5c8d987..e4f759efe4 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java\n\n@@ -14,9 +14,7 @@ public class InMemorySpool implements CloudMessageSpool {\n \n     @Override\n     public void removeMessageById(Long messageId) {\n-        if (messages.get(messageId) != null) {\n-            messages.remove(messageId);\n-        }\n+        messages.remove(messageId);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMDMxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511030314", "bodyText": "you need to subscribe to these topics so that the spooler will reconfigure when it changes.", "author": "MikeDombo", "createdAt": "2020-10-23T17:23:30Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMDc1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511030757", "bodyText": "don't trigger off of the packet id, check that the throwable is null or not", "author": "MikeDombo", "createdAt": "2020-10-23T17:24:23Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511031314", "bodyText": "catch InterruptedException separately and kill the thread if that happens. InterruptedException is telling you that someone wants the thread to stop.", "author": "MikeDombo", "createdAt": "2020-10-23T17:25:25Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n+                        }\n+                    } catch (Throwable t) {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzNDg3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511134872", "bodyText": "Do we need to add some logic to recover automatically later?", "author": "awszztt", "createdAt": "2020-10-23T20:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzNTY3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511135674", "bodyText": "No. That only happens when you are shutting down, so we want you to shutdown.", "author": "MikeDombo", "createdAt": "2020-10-23T20:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NDY3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511154672", "bodyText": "But it seems like here will not throw InterruptedException", "author": "awszztt", "createdAt": "2020-10-23T21:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NTI1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511155258", "bodyText": "Calling .get throws interrupted", "author": "MikeDombo", "createdAt": "2020-10-23T21:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTQ3OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511031479", "bodyText": "check !Thread.currentThread().isInterrupted()", "author": "MikeDombo", "createdAt": "2020-10-23T17:25:46Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzAyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511033027", "bodyText": "you need to call get on the future, otherwise again, this is going to run through all the messages and publish them all at once which is not what we want.", "author": "MikeDombo", "createdAt": "2020-10-23T17:28:49Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511033459", "bodyText": "Spooler queue is full... lowercase", "author": "MikeDombo", "createdAt": "2020-10-23T17:29:44Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTI0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512281245", "bodyText": "This isn't the behavior we want. If a Qos1 message is spooled, we need to keep it. We can drop qos0 messages to make room. If we can't make room, then we need to return an error to the client.", "author": "jbutler", "createdAt": "2020-10-26T21:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNDg2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511034860", "bodyText": "I think this may need to be synchronized", "author": "MikeDombo", "createdAt": "2020-10-23T17:32:24Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTMyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511035324", "bodyText": "do these before inserting into the queue, otherwise another thread which is running this same method will have the wrong information.\nReserve the space, then use the space.", "author": "MikeDombo", "createdAt": "2020-10-23T17:33:22Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTgyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512285823", "bodyText": "+1", "author": "jbutler", "createdAt": "2020-10-26T21:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTgzNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511035837", "bodyText": "since this is always an array of size 2, I'm not sure that a List is appropriate. Just return a long[]", "author": "MikeDombo", "createdAt": "2020-10-23T17:34:22Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n+        return id;\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }\n+\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjY2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036663", "bodyText": "this seems very similar to L135 can this duplication be reduced?", "author": "MikeDombo", "createdAt": "2020-10-23T17:35:58Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n+        return id;\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }\n+\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n+    }\n+\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n+    }\n+\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjkwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036904", "bodyText": "Memory or MEMORY and FileSystem or FILE_SYSTEM", "author": "MikeDombo", "createdAt": "2020-10-23T17:36:26Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+public enum SpoolerStorageType {\n+    memory, filesystem", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java\nindex 967b4ae281..bd08d98f4d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java\n\n@@ -1,5 +1,5 @@\n package com.aws.greengrass.mqttclient.spool;\n \n public enum SpoolerStorageType {\n-    memory, filesystem\n+    Memory, FileSystem\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjk5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036993", "bodyText": "private", "author": "MikeDombo", "createdAt": "2020-10-23T17:36:38Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n+@Builder\n+public class SpoolMessage {\n+    @NotNull\n+    public  PublishRequest publishRequest;", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\nindex 1ea2dfdbe4..3720c8822c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n\n@@ -4,21 +4,16 @@ import com.aws.greengrass.mqttclient.PublishRequest;\n import lombok.Builder;\n import lombok.Getter;\n \n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n-import javax.validation.constraints.NotNull;\n+import lombok.NonNull;\n+import lombok.Value;\n \n-@Getter\n @Builder\n+@Value\n+@Getter\n public class SpoolMessage {\n-    @NotNull\n-    public  PublishRequest publishRequest;\n-    @Builder.Default\n-    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @NonNull\n+    public   PublishRequest publishRequest;\n     @Builder.Default\n     public AtomicInteger retried = new AtomicInteger(0);\n-\n-    public SpoolMessage(PublishRequest request) {\n-        publishRequest = request;\n-    }\n }\n"}}, {"oid": "025d047eb2f3cdb8427fc04bd83e080dd918b324", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/025d047eb2f3cdb8427fc04bd83e080dd918b324", "message": "in-meory-spooler with publish request", "committedDate": "2020-10-26T20:08:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2Nzc5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512267793", "bodyText": "What does it mean for the customer to set KeepQos0WhenOffline=false? Do QoS 0 messages get purged from the spool when the MQTT connection drops? Or does it only prevent messages from being spooled when the device is disconnected? As a customer, I would think it's the former.", "author": "jbutler", "createdAt": "2020-10-26T21:05:36Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTY2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512271669", "bodyText": "int isn't big enough - max size is ~2GB. Make this a long", "author": "jbutler", "createdAt": "2020-10-26T21:12:42Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0NjA0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512346045", "bodyText": "Nevermind, you store this in a Long", "author": "jbutler", "createdAt": "2020-10-27T00:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTY2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzcxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512277719", "bodyText": "What are these for?", "author": "jbutler", "createdAt": "2020-10-26T21:24:30Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n+@Builder\n+public class SpoolMessage {\n+    @NotNull\n+    public  PublishRequest publishRequest;\n+    @Builder.Default\n+    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @Builder.Default\n+    public AtomicInteger retried = new AtomicInteger(0);", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\nindex 1ea2dfdbe4..3720c8822c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n\n@@ -4,21 +4,16 @@ import com.aws.greengrass.mqttclient.PublishRequest;\n import lombok.Builder;\n import lombok.Getter;\n \n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n-import javax.validation.constraints.NotNull;\n+import lombok.NonNull;\n+import lombok.Value;\n \n-@Getter\n @Builder\n+@Value\n+@Getter\n public class SpoolMessage {\n-    @NotNull\n-    public  PublishRequest publishRequest;\n-    @Builder.Default\n-    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @NonNull\n+    public   PublishRequest publishRequest;\n     @Builder.Default\n     public AtomicInteger retried = new AtomicInteger(0);\n-\n-    public SpoolMessage(PublishRequest request) {\n-        publishRequest = request;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTcxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512285713", "bodyText": "One of the benefits of using a LinkedBlockingDeque is that it blocks :) But you're trying to use it in a non-blocking manner. Think through what interface you want this spool to have, and then choose an appropriate structure.\nIn my initial skeleton, I used this because I wanted the spool.pop() method to block. The thread waiting for messages would run when connected, and stop when disconnected. Here, you're using a scheduled executor service instead, and are polling. With this model you don't want to block. A simple linked list would work better.", "author": "jbutler", "createdAt": "2020-10-26T21:40:03Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5abdd3f715..983881cf35 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,30 +1,38 @@\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.Arrays;\n-import java.util.List;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n \n public class Spool {\n \n     private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n     private CloudMessageSpool spooler;\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n     private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n \n-    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n     private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n-            = SpoolerStorageType.memory;\n+            = SpoolerStorageType.Memory;\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n     private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MDc5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512290798", "bodyText": "We also need to complete the future that we returned to the client.", "author": "jbutler", "createdAt": "2020-10-26T21:50:59Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MTM1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512291354", "bodyText": "We can't drop messages like this. It breaks the Qos1 contract.", "author": "jbutler", "createdAt": "2020-10-26T21:52:05Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }", "originalCommit": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 6bdf3ab65d..ff9140da88 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -346,11 +354,13 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean onlineFlag = callbackEventManager.hasCallbacked();\n-        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+        System.out.println(\"**** publish ****\");\n+        System.out.println(\"mqttOnline: \" + mqttOnline.get());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         if (willDropTheRequest) {\n+            logger.atDebug().log(\"drop the publish request with Qos 0 when MqttClient is offline\");\n             return CompletableFuture.completedFuture(0);\n         }\n \n"}}, {"oid": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "message": "address the comment", "committedDate": "2020-10-27T00:05:50Z", "type": "commit"}, {"oid": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "message": "address the comment", "committedDate": "2020-10-27T00:05:50Z", "type": "forcePushed"}, {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "message": "leave one messageID queue in the spool class", "committedDate": "2020-10-27T09:07:22Z", "type": "commit"}, {"oid": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "message": "in-meory-spooler with publish request", "committedDate": "2020-10-27T22:41:46Z", "type": "commit"}, {"oid": "7b46b0cd895ee7b189bef4516cc8e1fc34293495", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7b46b0cd895ee7b189bef4516cc8e1fc34293495", "message": "address the comment", "committedDate": "2020-10-27T22:41:46Z", "type": "commit"}, {"oid": "88d6f790b2b32af186b1c759b462343b6ec18bf4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/88d6f790b2b32af186b1c759b462343b6ec18bf4", "message": "leave one messageID queue in the spool class", "committedDate": "2020-10-27T22:41:47Z", "type": "commit"}, {"oid": "62db89f0b7559ceb357cef7824975fcdf75c52c8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62db89f0b7559ceb357cef7824975fcdf75c52c8", "message": "code clean up", "committedDate": "2020-10-27T22:43:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NjQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513056482", "bodyText": "TODO: Clean up this file", "author": "jbutler", "createdAt": "2020-10-27T21:55:34Z", "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -380,27 +380,33 @@ public void replaceAndWait(Map<String, Object> newValue) {\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/config/Topics.java b/src/main/java/com/aws/greengrass/config/Topics.java\nindex f1283820fe..b26cfbe953 100644\n--- a/src/main/java/com/aws/greengrass/config/Topics.java\n+++ b/src/main/java/com/aws/greengrass/config/Topics.java\n\n@@ -373,40 +368,34 @@ public class Topics extends Node implements Iterable<Node> {\n      */\n     public void replaceAndWait(Map<String, Object> newValue) {\n         context.runOnPublishQueueAndWait(() ->\n-                updateFromMap(System.currentTimeMillis(), newValue,\n-                        new UpdateBehaviorTree(UpdateBehaviorTree.UpdateBehavior.REPLACE))\n+                updateFromMap(newValue,\n+                        new UpdateBehaviorTree(UpdateBehaviorTree.UpdateBehavior.REPLACE, System.currentTimeMillis()))\n         );\n         context.runOnPublishQueueAndWait(() -> {});\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {\n-        try {\n-            for (Watcher s : watchers) {\n-                if (s instanceof ChildChanged) {\n-                    ((ChildChanged) s).childChanged(what, child);\n-                }\n-                // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n-            }\n-\n-            if (what.equals(WhatHappened.removed)) {\n-                children.forEach((k, v) -> v.fire(WhatHappened.removed));\n-                return;\n+        for (Watcher s : watchers) {\n+            if (s instanceof ChildChanged) {\n+                ((ChildChanged) s).childChanged(what, child);\n             }\n+            // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n+        }\n \n-            if (child.modtime > this.modtime || children.isEmpty()) {\n-                this.modtime = child.modtime;\n-            } else {\n-                Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n-                this.modtime = n.orElse(child).modtime;\n-            }\n-            if (parentNeedsToKnow()) {\n-                parent.childChanged(what, child);\n-            }\n-        } catch (Throwable t) {\n-            //\"ztong-placeholder\"\n-            logger.atError().log(t);\n+        if (what.equals(WhatHappened.removed)) {\n+            children.forEach((k, v) -> v.fire(WhatHappened.removed));\n+            return;\n         }\n \n+        if (child.modtime > this.modtime || children.isEmpty()) {\n+            this.modtime = child.modtime;\n+        } else {\n+            Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n+            this.modtime = n.orElse(child).modtime;\n+        }\n+        if (parentNeedsToKnow()) {\n+            parent.childChanged(what, child);\n+        }\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513060231", "bodyText": "Why pass this into the constructor? false is the only value that logically makes sense - it can't possibly be connected until the connect() method is called", "author": "jbutler", "createdAt": "2020-10-27T22:03:35Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -88,12 +91,14 @@ public void onConnectionResumed(boolean sessionPresent) {\n     AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n                      Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n                      String clientId, Topics mqttTopics,\n-                     CallbackEventManager callbackEventManager) {\n+                     CallbackEventManager callbackEventManager,\n+                     AtomicBoolean mqttOnline) {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5ODQxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513098419", "bodyText": "It will be updated in the online/offline callbacks or AwsIotMqttClient.connect()", "author": "awszztt", "createdAt": "2020-10-27T23:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyNjU1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514426555", "bodyText": "This isn't being used anywhere. You set it to true but the value is never read.", "author": "jbutler", "createdAt": "2020-10-29T17:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4OTc1MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514489751", "bodyText": "It is passed in from MqttClient and it is read by the spooler in MqttClient. It needs to be passed in so that once the client connects, it is marked as being online.", "author": "MikeDombo", "createdAt": "2020-10-29T18:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2ODk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514568975", "bodyText": "I'm really confused. MqttClient passes this AtomicBoolean in, and the AwsIotMqttClient sets the value as it becomes connected/disconnected. But MqttClient also sets the value as it gets connected/disconnected callbacks, which are aggregated through CallbackEventManager.\nSo I still don't see any purpose for this. AwsIotMqttClient already has a variable tracking connection state - currentlyConnected.", "author": "jbutler", "createdAt": "2020-10-29T21:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3MDgwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514570805", "bodyText": "Think about the startup case. MqttClient is new, it will create an AWS IoT MQTT Client which is not connected. What should the state of the boolean be? If must be false since it isn't connected yet. If this atomic bool wasn't passed in, then it wouldn't be set to online until the connection was first interrupted and then recovered.", "author": "MikeDombo", "createdAt": "2020-10-29T21:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4MjU2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514582569", "bodyText": "Ok, I didn't realize that the onConnect callback doesn't fire until we get disconnected.\nThis seems like the wrong way to solve that problem.", "author": "jbutler", "createdAt": "2020-10-29T21:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NDAyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514584026", "bodyText": "We can assume that we're online immediately, but that doesn't seem right either. Certainly open to suggestion.", "author": "MikeDombo", "createdAt": "2020-10-29T21:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NzE3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514587174", "bodyText": "Why not just invoke callbackEventManager.runOnConnectionResumed() when we connect the first time?\nAlso, we need a subscribe operation to bootstrap a connection. That's a bug, albeit probably a harmless one.", "author": "jbutler", "createdAt": "2020-10-29T21:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4ODIyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514588223", "bodyText": "That can work. Why do you say that we need a subscribe? The first call in subscribe, unsubscribe, and publish all establishes a connection.", "author": "MikeDombo", "createdAt": "2020-10-29T21:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MzcwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514593707", "bodyText": "Except publish has the drop on qos0 logic, which will drop all qos0 messages until an initial connection is established.", "author": "jbutler", "createdAt": "2020-10-29T22:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NTMyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514595324", "bodyText": "Well that's definitely not right", "author": "MikeDombo", "createdAt": "2020-10-29T22:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex ffd48b7dae..b96ac9a3e2 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -91,14 +88,12 @@ class AwsIotMqttClient implements Closeable {\n     AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n                      Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n                      String clientId, Topics mqttTopics,\n-                     CallbackEventManager callbackEventManager,\n-                     AtomicBoolean mqttOnline) {\n+                     CallbackEventManager callbackEventManager) {\n         this.builderProvider = builderProvider;\n         this.clientId = clientId;\n         this.mqttTopics = mqttTopics;\n         this.messageHandler = messageHandler.apply(this);\n         this.callbackEventManager = callbackEventManager;\n-        this.mqttOnline = mqttOnline;\n     }\n \n     // Notes about the CRT MQTT client:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2ODMyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513068329", "bodyText": "We need to talk to kernel team to see if there are use cases for knowing when the message is published. We might be able to get away with completing this future now, but not long term.", "author": "jbutler", "createdAt": "2020-10-27T22:22:57Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 15f53cbddb..593bdf4b21 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -354,22 +341,18 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n-        CompletableFuture<Integer> future = new CompletableFuture<>();\n         if (willDropTheRequest) {\n-            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n-                    + \" with Qos 0 when MqttClient is offline\");\n-            logger.atError().log(e);\n-            future.completeExceptionally(e);\n-            return future;\n+            return CompletableFuture.completedFuture(0);\n         }\n \n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n         try {\n             spool.addMessage(request);\n-        } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+        } catch (InterruptedException e) {\n             future.completeExceptionally(e);\n             return future;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTAxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513069011", "bodyText": "I assume you're doing this for testing. I think I'd prefer to mock out the AwsIotMqttClient rather than doing this", "author": "jbutler", "createdAt": "2020-10-27T22:24:28Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -436,4 +532,8 @@ public void addToCallbackEvents(MqttClientConnectionEvents callbacks) {\n     public int getTimeout() {\n         return Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_OPERATION_TIMEOUT, MQTT_OPERATION_TIMEOUT_KEY));\n     }\n+\n+    protected void setMqttOnline(boolean networkStatus) {\n+        mqttOnline.set(networkStatus);\n+    }", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 15f53cbddb..593bdf4b21 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -532,8 +500,4 @@ public class MqttClient implements Closeable {\n     public int getTimeout() {\n         return Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_OPERATION_TIMEOUT, MQTT_OPERATION_TIMEOUT_KEY));\n     }\n-\n-    protected void setMqttOnline(boolean networkStatus) {\n-        mqttOnline.set(networkStatus);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTQzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513069431", "bodyText": "Why is getSpoolerStorageType needed?", "author": "jbutler", "createdAt": "2020-10-27T22:25:22Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+\n+public interface CloudMessageSpool {\n+\n+    PublishRequest getMessageById(Long id);\n+\n+    void removeMessageById(Long id);\n+\n+    void add(Long id, PublishRequest request);\n+\n+    SpoolerStorageType getSpoolerStorageType();", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513099636", "bodyText": "I am wondering whether it would be allowed to change the spoolerStorageType when kernel is running,", "author": "awszztt", "createdAt": "2020-10-27T23:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NTYwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514455608", "bodyText": "Let's trim it down until we need it. Can always add it later", "author": "jbutler", "createdAt": "2020-10-29T17:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java\nindex ef5ced40a6..ceb6fd7a2e 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java\n\n@@ -1,14 +1,10 @@\n package com.aws.greengrass.mqttclient.spool;\n \n-import com.aws.greengrass.mqttclient.PublishRequest;\n-\n public interface CloudMessageSpool {\n \n-    PublishRequest getMessageById(Long id);\n-\n-    void removeMessageById(Long id);\n+    SpoolMessage getMessageById(Long smallestMessageId);\n \n-    void add(Long id, PublishRequest request);\n+    void removeMessageById(Long messageId);\n \n-    SpoolerStorageType getSpoolerStorageType();\n+    void add(Long id, SpoolMessage message);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzA1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083052", "bodyText": "You already have a method to get the config. Why do you need this?", "author": "jbutler", "createdAt": "2020-10-27T23:02:48Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                if (!(node.childOf(DEVICE_SPOOLER_NAMESPACE))) {\n+                    return;\n+                }\n+\n+                logger.atDebug().log(\"the spooler has been re-configured\");\n+                // re-set the spoolerConfig\n+                setSpoolerConfig(this.deviceConfiguration.getSpoolerNamespace());\n+                // TODO: does this needed? remove the oldest message if the spooler queue should be truncated\n+                if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes() ) {\n+                    removeOldestMessage();\n+                    logger.atDebug().log(\"spooler queue is full and will remove the oldest unsent message\");\n+                }\n+\n+                // TODO: implement the storage type converter after the file-system Spooler is done\n+                if (spooler.getSpoolerStorageType() != getSpoolConfig().getSpoolStorageType()) {\n+                    spoolerStorageTypeConverter();\n+                }\n+            }\n+        });\n+    }\n+\n+    // For unit test\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(this.config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics spoolerTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(spoolerTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes, ggSpoolKeepQos0WhenOffline);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) throws InterruptedException {\n+        queueOfMessageId.putFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        Long id = nextId.getAndIncrement();\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > maxSpoolerSizeInBytes()) {\n+            throw new SpoolerLoadException(\"the size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        // TODO: do we need to add the removed message back if exception is thrown??\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    public void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTkzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513099933", "bodyText": "yes,  I will remove this.", "author": "awszztt", "createdAt": "2020-10-27T23:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 48ec713684..ec114be561 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,32 +1,28 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.config.WhatHappened;\n import com.aws.greengrass.deployment.DeviceConfiguration;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n-\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n \n public class Spool {\n \n-    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private final DeviceConfiguration deviceConfiguration;\n-    private CloudMessageSpool spooler;\n+    private final CloudMessageSpool spooler;\n+\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4Mzc0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083740", "bodyText": "private", "author": "jbutler", "createdAt": "2020-10-27T23:04:51Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                if (!(node.childOf(DEVICE_SPOOLER_NAMESPACE))) {\n+                    return;\n+                }\n+\n+                logger.atDebug().log(\"the spooler has been re-configured\");\n+                // re-set the spoolerConfig\n+                setSpoolerConfig(this.deviceConfiguration.getSpoolerNamespace());\n+                // TODO: does this needed? remove the oldest message if the spooler queue should be truncated\n+                if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes() ) {\n+                    removeOldestMessage();\n+                    logger.atDebug().log(\"spooler queue is full and will remove the oldest unsent message\");\n+                }\n+\n+                // TODO: implement the storage type converter after the file-system Spooler is done\n+                if (spooler.getSpoolerStorageType() != getSpoolConfig().getSpoolStorageType()) {\n+                    spoolerStorageTypeConverter();\n+                }\n+            }\n+        });\n+    }\n+\n+    // For unit test\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(this.config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics spoolerTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(spoolerTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes, ggSpoolKeepQos0WhenOffline);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) throws InterruptedException {\n+        queueOfMessageId.putFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        Long id = nextId.getAndIncrement();\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > maxSpoolerSizeInBytes()) {\n+            throw new SpoolerLoadException(\"the size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        // TODO: do we need to add the removed message back if exception is thrown??\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    public void addMessageToSpooler(Long id, PublishRequest request) {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 48ec713684..ec114be561 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,32 +1,28 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.config.WhatHappened;\n import com.aws.greengrass.deployment.DeviceConfiguration;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n-\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n \n public class Spool {\n \n-    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private final DeviceConfiguration deviceConfiguration;\n-    private CloudMessageSpool spooler;\n+    private final CloudMessageSpool spooler;\n+\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjE5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082193", "bodyText": "remove this. We already catch and log errors in the publish queue", "author": "MikeDombo", "createdAt": "2020-10-27T23:00:23Z", "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -380,27 +380,33 @@ public void replaceAndWait(Map<String, Object> newValue) {\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {\n-        for (Watcher s : watchers) {\n-            if (s instanceof ChildChanged) {\n-                ((ChildChanged) s).childChanged(what, child);\n+        try {\n+            for (Watcher s : watchers) {\n+                if (s instanceof ChildChanged) {\n+                    ((ChildChanged) s).childChanged(what, child);\n+                }\n+                // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n             }\n-            // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n-        }\n \n-        if (what.equals(WhatHappened.removed)) {\n-            children.forEach((k, v) -> v.fire(WhatHappened.removed));\n-            return;\n-        }\n+            if (what.equals(WhatHappened.removed)) {\n+                children.forEach((k, v) -> v.fire(WhatHappened.removed));\n+                return;\n+            }\n \n-        if (child.modtime > this.modtime || children.isEmpty()) {\n-            this.modtime = child.modtime;\n-        } else {\n-            Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n-            this.modtime = n.orElse(child).modtime;\n-        }\n-        if (parentNeedsToKnow()) {\n-            parent.childChanged(what, child);\n+            if (child.modtime > this.modtime || children.isEmpty()) {\n+                this.modtime = child.modtime;\n+            } else {\n+                Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n+                this.modtime = n.orElse(child).modtime;\n+            }\n+            if (parentNeedsToKnow()) {\n+                parent.childChanged(what, child);\n+            }\n+        } catch (Throwable t) {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/config/Topics.java b/src/main/java/com/aws/greengrass/config/Topics.java\nindex f1283820fe..6c22a45c6e 100644\n--- a/src/main/java/com/aws/greengrass/config/Topics.java\n+++ b/src/main/java/com/aws/greengrass/config/Topics.java\n\n@@ -373,40 +368,34 @@ public class Topics extends Node implements Iterable<Node> {\n      */\n     public void replaceAndWait(Map<String, Object> newValue) {\n         context.runOnPublishQueueAndWait(() ->\n-                updateFromMap(System.currentTimeMillis(), newValue,\n-                        new UpdateBehaviorTree(UpdateBehaviorTree.UpdateBehavior.REPLACE))\n+                updateFromMap(newValue,\n+                        new UpdateBehaviorTree(UpdateBehaviorTree.UpdateBehavior.REPLACE, System.currentTimeMillis()))\n         );\n         context.runOnPublishQueueAndWait(() -> {});\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {\n-        try {\n-            for (Watcher s : watchers) {\n-                if (s instanceof ChildChanged) {\n-                    ((ChildChanged) s).childChanged(what, child);\n-                }\n-                // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n-            }\n-\n-            if (what.equals(WhatHappened.removed)) {\n-                children.forEach((k, v) -> v.fire(WhatHappened.removed));\n-                return;\n+        for (Watcher s : watchers) {\n+            if (s instanceof ChildChanged) {\n+                ((ChildChanged) s).childChanged(what, child);\n             }\n+            // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n+        }\n \n-            if (child.modtime > this.modtime || children.isEmpty()) {\n-                this.modtime = child.modtime;\n-            } else {\n-                Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n-                this.modtime = n.orElse(child).modtime;\n-            }\n-            if (parentNeedsToKnow()) {\n-                parent.childChanged(what, child);\n-            }\n-        } catch (Throwable t) {\n-            //\"ztong-placeholder\"\n-            logger.atError().log(t);\n+        if (what.equals(WhatHappened.removed)) {\n+            children.forEach((k, v) -> v.fire(WhatHappened.removed));\n+            return;\n         }\n \n+        if (child.modtime > this.modtime || children.isEmpty()) {\n+            this.modtime = child.modtime;\n+        } else {\n+            Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n+            this.modtime = n.orElse(child).modtime;\n+        }\n+        if (parentNeedsToKnow()) {\n+            parent.childChanged(what, child);\n+        }\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjM0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082346", "bodyText": "should this be under the MQTT namespace? I'd think so.", "author": "MikeDombo", "createdAt": "2020-10-27T23:00:46Z", "path": "src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java", "diffHunk": "@@ -262,6 +263,10 @@ public Topics getMQTTNamespace() {\n         return getTopics(DEVICE_MQTT_NAMESPACE);\n     }\n \n+    public Topics getSpoolerNamespace() {\n+        return getTopics(DEVICE_SPOOLER_NAMESPACE);", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMDU3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514410578", "bodyText": "do getMqttNamespace.lookup(DEVICE_SPOOLER_NAMESPACE) this way the spooler is under mqtt like\nmqtt:\n  stuff\n  spooler:\n    otherStuff", "author": "MikeDombo", "createdAt": "2020-10-29T16:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyMzUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514423519", "bodyText": "+1", "author": "jbutler", "createdAt": "2020-10-29T17:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java b/src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java\nindex 3bbeb8a53e..f77b6e7905 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java\n\n@@ -263,10 +262,6 @@ public class DeviceConfiguration {\n         return getTopics(DEVICE_MQTT_NAMESPACE);\n     }\n \n-    public Topics getSpoolerNamespace() {\n-        return getTopics(DEVICE_SPOOLER_NAMESPACE);\n-    }\n-\n     public Topics getNetworkProxyNamespace() {\n         return getTopics(DEVICE_NETWORK_PROXY_NAMESPACE);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjU5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082594", "bodyText": "compare and set is pointless, just set it to true.", "author": "MikeDombo", "createdAt": "2020-10-27T23:01:27Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -70,6 +72,7 @@ public void onConnectionInterrupted(int errorCode) {\n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n             currentlyConnected.set(true);\n+            mqttOnline.compareAndSet(false, true);", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex ffd48b7dae..bb376df788 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -72,7 +72,7 @@ class AwsIotMqttClient implements Closeable {\n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n             currentlyConnected.set(true);\n-            mqttOnline.compareAndSet(false, true);\n+            mqttOnline.set(true);\n             logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n             // If we didn't reconnect using the same session, then resubscribe to all the topics\n             if (!sessionPresent) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082636", "bodyText": "same as below", "author": "MikeDombo", "createdAt": "2020-10-27T23:01:36Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -50,12 +50,14 @@\n     private MqttClientConnection connection;\n     private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n     private final CallbackEventManager callbackEventManager;\n+    private final AtomicBoolean mqttOnline;\n \n     @Getter(AccessLevel.PACKAGE)\n     private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n+            mqttOnline.compareAndSet(true, false);", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex ffd48b7dae..bb376df788 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -57,7 +57,7 @@ class AwsIotMqttClient implements Closeable {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n-            mqttOnline.compareAndSet(true, false);\n+            mqttOnline.set(false);\n             // Error code 0 means that the disconnection was intentional, so we don't need to log it\n             if (errorCode != 0) {\n                 logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzU0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083544", "bodyText": "No, do not shutdown the executor. You should quit the thread, but don't kill the executor", "author": "MikeDombo", "createdAt": "2020-10-27T23:04:16Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+\n+        // TODO : to determine whether to use ScheduledExecutor\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                            spool.popOutMessagesWithQosZero();\n+                        }\n+\n+                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n+                                && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            PublishRequest request = spool.getMessageById(id);\n+                            if (request == null) {\n+                                continue;\n+                            }\n+\n+                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n+                            CompletableFuture future = awsIotMqttClient\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+\n+                                    future.whenComplete((packetId, throwable) -> {\n+                                        if (throwable != null) {\n+                                            logger.atError().log(\"failed to publish the message \"\n+                                                    + \"via Mqtt Client\", throwable);\n+                                            try {\n+                                                spool.addId(id);\n+                                            } catch (InterruptedException e) {\n+                                                // TODO: if failed, do we need to drop the message from the spooler too?\n+                                                logger.atError().log(\"failed to add the \" +\n+                                                        \"unpublished message back to spooler\");\n+                                            }\n+                                        } else {\n+                                            spool.removeMessageById(id);\n+                                        }\n+                                    });\n+                            // Right now, there is only one message sending out at the momentum.\n+                            future.get();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        ses.shutdownNow();", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 15f53cbddb..f7b9dbc9dc 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -368,64 +371,65 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n+\n         } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n             return future;\n         }\n+        // TODO: if needs to know when the message is published successfully, may need to change here\n         return CompletableFuture.completedFuture(0);\n     }\n \n     /**\n-     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n      */\n-    public void spoolMessage() {\n-\n-        // TODO : to determine whether to use ScheduledExecutor\n-        ScheduledFuture<?> handler =\n-                ses.scheduleWithFixedDelay(() -> {\n-                    try {\n-                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n-                            spool.popOutMessagesWithQosZero();\n-                        }\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n \n-                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n-                                && spool.messageCount() > 0) {\n-                            Long id = spool.popId();\n-                            PublishRequest request = spool.getMessageById(id);\n-                            if (request == null) {\n-                                continue;\n-                            }\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n \n-                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n-                            CompletableFuture future = awsIotMqttClient\n-                                    .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-\n-                                    future.whenComplete((packetId, throwable) -> {\n-                                        if (throwable != null) {\n-                                            logger.atError().log(\"failed to publish the message \"\n-                                                    + \"via Mqtt Client\", throwable);\n-                                            try {\n-                                                spool.addId(id);\n-                                            } catch (InterruptedException e) {\n-                                                // TODO: if failed, do we need to drop the message from the spooler too?\n-                                                logger.atError().log(\"failed to add the \" +\n-                                                        \"unpublished message back to spooler\");\n-                                            }\n-                                        } else {\n-                                            spool.removeMessageById(id);\n-                                        }\n-                                    });\n-                            // Right now, there is only one message sending out at the momentum.\n-                            future.get();\n-                        }\n-                    } catch (InterruptedException e) {\n-                        ses.shutdownNow();\n-                    } catch (Throwable t) {\n-                        logger.atError().log(\"Caught exception while spooling the message\", t);\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;\n+\n+                getConnection(false).publish(new MqttMessage(request.getTopic(),request.getPayload()),\n+                        request.getQos(), request.isRetain()).whenComplete((packetId, throwable) -> {\n+                    if (throwable == null) {\n+                        spool.removeMessageById(finalId);\n+                    } else {\n+                        logger.atError().log(\"failed to publish the message via Mqtt Client\", throwable.toString());\n+                        spool.addId(finalId);\n                     }\n-                }, 0, 5, TimeUnit.SECONDS);\n+                }).get();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.atError().log(\"spooler message is interrupted\");\n+        } catch (ExecutionException e) {\n+            logger.atError().log(\"failed to spool method\", e.toString());\n+        }\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzYzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083635", "bodyText": "Might need a timeout? @jbutler ?", "author": "MikeDombo", "createdAt": "2020-10-27T23:04:32Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+\n+        // TODO : to determine whether to use ScheduledExecutor\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                            spool.popOutMessagesWithQosZero();\n+                        }\n+\n+                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n+                                && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            PublishRequest request = spool.getMessageById(id);\n+                            if (request == null) {\n+                                continue;\n+                            }\n+\n+                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n+                            CompletableFuture future = awsIotMqttClient\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+\n+                                    future.whenComplete((packetId, throwable) -> {\n+                                        if (throwable != null) {\n+                                            logger.atError().log(\"failed to publish the message \"\n+                                                    + \"via Mqtt Client\", throwable);\n+                                            try {\n+                                                spool.addId(id);\n+                                            } catch (InterruptedException e) {\n+                                                // TODO: if failed, do we need to drop the message from the spooler too?\n+                                                logger.atError().log(\"failed to add the \" +\n+                                                        \"unpublished message back to spooler\");\n+                                            }\n+                                        } else {\n+                                            spool.removeMessageById(id);\n+                                        }\n+                                    });\n+                            // Right now, there is only one message sending out at the momentum.\n+                            future.get();", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 15f53cbddb..f7b9dbc9dc 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -368,64 +371,65 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n+\n         } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n             return future;\n         }\n+        // TODO: if needs to know when the message is published successfully, may need to change here\n         return CompletableFuture.completedFuture(0);\n     }\n \n     /**\n-     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n      */\n-    public void spoolMessage() {\n-\n-        // TODO : to determine whether to use ScheduledExecutor\n-        ScheduledFuture<?> handler =\n-                ses.scheduleWithFixedDelay(() -> {\n-                    try {\n-                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n-                            spool.popOutMessagesWithQosZero();\n-                        }\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n \n-                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n-                                && spool.messageCount() > 0) {\n-                            Long id = spool.popId();\n-                            PublishRequest request = spool.getMessageById(id);\n-                            if (request == null) {\n-                                continue;\n-                            }\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n \n-                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n-                            CompletableFuture future = awsIotMqttClient\n-                                    .publish(new MqttMessage(request.getTopic(),\n-                                            request.getPayload()), request.getQos(), request.isRetain());\n-\n-                                    future.whenComplete((packetId, throwable) -> {\n-                                        if (throwable != null) {\n-                                            logger.atError().log(\"failed to publish the message \"\n-                                                    + \"via Mqtt Client\", throwable);\n-                                            try {\n-                                                spool.addId(id);\n-                                            } catch (InterruptedException e) {\n-                                                // TODO: if failed, do we need to drop the message from the spooler too?\n-                                                logger.atError().log(\"failed to add the \" +\n-                                                        \"unpublished message back to spooler\");\n-                                            }\n-                                        } else {\n-                                            spool.removeMessageById(id);\n-                                        }\n-                                    });\n-                            // Right now, there is only one message sending out at the momentum.\n-                            future.get();\n-                        }\n-                    } catch (InterruptedException e) {\n-                        ses.shutdownNow();\n-                    } catch (Throwable t) {\n-                        logger.atError().log(\"Caught exception while spooling the message\", t);\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;\n+\n+                getConnection(false).publish(new MqttMessage(request.getTopic(),request.getPayload()),\n+                        request.getQos(), request.isRetain()).whenComplete((packetId, throwable) -> {\n+                    if (throwable == null) {\n+                        spool.removeMessageById(finalId);\n+                    } else {\n+                        logger.atError().log(\"failed to publish the message via Mqtt Client\", throwable.toString());\n+                        spool.addId(finalId);\n                     }\n-                }, 0, 5, TimeUnit.SECONDS);\n+                }).get();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.atError().log(\"spooler message is interrupted\");\n+        } catch (ExecutionException e) {\n+            logger.atError().log(\"failed to spool method\", e.toString());\n+        }\n     }\n \n     @SuppressWarnings(\"PMD.CloseResource\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDA4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084082", "bodyText": "you don't need to do this, you can just subscribe to the DEVICE_SPOOLER_NAMESPACE changes", "author": "MikeDombo", "createdAt": "2020-10-27T23:05:50Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5NjUwNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513096505", "bodyText": "I am not sure about the action we need to take about some configuration has changed. e.g. kernel is running, but the storageType has changed, does it need to create / delete a file? Or if the size of the queue decreased, does it need to drop the message immediately? if all of the actions are not required, the spooler may even not subscribe anything (I assume the spooler could get also configuration from the mqtt_name_space, right?)", "author": "awszztt", "createdAt": "2020-10-27T23:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5NzQ4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513097481", "bodyText": "We can worry about the reconfiguration actions a little later, just add a todo. But subscribe more specifically", "author": "MikeDombo", "createdAt": "2020-10-27T23:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 48ec713684..ec114be561 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -1,32 +1,28 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient.spool;\n \n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.config.WhatHappened;\n import com.aws.greengrass.deployment.DeviceConfiguration;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.concurrent.BlockingDeque;\n import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.atomic.AtomicLong;\n \n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n-import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n-\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n \n public class Spool {\n \n-    private static final Logger logger = LogManager.getLogger(Spool.class);\n     private final DeviceConfiguration deviceConfiguration;\n-    private CloudMessageSpool spooler;\n+    private final CloudMessageSpool spooler;\n+\n     private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n     private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n     private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDMyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084327", "bodyText": "formatting.\nThese should not be public.", "author": "MikeDombo", "createdAt": "2020-10-27T23:06:32Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+@Getter\n+public class SpoolMessage {\n+    @NonNull\n+    public   PublishRequest publishRequest;", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\ndeleted file mode 100644\nindex 3720c8822c..0000000000\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java\n+++ /dev/null\n\n@@ -1,19 +0,0 @@\n-package com.aws.greengrass.mqttclient.spool;\n-\n-import com.aws.greengrass.mqttclient.PublishRequest;\n-import lombok.Builder;\n-import lombok.Getter;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-import lombok.NonNull;\n-import lombok.Value;\n-\n-@Builder\n-@Value\n-@Getter\n-public class SpoolMessage {\n-    @NonNull\n-    public   PublishRequest publishRequest;\n-    @Builder.Default\n-    public AtomicInteger retried = new AtomicInteger(0);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDQ0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084444", "bodyText": "why is this public? Use a setter if it needs to be changed.", "author": "MikeDombo", "createdAt": "2020-10-27T23:06:50Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@Getter\n+public class SpoolerConfig {\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex 5e404f45a5..64e2f5cf6d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -1,3 +1,8 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient.spool;\n \n import lombok.Builder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084695", "bodyText": "this needs mockito and GG extensions", "author": "MikeDombo", "createdAt": "2020-10-27T23:07:39Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5MTUxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513091510", "bodyText": "may i know what is GG extentions?", "author": "awszztt", "createdAt": "2020-10-27T23:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5MjY0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513092644", "bodyText": "GG extensions is required on all our tests it will catch exceptions in logs and things like that", "author": "MikeDombo", "createdAt": "2020-10-27T23:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTQ4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513785480", "bodyText": "You need the mockito extension otherwise @Mock won't work", "author": "MikeDombo", "createdAt": "2020-10-28T21:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex e30fd85f26..c3d64979f4 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -1,3 +1,8 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient;\n \n import com.aws.greengrass.deployment.DeviceConfiguration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDc4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084781", "bodyText": "instead of new Long. Just use 25L", "author": "MikeDombo", "createdAt": "2020-10-27T23:07:54Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    private SpoolerConfig config;\n+    private BlockingDeque<Long> messageQueueOfQos0;\n+    private BlockingDeque<Long> messageQueueOfQos1And2;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config = SpoolerConfig.builder().keepQos0WhenOffline(true)\n+                .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex e30fd85f26..c3d64979f4 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -1,3 +1,8 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient;\n \n import com.aws.greengrass.deployment.DeviceConfiguration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDg1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084854", "bodyText": "do not use new Long", "author": "MikeDombo", "createdAt": "2020-10-27T23:08:08Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    private SpoolerConfig config;\n+    private BlockingDeque<Long> messageQueueOfQos0;\n+    private BlockingDeque<Long> messageQueueOfQos1And2;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config = SpoolerConfig.builder().keepQos0WhenOffline(true)\n+                .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool = spy(new Spool(deviceConfiguration, config));\n+        doNothing().when(spool).addMessageToSpooler(any(), any());\n+        Long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(any());\n+        verify(spool, times(1)).addMessageToSpooler(any(), any());\n+        assertEquals(1, spool.messageCount());\n+        assertEquals(new Long(0), id);", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex e30fd85f26..c3d64979f4 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -1,3 +1,8 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n package com.aws.greengrass.mqttclient;\n \n import com.aws.greengrass.deployment.DeviceConfiguration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NTAwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513085009", "bodyText": "fix this", "author": "MikeDombo", "createdAt": "2020-10-27T23:08:39Z", "path": "src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java", "diffHunk": "@@ -306,27 +328,193 @@ void GIVEN_incoming_messages_to_2clients_WHEN_received_THEN_subscribers_are_call\n         abc.getLeft().get(0, TimeUnit.SECONDS);\n     }\n \n-    @Test\n-    void GIVEN_incoming_message_WHEN_received_and_subscriber_throws_THEN_still_calls_remaining_subscriptions(\n-            ExtensionContext context) throws ExecutionException, InterruptedException, TimeoutException {\n-        ignoreExceptionWithMessage(context, \"Uncaught!\");\n-        MqttClient client = spy(new MqttClient(deviceConfiguration, (c) -> builder, executorService));\n-        AwsIotMqttClient mockIndividual = mock(AwsIotMqttClient.class);\n-        when(mockIndividual.subscribe(any(), any())).thenReturn(CompletableFuture.completedFuture(0));\n-        when(client.getNewMqttClient()).thenReturn(mockIndividual);\n-        assertFalse(client.connected());\n-\n-        client.subscribe(SubscribeRequest.builder().topic(\"A/B/+\").callback((m) -> {\n-            throw new RuntimeException(\"Uncaught!\");\n-        }).build());\n-        Pair<CompletableFuture<Void>, Consumer<MqttMessage>> abc = asyncAssertOnConsumer((m) -> {\n-            assertEquals(\"A/B/C\", m.getTopic());\n-        });\n-        client.subscribe(SubscribeRequest.builder().topic(\"A/B/C\").callback(abc.getRight()).build());\n-\n-        Consumer<MqttMessage> handler = client.getMessageHandlerForClient(mockIndividual);\n-\n-        handler.accept(new MqttMessage(\"A/B/C\", new byte[0]));\n-        abc.getLeft().get(0, TimeUnit.SECONDS);\n-    }\n+    //@Test", "originalCommit": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f2c20db7ccf08d42a35d401965c6f825b438750", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java b/src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java\nindex 438b361145..a9fdf9d2c2 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java\n\n@@ -328,193 +301,176 @@ class MqttClientTest {\n         abc.getLeft().get(0, TimeUnit.SECONDS);\n     }\n \n-    //@Test\n-    //void GIVEN_incoming_message_WHEN_received_and_subscriber_throws_THEN_still_calls_remaining_subscriptions(\n-    //        ExtensionContext context) throws ExecutionException, InterruptedException, TimeoutException {\n-    //    ignoreExceptionWithMessage(context, \"Uncaught!\");\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, (c) -> builder, executorService, ses));\n-    //    AwsIotMqttClient mockIndividual = mock(AwsIotMqttClient.class);\n-    //    when(mockIndividual.subscribe(any(), any())).thenReturn(CompletableFuture.completedFuture(0));\n-    //    when(client.getNewMqttClient()).thenReturn(mockIndividual);\n-    //    assertFalse(client.connected());\n-    //\n-    //    client.subscribe(SubscribeRequest.builder().topic(\"A/B/+\").callback((m) -> {\n-    //        throw new RuntimeException(\"Uncaught!\");\n-    //    }).build());\n-    //    Pair<CompletableFuture<Void>, Consumer<MqttMessage>> abc = asyncAssertOnConsumer((m) -> {\n-    //        assertEquals(\"A/B/C\", m.getTopic());\n-    //    });\n-    //    client.subscribe(SubscribeRequest.builder().topic(\"A/B/C\").callback(abc.getRight()).build());\n-    //\n-    //    Consumer<MqttMessage> handler = client.getMessageHandlerForClient(mockIndividual);\n-    //\n-    //    handler.accept(new MqttMessage(\"A/B/C\", new byte[0]));\n-    //    abc.getLeft().get(0, TimeUnit.SECONDS);\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_KeepQos0WhenOffline_is_false_and_mqtt_is_offline_WHEN_publish_THEN_the_request_will_drop() throws ExecutionException, InterruptedException, SpoolerLoadException {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_MOST_ONCE).build();\n-    //    SpoolerConfig config = SpoolerConfig.builder().keepQos0WhenOffline(false)\n-    //            .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)\n-    //            .build();\n-    //    when(spool.getSpoolConfig()).thenReturn(config);\n-    //\n-    //    CompletableFuture<Integer> future = client.publish(request);\n-    //\n-    //    assertEquals(0, future.get());\n-    //    verify(spool, never()).addMessage(request);\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_KeepQos0WhenOffline_is_true_and_mqtt_is_offline_WHEN_publish_THEN_return_complete_future() throws ExecutionException, InterruptedException, SpoolerLoadException {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_MOST_ONCE).build();\n-    //    SpoolerConfig config = SpoolerConfig.builder().keepQos0WhenOffline(true)\n-    //            .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)\n-    //            .build();\n-    //    when(spool.getSpoolConfig()).thenReturn(config);\n-    //    when(spool.addMessage(request)).thenReturn(new Long(0));\n-    //\n-    //    CompletableFuture<Integer> future = client.publish(request);\n-    //\n-    //    assertEquals(0, future.get());\n-    //    verify(spool, times(1)).addMessage(request);\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_KeepQos0WhenOffline_is_false_and_mqtt_is_online_WHEN_publish_THEN_return_complete_future() throws ExecutionException, InterruptedException {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_MOST_ONCE).build();\n-    //    when(spool.addMessage(request)).thenReturn(new Long(0));\n-    //\n-    //    client.setMqttOnline(true);\n-    //    CompletableFuture<Integer> future = client.publish(request);\n-    //\n-    //    assertEquals(0, future.get());\n-    //    verify(spool, times(1)).addMessage(request);\n-    //    verify(spool, never()).getSpoolConfig();\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_qos_is_1_and_mqtt_is_offline_WHEN_publish_THEN_return_complete_future() throws ExecutionException, InterruptedException {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_LEAST_ONCE).build();\n-    //\n-    //    CompletableFuture<Integer> future = client.publish(request);\n-    //\n-    //    assertEquals(0, future.get());\n-    //    verify(spool, times(1)).addMessage(request);\n-    //    verify(spool, never()).getSpoolConfig();\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_fail_to_add_message_to_spooler_queue_WHEN_publish_THEN_future_contains_exception() throws InterruptedException {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_LEAST_ONCE).build();\n-    //    when(spool.addMessage(any())).thenThrow(InterruptedException.class);\n-    //\n-    //    client.setMqttOnline(true);\n-    //    CompletableFuture<Integer> future = spy(client.publish(request));\n-    //\n-    //    verify(spool, times(1)).addMessage(request);\n-    //    assertTrue(future.isCompletedExceptionally());\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_published_request_with_popped_id_is_null_WHEN_spool_message_THEN_remove_message_id() {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    client.setMqttOnline(true);\n-    //\n-    //    when(spool.messageCount()).thenReturn(new Long(1));\n-    //    when(spool.popId()).thenReturn(new Long(0));\n-    //    // The message has been sent out and removed from the spooler's messageMap,\n-    //    //but not from the spool's messageIdQueue\n-    //    when(spool.getMessageById(any())).thenReturn(null);\n-    //\n-    //    client.spoolMessage();\n-    //\n-    //    verify(spool, never()).addId(any());\n-    //    verify(spool, never()).removeMessageById(any());\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_exceed_max_retried_WHEN_spool_message_THEN_remove_message() {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    client.setMqttOnline(true);\n-    //\n-    //    when(spool.messageCount()).thenReturn(new Long(1));\n-    //    when(spool.popId()).thenReturn(new Long(1));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_LEAST_ONCE).build();\n-    //    SpoolMessage message = SpoolMessage.builder().publishRequest(request)\n-    //            .retried(new AtomicInteger(2)).build();\n-    //    when(spool.getMessageById(any())).thenReturn(message);\n-    //    SpoolerConfig config = SpoolerConfig.builder().maxRetried(1).build();\n-    //    when(spool.getSpoolConfig()).thenReturn(config);\n-    //    AwsIotMqttClient awsIotMqttClient = mock(AwsIotMqttClient.class);\n-    //    when(client.getNewMqttClient()).thenReturn(awsIotMqttClient);\n-    //\n-    //    client.spoolMessage();\n-    //\n-    //    verify(spool, atLeastOnce()).removeMessageById(any());\n-    //    verify(client, never()).getNewMqttClient();\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_publish_request_successfully_WHEN_spool_message_THEN_remove_message_from_spooler_queue() {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses));\n-    //    client.setMqttOnline(true);\n-    //\n-    //    when(spool.messageCount()).thenReturn(new Long(1));\n-    //    when(spool.popId()).thenReturn(new Long(1));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n-    //            .qos(QualityOfService.AT_LEAST_ONCE).build();\n-    //    SpoolMessage message = SpoolMessage.builder().publishRequest(request)\n-    //            .retried(new AtomicInteger(0)).build();\n-    //    when(spool.getMessageById(any())).thenReturn(message);\n-    //    SpoolerConfig config = SpoolerConfig.builder().maxRetried(1).build();\n-    //    when(spool.getSpoolConfig()).thenReturn(config);\n-    //    AwsIotMqttClient awsIotMqttClient = mock(AwsIotMqttClient.class);\n-    //    when(awsIotMqttClient.publish(any(), any(), any())).thenReturn(CompletableFuture.completedFuture(1));\n-    //    when(client.getNewMqttClient()).thenReturn(awsIotMqttClient);\n-    //\n-    //\n-    //    client.spoolMessage();\n-    //\n-    //    //verify(spool, atLeast(2)).removeMessageById(any());\n-    //    verify(client, atLeastOnce()).getNewMqttClient();\n-    //    //verify(awsIotMqttClient, atLeastOnce()).publish(any(), any(), any());\n-    //    //verify(spool, never()).addId(any());\n-    //}\n-\n-    //@Test\n-    //void GIVEN_publish_request_with_interrupted_exception_WHEN_spool_message_THEN_stop_spooling_message() {\n-    //    MqttClient client = spy(new MqttClient(deviceConfiguration, (c) -> builder, executorService, ses));\n-    //    mqttOnline.set(true);\n-    //\n-    //    Spool mockSpool = mock(Spool.class);\n-    //    when(mockSpool.messageCount()).thenReturn(new Long(1));\n-    //    when(mockSpool.popId()).thenReturn(new Long(1));\n-    //    PublishRequest request = PublishRequest.builder().topic(\"A\").payload(new byte[0]).build();\n-    //    SpoolMessage message = SpoolMessage.builder().publishRequest(request)\n-    //            .retried(new AtomicInteger(0)).build();\n-    //    when(mockSpool.getMessageById(any())).thenReturn(message);\n-    //    AwsIotMqttClient mockIndividual = mock(AwsIotMqttClient.class);\n-    //\n-    //    verify(mockSpool, times(1)).removeMessageById(any());\n-    //    verify(client, times(1)).spoolMessage();\n-    //    verify(mockIndividual, never()).publish(any(),any(), any());\n-    //}\n-    //\n-    //@Test\n-    //void GIVEN_publish_request_unsuccessfully_with_throwable_WHEN_spool_message_THEN_add_id_into_back_to_spool() {\n-    //\n-    //}\n+    @Test\n+    void GIVEN_incoming_message_WHEN_received_and_subscriber_throws_THEN_still_calls_remaining_subscriptions(\n+            ExtensionContext context) throws ExecutionException, InterruptedException, TimeoutException {\n+        ignoreExceptionWithMessage(context, \"Uncaught!\");\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, (c) -> builder, executorService, ses));\n+        AwsIotMqttClient mockIndividual = mock(AwsIotMqttClient.class);\n+        when(mockIndividual.subscribe(any(), any())).thenReturn(CompletableFuture.completedFuture(0));\n+        when(client.getNewMqttClient()).thenReturn(mockIndividual);\n+        assertFalse(client.connected());\n+\n+        client.subscribe(SubscribeRequest.builder().topic(\"A/B/+\").callback((m) -> {\n+            throw new RuntimeException(\"Uncaught!\");\n+        }).build());\n+        Pair<CompletableFuture<Void>, Consumer<MqttMessage>> abc = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"A/B/C\", m.getTopic());\n+        });\n+        client.subscribe(SubscribeRequest.builder().topic(\"A/B/C\").callback(abc.getRight()).build());\n+\n+        Consumer<MqttMessage> handler = client.getMessageHandlerForClient(mockIndividual);\n+\n+        handler.accept(new MqttMessage(\"A/B/C\", new byte[0]));\n+        abc.getLeft().get(0, TimeUnit.SECONDS);\n+    }\n+\n+    @Test\n+    void GIVEN_keep_qos_0_when_offline_is_false_and_mqtt_is_offline_WHEN_publish_THEN_future_complete_exceptionally() throws InterruptedException, SpoolerLoadException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, false));\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        SpoolerConfig config = SpoolerConfig.builder().keepQos0WhenOffline(false)\n+                .spoolMaxMessageQueueSizeInBytes(25L).spoolStorageType(SpoolerStorageType.Memory)\n+                .build();\n+        when(spool.getSpoolConfig()).thenReturn(config);\n+\n+        CompletableFuture<Integer> future = client.publish(request);\n+\n+        assertTrue(future.isCompletedExceptionally());\n+        verify(spool, never()).addMessage(request);\n+    }\n+\n+    @Test\n+    void GIVEN_keep_qos_0_when_offline_is_false_and_mqtt_is_online_WHEN_publish_THEN_return_future_complete() throws ExecutionException, InterruptedException, SpoolerLoadException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, true));\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        when(spool.addMessage(request)).thenReturn(0L);\n+\n+        CompletableFuture<Integer> future = client.publish(request);\n+\n+        assertEquals(0, future.get());\n+        verify(spool, times(1)).addMessage(request);\n+        verify(spool, never()).getSpoolConfig();\n+    }\n+\n+    @Test\n+    void GIVEN_qos_is_1_and_mqtt_is_offline_WHEN_publish_THEN_return_future_complete() throws ExecutionException, InterruptedException, SpoolerLoadException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, false));\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+\n+        CompletableFuture<Integer> future = client.publish(request);\n+\n+        assertEquals(0, future.get());\n+        verify(spool, times(1)).addMessage(request);\n+        verify(spool, never()).getSpoolConfig();\n+    }\n+\n+    @Test\n+    void GIVEN_add_message_to_spooler_throw_spooler_load_exception_WHEN_publish_THEN_return_future_complete_exceptionally() throws SpoolerLoadException, InterruptedException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, false));\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        when(spool.addMessage(any())).thenThrow(new SpoolerLoadException(\"spooler is full\"));\n+\n+        CompletableFuture<Integer> future = client.publish(request);\n+\n+        assertTrue(future.isCompletedExceptionally());\n+        verify(spool, times(1)).addMessage(request);\n+        verify(spool, never()).getSpoolConfig();\n+    }\n+\n+    @Test\n+    void GIVEN_add_message_to_spooler_throw_interrupted_exception_WHEN_publish_THEN_return_future_complete_exceptionally() throws InterruptedException, SpoolerLoadException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, false));\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        when(spool.addMessage(any())).thenThrow(InterruptedException.class);\n+\n+        CompletableFuture<Integer> future = spy(client.publish(request));\n+\n+        verify(spool, times(1)).addMessage(request);\n+        assertTrue(future.isCompletedExceptionally());\n+    }\n+\n+    @Test\n+    void GIVEN_published_request_with_popped_id_is_null_WHEN_spool_message_THEN_remove_message_by_id() throws InterruptedException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, true));\n+\n+        Long id = 1L;\n+        when(spool.getCurrentMessageCount()).thenReturn(1).thenReturn(0);\n+        when(spool.popId()).thenReturn(id);\n+        when(spool.getMessageById(id)).thenReturn(null);\n+\n+        client.spoolTask();\n+\n+        verify(spool, never()).addId(any());\n+        verify(spool, never()).removeMessageById(any());\n+    }\n+\n+    @Test\n+    void GIVEN_publish_request_successfully_WHEN_spool_message_THEN_remove_message_from_spooler_queue() throws InterruptedException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, true));\n+\n+        Long id = 1L;\n+        when(spool.getCurrentMessageCount()).thenReturn(1).thenReturn(0);\n+        when(spool.popId()).thenReturn(id);\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\")\n+                .payload(\"What's up\".getBytes(StandardCharsets.UTF_8))\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        when(spool.getMessageById(id)).thenReturn(request);\n+\n+        AwsIotMqttClient awsIotMqttClient = mock(AwsIotMqttClient.class);\n+        when(client.getNewMqttClient()).thenReturn(awsIotMqttClient);\n+        when(awsIotMqttClient.publish(any(), any(), anyBoolean())).thenReturn(CompletableFuture.completedFuture(0));\n+\n+        client.spoolTask();\n+\n+        verify(spool).removeMessageById(any());\n+        verify(awsIotMqttClient).publish(any(), any(), anyBoolean());\n+        verify(spool, never()).addId(any());\n+    }\n+\n+    @Test\n+    void GIVEN_publish_request_with_interrupted_exception_WHEN_spool_message_THEN_stop_spooling_message() throws InterruptedException, ExecutionException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, true));\n+\n+        Long id = 1L;\n+        when(spool.getCurrentMessageCount()).thenReturn(1);\n+        when(spool.popId()).thenReturn(id);\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\")\n+                .payload(\"What's up\".getBytes(StandardCharsets.UTF_8))\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        when(spool.getMessageById(id)).thenReturn(request);\n+\n+        AwsIotMqttClient awsIotMqttClient = mock(AwsIotMqttClient.class);\n+        when(client.getNewMqttClient()).thenReturn(awsIotMqttClient);\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        future.completeExceptionally(new InterruptedException(\"interrupted\"));\n+        when(awsIotMqttClient.publish(any(), any(), anyBoolean())).thenReturn(future);\n+\n+        client.spoolTask();\n+\n+        verify(awsIotMqttClient, atLeastOnce()).publish(any(), any(), anyBoolean());\n+        verify(spool).addId(any());\n+        verify(spool, never()).removeMessageById(any());\n+    }\n+\n+    @Test\n+    void GIVEN_keep_qos0_message_when_offline_is_false_and_mqtt_offline_WHEN_spool_message_THEN_drop_qos_0_message() throws InterruptedException {\n+        MqttClient client = spy(new MqttClient(deviceConfiguration, spool, ses, false));\n+        SpoolerConfig config = SpoolerConfig.builder().keepQos0WhenOffline(false)\n+                .spoolMaxMessageQueueSizeInBytes(25L).spoolStorageType(SpoolerStorageType.Memory)\n+                .build();\n+        when(spool.getSpoolConfig()).thenReturn(config);\n+\n+        client.spoolTask();\n+\n+        verify(spool).popOutMessagesWithQosZero();\n+        verify(spool, never()).popId();\n+        verify(spool, never()).addId(any());\n+        verify(spool, never()).removeMessageById(any());\n+    }\n }\n"}}, {"oid": "2f2c20db7ccf08d42a35d401965c6f825b438750", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2f2c20db7ccf08d42a35d401965c6f825b438750", "message": "clean up code", "committedDate": "2020-10-28T10:42:20Z", "type": "commit"}, {"oid": "89a7b6086e026a399db84f1b738260a31852b54c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/89a7b6086e026a399db84f1b738260a31852b54c", "message": "Merge branch 'spooler' of ssh://github.com/aws/aws-greengrass-kernel into spooler", "committedDate": "2020-10-28T11:23:05Z", "type": "commit"}, {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17b82438e1d0a00dcabe8359d98a76b56f62e25f", "message": "Merge branch 'backup' into spooler2", "committedDate": "2020-10-28T20:19:22Z", "type": "commit"}, {"oid": "8112725802fb408ea23ba92949f6e75899294ced", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8112725802fb408ea23ba92949f6e75899294ced", "message": "leave one messageID queue in the spool class", "committedDate": "2020-10-28T20:05:25Z", "type": "forcePushed"}, {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17b82438e1d0a00dcabe8359d98a76b56f62e25f", "message": "Merge branch 'backup' into spooler2", "committedDate": "2020-10-28T20:19:22Z", "type": "forcePushed"}, {"oid": "bfa05d652136d29eb1785cc0fac5db3f87edb3db", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bfa05d652136d29eb1785cc0fac5db3f87edb3db", "message": "fix format", "committedDate": "2020-10-28T20:48:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2NDA3MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513764070", "bodyText": "IDE issue, the format has been corrected in the next commit.", "author": "awszztt", "createdAt": "2020-10-28T21:12:55Z", "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -113,7 +113,7 @@ private Topic createLeafChild(CaseInsensitiveString name) {\n      * @return the node\n      */\n     public Topics createInteriorChild(String name) {\n-       return createInteriorChild(new CaseInsensitiveString(name));\n+        return createInteriorChild(new CaseInsensitiveString(name));", "originalCommit": "17b82438e1d0a00dcabe8359d98a76b56f62e25f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "chunk": "diff --git a/src/main/java/com/aws/greengrass/config/Topics.java b/src/main/java/com/aws/greengrass/config/Topics.java\nindex 358027c637..c5f1330b0d 100644\n--- a/src/main/java/com/aws/greengrass/config/Topics.java\n+++ b/src/main/java/com/aws/greengrass/config/Topics.java\n\n@@ -113,7 +113,7 @@ public class Topics extends Node implements Iterable<Node> {\n      * @return the node\n      */\n     public Topics createInteriorChild(String name) {\n-        return createInteriorChild(new CaseInsensitiveString(name));\n+       return createInteriorChild(new CaseInsensitiveString(name));\n     }\n \n     private Topics createInteriorChild(CaseInsensitiveString name) {\n"}}, {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/df4ae162cacf78cac930ef95bfdfe4fdfd941479", "message": "remove unnecessary change", "committedDate": "2020-10-28T21:24:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3Mjc4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513772781", "bodyText": "remove this from here, just register a public callback in MqttClient class for setting this flag. Same with L75.\nThis way you only set it to online in this class when the connect call completes, everything else can happen outside of this class", "author": "MikeDombo", "createdAt": "2020-10-28T21:29:37Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -50,12 +50,14 @@\n     private MqttClientConnection connection;\n     private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n     private final CallbackEventManager callbackEventManager;\n+    private final AtomicBoolean mqttOnline;\n \n     @Getter(AccessLevel.PACKAGE)\n     private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n+            mqttOnline.set(false);", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex d2556f3891..2c7ead7bbc 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -57,7 +57,6 @@ class AwsIotMqttClient implements Closeable {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n-            mqttOnline.set(false);\n             // Error code 0 means that the disconnection was intentional, so we don't need to log it\n             if (errorCode != 0) {\n                 logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDQ2MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774461", "bodyText": "don't call this until someone first calls publish. Store the future for the task and check if it is null or not", "author": "MikeDombo", "createdAt": "2020-10-28T21:32:56Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -212,6 +222,25 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n         eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+        spool = initSpooler(deviceConfiguration);\n+        spoolMessage();", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 24bf7dacab..0fa90dc731 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -223,7 +241,7 @@ public class MqttClient implements Closeable {\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n         spool = initSpooler(deviceConfiguration);\n-        spoolMessage();\n+        addToCallbackEvents(callbacks);\n     }\n \n     private Spool initSpooler(DeviceConfiguration deviceConfiguration) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDcwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774701", "bodyText": "capital W", "author": "MikeDombo", "createdAt": "2020-10-28T21:33:28Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 24bf7dacab..0fa90dc731 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -357,22 +375,28 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n+\n         boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         CompletableFuture<Integer> future = new CompletableFuture<>();\n         if (willDropTheRequest) {\n-            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n                     + \" with Qos 0 when MqttClient is offline\");\n-            logger.atError().log(e);\n             future.completeExceptionally(e);\n             return future;\n         }\n \n         try {\n             spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n         } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n             return future;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774966", "bodyText": "do not use toString. Log the full exception", "author": "MikeDombo", "createdAt": "2020-10-28T21:34:02Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5Mzk4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513793980", "bodyText": "The reason I use the e.toString here is that, if I make the mock throw an exception, it won't actucaly stops here.", "author": "awszztt", "createdAt": "2020-10-28T22:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NTAyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513795023", "bodyText": "I don't understand your response. Using a mock has nothing to do with how this should be logged or what stops or doesn't stop.\nIf your test is failing due to the exception that you throw then you can ignore the exception in the tests.", "author": "MikeDombo", "createdAt": "2020-10-28T22:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 24bf7dacab..0fa90dc731 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -357,22 +375,28 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n+\n         boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         CompletableFuture<Integer> future = new CompletableFuture<>();\n         if (willDropTheRequest) {\n-            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n                     + \" with Qos 0 when MqttClient is offline\");\n-            logger.atError().log(e);\n             future.completeExceptionally(e);\n             return future;\n         }\n \n         try {\n             spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n         } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n             return future;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513775802", "bodyText": "do not call tostring", "author": "MikeDombo", "createdAt": "2020-10-28T21:35:39Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n+\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;\n+\n+                getConnection(false).publish(new MqttMessage(request.getTopic(),request.getPayload()),\n+                        request.getQos(), request.isRetain()).whenComplete((packetId, throwable) -> {\n+                    if (throwable == null) {\n+                        spool.removeMessageById(finalId);\n+                    } else {\n+                        logger.atError().log(\"failed to publish the message via Mqtt Client\", throwable.toString());\n+                        spool.addId(finalId);\n+                    }\n+                }).get();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.atError().log(\"spooler message is interrupted\");\n+        } catch (ExecutionException e) {\n+            logger.atError().log(\"failed to spool method\", e.toString());", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NjIxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513776214", "bodyText": "What does it mean to spool a method? That log doesn't make sense. Try \"Error when publishing from spooler\" or something.", "author": "MikeDombo", "createdAt": "2020-10-28T21:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NDg3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513794873", "bodyText": "It is easier for testing. If the test is working with the ses in spoolMessage, some test is prone to be flaky.", "author": "awszztt", "createdAt": "2020-10-28T22:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5NTk0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513795944", "bodyText": "I don't care that your test fails. We need to have proper exception logging so that we can debug when a customer has this problem. Ignore the exception in the test when needed.", "author": "MikeDombo", "createdAt": "2020-10-28T22:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 24bf7dacab..0fa90dc731 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -357,22 +375,28 @@ public class MqttClient implements Closeable {\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n+\n         boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n                 && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n \n         CompletableFuture<Integer> future = new CompletableFuture<>();\n         if (willDropTheRequest) {\n-            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n                     + \" with Qos 0 when MqttClient is offline\");\n-            logger.atError().log(e);\n             future.completeExceptionally(e);\n             return future;\n         }\n \n         try {\n             spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n         } catch (InterruptedException | SpoolerLoadException e) {\n-            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n             return future;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3ODExNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513778116", "bodyText": "you can keep the method you had to get the spooler namespace, I think that makes lots of sense.", "author": "MikeDombo", "createdAt": "2020-10-28T21:40:14Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+\n+public class Spool {\n+\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getMQTTNamespace();", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex ec114be561..5d84488cf0 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -8,6 +8,8 @@ package com.aws.greengrass.mqttclient.spool;\n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.config.WhatHappened;\n import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3ODU1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513778555", "bodyText": "don't check for childof mqtt, that's a guarantee since that's what you subscribed to.\nCheck that it is a childof spooler. Or just remove it.", "author": "MikeDombo", "createdAt": "2020-10-28T21:41:05Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+\n+public class Spool {\n+\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getMQTTNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to a topic\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null && node.childOf(DEVICE_MQTT_NAMESPACE)) {", "originalCommit": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex ec114be561..5d84488cf0 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -8,6 +8,8 @@ package com.aws.greengrass.mqttclient.spool;\n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.config.WhatHappened;\n import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n import com.aws.greengrass.mqttclient.PublishRequest;\n import com.aws.greengrass.util.Coerce;\n \n"}}, {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8e6c424367207c59de9e1cec81e43cf699ef24f8", "message": "address the comment - 2", "committedDate": "2020-10-29T08:04:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMzg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514413862", "bodyText": "why does this need a getter?", "author": "MikeDombo", "createdAt": "2020-10-29T16:52:02Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -87,25 +94,44 @@\n     private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n     private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n     private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+    private final AtomicBoolean mqttOnline = new AtomicBoolean(false);\n \n     private final EventLoopGroup eventLoopGroup;\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private final CompletableFuture<String> spoolerMonitor = CompletableFuture.completedFuture(READY_TO_SPOOL);\n+\n+\n+    @Getter(AccessLevel.PACKAGE)", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 0fa90dc731..8834605b4c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -102,14 +99,15 @@ public class MqttClient implements Closeable {\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n     private final Spool spool;\n     private final ScheduledExecutorService ses;\n-    private final CompletableFuture<String> spoolerMonitor = CompletableFuture.completedFuture(READY_TO_SPOOL);\n+    private final AtomicReference<Future<?>> spoolingFuture = new AtomicReference<>();\n \n-\n-    @Getter(AccessLevel.PACKAGE)\n     private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             setMqttOnline(false);\n+            if (!spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                spool.popOutMessagesWithQosZero();\n+            }\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyOTU1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514429555", "bodyText": "inside of spoolMessage here you should have\nif (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n    spoolingFuture.set(ses.schedule....)\n}\n\nWhere spoolingFuture is an AtomicReference<Future<?>>\nThis way you should just call spoolMessage for every single call to publish which will make sure that the spooler is active when needed.", "author": "MikeDombo", "createdAt": "2020-10-29T17:14:30Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 0fa90dc731..8834605b4c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -389,11 +383,10 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n-            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n-                CompletableFuture.supplyAsync(() -> {\n-                    spoolMessage();\n-                    return READY_TO_SPOOL;\n-                });\n+            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n+                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n+                    spoolTask();\n+                }, 0, 5, TimeUnit.SECONDS));\n             }\n         } catch (InterruptedException | SpoolerLoadException e) {\n             logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMDMwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514430301", "bodyText": "this seems like something that the spooler should be doing, is it possible to move this into the spooler class?", "author": "MikeDombo", "createdAt": "2020-10-29T17:15:28Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1OTYxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514459614", "bodyText": "I prefer to leave it in the mqtt class, because it needs to get the connection to publish the message.", "author": "awszztt", "createdAt": "2020-10-29T17:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMDMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 0fa90dc731..8834605b4c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -389,11 +383,10 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n-            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n-                CompletableFuture.supplyAsync(() -> {\n-                    spoolMessage();\n-                    return READY_TO_SPOOL;\n-                });\n+            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n+                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n+                    spoolTask();\n+                }, 0, 5, TimeUnit.SECONDS));\n             }\n         } catch (InterruptedException | SpoolerLoadException e) {\n             logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMDU3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514430575", "bodyText": "long not Long", "author": "MikeDombo", "createdAt": "2020-10-29T17:15:51Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n+\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 0fa90dc731..8834605b4c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -389,11 +383,10 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n-            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n-                CompletableFuture.supplyAsync(() -> {\n-                    spoolMessage();\n-                    return READY_TO_SPOOL;\n-                });\n+            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n+                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n+                    spoolTask();\n+                }, 0, 5, TimeUnit.SECONDS));\n             }\n         } catch (InterruptedException | SpoolerLoadException e) {\n             logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514431824", "bodyText": "set the config? setup spooler using config?\nIf you don't want to do it in this pr, which is fine, add a todo", "author": "MikeDombo", "createdAt": "2020-10-29T17:17:31Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjEyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432126", "bodyText": "long not Long", "author": "MikeDombo", "createdAt": "2020-10-29T17:17:58Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjI1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432255", "bodyText": "long", "author": "MikeDombo", "createdAt": "2020-10-29T17:18:10Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     *\n+     * @return message id\n+     * @throws InterruptedException the thread is interrupted while popping the first id from the queue\n+     */\n+    public Long popId() throws InterruptedException {", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjc5Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432797", "bodyText": "use the primitive type long for everything instead of the object type Long. This will be more efficient as Java won't have to keep boxing and unboxing. See: https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html", "author": "MikeDombo", "createdAt": "2020-10-29T17:19:01Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyODEzNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514428135", "bodyText": "Nit: inline this, you're not using it anywhere other than the constructor", "author": "jbutler", "createdAt": "2020-10-29T17:12:30Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -212,6 +240,25 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n         eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+        spool = initSpooler(deviceConfiguration);\n+        addToCallbackEvents(callbacks);\n+    }\n+\n+    private Spool initSpooler(DeviceConfiguration deviceConfiguration) {\n+        return new Spool(deviceConfiguration);\n+    }", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 0fa90dc731..8834605b4c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -240,14 +238,10 @@ public class MqttClient implements Closeable {\n         eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n-        spool = initSpooler(deviceConfiguration);\n+        spool = new Spool(deviceConfiguration);\n         addToCallbackEvents(callbacks);\n     }\n \n-    private Spool initSpooler(DeviceConfiguration deviceConfiguration) {\n-        return new Spool(deviceConfiguration);\n-    }\n-\n     // constructor specific for unit test with spooler\n     protected MqttClient(DeviceConfiguration deviceConfiguration, Spool spool, ScheduledExecutorService ses,\n                          boolean mqttOnline) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjA3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482076", "bodyText": "I'm still not a fan of adding public constructors like this for testing purposes, but we can revisit later if there's a better way", "author": "jbutler", "createdAt": "2020-10-29T18:35:31Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjI5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482296", "bodyText": "private", "author": "jbutler", "createdAt": "2020-10-29T18:35:52Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjkzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482931", "bodyText": "We're using thread safe data structures so that we don't need to synchronize this.\nCan you add a TODO?", "author": "jbutler", "createdAt": "2020-10-29T18:36:56Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4Mzk3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514483977", "bodyText": "This loop is going to be very expensive since it requires reading the message itself and not just the metadata. I think we can push this for now, but will need to revisit it. Please add a TODO", "author": "jbutler", "createdAt": "2020-10-29T18:38:53Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     *\n+     * @return message id\n+     * @throws InterruptedException the thread is interrupted while popping the first id from the queue\n+     */\n+    public Long popId() throws InterruptedException {\n+        return queueOfMessageId.takeFirst();\n+    }\n+\n+    public PublishRequest getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        PublishRequest toBeRemovedRequest = getMessageById(messageId);\n+        if (toBeRemovedRequest != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedRequest.getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    public void removeOldestMessage() {\n+        removeMessagesWithQosZero(true);\n+    }\n+\n+    public void popOutMessagesWithQosZero() {\n+        removeMessagesWithQosZero(false);\n+    }\n+\n+    private void removeMessagesWithQosZero(boolean needToCheckCurSpoolerSize) {\n+        Iterator<Long> messageIdIterator = queueOfMessageId.iterator();\n+        while (messageIdIterator.hasNext() && addJudgementWithCurrentSpoolerSize(needToCheckCurSpoolerSize)) {\n+            Long idToBeRemoved = messageIdIterator.next();\n+            if (getMessageById(idToBeRemoved).getQos().getValue() == 0) {\n+                removeMessageById(idToBeRemoved);\n+            }", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 5d84488cf0..2d508b83de 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -33,7 +33,7 @@ public class Spool {\n     private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n \n     private final AtomicLong nextId = new AtomicLong(0);\n-    private final SpoolerConfig config;\n+    private SpoolerConfig config;\n     private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n     private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NDY1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514484656", "bodyText": "Nit: shorten these\nstorageType;\nspoolSizeInBytes;\nkeepQos0WhenOffline;", "author": "jbutler", "createdAt": "2020-10-29T18:40:04Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@Getter\n+public class SpoolerConfig {\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    private boolean keepQos0WhenOffline;", "originalCommit": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\nindex 64e2f5cf6d..cd3cb2aff8 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java\n\n@@ -11,7 +11,7 @@ import lombok.Getter;\n @Builder\n @Getter\n public class SpoolerConfig {\n-    private SpoolerStorageType spoolStorageType;\n-    private Long spoolMaxMessageQueueSizeInBytes;\n+    private SpoolerStorageType storageType;\n+    private Long spoolSizeInBytes;\n     private boolean keepQos0WhenOffline;\n }\n"}}, {"oid": "d36252bdf7c36e6996321e108e71039d53b8be3b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d36252bdf7c36e6996321e108e71039d53b8be3b", "message": "address comment comment -3", "committedDate": "2020-10-29T19:57:27Z", "type": "commit"}, {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a7718ec6dcfefe47051d97127c10a8becc3d7e53", "message": "fix some format", "committedDate": "2020-10-29T20:13:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0Njc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514546783", "bodyText": "this won't be spooling, will it? It is online.", "author": "MikeDombo", "createdAt": "2020-10-29T20:29:24Z", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttTest.java", "diffHunk": "@@ -64,7 +64,7 @@ void GIVEN_mqttclient_WHEN_subscribe_and_publish_THEN_receives_all_messages()\n         for (int i = 0; i < NUM_MESSAGES; i++) {\n             client.publish(PublishRequest.builder().topic(\"A/B/C\").payload(\"What's up\".getBytes(StandardCharsets.UTF_8))\n                     .build()).get(5, TimeUnit.SECONDS);\n-            logger.atInfo().kv(\"total\", i + 1).log(\"Published 1 message to cloud.\");\n+            logger.atInfo().kv(\"total\", i + 1).log(\"Added 1 message to spooler.\");", "originalCommit": "a7718ec6dcfefe47051d97127c10a8becc3d7e53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1OTcxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514559714", "bodyText": "I logged every step, the messages are indeed spooled and sent. After the first publish request comes, the spooler is up and running.", "author": "awszztt", "createdAt": "2020-10-29T20:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0Njc4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0ODM2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514548364", "bodyText": "this need to be synchronized, use a separate synchronized method", "author": "MikeDombo", "createdAt": "2020-10-29T20:32:05Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +369,66 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n+                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n+                    spoolTask();\n+                }, 0, 5, TimeUnit.SECONDS));\n+            }", "originalCommit": "a7718ec6dcfefe47051d97127c10a8becc3d7e53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e2decd2903a5088971c3c95fbe8b497e08479e6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 8834605b4c..3069084d2d 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -383,11 +383,7 @@ public class MqttClient implements Closeable {\n \n         try {\n             spool.addMessage(request);\n-            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n-                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n-                    spoolTask();\n-                }, 0, 5, TimeUnit.SECONDS));\n-            }\n+            spoolMessage();\n         } catch (InterruptedException | SpoolerLoadException e) {\n             logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n             future.completeExceptionally(e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0OTUwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514549509", "bodyText": "Doesn't seem very useful", "author": "MikeDombo", "createdAt": "2020-10-29T20:34:19Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = readSpoolerConfigFromDeviceConfig(topics);\n+        setSpoolerConfig(config);\n+        spooler = setupSpooler();\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                SpoolerConfig updatedConfig = readSpoolerConfigFromDeviceConfig(topics);\n+                setSpoolerConfig(updatedConfig);\n+            }\n+        });\n+    }\n+\n+    private void setSpoolerConfig(SpoolerConfig config) {\n+        this.config = config;\n+    }", "originalCommit": "a7718ec6dcfefe47051d97127c10a8becc3d7e53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e2decd2903a5088971c3c95fbe8b497e08479e6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex b1a16ca85a..8363faa149 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -47,14 +47,13 @@ public class Spool {\n     public Spool(DeviceConfiguration deviceConfiguration) {\n         this.deviceConfiguration = deviceConfiguration;\n         Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n-        config = readSpoolerConfigFromDeviceConfig(topics);\n+        setSpoolerConfigFromDeviceConfig(topics);\n         setSpoolerConfig(config);\n         spooler = setupSpooler();\n         // To subscribe to the topics of spooler configuration\n         topics.subscribe((what, node) -> {\n             if (WhatHappened.childChanged.equals(what) && node != null) {\n-                SpoolerConfig updatedConfig = readSpoolerConfigFromDeviceConfig(topics);\n-                setSpoolerConfig(updatedConfig);\n+                setSpoolerConfigFromDeviceConfig(topics);\n             }\n         });\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NjI0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514556248", "bodyText": "Sorry, I didn't mean to remove synchronized. As written, you need it. But we can follow up and remove it later", "author": "jbutler", "createdAt": "2020-10-29T20:46:46Z", "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -117,30 +111,31 @@ public void addId(Long id) {\n      * @throws InterruptedException result from the queue implementation\n      * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n      */\n-    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {", "originalCommit": "d36252bdf7c36e6996321e108e71039d53b8be3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e2decd2903a5088971c3c95fbe8b497e08479e6", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\nindex 2d508b83de..8363faa149 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java\n\n@@ -111,8 +110,8 @@ public class Spool {\n      * @throws InterruptedException result from the queue implementation\n      * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n      */\n-    public long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n-        // TODO: revisit the thread safety later\n+    public synchronized long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        // TODO: revisit the thread safety and whether the \"synchronized\" could be removed\n         int messageSizeInBytes = request.getPayload().length;\n         if (messageSizeInBytes > getSpoolConfig().getSpoolSizeInBytes()) {\n             throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n"}}, {"oid": "2e2decd2903a5088971c3c95fbe8b497e08479e6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2e2decd2903a5088971c3c95fbe8b497e08479e6", "message": "Address the comments 4", "committedDate": "2020-10-30T00:48:21Z", "type": "commit"}, {"oid": "8f5f6e711689b510357a4c74e8efd438ed79060f", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8f5f6e711689b510357a4c74e8efd438ed79060f", "message": "Ensure that EventLoopGroup is always closed if some exception occurs (#577)", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "3b8497c9f0960674daffb2163f35f2e918c59543", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b8497c9f0960674daffb2163f35f2e918c59543", "message": "Suspend service lifecycle when config is being merged during deployment (#567)\n\n* Suspend service lifecycle when config is being merged.\r\n\r\nConfiguration is updated asynchronously on each node, this will cause services to start with old config.\r\nPostponse installing/starting when config is being updated in deployment,\r\nso that service won't be started with partially updated config.\r\n\r\n* Address comments\r\n\r\nCo-authored-by: Xueli Zheng <shirlez@amazon.com>", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "5d3b01866ea4dc6cb6a4bb0ca066ef30b94d31a9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d3b01866ea4dc6cb6a4bb0ca066ef30b94d31a9", "message": "handle config update when default value is specified in the using Parameters: (#578)\n\n* handle config update when default value is specified in the Parameters section", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "3024685c51fb75059db0e16672c45f2ca5f2d25d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3024685c51fb75059db0e16672c45f2ca5f2d25d", "message": "Set the owner of artifacts for a service when commands are first run. (#555)\n\n* Set the owner of artifacts for a service when commands are first run.\r\n\r\nRefactored generation of the user/group to run a service with.\r\n\r\nArtifacts are set to the user/group running the service.\r\nThe run as user is set for a component in the deployment. If none is\r\nprovided, the default user/group is used. If no default is set, and\r\nthe kernel user is not root, the kernel user is used.\r\n\r\nArtifacts that are not \"run\" are left unchanged - they are owned by\r\nthe kernel user.\r\n\r\nSet artifact and artifact dir permissions\r\n\r\nPermissions will be set to world readable for artifacts - this is temporary until the component model change is consumed\r\n\r\nThe artifacts directories need to be globally readable and executable so any user can enter the directories - otherwise sharing artifacts does not work\r\n\r\nOwnership of artifacts directories is set to the nucleus user. Ownership of artifact files is set to the user running the component (or default user)\r\n\r\nFixes so tests run as non-root user\r\n\r\nAdd default user and group to easy setup", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "5457032bc05847d7456e49fe96effc89b29eb6f9", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5457032bc05847d7456e49fe96effc89b29eb6f9", "message": "Proper config interpolation using timestamps (#580)\n\n* Proper config interpolation using timestamps\r\n\r\n* Revert \"handle config update when default value is specified in the using Parameters: (#578)\"\r\n\r\nThis reverts commit 19958f5b58c11bbb668114aacccea8656d062ddd.\r\n\r\n* Add test case for resolving with different timestamps\r\n\r\n* Simplify RESET behavior", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "message": "Updating IPC library for server, client and model (#583)\n\n* Updating IPC library for server, client and model\r\n\r\n* Replacing InvalidArgumentError with InvalidArgumentsError\r\n\r\nCo-authored-by: fahadmohammed01 <52720275+fahadmohammed01@users.noreply.github.com>", "committedDate": "2020-10-30T01:01:08Z", "type": "commit"}, {"oid": "435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "message": "Updating IPC library for server, client and model (#583)\n\n* Updating IPC library for server, client and model\r\n\r\n* Replacing InvalidArgumentError with InvalidArgumentsError\r\n\r\nCo-authored-by: fahadmohammed01 <52720275+fahadmohammed01@users.noreply.github.com>", "committedDate": "2020-10-30T01:01:08Z", "type": "forcePushed"}, {"oid": "5aee7a889cb393ce547349fe4753a29368243369", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5aee7a889cb393ce547349fe4753a29368243369", "message": "remove the parameter of mqttOnline from AwsMqttIotClient", "committedDate": "2020-10-30T01:35:20Z", "type": "commit"}, {"oid": "b87c605cb10eb235ded5cd85f8afeccb36beeaf1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b87c605cb10eb235ded5cd85f8afeccb36beeaf1", "message": "resolve the rebase issue", "committedDate": "2020-10-30T01:42:49Z", "type": "commit"}, {"oid": "e5e7b24857f949d365096144a558a2de45609c02", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e5e7b24857f949d365096144a558a2de45609c02", "message": "Merge branch 'spooler' of ssh://github.com/aws/aws-greengrass-kernel into spooler", "committedDate": "2020-10-30T01:47:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcwOTU2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514709562", "bodyText": "pass in sessionPresent instead of just false.", "author": "MikeDombo", "createdAt": "2020-10-30T02:15:09Z", "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -156,8 +155,8 @@ void reconnect() throws TimeoutException, ExecutionException, InterruptedExcepti\n             logger.atInfo().log(\"Connecting to AWS IoT Core\");\n             return connection.connect().thenApply((sessionPresent) -> {\n                 currentlyConnected.set(true);\n+                callbackEventManager.runOnConnectionResumed(false);", "originalCommit": "e5e7b24857f949d365096144a558a2de45609c02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\nindex 270f103258..80d3f7904c 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java\n\n@@ -155,7 +155,7 @@ class AwsIotMqttClient implements Closeable {\n             logger.atInfo().log(\"Connecting to AWS IoT Core\");\n             return connection.connect().thenApply((sessionPresent) -> {\n                 currentlyConnected.set(true);\n-                callbackEventManager.runOnConnectionResumed(false);\n+                callbackEventManager.runOnConnectionResumed(sessionPresent);\n                 logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n                 if (!sessionPresent) {\n                     resubscribe();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxMDcxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514710711", "bodyText": "cancel this as the very first thing, otherwise it might be trying to publish messages while the mqtt client is shutting down.", "author": "MikeDombo", "createdAt": "2020-10-30T02:16:28Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -427,6 +530,9 @@ public synchronized void close() {\n         } catch (TimeoutException e) {\n             logger.atError().log(\"Timed out shutting down event loop\", e);\n         }\n+        if (spoolingFuture.get() != null) {\n+            spoolingFuture.get().cancel(true);\n+        }", "originalCommit": "e5e7b24857f949d365096144a558a2de45609c02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3ODAwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514878004", "bodyText": "Yes, that it true. I will put this in the first place.", "author": "awszztt", "createdAt": "2020-10-30T05:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxMDcxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "chunk": "diff --git a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\nindex 3069084d2d..6807d9bea2 100644\n--- a/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n+++ b/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java\n\n@@ -530,9 +535,6 @@ public class MqttClient implements Closeable {\n         } catch (TimeoutException e) {\n             logger.atError().log(\"Timed out shutting down event loop\", e);\n         }\n-        if (spoolingFuture.get() != null) {\n-            spoolingFuture.get().cancel(true);\n-        }\n     }\n \n     public void addToCallbackEvents(MqttClientConnectionEvents callbacks) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0MDAyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514840029", "bodyText": "Ideally we wouldn't drop the qos 0 message here. But we can fix that later :)", "author": "jbutler", "createdAt": "2020-10-30T04:33:27Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);", "originalCommit": "e5e7b24857f949d365096144a558a2de45609c02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex 90946ec4fa..53de024a1e 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -106,7 +106,7 @@ public class InMemorySpoolTest {\n \n     @Test\n     void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n-        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n                 .qos(QualityOfService.AT_LEAST_ONCE).build();\n         long id = spool.addMessage(request);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0MTAxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514841014", "bodyText": "You need to make sure that spooler size is increased before you can check that it decreased - make the publish request more than 0 bytes", "author": "jbutler", "createdAt": "2020-10-30T04:34:38Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);\n+    }\n+\n+    @Test\n+    void GIVEN_message_size_exceeds_max_size_of_spooler_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(30).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request); });\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        long id = spool.addMessage(request);\n+\n+        spool.removeMessageById(id);\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());", "originalCommit": "e5e7b24857f949d365096144a558a2de45609c02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NjY1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514876655", "bodyText": "Yes, that should something more than 0.", "author": "awszztt", "createdAt": "2020-10-30T05:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0MTAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex 90946ec4fa..53de024a1e 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -106,7 +106,7 @@ public class InMemorySpoolTest {\n \n     @Test\n     void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n-        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n                 .qos(QualityOfService.AT_LEAST_ONCE).build();\n         long id = spool.addMessage(request);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0ODUwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514848507", "bodyText": "This doesn't test that only Qos 0 messages are removed, it only checks that 2 were removed. Also, getCurrentSpoolerSize() doesn't seem like a useful method since it doesn't actually return the number of spooled messages... it only contains the number of IDs that are queued.", "author": "jbutler", "createdAt": "2020-10-30T04:43:28Z", "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);\n+    }\n+\n+    @Test\n+    void GIVEN_message_size_exceeds_max_size_of_spooler_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(30).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request); });\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        long id = spool.addMessage(request);\n+\n+        spool.removeMessageById(id);\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_message_with_qos_zero_WHEN_pop_out_messages_with_qos_zero_THEN_only_remove_message_with_qos_zero() throws SpoolerLoadException, InterruptedException {\n+\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(3).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(5).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        List<PublishRequest> requests = Arrays.asList(request1, request2, request2);\n+\n+        for (PublishRequest request : requests) {\n+            spool.addMessage(request);\n+        }\n+\n+        spool.popOutMessagesWithQosZero();\n+\n+        verify(spool, times(2)).removeMessageById(anyLong());\n+        assertEquals(3, spool.getCurrentSpoolerSize());", "originalCommit": "e5e7b24857f949d365096144a558a2de45609c02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3NzM3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514877375", "bodyText": "getCurrentSpoolerSize() return the real space occupied by spooler.  getMessageCount() would return the number of messageID.", "author": "awszztt", "createdAt": "2020-10-30T05:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0ODUwNw=="}], "type": "inlineReview", "revised_code": {"commit": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "chunk": "diff --git a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\nindex 90946ec4fa..53de024a1e 100644\n--- a/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n+++ b/src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java\n\n@@ -106,7 +106,7 @@ public class InMemorySpoolTest {\n \n     @Test\n     void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n-        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n                 .qos(QualityOfService.AT_LEAST_ONCE).build();\n         long id = spool.addMessage(request);\n \n"}}, {"oid": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "message": "fix the unit test and shut down spooler at the beginning of mqtt closing", "committedDate": "2020-10-30T05:32:11Z", "type": "commit"}, {"oid": "300ac86141b1fdc28985d8611ebc8252d66ed5a1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/300ac86141b1fdc28985d8611ebc8252d66ed5a1", "message": "rebase with master branch", "committedDate": "2020-10-30T05:37:06Z", "type": "commit"}, {"oid": "59e301a077b13bb34e0ee7bbd7313fe15132e4a1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/59e301a077b13bb34e0ee7bbd7313fe15132e4a1", "message": "Remove unnecessary stubs", "committedDate": "2020-10-30T21:53:48Z", "type": "commit"}, {"oid": "2afdf6cf78df19b443139e22c527b6166bf4f48d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2afdf6cf78df19b443139e22c527b6166bf4f48d", "message": "Merge branch 'spooler' into spooler-test", "committedDate": "2020-10-30T23:45:53Z", "type": "commit"}, {"oid": "ddf0230984d7d2e3e87c326be4acf4a4549d6452", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ddf0230984d7d2e3e87c326be4acf4a4549d6452", "message": "onconnect callback", "committedDate": "2020-11-01T00:43:28Z", "type": "commit"}, {"oid": "7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "message": "rebase", "committedDate": "2020-11-01T12:11:57Z", "type": "forcePushed"}, {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deed1d896ca9d8914ac2e49eb727201e7bd63b89", "message": "rebase", "committedDate": "2020-11-01T12:25:18Z", "type": "commit"}, {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deed1d896ca9d8914ac2e49eb727201e7bd63b89", "message": "rebase", "committedDate": "2020-11-01T12:25:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1ODUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r515658539", "bodyText": "Pretty sure this can just be a lambda function instead of an anonymous class", "author": "MikeDombo", "createdAt": "2020-11-01T19:00:49Z", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -87,25 +91,52 @@\n     private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n     private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n     private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+    private final AtomicBoolean mqttOnline = new AtomicBoolean(false);\n \n     private final EventLoopGroup eventLoopGroup;\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private final AtomicReference<Future<?>> spoolingFuture = new AtomicReference<>();\n+\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            setMqttOnline(false);\n+            if (!spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                spool.popOutMessagesWithQosZero();\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            setMqttOnline(true);\n+        }\n+    };\n+\n+    private final CallbackEventManager.OnConnectCallback onConnect = new CallbackEventManager.OnConnectCallback() {", "originalCommit": "deed1d896ca9d8914ac2e49eb727201e7bd63b89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}