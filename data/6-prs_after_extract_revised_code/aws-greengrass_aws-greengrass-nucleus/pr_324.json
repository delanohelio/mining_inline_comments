{"pr_number": 324, "pr_title": "Add first draft for AuthZ module", "pr_createdAt": "2020-07-21T19:11:38Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324", "timeline": [{"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5011ff64d8764389fffb8ece36b5f3e059df4c4a", "message": "Add first draft for AuthZ module\n\nBasic authZ functionality for evergreen. This change tries to define\nthe interface for authZ handler to unblock integration with services.\nFollow up changes will include end to end integration with other\nservices.", "committedDate": "2020-07-21T19:03:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMyOTIwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458329208", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and put() may not be thread-safe at lines: 115 and 123. Two threads can perform this same check at the same time and one thread can overwrite the value written by the other thread.\nFix\nConsider replacing put() with putIfAbsent() to help prevent accidental overwriting. putIfAbsent() puts the value only if the ConcurrentHashMap does not contain the key and therefore avoids overwriting the value written there by the other thread's putIfAbsent().\nMore info\nIf the key already exists, the code should throw an error at line: 116. putIfAbsent() returns null if the value did not exist and returns the value in the map if one already exists.", "author": "MikeDombo", "createdAt": "2020-07-21T19:14:34Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);\n+        if (!operationsCopy.contains(ANY_REGEX)) {\n+            operationsCopy.add(ANY_REGEX);\n+        }\n+        serviceToOperationsMap.put(serviceName, operationsCopy);", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nindex 15fd542da..39d2a898d 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n\n@@ -9,8 +9,10 @@ import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n \n-import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMzUwMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458333501", "bodyText": "inject the auth module for easier testing", "author": "MikeDombo", "createdAt": "2020-07-21T19:22:27Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NzUxMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458377511", "bodyText": "I wanted to test them together as part of UT as authModule is just a store only used by this class. This way UT is more closer to real scenarios. Let me know if that makes sense.", "author": "prateek-y", "createdAt": "2020-07-21T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMzUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nindex 15fd542da..39d2a898d 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n\n@@ -9,8 +9,10 @@ import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n \n-import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTExMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335111", "bodyText": "maybe use a Set instead? Then you can just add ANY_REGEX", "author": "MikeDombo", "createdAt": "2020-07-21T19:25:36Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjU3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396577", "bodyText": "changed", "author": "prateek-y", "createdAt": "2020-07-21T21:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nindex 15fd542da..39d2a898d 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n\n@@ -9,8 +9,10 @@ import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n \n-import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTY1NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335654", "bodyText": "use Utils.isEmpty?", "author": "MikeDombo", "createdAt": "2020-07-21T19:26:39Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjUyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396523", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-21T21:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nindex 15fd542da..39d2a898d 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n\n@@ -9,8 +9,10 @@ import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Utils;\n \n-import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzIyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337226", "bodyText": "may want to make these lists into sets so the contains check is faster", "author": "MikeDombo", "createdAt": "2020-07-21T19:29:34Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.List;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {\n+    @NonNull String policyId;\n+    String policyDescription;\n+    @NonNull List<String> sources;\n+    @NonNull List<String> operations;\n+    List<String> resources;", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjQ2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396462", "bodyText": "Yeah. I was thinking this to be public model which customer specifies in kernel config, but lets do set for now. We will revisit that later when we make end to end changes.", "author": "prateek-y", "createdAt": "2020-07-21T21:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java\nindex 5b26cd845..8c1c3a479 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java\n\n@@ -7,14 +7,14 @@ import lombok.Builder;\n import lombok.NonNull;\n import lombok.Value;\n \n-import java.util.List;\n+import java.util.Set;\n \n @Value\n @Builder\n public class AuthZPolicy {\n     @NonNull String policyId;\n     String policyDescription;\n-    @NonNull List<String> sources;\n-    @NonNull List<String> operations;\n-    List<String> resources;\n+    @NonNull Set<String> sources;\n+    @NonNull Set<String> operations;\n+    Set<String> resources;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzUyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337526", "bodyText": "maybe also assert on what the message is in the exception", "author": "MikeDombo", "createdAt": "2020-07-21T19:30:12Z", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthZHandlerTest {\n+\n+    @Mock\n+    private Kernel mockKernel;\n+\n+    @Mock\n+    private Topics mockTopics;\n+\n+    private AuthZPolicy getAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getAuthZPolicyB() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id2\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"ServiceC\", \"ServiceD\"))\n+                .operations(Arrays.asList(\"OpD\", \"OpE\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarOperationsAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"*\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarSourcesAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"*\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_AuthZ_manager_WHEN_service_registered_twice_THEN_errors() throws AuthZException {\n+        AuthZHandler authZHandler = new AuthZHandler(mockKernel);\n+        final List<String> serviceOps = Arrays.asList(\"OpA\", \"OpB\", \"OpC\");\n+        authZHandler.registerService(\"ServiceA\", serviceOps);\n+\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps));\n+        final List<String> serviceOps_2 = Arrays.asList(\"OpA\");\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps_2));", "originalCommit": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4ODU3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458388575", "bodyText": "I have a task to add fine grained exceptions. I will add that as part of that task", "author": "prateek-y", "createdAt": "2020-07-21T21:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java b/src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java\nindex b770fe7c8..1cd864e8a 100644\n--- a/src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java\n\n@@ -11,7 +11,8 @@ import org.mockito.junit.jupiter.MockitoExtension;\n \n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n"}}, {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ff2ee02726c325fc7e3d1453999f68d75d442a2", "message": "Apply feedback, modify type to Set for policy elements", "committedDate": "2020-07-21T21:27:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458409666", "bodyText": "why copy it?", "author": "MikeDombo", "createdAt": "2020-07-21T21:51:13Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));", "originalCommit": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1ODUxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458458519", "bodyText": "Did not want to keep a reference to an object writable by the caller. Not sure if this is the right way to avoid it. Do you have suggestions?", "author": "prateek-y", "createdAt": "2020-07-22T00:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1OTI2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458459264", "bodyText": "The caller is within our kernel, we should be able to trust that it is fine.", "author": "MikeDombo", "createdAt": "2020-07-22T00:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "message": "Add more UT", "committedDate": "2020-07-22T06:52:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0MzMzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458943331", "bodyText": "just set these in the field definition?", "author": "MikeDombo", "createdAt": "2020-07-22T16:58:16Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODgwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778807", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0MzMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NDU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458944573", "bodyText": "[nit]\nFormatting, reformat all files just in case.", "author": "MikeDombo", "createdAt": "2020-07-22T17:00:10Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTU5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945593", "bodyText": "[nit]\nWhen you have all the data in one place, just use the constructor instead of builder.", "author": "MikeDombo", "createdAt": "2020-07-22T17:01:53Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {\n+            addPermission(serviceName, policy.getSources(), policy.getOperations(), policy.getResources());\n+        }\n+        this.serviceToAuthZConfig.put(serviceName, config);\n+    }\n+\n+    private void isServiceRegistered(String serviceName) throws AuthZException {\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Invalid service name: \" + serviceName);\n+        }\n+        if (!serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service not registered: \" + serviceName);\n+        }\n+    }\n+\n+    private void isOperationValid(String serviceName, String operation)\n+            throws AuthZException {\n+        isServiceRegistered(serviceName);\n+        if (!serviceToOperationsMap.get(serviceName).contains(operation)) {\n+            throw new AuthZException(String.format(\"Service %s not registered for operation %s\",\n+                    serviceName, operation));\n+        }\n+\n+    }\n+\n+    private void validateOperations(String serviceName, AuthZPolicy policy) throws AuthZException {\n+        Set<String> operations = policy.getOperations();\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty operations: \"\n+                    + policy.getPolicyId());\n+        }\n+        Set<String> supportedOps = serviceToOperationsMap.get(serviceName);\n+        // check if operations are valid and registered.\n+        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n+            throw new AuthZException(String.format(\"Operation not registered with service %s\", serviceName));\n+        }\n+    }\n+\n+    private void validateSources(AuthZPolicy policy) throws AuthZException {\n+        Set<String> sources = policy.getSources();\n+        if (Utils.isEmpty(sources)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty source: \" + policy.getPolicyId());\n+        }\n+        // check if source is a valid EG service\n+        List<String> unknownSources = sources.stream().filter(s -> !s.equals(ANY_REGEX)).filter(s ->\n+                kernel.findServiceTopic(s) == null).collect(Collectors.toList());\n+\n+        if (!unknownSources.isEmpty()) {\n+            throw new AuthZException(String.format(\"Source %s in auth policy are not valid services\", unknownSources));\n+        }\n+    }\n+\n+    private void addPermission(String destination,\n+                               Set<String> sources,\n+                               Set<String> operations,\n+                               Set<String> resources) throws AuthZException {\n+        // Method assumes that all inputs are valid now\n+        for (String source: sources) {\n+            for (String operation: operations) {\n+                if (resources == null || resources.isEmpty()) {\n+                    authModule.addPermission(destination,\n+                            Permission.builder().source(source).operation(operation).resource(null).build());\n+                } else {\n+                    for (String resource : resources) {\n+                        authModule.addPermission(destination,\n+                                Permission.builder().source(source).operation(operation).resource(resource).build());", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTczOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945739", "bodyText": "just set in field definition?", "author": "MikeDombo", "createdAt": "2020-07-22T17:02:07Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODc4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778783", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\nindex 2cc6d30dd..6c4fa8028 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjI5NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458946294", "bodyText": "consider using DefaultConcurrentHashMap which implements get in this same way, so you can do permissions.get(destination).add(permission), without needing a nullcheck or computeIfAbsent.", "author": "MikeDombo", "createdAt": "2020-07-22T17:03:06Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add permission for the given input set.\n+     * @param destination destination entity\n+     * @param permission set of source, operation, resource.\n+     * @throws AuthZException when arguments are invalid\n+     */\n+    public void addPermission(final String destination, Permission permission) throws AuthZException {\n+        // resource is allowed to be null\n+        if (Utils.isEmpty(permission.getSource())\n+                || Utils.isEmpty(destination)\n+                || Utils.isEmpty(permission.getOperation())) {\n+            throw new AuthZException(\"Either one parameter is empty\");\n+        }\n+        // resource as null is ok, but it should not be empty\n+        String resource = permission.getResource();\n+        if (resource != null && Utils.isEmpty(resource)) {\n+            throw new AuthZException(\"Resource cannot be empty\");\n+        }\n+        permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MTI2Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459781263", "bodyText": "will try to modify this in later cr's", "author": "prateek-y", "createdAt": "2020-07-23T23:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\nindex 2cc6d30dd..6c4fa8028 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODUwMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459118500", "bodyText": "Use full name? AuthorizationException", "author": "fengwang666", "createdAt": "2020-07-22T22:25:49Z", "path": "src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.iot.evergreen.auth.exceptions;\n+\n+public class AuthZException extends Exception {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODc0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778743", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java b/src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthorizationException.java\nsimilarity index 58%\nrename from src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java\nrename to src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthorizationException.java\nindex 4d3bbc389..9405971c8 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthorizationException.java\n\n@@ -1,14 +1,14 @@\n package com.aws.iot.evergreen.auth.exceptions;\n \n-public class AuthZException extends Exception {\n+public class AuthorizationException extends Exception {\n     // TODO: define better exceptions for AuthZ\n     static final long serialVersionUID = -3387516993124229948L;\n \n-    public AuthZException(String message) {\n+    public AuthorizationException(String message) {\n         super(message);\n     }\n \n-    public AuthZException(Throwable e) {\n+    public AuthorizationException(Throwable e) {\n         super(e);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTExMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119112", "bodyText": "Use Principal? source is a bit vague.", "author": "fengwang666", "createdAt": "2020-07-22T22:27:28Z", "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -0,0 +1,16 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+public class Permission {\n+    @NonNull String source;", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODczMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778732", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTExMg=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/Permission.java b/src/main/java/com/aws/iot/evergreen/auth/Permission.java\nindex 5d9e4ce8e..885336c6a 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/Permission.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/Permission.java\n\n@@ -10,7 +10,7 @@ import lombok.Value;\n @Builder\n @Value\n public class Permission {\n-    @NonNull String source;\n+    @NonNull String principal;\n     @NonNull String operation;\n     String resource;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTcxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119717", "bodyText": "Use full name: AuthorizationPolicy", "author": "fengwang666", "createdAt": "2020-07-22T22:29:17Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODcxMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778712", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\nsimilarity index 84%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\nindex 8c1c3a479..387e8c26e 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java\n\n@@ -11,10 +11,10 @@ import java.util.Set;\n \n @Value\n @Builder\n-public class AuthZPolicy {\n+public class AuthorizationPolicy {\n     @NonNull String policyId;\n     String policyDescription;\n-    @NonNull Set<String> sources;\n+    @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzA0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459123045", "bodyText": "nit: AuthorizationHandler?", "author": "fengwang666", "createdAt": "2020-07-22T22:38:20Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MDQ1OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459780459", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzA0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDYyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459124620", "bodyText": "What is flow? It's a weird name. Why not just isAuthorized? Also do you separate destination and permission? Can't they be modeled in one object, such as AuthorizationRequest?\nclass AuthorizationRequest {\nString principal;\nString operation;\nResource resource;\n}\n\nclass Resource {\nString target;\nList<String> subresources;\n}", "author": "fengwang666", "createdAt": "2020-07-22T22:42:51Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTI3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779278", "bodyText": "renamed the method. For the object, I have all the policies partitioned based on destination principal. Also the customer also configures the policies on a component. We can decide on a composite object when we open this up for API's in future, but intent here was to keep the interfaces keyed on principal destination.", "author": "prateek-y", "createdAt": "2020-07-23T23:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459129896", "bodyText": "Who will call this method? Why is it needed? is this registering the principal? Also I would not sure the name \"service\". It's an overloaded term.", "author": "fengwang666", "createdAt": "2020-07-22T22:57:27Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTcxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779716", "bodyText": "This is needed for services to register their operations. For kernel this is pre defined, but for components in future, we dont know what operations they need. This method is called to register a component with authZ and defines the set of operations that services intends to register.", "author": "prateek-y", "createdAt": "2020-07-23T23:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTkyMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779921", "bodyText": "regarding the name, registerComponent?", "author": "prateek-y", "createdAt": "2020-07-23T23:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxNzE2MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r461217160", "bodyText": "Let's call registerComponent.", "author": "fengwang666", "createdAt": "2020-07-27T22:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMTYwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459131604", "bodyText": "Call it loadAuthorizationPolicy(). Don't introduce another term Config if it's already called Policy.", "author": "fengwang666", "createdAt": "2020-07-22T23:02:35Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTk0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779940", "bodyText": "ok", "author": "prateek-y", "createdAt": "2020-07-23T23:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMTYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nsimilarity index 50%\nrename from src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\nrename to src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\nindex 39d2a898d..97dddfb81 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NzIzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459147239", "bodyText": "Why modeling this as as a separate class in stead of part of AuthZHandler?", "author": "fengwang666", "createdAt": "2020-07-22T23:53:33Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {", "originalCommit": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MDIxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459780219", "bodyText": "I just wanted to add UT's targeting table to better test * and null scenarios, so decided to keep this separate.", "author": "prateek-y", "createdAt": "2020-07-23T23:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NzIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\nindex 2cc6d30dd..6c4fa8028 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n\n@@ -3,7 +3,7 @@\n \n package com.aws.iot.evergreen.auth;\n \n-import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.util.Utils;\n \n import java.util.ArrayList;\n"}}, {"oid": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "message": "Add feedback, renaming", "committedDate": "2020-07-23T23:24:26Z", "type": "commit"}, {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ecaf782ff24c4e775a8653c1c483cdabf591b55e", "message": "rename principal to principle", "committedDate": "2020-07-24T00:18:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMjY4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459802685", "bodyText": "Should this also be renamed to use the full form instead of AuthZ?", "author": "avipinku", "createdAt": "2020-07-24T00:44:37Z", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.", "originalCommit": "ecaf782ff24c4e775a8653c1c483cdabf591b55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzMzYzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r460333636", "bodyText": "changed", "author": "prateek-y", "createdAt": "2020-07-24T23:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMjY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "afb3120b4920be00c1a0473c15c03f823e4fcdde", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\nindex 12ea22f9e..6c4fa8028 100644\n--- a/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n+++ b/src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java\n\n@@ -12,7 +12,7 @@ import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * Simple permission table which stores permissions. A permission is a\n- * 4 value set of destination,principle,operation,resource.\n+ * 4 value set of destination,principal,operation,resource.\n  */\n public class AuthZModule {\n     ConcurrentHashMap<String, List<Permission>> permissions = new ConcurrentHashMap<>();\n"}}, {"oid": "afb3120b4920be00c1a0473c15c03f823e4fcdde", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afb3120b4920be00c1a0473c15c03f823e4fcdde", "message": "Revert \"rename principal to principle\"\n\nThis reverts commit ecaf782ff24c4e775a8653c1c483cdabf591b55e.", "committedDate": "2020-07-24T01:01:24Z", "type": "commit"}, {"oid": "d5b8b8e3acb556921aec53ff98cfa28955771652", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5b8b8e3acb556921aec53ff98cfa28955771652", "message": "rename AuthZmodule", "committedDate": "2020-07-24T23:51:38Z", "type": "commit"}, {"oid": "98891ce147221429a604624786f056454a819c84", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98891ce147221429a604624786f056454a819c84", "message": "Merge branch 'master' into authZ_interface", "committedDate": "2020-07-27T18:33:50Z", "type": "commit"}, {"oid": "d5bd74ad716d86b902b67c90d686e648cc93cd64", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5bd74ad716d86b902b67c90d686e648cc93cd64", "message": "Add first draft for AuthZ module\n\nBasic authZ functionality for evergreen. This change tries to define\nthe interface for authZ handler to unblock integration with services.\nFollow up changes will include end to end integration with other\nservices.", "committedDate": "2020-07-28T06:25:17Z", "type": "commit"}, {"oid": "8026c189df076ae069a9c5f122778b42a2e316a5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8026c189df076ae069a9c5f122778b42a2e316a5", "message": "Apply feedback, modify type to Set for policy elements", "committedDate": "2020-07-28T06:25:17Z", "type": "commit"}, {"oid": "bce7aa491afe48b1e03c1935cdc51aae02d66066", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bce7aa491afe48b1e03c1935cdc51aae02d66066", "message": "Add more UT", "committedDate": "2020-07-28T06:25:17Z", "type": "commit"}, {"oid": "896f4fe145f54bd03fecdd8342d9d546dcef0f43", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/896f4fe145f54bd03fecdd8342d9d546dcef0f43", "message": "Add feedback, renaming", "committedDate": "2020-07-28T06:25:18Z", "type": "commit"}, {"oid": "f004e45036bb605fb5f9765d1a201012e115dad4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f004e45036bb605fb5f9765d1a201012e115dad4", "message": "rename principal to principle", "committedDate": "2020-07-28T06:25:18Z", "type": "commit"}, {"oid": "d0ee8ac4fc29386c13d1eeae2fcc60a1326bd2cf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d0ee8ac4fc29386c13d1eeae2fcc60a1326bd2cf", "message": "Revert \"rename principal to principle\"\n\nThis reverts commit ecaf782ff24c4e775a8653c1c483cdabf591b55e.", "committedDate": "2020-07-28T06:25:18Z", "type": "commit"}, {"oid": "5d21a8514a4f92af6d5d288485a2771f7ac8ccab", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d21a8514a4f92af6d5d288485a2771f7ac8ccab", "message": "rename AuthZmodule", "committedDate": "2020-07-28T06:25:18Z", "type": "commit"}, {"oid": "907b66886b8fa99e134ce0d0763045aa6935d9f7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/907b66886b8fa99e134ce0d0763045aa6935d9f7", "message": "Merge branch 'master' into authZ_interface", "committedDate": "2020-07-28T06:26:22Z", "type": "commit"}, {"oid": "1ca91ec138acee96a6be83c107f87a30fbfbbfb5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1ca91ec138acee96a6be83c107f87a30fbfbbfb5", "message": "Merge branch 'authZ_interface' of https://github.com/aws/aws-greengrass-kernel", "committedDate": "2020-07-28T06:30:03Z", "type": "commit"}, {"oid": "eeee6595323ef5321d83685abb97a5763d67ef60", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eeee6595323ef5321d83685abb97a5763d67ef60", "message": "increase auth coverage to 100%", "committedDate": "2020-07-28T06:30:25Z", "type": "commit"}, {"oid": "e9edb443d4ce0b35bc89c33057567f790f376a1e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9edb443d4ce0b35bc89c33057567f790f376a1e", "message": "Reduce the coverage bar for integration tests\n\nWe do not include all tests in integration tests folder as part of\ncoverage. We exclude tests with E2E annotation from integ test\ncoverage. After adding auth module which has integ test with TES,\nthe coverage dropped because TES is not part of integ test coverage.", "committedDate": "2020-07-29T18:56:05Z", "type": "commit"}, {"oid": "c96b0f5903952f1afcffe01d76fe8021c44417fd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c96b0f5903952f1afcffe01d76fe8021c44417fd", "message": "Add copyright header", "committedDate": "2020-07-29T19:05:59Z", "type": "commit"}, {"oid": "95f2cdd1a6ab734365139009f2e5d121fb98eb50", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/95f2cdd1a6ab734365139009f2e5d121fb98eb50", "message": "rename service to component", "committedDate": "2020-07-29T20:14:09Z", "type": "commit"}, {"oid": "8888b998132ae00c76f6ab4bda5be9814e50afcb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8888b998132ae00c76f6ab4bda5be9814e50afcb", "message": "Merge branch 'master' into authZ_interface", "committedDate": "2020-07-29T21:21:24Z", "type": "commit"}, {"oid": "cb13c79d3c354b60ac29df91e7bca97defeb4f82", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb13c79d3c354b60ac29df91e7bca97defeb4f82", "message": "Merge branch 'master' into authZ_interface", "committedDate": "2020-07-29T22:46:24Z", "type": "commit"}]}