{"pr_number": 188, "pr_title": "Add more Kernel testing", "pr_createdAt": "2020-04-16T23:19:54Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188", "timeline": [{"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "message": "Add more Kernel testing", "committedDate": "2020-04-17T00:04:45Z", "type": "forcePushed"}, {"oid": "3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "message": "Add more Kernel testing", "committedDate": "2020-04-17T00:40:32Z", "type": "forcePushed"}, {"oid": "93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "message": "Add more Kernel testing", "committedDate": "2020-04-17T00:42:34Z", "type": "forcePushed"}, {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77c622a7a20bef2b9bccc958fe6b907af8e80273", "message": "Add more Kernel testing", "committedDate": "2020-04-17T01:08:35Z", "type": "commit"}, {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77c622a7a20bef2b9bccc958fe6b907af8e80273", "message": "Add more Kernel testing", "committedDate": "2020-04-17T01:08:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMzM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r409923396", "bodyText": "Nice!", "author": "ShirleyZheng92", "createdAt": "2020-04-17T00:25:01Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -513,11 +509,11 @@ public String toString() {\n         return sb.toString();\n     }\n \n-    protected void addDependencies(Set<EvergreenService> deps) {\n+    protected void putDependenciesIntoSet(Set<EvergreenService> deps) {", "originalCommit": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyNDgwOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r409924809", "bodyText": "I remember findbug or some check complains on creating new thread in constructor", "author": "ShirleyZheng92", "createdAt": "2020-04-17T00:29:54Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -83,6 +82,10 @@ public EvergreenService(Topics topics) {\n         this.externalDependenciesTopic = topics.createLeafChild(\"dependencies\").dflt(new ArrayList<String>());\n         this.externalDependenciesTopic.withParentNeedsToKnow(false);\n         this.lifecycle = new Lifecycle(this, state, logger);\n+\n+        initDependenciesTopic();\n+        periodicityInformation = Periodicity.of(this);\n+        lifecycle.initLifecycleThread();", "originalCommit": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2Nzk2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410367966", "bodyText": "It doesn't know that this is a thread because it isn't using raw threads, but an ExecutorService. Also, our previous thing was doing essentially the same since it was running in postInject. This just makes it explicit.", "author": "MikeDombo", "createdAt": "2020-04-17T17:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyNDgwOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDc5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410370798", "bodyText": "Why hardcoded 2?", "author": "ShirleyZheng92", "createdAt": "2020-04-17T17:35:41Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));", "originalCommit": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMjE4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410412182", "bodyText": "Because on L110 I define that EZPlugins will return 2 builtin plugins. I will try to make that more clear.", "author": "MikeDombo", "createdAt": "2020-04-17T18:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDc5OA=="}], "type": "inlineReview", "revised_code": {"commit": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\nindex fdbd2697..1dd79dbe 100644\n--- a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n\n@@ -112,6 +112,7 @@ class KernelLifecycleTest {\n         }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n \n         kernelLifecycle.launch();\n+        // Expect 2 times because I returned 2 plugins from above: IPC and Deployment\n         verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4Njg2Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410386862", "bodyText": "If services are stopped in reverse order, why \"bad2\" is seen after \"Bad\" ? Also can we name the variable more explicit of bad1Service /bad2Service ?", "author": "ShirleyZheng92", "createdAt": "2020-04-17T18:06:12Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_config_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configYaml = mockKernel.getConfigPath().resolve(\"config.yaml\").toFile();\n+        configYaml.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_tlog_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configTlog = mockKernel.getConfigPath().resolve(\"config.tlog\").toFile();\n+        configTlog.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_config_THEN_effective_config_written() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        mockKernelCommandLine.haveRead = true;\n+\n+        kernelLifecycle.launch();\n+        Path configPath = mockKernel.getConfigPath().resolve(\"config.yaml\");\n+        verify(mockKernel).writeEffectiveConfig(eq(configPath));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_startupAllServices_THEN_services_started_in_order() {\n+        EvergreenService service1 = mock(EvergreenService.class);\n+        EvergreenService service2 = mock(EvergreenService.class);\n+        EvergreenService service3 = mock(EvergreenService.class);\n+        EvergreenService service4 = mock(EvergreenService.class);\n+        doNothing().when(service1).requestStart();\n+        doNothing().when(service2).requestStart();\n+        doNothing().when(service3).requestStart();\n+        doNothing().when(service4).requestStart();\n+\n+        doReturn(Arrays.asList(service1, service2, service3, service4)).when(mockKernel).orderedDependencies();\n+\n+        kernelLifecycle.startupAllServices();\n+\n+        InOrder inOrder = inOrder(service1, service2, service3, service4);\n+        inOrder.verify(service1).requestStart();\n+        inOrder.verify(service2).requestStart();\n+        inOrder.verify(service3).requestStart();\n+        inOrder.verify(service4).requestStart();\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_shutdown_twice_THEN_only_1_shutdown_happens() {\n+        doReturn(Collections.emptyList()).when(mockKernel).orderedDependencies();\n+\n+        kernelLifecycle.shutdown();\n+        kernelLifecycle.shutdown();\n+\n+        verify(mockKernel).orderedDependencies();\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_shutdown_THEN_shutsdown_services_in_order() throws Exception {\n+        EvergreenService service1 = mock(EvergreenService.class);\n+        EvergreenService service2 = mock(EvergreenService.class);\n+        EvergreenService service3 = mock(EvergreenService.class);\n+        EvergreenService service4 = mock(EvergreenService.class);\n+        EvergreenService service5 = mock(EvergreenService.class);\n+\n+        CompletableFuture<Void> fut = new CompletableFuture<>();\n+        fut.complete(null);\n+        CompletableFuture<Void> failedFut = new CompletableFuture<>();\n+        failedFut.completeExceptionally(new Exception(\"Bad\"));\n+\n+        doReturn(failedFut).when(service1).close();\n+        doReturn(fut).when(service2).close();\n+        doReturn(fut).when(service3).close();\n+        doReturn(fut).when(service4).close();\n+        doThrow(new RuntimeException(\"Bad2\")).when(service5).close();\n+\n+        doReturn(Arrays.asList(service1, service2, service3, service4, service5)).when(mockKernel).orderedDependencies();\n+\n+        // Check that logging of exceptions works as expected\n+        CountDownLatch seenErrors = new CountDownLatch(2);\n+        Pair<CompletableFuture<Void>, Consumer<EvergreenStructuredLogMessage>> listener =\n+                TestUtils.asyncAssertOnConsumer((m) -> {\n+            if(m.getEventType().equals(\"service-shutdown-error\")) {\n+                if (seenErrors.getCount() == 2) {\n+                    assertEquals(\"Bad2\", m.getCause().getMessage());", "originalCommit": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMzQ2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410413464", "bodyText": "It is because orderedDependencies has them as 1-5, therefore when reversed it is 5-1, so we get bad2, then bad.\nI'll see if I can make this more clear.", "author": "MikeDombo", "createdAt": "2020-04-17T18:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4Njg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\nindex fdbd2697..1dd79dbe 100644\n--- a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n\n@@ -112,6 +112,7 @@ class KernelLifecycleTest {\n         }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n \n         kernelLifecycle.launch();\n+        // Expect 2 times because I returned 2 plugins from above: IPC and Deployment\n         verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwOTE0NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410409144", "bodyText": "NIT: I'd prefer parsing the output through yaml and compare the map object.", "author": "ShirleyZheng92", "createdAt": "2020-04-17T18:50:19Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.StringWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+class KernelTest {\n+    private static final String EXPECTED_CONFIG_OUTPUT =\n+            \"---\\n\"\n+            + \"services:\\n\"\n+            + \"  service1:\\n\"\n+            + \"    dependencies: []\\n\"\n+            + \"    lifecycle:\\n\"\n+            + \"      run:\\n\"\n+            + \"        script: \\\"test script\\\"\\n\"\n+            + \"  main:\\n\"\n+            + \"    dependencies:\\n\"\n+            + \"    - \\\"service1\\\"\\n\";\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+    private Kernel kernel;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+        kernel = new Kernel();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        kernel.shutdown(1);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_and_services_WHEN_orderedDependencies_THEN_dependencies_are_returned_in_order()\n+            throws InputValidationException {\n+        KernelLifecycle kernelLifecycle = spy(new KernelLifecycle(kernel, new KernelCommandLine(kernel)));\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+        EvergreenService service2 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service2\"));\n+\n+        List<EvergreenService> od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(1));\n+        assertEquals(mockMain, od.get(0));\n+\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(2));\n+\n+        assertEquals(service1, od.get(0));\n+        assertEquals(mockMain, od.get(1));\n+\n+        mockMain.addOrUpdateDependency(service2, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(3));\n+\n+        // Since service 1 and 2 are equal in the tree, they may come back as either position 1 or 2\n+        assertThat(od.get(0), anyOf(is(service1), is(service2)));\n+        assertThat(od.get(1), anyOf(is(service1), is(service2)));\n+        assertEquals(mockMain, od.get(2));\n+\n+        service1.addOrUpdateDependency(service2, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(3));\n+\n+        // Now that 2 is a dependency of 1, there is a strict order required\n+        assertEquals(service2, od.get(0));\n+        assertEquals(service1, od.get(1));\n+        assertEquals(mockMain, od.get(2));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_and_services_WHEN_orderedDependencies_with_a_cycle_THEN_no_dependencies_returned()\n+            throws InputValidationException {\n+        KernelLifecycle kernelLifecycle = mock(KernelLifecycle.class);\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+\n+        // Introduce a dependency cycle\n+        service1.addOrUpdateDependency(mockMain, State.RUNNING, false);\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+\n+        List<EvergreenService> od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(0));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_with_services_WHEN_writeConfig_THEN_service_config_written_to_file()\n+            throws Exception {\n+        kernel.parseArgs();\n+\n+        KernelLifecycle kernelLifecycle = mock(KernelLifecycle.class);\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+\n+        // Add dependency on service1 to main\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+        ((List<String>) kernel.findServiceTopic(\"main\").findLeafChild(\"dependencies\").getOnce())\n+                .add(\"service1\");\n+        kernel.findServiceTopic(\"service1\")\n+                .lookup(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, \"run\", \"script\")\n+                .withValue(\"test script\");\n+\n+        StringWriter writer = new StringWriter();\n+        kernel.writeConfig(writer);\n+        assertEquals(EXPECTED_CONFIG_OUTPUT, writer.toString());", "originalCommit": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMDIyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410410226", "bodyText": "Where is configTlog used?", "author": "ShirleyZheng92", "createdAt": "2020-04-17T18:52:28Z", "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_config_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configYaml = mockKernel.getConfigPath().resolve(\"config.yaml\").toFile();\n+        configYaml.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_tlog_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configTlog = mockKernel.getConfigPath().resolve(\"config.tlog\").toFile();\n+        configTlog.createNewFile();", "originalCommit": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMjc4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410412780", "bodyText": "The file itself isn't used, but I call createNewFile so that the file does exist, thus the kernel will try to read in the tlog as its config.", "author": "MikeDombo", "createdAt": "2020-04-17T18:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMDIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "chunk": "diff --git a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\nindex fdbd2697..1dd79dbe 100644\n--- a/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java\n\n@@ -112,6 +112,7 @@ class KernelLifecycleTest {\n         }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n \n         kernelLifecycle.launch();\n+        // Expect 2 times because I returned 2 plugins from above: IPC and Deployment\n         verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTYyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410471625", "bodyText": "nit rename l?", "author": "fahadmohammed01", "createdAt": "2020-04-17T21:10:19Z", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -137,12 +143,12 @@ public synchronized void clearODcache() {\n         }\n \n         final HashSet<EvergreenService> pending = new LinkedHashSet<>();\n-        getMain().addDependencies(pending);\n+        getMain().putDependenciesIntoSet(pending);\n         final HashSet<EvergreenService> ready = new LinkedHashSet<>();\n         while (!pending.isEmpty()) {\n             int sz = pending.size();\n             pending.removeIf(l -> {", "originalCommit": "6eb307152fa9bf5378149355f61480ef384069c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "chunk": "diff --git a/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java b/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\nindex f72f2832..d931674d 100644\n--- a/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\n+++ b/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java\n\n@@ -142,24 +142,24 @@ public class Kernel {\n             return Collections.emptyList();\n         }\n \n-        final HashSet<EvergreenService> pending = new LinkedHashSet<>();\n-        getMain().putDependenciesIntoSet(pending);\n-        final HashSet<EvergreenService> ready = new LinkedHashSet<>();\n-        while (!pending.isEmpty()) {\n-            int sz = pending.size();\n-            pending.removeIf(l -> {\n-                if (ready.containsAll(l.getDependencies().keySet())) {\n-                    ready.add(l);\n+        final HashSet<EvergreenService> pendingDependencyServices = new LinkedHashSet<>();\n+        getMain().putDependenciesIntoSet(pendingDependencyServices);\n+        final HashSet<EvergreenService> dependencyFoundServices = new LinkedHashSet<>();\n+        while (!pendingDependencyServices.isEmpty()) {\n+            int sz = pendingDependencyServices.size();\n+            pendingDependencyServices.removeIf(pendingService -> {\n+                if (dependencyFoundServices.containsAll(pendingService.getDependencies().keySet())) {\n+                    dependencyFoundServices.add(pendingService);\n                     return true;\n                 }\n                 return false;\n             });\n-            if (sz == pending.size()) {\n+            if (sz == pendingDependencyServices.size()) {\n                 // didn't find anything to remove, there must be a cycle\n                 break;\n             }\n         }\n-        return cachedOD = ready;\n+        return cachedOD = dependencyFoundServices;\n     }\n \n     public void writeEffectiveConfig() {\n"}}, {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "message": "Address comments", "committedDate": "2020-04-17T21:27:54Z", "type": "commit"}, {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "message": "Address comments", "committedDate": "2020-04-17T21:27:54Z", "type": "forcePushed"}]}