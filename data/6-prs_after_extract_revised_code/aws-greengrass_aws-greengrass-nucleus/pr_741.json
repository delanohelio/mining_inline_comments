{"pr_number": 741, "pr_title": "local deployment bug fix", "pr_createdAt": "2020-12-01T22:03:26Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741", "timeline": [{"oid": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea44fc3f59286e25ce3fe03d66271cf23185c777", "message": "local deployment bug fix", "committedDate": "2020-12-01T22:01:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533757293", "bodyText": "What is the logic behind special casing an empty file? I'm guessing some intent here, but intent is not described. If there isn't a legitimate reason to do this, we should treat this as an error instead as it would indicate customer made a mistake.", "author": "JamieHunter", "createdAt": "2020-12-01T22:15:21Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2Mjc1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533762756", "bodyText": "When it is empty, the Jackson deserialization fails, when it shouldn't necessarily fail since empty isn't exactly malformed.", "author": "MikeDombo", "createdAt": "2020-12-01T22:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2NjQxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533766410", "bodyText": "I moved this logic from CLI repo to kernel, tagging @MikeDombo  who wrote this logic", "author": "fahadmohammed01", "createdAt": "2020-12-01T22:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxMzE0MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533813140", "bodyText": "I think in that case then, we only care about empty files if the extension is one of the \"yaml/yml/json\" then", "author": "rbattle", "createdAt": "2020-12-02T00:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkwMzcyMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533903723", "bodyText": "you can remove this log line and move if (r.toFile().length() > 0) { in the try/catch block below.\nEmpty files will then get treated the same as \"unknown\" extension with a consistent message that they are not recognized as a recipe", "author": "rbattle", "createdAt": "2020-12-02T05:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0MjQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533942439", "bodyText": "Updated like wise", "author": "fahadmohammed01", "createdAt": "2020-12-02T07:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzY4Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533757686", "bodyText": "Is the assumption here to validate?", "author": "JamieHunter", "createdAt": "2020-12-01T22:16:08Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n+                continue;\n+            }\n+\n+            try {\n+                switch (ext.toLowerCase()) {\n+                    case \"yaml\":\n+                    case \"yml\":\n+                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MjUwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533782504", "bodyText": "I don't understand your question. We're reading it in as a recipe, so that will fail if it is malformed with a good error. The second reason to do this is to parse the name and version so that we can properly name the file when writing it into the local recipe store.", "author": "MikeDombo", "createdAt": "2020-12-01T23:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NjQzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533796432", "bodyText": "Making sure I understand the intent of the logic due to lack of comments and trying to guess intent.\nSo yes, intent is to (a) validate, and (b) use information to save name.\nComments please....", "author": "JamieHunter", "createdAt": "2020-12-01T23:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTA2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533801064", "bodyText": "added comments", "author": "fahadmohammed01", "createdAt": "2020-12-01T23:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1NzY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODQ1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533758450", "bodyText": "Why is this neither logged nor an error?", "author": "JamieHunter", "createdAt": "2020-12-01T22:17:36Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n+                continue;\n+            }\n+\n+            try {\n+                switch (ext.toLowerCase()) {\n+                    case \"yaml\":\n+                    case \"yml\":\n+                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    case \"json\":\n+                        recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    default:\n+                        break;", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MjYyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533782629", "bodyText": "If the recipe directory has non-recipes that isn't really a problem", "author": "MikeDombo", "createdAt": "2020-12-01T23:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NjY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533796695", "bodyText": "But it could also mean that the user named their recipe wrong and is scratching their head wondering why their recipe did not get loaded properly.", "author": "JamieHunter", "createdAt": "2020-12-01T23:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5OTg4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533799882", "bodyText": "we log the files that got skipped because the extension was not correct", "author": "fahadmohammed01", "createdAt": "2020-12-01T23:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODk1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533758952", "bodyText": "There's multiple code paths to the same effect - maybe empty file should log here. But is this really Info level? If only recipe files expected in that directory, error. Otherwise... comment comment comment.", "author": "JamieHunter", "createdAt": "2020-12-01T22:18:37Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n+                continue;\n+            }\n+\n+            try {\n+                switch (ext.toLowerCase()) {\n+                    case \"yaml\":\n+                    case \"yml\":\n+                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    case \"json\":\n+                        recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } catch (IOException e) {\n+                // Throw on error so that the user will receive this message and we will stop the deployment.\n+                // This is to fail fast while providing actionable feedback.\n+                throw new IOException(\n+                        String.format(\"Unable to parse %s as a recipe due to: %s\", r.toString(), e.getMessage()),\n+                        e);\n+            }\n+            if (recipe == null) {\n+                logger.atInfo().log(\"Skipping file {} because it was not recognized as a recipe\", r);", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4NjYyNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533786625", "bodyText": "Didnt understand your comment, this is just logging the files that are being ignored because the extension would not match that of a recipe file", "author": "fahadmohammed01", "createdAt": "2020-12-01T23:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxOTg3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533819878", "bodyText": "I interpret this comment as the log level is not high enough - we aren't expecting non recipe files here so either an error put them there, or the customer screwed up somehow. Jamie is suggesting to log it at error so it is obvious", "author": "rbattle", "createdAt": "2020-12-02T00:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgzMDg4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533830882", "bodyText": "updated log level to error", "author": "fahadmohammed01", "createdAt": "2020-12-02T01:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1ODk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1OTQ1Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533759456", "bodyText": "Why YAML, not JSON? We should be using JSON for intermediate storage due to issues with YAML (truncated YAML files are valid files). I thought we had decided this based on Lore review.", "author": "JamieHunter", "createdAt": "2020-12-01T22:19:36Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n+                continue;\n+            }\n+\n+            try {\n+                switch (ext.toLowerCase()) {\n+                    case \"yaml\":\n+                    case \"yml\":\n+                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    case \"json\":\n+                        recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } catch (IOException e) {\n+                // Throw on error so that the user will receive this message and we will stop the deployment.\n+                // This is to fail fast while providing actionable feedback.\n+                throw new IOException(\n+                        String.format(\"Unable to parse %s as a recipe due to: %s\", r.toString(), e.getMessage()),\n+                        e);\n+            }\n+            if (recipe == null) {\n+                logger.atInfo().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n+                continue;\n+            }\n+\n+            // Write the recipe as YAML with the proper filename into the store\n+            ComponentIdentifier componentIdentifier =\n+                    new ComponentIdentifier(recipe.getComponentName(), recipe.getComponentVersion());", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MzAxNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533763017", "bodyText": "Recipes are always stored as YAML on disk", "author": "MikeDombo", "createdAt": "2020-12-01T22:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1OTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NzE3Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533797176", "bodyText": "Per LORE, intermediate data should be JSON. We accept YAML as a concession to the user. As this is not intended for editing by the user it should be JSON.", "author": "JamieHunter", "createdAt": "2020-12-01T23:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1OTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5Nzc3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533797772", "bodyText": "This isn't intermediate though. This is the final file which will be written to disk", "author": "MikeDombo", "createdAt": "2020-12-01T23:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1OTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODI3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533798272", "bodyText": "https://www.coe.a2z.com/coe/93856/content To give an example of why you generally don't store things in YAML. If the machine reboots half way through writing YAML file, it'll be considered valid.", "author": "JamieHunter", "createdAt": "2020-12-01T23:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc1OTQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MDExNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533760115", "bodyText": "Do we log two errors if the file is bad?", "author": "JamieHunter", "createdAt": "2020-12-01T22:20:46Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,84 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);\n+        }\n+    }\n+\n+\n+    private void copyRecipesToComponentStore(Path from) throws IOException {\n+        for (Path r : Files.walk(from).collect(Collectors.toList())) {\n+            String ext = Utils.extension(r.toString());\n+            ComponentRecipe recipe = null;\n+            if (r.toFile().length() == 0) {\n+                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n+                continue;\n+            }\n+\n+            try {\n+                switch (ext.toLowerCase()) {\n+                    case \"yaml\":\n+                    case \"yml\":\n+                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    case \"json\":\n+                        recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } catch (IOException e) {\n+                // Throw on error so that the user will receive this message and we will stop the deployment.\n+                // This is to fail fast while providing actionable feedback.\n+                throw new IOException(\n+                        String.format(\"Unable to parse %s as a recipe due to: %s\", r.toString(), e.getMessage()),\n+                        e);\n+            }\n+            if (recipe == null) {\n+                logger.atInfo().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n+                continue;\n+            }\n+\n+            // Write the recipe as YAML with the proper filename into the store\n+            ComponentIdentifier componentIdentifier =\n+                    new ComponentIdentifier(recipe.getComponentName(), recipe.getComponentVersion());\n+\n+            try {\n+                componentStore.savePackageRecipe(componentIdentifier,\n+                        getRecipeSerializer().writeValueAsString(recipe));\n+            } catch (PackageLoadingException e) {\n+                // Throw on error so that the user will receive this message and we will stop the deployment.\n+                // This is to fail fast while providing actionable feedback.\n+                throw new IOException(String.format(\"Unable to copy recipe for '%s' to component store due to: %s\",\n+                        componentIdentifier.toString(), e.getMessage()), e);", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MzM5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533783399", "bodyText": "I don't think so, this error is only when it cannot be saved for some reason, which should be rare.", "author": "MikeDombo", "createdAt": "2020-12-01T23:09:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4NDU1Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533784552", "bodyText": "no we just log the error thrown above and fail the deployment", "author": "fahadmohammed01", "createdAt": "2020-12-01T23:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MDExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 4eb1c157e..56771ee17 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -510,6 +510,9 @@ public class DeploymentService extends GreengrassService {\n                 continue;\n             }\n \n+            //reading it in as a recipe, so that will fail if it is malformed with a good error.\n+            //The second reason to do this is to parse the name and version so that we can properly name\n+            //the file when writing it into the local recipe store.\n             try {\n                 switch (ext.toLowerCase()) {\n                     case \"yaml\":\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MDg2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533760866", "bodyText": "Is this supposed to be an immutable class? All these fields should be final else we may have threading memory access issues.", "author": "JamieHunter", "createdAt": "2020-12-01T22:22:15Z", "path": "src/main/java/com/aws/greengrass/deployment/model/LocalOverrideRequest.java", "diffHunk": "@@ -37,4 +37,8 @@\n     Map<String, ConfigurationUpdateOperation> configurationUpdate;\n \n     Map<String, RunWithInfo> componentToRunWithInfo;\n+\n+    String recipeDirectoryPath;", "originalCommit": "ea44fc3f59286e25ce3fe03d66271cf23185c777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3ODYzMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533778633", "bodyText": "This class is used in an immutable way. But this class requires a no args constructor for serialization to work. Hence not marked final", "author": "fahadmohammed01", "createdAt": "2020-12-01T22:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MDg2Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ebf8b15183b79b7f2a93d3c08c93a138bae5eea7", "message": "added comment", "committedDate": "2020-12-01T23:54:14Z", "type": "commit"}, {"oid": "adb1a466da13aa431eb56a42f8b80aaf0790ddcb", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/adb1a466da13aa431eb56a42f8b80aaf0790ddcb", "message": "Merge branch 'master' into local-deployment-bug-fix", "committedDate": "2020-12-01T23:55:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxMjY0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533812642", "bodyText": "is it a valid request to have an empty recipe directory path and empty artifacts path?", "author": "rbattle", "createdAt": "2020-12-02T00:27:05Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,87 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {", "originalCommit": "adb1a466da13aa431eb56a42f8b80aaf0790ddcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNTgyNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533825826", "bodyText": "Yes, local override request can be made for updating a config entry.", "author": "fahadmohammed01", "createdAt": "2020-12-02T01:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxMjY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8c220e5d01f7d79d43aa6bb2150030145807a7b3", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 56771ee17..0a5ac70f9 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -533,7 +533,7 @@ public class DeploymentService extends GreengrassService {\n                         e);\n             }\n             if (recipe == null) {\n-                logger.atInfo().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n+                logger.atError().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533817387", "bodyText": "why do you populate the messages for IOExceptions, but not here?\nIt seems like you want to return a \"fancy\" exception so you send it to the deployment status keeper.\nWhy not have a custom exception that does this for you instead of rebuilding messages in IOException?", "author": "rbattle", "createdAt": "2020-12-02T00:40:15Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -444,6 +472,87 @@ private void createNewDeployment(Deployment deployment) {\n                                            new AtomicInteger(1), deployment.getDeploymentDocumentObj(), cancellable);\n     }\n \n+    @SuppressWarnings(\"PMD.ExceptionAsFlowControl\")\n+    private void copyRecipesAndArtifacts(Deployment deployment) throws InvalidRequestException, IOException {\n+        try {\n+            LocalOverrideRequest localOverrideRequest = SerializerFactory.getFailSafeJsonObjectMapper()\n+                    .readValue(deployment.getDeploymentDocument(), LocalOverrideRequest.class);\n+            if (!Utils.isEmpty(localOverrideRequest.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(localOverrideRequest.getRecipeDirectoryPath());\n+                copyRecipesToComponentStore(recipeDirectoryPath);\n+\n+            }\n+\n+            if (!Utils.isEmpty(localOverrideRequest.getArtifactsDirectoryPath())) {\n+                Path kernelArtifactsDirectoryPath = kernel.getNucleusPaths().componentStorePath()\n+                        .resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                Path artifactsDirectoryPath = Paths.get(localOverrideRequest.getArtifactsDirectoryPath());\n+                try {\n+                    Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                            StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new IOException(String.format(\"Unable to copy artifacts from  %s due to: %s\",\n+                            artifactsDirectoryPath.toString(), e.getMessage()), e);\n+                }\n+            }\n+        } catch (JsonProcessingException e) {\n+            throw new InvalidRequestException(\"Unable to parse the job document\", e);", "originalCommit": "adb1a466da13aa431eb56a42f8b80aaf0790ddcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxOTUxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533819518", "bodyText": "For the case of a local deployment, do customers provide the job document?\nShould this say 'Unable to parse the deployment' instead?", "author": "rbattle", "createdAt": "2020-12-02T00:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNzI3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533827277", "bodyText": "no the customer do not provide the job document,  customer uses the CLI to provide the information, which gets to the CLI plugin via IPC and the plugin creates the job document", "author": "fahadmohammed01", "createdAt": "2020-12-02T01:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyOTc1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533829753", "bodyText": "populated the messaeges for Io-exception to make it more readable.  The customer when checking the deployment status doesnt see the exception type but just the error message. InvalidRequestException is used for failure in parsing the deployment document at few places, hence used it to be consistent.", "author": "fahadmohammed01", "createdAt": "2020-12-02T01:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg3MTA4OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533871089", "bodyText": "Asking in another way - what is special about this exception that it doesn't get the more \"readable\" treatment to include the source exception message? What determines whether a source exception message needs to go to the status keeper?\nI guess my point is - how are you supposed to know whether to rethrow an exception or prettify it? Is it if the exception comes from one of the private methods here you \"know\" it's been updated, and if it's from any other source it needs to be wrapped?", "author": "rbattle", "createdAt": "2020-12-02T03:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg5ODc2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533898769", "bodyText": "what is special about this exception that it doesn't get the more \"readable\" treatment to include the source exception message?\nThe JsonProcessingException above if thrown would be due to a bug in CLI plugin/kernel. There is nothing the customer can do to fix that as the job document is constructed by the plugin in and parsed by the kernel.  The more readable treatment is given to exceptions where the issue is on the customer side, like an invalid recipe.\nWhat determines whether a source exception message needs to go to the status keeper?\nIf the exception causes the deployment to fail,  the status keeper need to be updated that the deployment failed and the exception message is stored in the DeploymentStatusDetails section to provide more info on the failure.", "author": "fahadmohammed01", "createdAt": "2020-12-02T05:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkxOTQ5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533919491", "bodyText": "Thanks for the explanation - to be clear, I wasn't asking about why the exception message needs to go the status keeper, but under what circumstances it needs to be wrapped and re-thrown.\nIt is unfortunate to have to guess the intention of whether an exception is useful to explain to the customer vs one that is not - Exceptions and their messages are part of our interface with the customer - granted this is not like being part of the SDK - but I'm assuming that these status messages will either end up in the status service or when the customer looks at the result of the deployment. Is that correct? If it the exception can get in front of the customer has to have some meaning - even if it is not the fault of the customer. It's their device that has an error - and we are the ones that are going to get tickets and have to explain.\nLooking at the PackageLoadingExceptions that the ComponentStore is throwing, we are going to get message given back to the status keeper like:\nUnable to copy recipe for '<my awesome component>' to component store due to: Failed to save package recipe\"\nwhich doesn't provide any helpful context when entered into the status keeper.\nThere is also an issue to improve the error messages in the component store - lets suppose it does change to add more info -and whoever updates the ComponentStore doesn't know how the exception is used downstream. We might get end up with something like:\nUnable to copy recipe for '<my awesome component>' to component store due to: Failed to save package recipe for '<my awesome component> because of No space left on device\"`\nIn this (hypothetical) case it would have been better to leave the PackageLoadingException alone and not modify the exception message.\nFor the JSON processing example here, even just changing the phrasing to something like Unable to parse the deployment request - invalid JSON would at least tell you something (and it might be worth logging the deployment doc here so that it can be captured - unless we have security reasons not to log that)", "author": "rbattle", "createdAt": "2020-12-02T06:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk0OTYwNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r533949607", "bodyText": "Status messages for the local deployments do not get propagated to the fleet status service. Only the deployment status is propagated to the customer via the CLI and status message is not used.\nFor the JSON processing example: updated the error message. But not sure that would help customers root cause it as a kernel bug vs bug in something they did.\nI agree that if the component store returns a more meaning full message, the message can get more verbose.  But as of now the current the exception message from the component store may not provide the recipe name for which the save operation failed and it would be useful to keep that in the exception message", "author": "fahadmohammed01", "createdAt": "2020-12-02T07:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMjMzMQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r534312331", "bodyText": "Alright - I think we can wrap up the discussion here then - I wish this was a bit clearer though - if there is an issue for updating the exceptions can you update it to make sure they check all usages of the exception (and specifically this class) or create one if there isn't", "author": "rbattle", "createdAt": "2020-12-02T16:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MzgwMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r534353803", "bodyText": "updated sim https://sim.amazon.com/issues/P41215929.", "author": "fahadmohammed01", "createdAt": "2020-12-02T17:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgxNzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8c220e5d01f7d79d43aa6bb2150030145807a7b3", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 56771ee17..0a5ac70f9 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -533,7 +533,7 @@ public class DeploymentService extends GreengrassService {\n                         e);\n             }\n             if (recipe == null) {\n-                logger.atInfo().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n+                logger.atError().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n                 continue;\n             }\n \n"}}, {"oid": "8c220e5d01f7d79d43aa6bb2150030145807a7b3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8c220e5d01f7d79d43aa6bb2150030145807a7b3", "message": "updated log level", "committedDate": "2020-12-02T01:16:59Z", "type": "commit"}, {"oid": "ce136cf6c29ed101b52da32a5f62039952291f40", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ce136cf6c29ed101b52da32a5f62039952291f40", "message": "Merge branch 'master' into local-deployment-bug-fix", "committedDate": "2020-12-02T04:51:39Z", "type": "commit"}, {"oid": "be2e7931b036a778eb6e2b65457004169526d968", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be2e7931b036a778eb6e2b65457004169526d968", "message": "addressed comments", "committedDate": "2020-12-02T07:32:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3OTY0OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r534279648", "bodyText": "this is unnecessary since you already check above - the length should not be 0 here", "author": "rbattle", "createdAt": "2020-12-02T15:56:10Z", "path": "src/main/java/com/aws/greengrass/deployment/DeploymentService.java", "diffHunk": "@@ -505,32 +505,31 @@ private void copyRecipesToComponentStore(Path from) throws IOException {\n         for (Path r : Files.walk(from).collect(Collectors.toList())) {\n             String ext = Utils.extension(r.toString());\n             ComponentRecipe recipe = null;\n-            if (r.toFile().length() == 0) {\n-                logger.atInfo().log(\"Skipping recipe file {} because it is empty\", r);\n-                continue;\n-            }\n \n             //reading it in as a recipe, so that will fail if it is malformed with a good error.\n             //The second reason to do this is to parse the name and version so that we can properly name\n             //the file when writing it into the local recipe store.\n             try {\n-                switch (ext.toLowerCase()) {\n-                    case \"yaml\":\n-                    case \"yml\":\n-                        recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n-                        break;\n-                    case \"json\":\n-                        recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n-                        break;\n-                    default:\n-                        break;\n+                if (r.toFile().length() > 0) {\n+                    switch (ext.toLowerCase()) {\n+                        case \"yaml\":\n+                        case \"yml\":\n+                            recipe = getRecipeSerializer().readValue(r.toFile(), ComponentRecipe.class);\n+                            break;\n+                        case \"json\":\n+                            recipe = getRecipeSerializerJson().readValue(r.toFile(), ComponentRecipe.class);\n+                            break;\n+                        default:\n+                            break;\n+                    }\n                 }\n             } catch (IOException e) {\n                 // Throw on error so that the user will receive this message and we will stop the deployment.\n                 // This is to fail fast while providing actionable feedback.\n-                throw new IOException(\n-                        String.format(\"Unable to parse %s as a recipe due to: %s\", r.toString(), e.getMessage()),\n-                        e);\n+                if (r.toFile().length() > 0) {", "originalCommit": "be2e7931b036a778eb6e2b65457004169526d968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MzUxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/741#discussion_r534353513", "bodyText": "removed this check", "author": "fahadmohammed01", "createdAt": "2020-12-02T17:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3OTY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f5d738c590eb78c988c54d69394dc654bdad36db", "chunk": "diff --git a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\nindex 5ad5e390d..bc98f32ce 100644\n--- a/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n+++ b/src/main/java/com/aws/greengrass/deployment/DeploymentService.java\n\n@@ -526,10 +526,8 @@ public class DeploymentService extends GreengrassService {\n             } catch (IOException e) {\n                 // Throw on error so that the user will receive this message and we will stop the deployment.\n                 // This is to fail fast while providing actionable feedback.\n-                if (r.toFile().length() > 0) {\n-                    throw new IOException(String.format(\"Unable to parse %s as a recipe due to: %s\",\n-                            r.toString(), e.getMessage()), e);\n-                }\n+                throw new IOException(String.format(\"Unable to parse %s as a recipe due to: %s\",\n+                        r.toString(), e.getMessage()), e);\n             }\n             if (recipe == null) {\n                 logger.atError().log(\"Skipping file {} because it was not recognized as a recipe\", r);\n"}}, {"oid": "f5d738c590eb78c988c54d69394dc654bdad36db", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5d738c590eb78c988c54d69394dc654bdad36db", "message": "removed reduntant check", "committedDate": "2020-12-02T17:28:07Z", "type": "commit"}, {"oid": "2b5c22721792917550a3123f78e35aaf195df311", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2b5c22721792917550a3123f78e35aaf195df311", "message": "Merge branch 'master' into local-deployment-bug-fix", "committedDate": "2020-12-02T17:34:24Z", "type": "commit"}, {"oid": "3c1af116c4f77b86832da6d6dd624674d65a895e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3c1af116c4f77b86832da6d6dd624674d65a895e", "message": "Merge branch 'master' into local-deployment-bug-fix", "committedDate": "2020-12-02T17:48:45Z", "type": "commit"}]}