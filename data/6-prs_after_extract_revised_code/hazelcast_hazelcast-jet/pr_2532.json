{"pr_number": 2532, "pr_title": "Fix job hanging due to lost DONE_ITEM", "pr_createdAt": "2020-09-18T14:14:13Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2532", "timeline": [{"oid": "32a7d3074cc22c43f55fee41e738cdf8847044b8", "url": "https://github.com/hazelcast/hazelcast-jet/commit/32a7d3074cc22c43f55fee41e738cdf8847044b8", "message": "Fix job hanging due to lost DONE_ITEM\n\nThe failure scenario was this:\n\n- SenderTasklet reaches EOS in tryFillInbox(), writes DONE_ITEM\n\n- We try to send the last packet in the call method, Connection.write()\nreturns true\n\n- The connection is broken and the packet is never sent. The connection\nis transparently reestablished, but the packet isn't sent again.\n\n- Jet doesn't use this connection anymore in SenderTasklet as EOS has\nbeen reached, so the failure goes unnoticed\n\n- Remote member never receives the packet, the ReceiverTasklet will keep\nwaiting for the DONE_ITEM\n\nThe solution is that when the ReceiverTasklet creates data for the flow\ncontrol packet, it compares that the Connection object it was crated\nwith is the same.\n\nWe send the flow control packet regularly so any transparent\nreconnection will cause the job to fail. Currently it would fail only if\nsome SenderTasklet tried to send something.\n\nFixes #2158", "committedDate": "2020-09-18T14:13:14Z", "type": "commit"}, {"oid": "f8af7ea9088e01c98a71ef0279d52acef35f0887", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f8af7ea9088e01c98a71ef0279d52acef35f0887", "message": "Fix checkstyle", "committedDate": "2020-09-18T14:22:00Z", "type": "commit"}, {"oid": "b223b6030887a697fdc6f4ada94f16f76f5716c3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b223b6030887a697fdc6f4ada94f16f76f5716c3", "message": "Use unique name for real-network clusters", "committedDate": "2020-09-18T14:49:50Z", "type": "commit"}, {"oid": "112e78192a14f1a2788d121bfdd505beabc8b1aa", "url": "https://github.com/hazelcast/hazelcast-jet/commit/112e78192a14f1a2788d121bfdd505beabc8b1aa", "message": "Update Javadoc", "committedDate": "2020-09-21T11:25:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDI4NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491970285", "bodyText": "Is this change mostly about \"FP delete\"? The new code has explicit types on everything, but with the types being Integer, Map etc., their true meaning is not known, and previously there were lambda parameters with descriptive names. I don't see a win here.", "author": "mtopolnik", "createdAt": "2020-09-21T11:31:14Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java", "diffHunk": "@@ -129,23 +131,26 @@ private void broadcastFlowControlPacket() {\n         }\n     }\n \n-    private byte[] createFlowControlPacket(Address member) throws IOException {\n+    private byte[] createFlowControlPacket(Address member, Connection expectedConnection) throws IOException {\n         try (BufferObjectDataOutput output = createObjectDataOutput(nodeEngine, lastFlowPacketSize)) {\n-            final boolean[] hasData = {false};\n+            boolean hasData = false;\n             Map<Long, ExecutionContext> executionContexts = jobExecutionService.getExecutionContextsFor(member);\n             output.writeInt(executionContexts.size());\n-            executionContexts.forEach((execId, exeCtx) -> uncheckRun(() -> {", "originalCommit": "112e78192a14f1a2788d121bfdd505beabc8b1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4ODg0NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491988845", "bodyText": "I guess FP means functional programming. Then yes. It also creates less garbage and it's easier to debug.\nThe only real change is the argument to updateAndGetSendSeqLimitCompressed IIRC.", "author": "viliam-durina", "createdAt": "2020-09-21T12:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7353206c7aee417b4edcfbcaaf4da7e84f81760e", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java\nindex 63f2491ab1..369e7de670 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java\n\n@@ -136,15 +136,21 @@ public class Networking {\n             boolean hasData = false;\n             Map<Long, ExecutionContext> executionContexts = jobExecutionService.getExecutionContextsFor(member);\n             output.writeInt(executionContexts.size());\n-            for (Entry<Long, ExecutionContext> entry : executionContexts.entrySet()) {\n-                output.writeLong(entry.getKey()); // executionId\n-                Map<Integer, Map<Integer, Map<Address, ReceiverTasklet>>> receiverMap = entry.getValue().receiverMap();\n+            for (Entry<Long, ExecutionContext> executionIdAndCtx : executionContexts.entrySet()) {\n+                output.writeLong(executionIdAndCtx.getKey());\n+                // dest vertex id --> dest ordinal --> sender addr --> receiver tasklet\n+                Map<Integer, Map<Integer, Map<Address, ReceiverTasklet>>> receiverMap =\n+                        executionIdAndCtx.getValue().receiverMap();\n                 output.writeInt(receiverMap.values().stream().mapToInt(Map::size).sum());\n-                for (Entry<Integer, Map<Integer, Map<Address, ReceiverTasklet>>> e : receiverMap.entrySet()) {\n-                    for (Entry<Integer, Map<Address, ReceiverTasklet>> mapEntry : e.getValue().entrySet()) {\n-                        output.writeInt(e.getKey());\n-                        output.writeInt(mapEntry.getKey());\n-                        ReceiverTasklet receiverTasklet = mapEntry.getValue().get(member);\n+                for (Entry<Integer, Map<Integer, Map<Address, ReceiverTasklet>>> e1 : receiverMap.entrySet()) {\n+                    int vertexId = e1.getKey();\n+                    Map<Integer, Map<Address, ReceiverTasklet>> ordinalToMemberToTasklet = e1.getValue();\n+                    for (Entry<Integer, Map<Address, ReceiverTasklet>> e2 : ordinalToMemberToTasklet.entrySet()) {\n+                        int ordinal = e2.getKey();\n+                        Map<Address, ReceiverTasklet> memberToTasklet = e2.getValue();\n+                        output.writeInt(vertexId);\n+                        output.writeInt(ordinal);\n+                        ReceiverTasklet receiverTasklet = memberToTasklet.get(member);\n                         output.writeInt(receiverTasklet.updateAndGetSendSeqLimitCompressed(expectedConnection));\n                         hasData = true;\n                     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MjY2MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491972660", "bodyText": "Does this just make a problem less likely? Since the read and write of this variable are concurrent to each other?", "author": "mtopolnik", "createdAt": "2020-09-21T11:36:19Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/ReceiverTasklet.java", "diffHunk": "@@ -208,9 +217,14 @@ public int updateAndGetSendSeqLimitCompressed() {\n      *\n      * @param timestampNow value of the timestamp at the time the method is called. The timestamp\n      *                     must be obtained from {@code System.nanoTime()}.\n+     * @param expectedConnection The connection to which the result will be sent. We use it\n+     *                           to check that it's the same connection the tasklet was crated with.\n      */\n     // Invoked sequentially by a task scheduler\n-    int updateAndGetSendSeqLimitCompressed(long timestampNow) {\n+    int updateAndGetSendSeqLimitCompressed(long timestampNow, Connection expectedConnection) {\n+        if (!Objects.equals(expectedConnection, memberConnection)) {\n+            connectionChanged = true;", "originalCommit": "112e78192a14f1a2788d121bfdd505beabc8b1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk5MDE1MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491990150", "bodyText": "It should prevent the problem completely. The connectionChanged is checked in a loop so if it's changed to true (and it's only ever changed to true), it will be noticed, the error will be thrown and the job will fail and not get stuck.", "author": "viliam-durina", "createdAt": "2020-09-21T12:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MjY2MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7353206c7aee417b4edcfbcaaf4da7e84f81760e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7353206c7aee417b4edcfbcaaf4da7e84f81760e", "message": "Improve readability", "committedDate": "2020-09-21T12:22:11Z", "type": "commit"}]}