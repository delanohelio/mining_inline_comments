{"pr_number": 2671, "pr_title": "Fix race in MetricsContext", "pr_createdAt": "2020-11-17T11:36:26Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2671", "timeline": [{"oid": "d38f24e7e7aa3fee93567ca35cf8106330ccd48a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d38f24e7e7aa3fee93567ca35cf8106330ccd48a", "message": "Fix race in MetricsContext", "committedDate": "2020-11-17T11:32:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEyNDQ3MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525124471", "bodyText": "threadSafeStore.forEach(consumer); ?", "author": "gurbuzali", "createdAt": "2020-11-17T12:42:22Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;\n+        private volatile ConcurrentMap<String, AbstractMetric> threadSafeStore;\n+\n+        /**\n+         * Always called on the same thread, the one executing the Tasklet this context belongs to.\n+         */\n+        Metric localGet(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n+            if (threadLocalStore == null) { //first metric being stored\n+                threadLocalStore = new HashMap<>();\n+                threadSafeStore = new ConcurrentHashMap<>();\n+            }\n+\n+            AbstractMetric metric = threadLocalStore.get(name);\n+            if (metric != null) {\n+                return metric;\n+            }\n+\n+            metric = metricSupplier.apply(name, unit);\n+            threadLocalStore.put(name, metric);\n+            threadSafeStore.put(name, metric);\n+\n+            return metric;\n+        }\n+\n+        void threadSafeForEach(BiConsumer<? super String, ? super AbstractMetric> consumer) {\n+            if (threadSafeStore != null) {\n+                threadLocalStore.forEach(consumer);", "originalCommit": "d38f24e7e7aa3fee93567ca35cf8106330ccd48a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNTUyMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525135520", "bodyText": "Yeah... copy-paste... Fixing it.", "author": "jbartok", "createdAt": "2020-11-17T13:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEyNDQ3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "36f0e3ec968615c0a33d86c0c981533ab24606bb", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\nindex 2946ccd39..c98c6de7e 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n\n@@ -210,7 +210,7 @@ public class MetricsContext implements DynamicMetricsProvider {\n \n         void threadSafeForEach(BiConsumer<? super String, ? super AbstractMetric> consumer) {\n             if (threadSafeStore != null) {\n-                threadLocalStore.forEach(consumer);\n+                threadSafeStore.forEach(consumer);\n             }\n         }\n     }\n"}}, {"oid": "36f0e3ec968615c0a33d86c0c981533ab24606bb", "url": "https://github.com/hazelcast/hazelcast-jet/commit/36f0e3ec968615c0a33d86c0c981533ab24606bb", "message": "Fix copy-paste mistake", "committedDate": "2020-11-17T13:02:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg1ODY3Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525858676", "bodyText": "addUserTag(tagger) is not necessary any more", "author": "gurbuzali", "createdAt": "2020-11-18T07:14:31Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -50,47 +50,15 @@ Metric threadSafeMetric(String name, Unit unit) {\n     }\n \n     private Metric metric(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n-        if (metrics == null) { //at most one already defined metric\n-            if (onlyMetric == null) { //no already defined metrics\n-                onlyMetric = metricSupplier.apply(name, unit);\n-                onlyName = name;\n-                return onlyMetric;\n-            } else { //one single already defined metric\n-                if (name.equals(onlyName)) { //single already defined metric same as the requested one\n-                    return onlyMetric;\n-                } else { //single already defined metric different from the requested one\n-                    metrics = new HashMap<>();\n-                    metrics.put(onlyName, onlyMetric);\n-\n-                    onlyMetric = null;\n-                    onlyName = null;\n-\n-                    AbstractMetric metric = metricSupplier.apply(name, unit);\n-                    metrics.put(name, metric);\n-                    return metric;\n-                }\n-            }\n-        } else { //multiple metrics already defined\n-            AbstractMetric metric = metrics.get(name);\n-            if (metric == null) { //requested metric not yet defined\n-                metric = metricSupplier.apply(name, unit);\n-                metrics.put(name, metric);\n-            }\n-            return metric;\n-        }\n+        return store.localGet(name, unit, metricSupplier);\n     }\n \n     @Override\n     public void provideDynamicMetrics(MetricDescriptor tagger, MetricsCollectionContext context) {\n-        if (onlyMetric != null) {\n-            context.collect(\n-                    addUserTag(tagger), onlyName, ProbeLevel.INFO, toProbeUnit(onlyMetric.unit()), onlyMetric.get()\n-            );\n-        } else if (metrics != null) {\n-            MetricDescriptor withUserTag = addUserTag(tagger);", "originalCommit": "36f0e3ec968615c0a33d86c0c981533ab24606bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4b3d10fff75cd8bb7feed21635cafc3ef658f214", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\nindex c98c6de7e..366184b3b 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n\n@@ -50,15 +47,28 @@ public class MetricsContext implements DynamicMetricsProvider {\n     }\n \n     private Metric metric(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n-        return store.localGet(name, unit, metricSupplier);\n+        if (metrics == null) { //first metric being stored\n+            metrics = new ConcurrentHashMap<>();\n+        }\n+\n+        AbstractMetric metric = metrics.get(name);\n+        if (metric != null) {\n+            return metric;\n+        }\n+\n+        metric = metricSupplier.apply(name, unit);\n+        metrics.put(name, metric);\n+\n+        return metric;\n     }\n \n     @Override\n     public void provideDynamicMetrics(MetricDescriptor tagger, MetricsCollectionContext context) {\n-        MetricDescriptor withUserTag = tagger.copy().withTag(MetricTags.USER, \"true\");\n-\n-        store.threadSafeForEach((name, metric) ->\n-                context.collect(withUserTag, name, ProbeLevel.INFO, toProbeUnit(metric.unit()), metric.get()));\n+        if (metrics != null) {\n+            MetricDescriptor withUserTag = addUserTag(tagger);\n+            metrics.forEach((name, metric) ->\n+                    context.collect(withUserTag, name, ProbeLevel.INFO, toProbeUnit(metric.unit()), metric.get()));\n+        }\n     }\n \n     private static MetricDescriptor addUserTag(MetricDescriptor tagger) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525864373", "bodyText": "we are doubling the memory footprint and complicating the implementation to provide a fast local get. Is this really necessary? does it affect the performance that much to use a single ConcurrentHashMap ?", "author": "gurbuzali", "createdAt": "2020-11-18T07:28:32Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;", "originalCommit": "36f0e3ec968615c0a33d86c0c981533ab24606bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3NDkzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525874936", "bodyText": "The metric method is called for each processed item, so with just using the ConcurrentHashMap, the performance impact might be too big. At least that's what I think...", "author": "jbartok", "createdAt": "2020-11-18T07:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5MzQyOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525893428", "bodyText": "I was curious and suspected that a non-contended read-only CHM might be very similar to plain HM because non-contended volatile read on x86 is as fast as a non-volatile read:\nBenchmark     Mode  Cnt   Score   Error  Units\nChmBench.chm  avgt   10  21,687 \u00b1 0,122  ns/op\nChmBench.hm   avgt   10  22,610 \u00b1 0,163  ns/op\n\nsource:\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Thread)\n@Fork(value = 1, warmups = 1)\n@Warmup(iterations = 10)\n@Measurement(iterations = 10)\npublic class ChmBench {\n\n    private final Map<String, Integer> chm = new ConcurrentHashMap<>();\n    private final Map<String, Integer> hm = new HashMap<>();\n\n    {\n        chm.put(\"1\", 1);\n        chm.put(\"2\", 2);\n        chm.put(\"3\", 3);\n\n        hm.putAll(chm);\n    }\n\n    @Benchmark\n    public void chm() {\n        chm.get(\"3\");\n        chm.get(\"1\");\n        chm.get(\"2\");\n    }\n\n    @Benchmark\n    public void hm() {\n        hm.get(\"3\");\n        hm.get(\"1\");\n        hm.get(\"2\");\n    }\n}\nMaybe another CPU will be different, I don't know. I used JDK 1.8.", "author": "viliam-durina", "createdAt": "2020-11-18T08:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4b3d10fff75cd8bb7feed21635cafc3ef658f214", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\nindex c98c6de7e..366184b3b 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java\n\n@@ -177,42 +187,4 @@ public class MetricsContext implements DynamicMetricsProvider {\n         }\n     }\n \n-    /**\n-     * Map for storing metrics on a per name basis. Meant to offer fast,\n-     * single-threaded access, but also a loosely consistent, thread safe\n-     * way to iterate over the content.\n-     */\n-    private static class MetricsStore {\n-\n-        private Map<String, AbstractMetric> threadLocalStore;\n-        private volatile ConcurrentMap<String, AbstractMetric> threadSafeStore;\n-\n-        /**\n-         * Always called on the same thread, the one executing the Tasklet this context belongs to.\n-         */\n-        Metric localGet(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n-            if (threadLocalStore == null) { //first metric being stored\n-                threadLocalStore = new HashMap<>();\n-                threadSafeStore = new ConcurrentHashMap<>();\n-            }\n-\n-            AbstractMetric metric = threadLocalStore.get(name);\n-            if (metric != null) {\n-                return metric;\n-            }\n-\n-            metric = metricSupplier.apply(name, unit);\n-            threadLocalStore.put(name, metric);\n-            threadSafeStore.put(name, metric);\n-\n-            return metric;\n-        }\n-\n-        void threadSafeForEach(BiConsumer<? super String, ? super AbstractMetric> consumer) {\n-            if (threadSafeStore != null) {\n-                threadSafeStore.forEach(consumer);\n-            }\n-        }\n-    }\n-\n }\n"}}, {"oid": "4b3d10fff75cd8bb7feed21635cafc3ef658f214", "url": "https://github.com/hazelcast/hazelcast-jet/commit/4b3d10fff75cd8bb7feed21635cafc3ef658f214", "message": "Removed duplicate thread-local map", "committedDate": "2020-11-18T10:39:18Z", "type": "commit"}]}