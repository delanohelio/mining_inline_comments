{"pr_number": 2754, "pr_title": "Add FANOUT routing policy", "pr_createdAt": "2020-12-14T13:58:38Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2754", "timeline": [{"oid": "a763782deb2945ef6fb1c136dd025f7c926602f4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a763782deb2945ef6fb1c136dd025f7c926602f4", "message": "Add FANOUT routing policy", "committedDate": "2020-12-14T13:47:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542442375", "bodyText": "This doesn't state which processor on each member. The PR mentions \"round robin\" so I guess it's a different processor every time?", "author": "mtopolnik", "createdAt": "2020-12-14T14:49:31Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +692,12 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends each item to a single processor on each of the", "originalCommit": "a763782deb2945ef6fb1c136dd025f7c926602f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0OTk2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542449962", "bodyText": "Slightly reworded.", "author": "gierlachg", "createdAt": "2020-12-14T14:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ2NjQ4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542466489", "bodyText": "I think it would be better to describe the procedure made in a round-robin fashion in another sentence. Because it's a bit unclear what exactly is done in a round-robin fashion.", "author": "ufukyilmaz", "createdAt": "2020-12-14T15:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU1ODgwNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542558807", "bodyText": "Let's follow the lead of UNICAST, which says \"with no restriction on the choice.\" Here we can say \"sends each item to a single processor on every cluster member. Which exactly processor inside a member it chooses is arbitrary and may change with every item.\".", "author": "mtopolnik", "createdAt": "2020-12-14T17:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYwNjE0OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542606149", "bodyText": "Currently, we can run a DAG containing a fanout edge only in a cluster containing multiple members. Is this expected behavior? I would expect it to act like unicast when it is running on single member because we can normally run a DAG with a distributed edge on a single member.\nOtherwise, failing the job in this case is the expected behavior, let's note it here. Also, I think that we should add tests to RoutingPolicyTest for distributed edge types to demonstrate the single member behavior of them (I am aware that currently other distributed edge types isn't tested for their single member behaviors either.)", "author": "ufukyilmaz", "createdAt": "2020-12-14T18:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\nindex 58b46c040..633b369f6 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\n@@ -695,7 +695,8 @@ public class Edge implements IdentifiedDataSerializable {\n         BROADCAST,\n         /**\n          * This policy sends each item to a single processor on each of the\n-         * cluster members. It is only available on a distributed edge.\n+         * cluster members in a round robin fashion. It is only available\n+         * on a distributed edge.\n          */\n         FANOUT\n     }\n"}}, {"oid": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "message": "Improve javadocs", "committedDate": "2020-12-14T14:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzMTIxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542631212", "bodyText": "This causes a job to be failed when it runs on a single member. If it is not intended, you can check this", "author": "ufukyilmaz", "createdAt": "2020-12-14T18:43:51Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -378,23 +379,160 @@ private void initDag(InternalSerializationService jobSerializationService) {\n         return processors;\n     }\n \n+    private List<OutboundEdgeStream> createOutboundEdgeStreams(\n+            VertexDef vertex,\n+            int processorIdx,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n+        for (EdgeDef edge : vertex.outboundEdges()) {\n+            OutboundCollector outboundCollector = createOutboundCollector(edge, processorIdx, jobSerializationService);\n+            OutboundEdgeStream outboundEdgeStream = new OutboundEdgeStream(edge.sourceOrdinal(), outboundCollector);\n+            outboundStreams.add(outboundEdgeStream);\n+        }\n+        return outboundStreams;\n+    }\n+\n     /**\n-     * Populates {@code localConveyorMap}, {@code edgeSenderConveyorMap}.\n-     * Populates {@link #senderMap} and {@link #tasklets} fields.\n+     * Each edge is represented by an array of conveyors between the producers and consumers.\n+     * There are as many conveyors as there are consumers.\n+     * Each conveyor has one queue per producer.\n+     *\n+     * For a distributed edge, there is one additional producer per member represented\n+     * by the ReceiverTasklet.\n      */\n-    private List<OutboundEdgeStream> createOutboundEdgeStreams(VertexDef srcVertex, int processorIdx,\n-                                                               InternalSerializationService jobSerializationService) {\n-        final List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n-        for (EdgeDef edge : srcVertex.outboundEdges()) {\n-            Map<Address, ConcurrentConveyor<Object>> memberToSenderConveyorMap = null;\n-            if (edge.getDistributedTo() != null) {\n-                memberToSenderConveyorMap =\n-                        memberToSenderConveyorMap(edgeSenderConveyorMap, edge, jobSerializationService);\n+    private OutboundCollector createOutboundCollector(\n+            EdgeDef edge,\n+            int processorIndex,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+            throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n+        }\n+        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n+            && edge.routingPolicy() == RoutingPolicy.FANOUT) {\n+            throw new IllegalArgumentException(\"Fanout edges must be distributed: \" + edge);", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\nindex d5ee45cb3..5f6227e9d 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\n\n@@ -406,13 +405,9 @@ public class ExecutionPlan implements IdentifiedDataSerializable {\n             int processorIndex,\n             InternalSerializationService jobSerializationService\n     ) {\n-        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+        if (edge.routingPolicy() == RoutingPolicy.ISOLATED && edge.getDistributedTo() != null) {\n             throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n         }\n-        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n-            && edge.routingPolicy() == RoutingPolicy.FANOUT) {\n-            throw new IllegalArgumentException(\"Fanout edges must be distributed: \" + edge);\n-        }\n \n         int totalPartitionCount = nodeEngine.getPartitionService().getPartitionCount();\n         int[][] partitionsPerProcessor = getLocalPartitionDistribution(edge, edge.destVertex().localParallelism());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMTUxNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543111517", "bodyText": "This method and the localCompositeCollector method are almost the same, except for the FANOUT case. It might be easier to follow if we have just one method, add boolean local argument, and in the FANOUT case do:\nlocal ? new RoundRobin(collectors) : new Broadcast(collectors);", "author": "viliam-durina", "createdAt": "2020-12-15T07:36:51Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java", "diffHunk": "@@ -76,6 +77,26 @@ static OutboundCollector compositeCollector(\n         }\n     }\n \n+    static OutboundCollector distributedCompositeCollector(", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java\nindex ca6397e0f..7bdd56fda 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java\n\n@@ -66,32 +66,13 @@ public interface OutboundCollector {\n         switch (outboundEdge.routingPolicy()) {\n             case UNICAST:\n             case ISOLATED:\n-            case FANOUT:\n                 return new RoundRobin(collectors);\n             case PARTITIONED:\n                 return new Partitioned(collectors, outboundEdge.partitioner(), partitionCount);\n             case BROADCAST:\n                 return new Broadcast(collectors);\n-            default:\n-                throw new AssertionError(\"Missing case label for \" + outboundEdge.routingPolicy());\n-        }\n-    }\n-\n-    static OutboundCollector distributedCompositeCollector(\n-            OutboundCollector[] collectors, EdgeDef outboundEdge, int partitionCount\n-    ) {\n-        if (collectors.length == 1) {\n-            return collectors[0];\n-        }\n-        switch (outboundEdge.routingPolicy()) {\n-            case UNICAST:\n-            case ISOLATED:\n-                return new RoundRobin(collectors);\n-            case PARTITIONED:\n-                return new Partitioned(collectors, outboundEdge.partitioner(), partitionCount);\n-            case BROADCAST:\n             case FANOUT:\n-                return new Broadcast(collectors);\n+                return local ? new RoundRobin(collectors) : new Broadcast(collectors);\n             default:\n                 throw new AssertionError(\"Missing case label for \" + outboundEdge.routingPolicy());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNjYyOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543126628", "bodyText": "If the second condition is true, the first is always true:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n          \n          \n            \n                    if (!DISTRIBUTE_TO_ALL.equals(edge.getDistributedTo())", "author": "viliam-durina", "createdAt": "2020-12-15T08:04:14Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -378,23 +379,160 @@ private void initDag(InternalSerializationService jobSerializationService) {\n         return processors;\n     }\n \n+    private List<OutboundEdgeStream> createOutboundEdgeStreams(\n+            VertexDef vertex,\n+            int processorIdx,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n+        for (EdgeDef edge : vertex.outboundEdges()) {\n+            OutboundCollector outboundCollector = createOutboundCollector(edge, processorIdx, jobSerializationService);\n+            OutboundEdgeStream outboundEdgeStream = new OutboundEdgeStream(edge.sourceOrdinal(), outboundCollector);\n+            outboundStreams.add(outboundEdgeStream);\n+        }\n+        return outboundStreams;\n+    }\n+\n     /**\n-     * Populates {@code localConveyorMap}, {@code edgeSenderConveyorMap}.\n-     * Populates {@link #senderMap} and {@link #tasklets} fields.\n+     * Each edge is represented by an array of conveyors between the producers and consumers.\n+     * There are as many conveyors as there are consumers.\n+     * Each conveyor has one queue per producer.\n+     *\n+     * For a distributed edge, there is one additional producer per member represented\n+     * by the ReceiverTasklet.\n      */\n-    private List<OutboundEdgeStream> createOutboundEdgeStreams(VertexDef srcVertex, int processorIdx,\n-                                                               InternalSerializationService jobSerializationService) {\n-        final List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n-        for (EdgeDef edge : srcVertex.outboundEdges()) {\n-            Map<Address, ConcurrentConveyor<Object>> memberToSenderConveyorMap = null;\n-            if (edge.getDistributedTo() != null) {\n-                memberToSenderConveyorMap =\n-                        memberToSenderConveyorMap(edgeSenderConveyorMap, edge, jobSerializationService);\n+    private OutboundCollector createOutboundCollector(\n+            EdgeDef edge,\n+            int processorIndex,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+            throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n+        }\n+        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\nindex d5ee45cb3..5f6227e9d 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java\n\n@@ -406,13 +405,9 @@ public class ExecutionPlan implements IdentifiedDataSerializable {\n             int processorIndex,\n             InternalSerializationService jobSerializationService\n     ) {\n-        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+        if (edge.routingPolicy() == RoutingPolicy.ISOLATED && edge.getDistributedTo() != null) {\n             throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n         }\n-        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n-            && edge.routingPolicy() == RoutingPolicy.FANOUT) {\n-            throw new IllegalArgumentException(\"Fanout edges must be distributed: \" + edge);\n-        }\n \n         int totalPartitionCount = nodeEngine.getPartitionService().getPartitionCount();\n         int[][] partitionsPerProcessor = getLocalPartitionDistribution(edge, edge.destVertex().localParallelism());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MjgxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543152812", "bodyText": "I specifically didn't want to create this method because of the distributed-to-one edge type - it won't strike your eye that there are two types of distributed edges, especially when the distributed-to-one is rarely used. Maybe we can create isLocal method instead, it seems that there are more instances of !edge.isDistributed() than without the negation.", "author": "viliam-durina", "createdAt": "2020-12-15T08:46:30Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java", "diffHunk": "@@ -114,6 +114,10 @@ Address getDistributedTo() {\n         return distributedTo;\n     }\n \n+    boolean isDistributed() {", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java\nindex 25aad6f05..3370d7ac0 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java\n\n@@ -114,10 +114,6 @@ public class EdgeDef implements IdentifiedDataSerializable {\n         return distributedTo;\n     }\n \n-    boolean isDistributed() {\n-        return distributedTo != null;\n-    }\n-\n     EdgeConfig getConfig() {\n         return config;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE2NzcxNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543167716", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /**\n          \n          \n            \n                     * This policy sends each item to a single processor on each of the\n          \n          \n            \n                     * cluster members in a round robin fashion. It is only available\n          \n          \n            \n                     * on a distributed edge.\n          \n          \n            \n                     */\n          \n          \n            \n                    /**\n          \n          \n            \n                     * This policy sends an item to all members, but only to one processor on\n          \n          \n            \n                     * each member. It's a combination of {@link #BROADCAST} and {@link\n          \n          \n            \n                     * #UNICAST}: an item is first <em>broadcast</em> to all members, and then,\n          \n          \n            \n                     * on each member, it is <em>unicast</em> to one processor.\n          \n          \n            \n                     * <p>\n          \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @since 4.4\n          \n          \n            \n                     */", "author": "viliam-durina", "createdAt": "2020-12-15T09:08:42Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +692,13 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends each item to a single processor on each of the\n+         * cluster members in a round robin fashion. It is only available\n+         * on a distributed edge.\n+         */", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a99e679f74adfc05a64ee6fdf58230c92e1b71b4", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\nindex 633b369f6..d350747f8 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\n@@ -694,9 +694,15 @@ public class Edge implements IdentifiedDataSerializable {\n          */\n         BROADCAST,\n         /**\n-         * This policy sends each item to a single processor on each of the\n-         * cluster members in a round robin fashion. It is only available\n-         * on a distributed edge.\n+         * This policy sends an item to all members, but only to one processor on\n+         * each member. It's a combination of {@link #BROADCAST} and {@link\n+         * #UNICAST}: an item is first <em>broadcast</em> to all members, and then,\n+         * on each member, it is <em>unicast</em> to one processor.\n+         * <p>\n+         * If the destination local parallelism is 1, the behavior is equal to\n+         * {@link #BROADCAST}.\n+         *\n+         * @since 4.4\n          */\n         FANOUT\n     }\n"}}, {"oid": "a99e679f74adfc05a64ee6fdf58230c92e1b71b4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a99e679f74adfc05a64ee6fdf58230c92e1b71b4", "message": "Update hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-12-15T09:09:40Z", "type": "commit"}, {"oid": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/14a6547b76b190d1ffae894b046d5c019eeb12c3", "message": "Allow FANOUT for local edges & fix it for single node clusters", "committedDate": "2020-12-15T09:38:38Z", "type": "commit"}, {"oid": "308f600f232229acbfae271b58f5c1beffe9432d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/308f600f232229acbfae271b58f5c1beffe9432d", "message": "Update javadoc", "committedDate": "2020-12-15T10:09:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0OTIyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543249222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}.\n          \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}. If the member count in the cluster is 1, the\n          \n          \n            \n                     * behavior is equal to {@link #UNICAST}.", "author": "viliam-durina", "createdAt": "2020-12-15T11:04:01Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +690,19 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends an item to all members, but only to one processor on\n+         * each member. It's a combination of {@link #BROADCAST} and {@link\n+         * #UNICAST}: an item is first <em>broadcast</em> to all members, and then,\n+         * on each member, it is <em>unicast</em> to one processor.\n+         * <p>\n+         * If the destination local parallelism is 1, the behavior is equal to\n+         * {@link #BROADCAST}.", "originalCommit": "308f600f232229acbfae271b58f5c1beffe9432d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "230e083200842104848aefcdb0793c1969acacfd", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\nindex dcc82b7ff..7e796e3cd 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\n@@ -698,7 +698,8 @@ public class Edge implements IdentifiedDataSerializable {\n          * on each member, it is <em>unicast</em> to one processor.\n          * <p>\n          * If the destination local parallelism is 1, the behavior is equal to\n-         * {@link #BROADCAST}.\n+         * {@link #BROADCAST}. If the member count in the cluster is 1, the\n+         * behavior is equal to {@link #UNICAST}.\n          *\n          * @since 4.4\n          */\n"}}, {"oid": "230e083200842104848aefcdb0793c1969acacfd", "url": "https://github.com/hazelcast/hazelcast-jet/commit/230e083200842104848aefcdb0793c1969acacfd", "message": "Update hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-12-15T11:06:17Z", "type": "commit"}, {"oid": "f628d36295c4c087291c98cf15e5de411a7ef631", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f628d36295c4c087291c98cf15e5de411a7ef631", "message": "Add EdgeDef.isLocal()", "committedDate": "2020-12-15T11:07:56Z", "type": "commit"}]}