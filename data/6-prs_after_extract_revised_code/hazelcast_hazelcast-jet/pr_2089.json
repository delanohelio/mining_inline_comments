{"pr_number": 2089, "pr_title": "Inner join distinction", "pr_createdAt": "2020-03-23T17:27:16Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2089", "timeline": [{"oid": "3f0f6702543aed5876ecb2f1a85e237c376fd7b0", "url": "https://github.com/hazelcast/hazelcast-jet/commit/3f0f6702543aed5876ecb2f1a85e237c376fd7b0", "message": "Added special innerHashJoin method, to avoid repetitive filtering and make it more clear for users #1238", "committedDate": "2020-03-23T17:21:41Z", "type": "commit"}, {"oid": "a66ec04259cf1375401080f193bf237946c3b0b6", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a66ec04259cf1375401080f193bf237946c3b0b6", "message": "Added JavaDoc", "committedDate": "2020-03-23T17:27:12Z", "type": "commit"}, {"oid": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d8c44e658586e4aae4c9f0008fb8e5c51a048919", "message": "Fix checkstyl error", "committedDate": "2020-03-23T19:18:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODE4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678189", "bodyText": "Please follow the formatting guidelines you can infer from the rest of the docs. We use text line length of 72 (excluding any indentation and *),  we don't use </p> and we don't indent the text.", "author": "mtopolnik", "createdAt": "2020-03-25T08:27:58Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3OTkxMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397679913", "bodyText": "You should also update the Javadoc that this doc points to. The com.hazelcast.jet.pipeline Javadoc now explicitly states that \"hash join is a left-outer join\".", "author": "mtopolnik", "createdAt": "2020-03-25T08:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 44abf81bc5..d1610dd907 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -751,8 +751,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * Attaches to both this and the supplied stage\n+     * an inner-hash-joining stage and  returns it.\n+     * This stage plays the role of the <em>primary stage</em> in\n      * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODQzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678436", "bodyText": "Typo: metod", "author": "mtopolnik", "createdAt": "2020-03-25T08:28:27Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     *     This metod is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)} method,", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 44abf81bc5..d1610dd907 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -751,8 +751,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * Attaches to both this and the supplied stage\n+     * an inner-hash-joining stage and  returns it.\n+     * This stage plays the role of the <em>primary stage</em> in\n      * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY3ODU0Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397678542", "bodyText": "Typo: a inner, should be an inner.", "author": "mtopolnik", "createdAt": "2020-03-25T08:28:41Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,48 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage a inner-hash-joining stage and", "originalCommit": "d8c44e658586e4aae4c9f0008fb8e5c51a048919", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 44abf81bc5..d1610dd907 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -751,8 +751,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to both this and the supplied stage a inner-hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * Attaches to both this and the supplied stage\n+     * an inner-hash-joining stage and  returns it.\n+     * This stage plays the role of the <em>primary stage</em> in\n      * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"oid": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "message": "Fixed formatting and added info to package-info", "committedDate": "2020-03-25T12:54:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397841062", "bodyText": "Please reflow these paragraphs.", "author": "mtopolnik", "createdAt": "2020-03-25T13:12:25Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2MTgzNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401761836", "bodyText": "Please reflow these paragraphs.\n\nBy reflow you mean only formatting or also how sentences are written?", "author": "TomaszGaweda", "createdAt": "2020-04-01T16:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NjMyMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401796321", "bodyText": "Just the formatting aspect :)", "author": "mtopolnik", "createdAt": "2020-04-01T17:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MTA2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e875aabb41969304f2410a700addc9810272fa7d", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\nindex 65eecb3cba..ffb569d354 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n\n@@ -72,24 +72,21 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output of {@code hashJoin} is just like an SQL left-outer join:\n- * for each primary item there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item.\n+ * The output of {@code hashJoin} is just like an SQL left outer join:\n+ * for each primary item there are N output items,  one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, the output will have a {@code null} instead of the enriching item.\n  * <p>\n- * If SQL inner-join is needed,\n- * then specialised {@code innerHashJoin} can be used, in which\n- * for each primary item with at least one match, there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item,\n- * there will be no records with given primary item.\n- * In this case output function's arguments are always non-null.\n+ * If you need SQL inner join, then you can use the specialised\n+ * {@code innerHashJoin} function, in which for each primary item with\n+ * at least one match, there are N output items, one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, there will be no records with given primary item. In this case\n+ * output function's arguments are always non-null.\n  *\n  * <p>\n- * The join also allows\n- * duplicate keys on both enriching and primary inputs: the output is a\n- * cartesian product of all the matching entries.\n+ * The join also allows duplicate keys on both enriching and primary inputs:\n+ * the output is a cartesian product of all the matching entries.\n \n  * <p>\n  * Example:<pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MjE5OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397842198", "bodyText": "Please try to use the active voice as much as possible. This can be \"If you need the inner join, \". Also note \"inner join\" (without a dash). We actually need to fix \"hash-join\" into \"hash join\" as well, but this is not the topic of this PR.", "author": "mtopolnik", "createdAt": "2020-03-25T13:13:52Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e875aabb41969304f2410a700addc9810272fa7d", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\nindex 65eecb3cba..ffb569d354 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n\n@@ -72,24 +72,21 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output of {@code hashJoin} is just like an SQL left-outer join:\n- * for each primary item there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item.\n+ * The output of {@code hashJoin} is just like an SQL left outer join:\n+ * for each primary item there are N output items,  one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, the output will have a {@code null} instead of the enriching item.\n  * <p>\n- * If SQL inner-join is needed,\n- * then specialised {@code innerHashJoin} can be used, in which\n- * for each primary item with at least one match, there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item,\n- * there will be no records with given primary item.\n- * In this case output function's arguments are always non-null.\n+ * If you need SQL inner join, then you can use the specialised\n+ * {@code innerHashJoin} function, in which for each primary item with\n+ * at least one match, there are N output items, one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, there will be no records with given primary item. In this case\n+ * output function's arguments are always non-null.\n  *\n  * <p>\n- * The join also allows\n- * duplicate keys on both enriching and primary inputs: the output is a\n- * cartesian product of all the matching entries.\n+ * The join also allows duplicate keys on both enriching and primary inputs:\n+ * the output is a cartesian product of all the matching entries.\n \n  * <p>\n  * Example:<pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzE3Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843177", "bodyText": "the specialized innerHashJoin", "author": "mtopolnik", "createdAt": "2020-03-25T13:15:21Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e875aabb41969304f2410a700addc9810272fa7d", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\nindex 65eecb3cba..ffb569d354 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n\n@@ -72,24 +72,21 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output of {@code hashJoin} is just like an SQL left-outer join:\n- * for each primary item there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item.\n+ * The output of {@code hashJoin} is just like an SQL left outer join:\n+ * for each primary item there are N output items,  one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, the output will have a {@code null} instead of the enriching item.\n  * <p>\n- * If SQL inner-join is needed,\n- * then specialised {@code innerHashJoin} can be used, in which\n- * for each primary item with at least one match, there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item,\n- * there will be no records with given primary item.\n- * In this case output function's arguments are always non-null.\n+ * If you need SQL inner join, then you can use the specialised\n+ * {@code innerHashJoin} function, in which for each primary item with\n+ * at least one match, there are N output items, one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, there will be no records with given primary item. In this case\n+ * output function's arguments are always non-null.\n  *\n  * <p>\n- * The join also allows\n- * duplicate keys on both enriching and primary inputs: the output is a\n- * cartesian product of all the matching entries.\n+ * The join also allows duplicate keys on both enriching and primary inputs:\n+ * the output is a cartesian product of all the matching entries.\n \n  * <p>\n  * Example:<pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzQzMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843433", "bodyText": "with the given primary item", "author": "mtopolnik", "createdAt": "2020-03-25T13:15:44Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which\n+ * for each primary item with at least one match, there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item,\n+ * there will be no records with given primary item.", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e875aabb41969304f2410a700addc9810272fa7d", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\nindex 65eecb3cba..ffb569d354 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n\n@@ -72,24 +72,21 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output of {@code hashJoin} is just like an SQL left-outer join:\n- * for each primary item there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item.\n+ * The output of {@code hashJoin} is just like an SQL left outer join:\n+ * for each primary item there are N output items,  one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, the output will have a {@code null} instead of the enriching item.\n  * <p>\n- * If SQL inner-join is needed,\n- * then specialised {@code innerHashJoin} can be used, in which\n- * for each primary item with at least one match, there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item,\n- * there will be no records with given primary item.\n- * In this case output function's arguments are always non-null.\n+ * If you need SQL inner join, then you can use the specialised\n+ * {@code innerHashJoin} function, in which for each primary item with\n+ * at least one match, there are N output items, one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, there will be no records with given primary item. In this case\n+ * output function's arguments are always non-null.\n  *\n  * <p>\n- * The join also allows\n- * duplicate keys on both enriching and primary inputs: the output is a\n- * cartesian product of all the matching entries.\n+ * The join also allows duplicate keys on both enriching and primary inputs:\n+ * the output is a cartesian product of all the matching entries.\n \n  * <p>\n  * Example:<pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzcwOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397843709", "bodyText": "the output function's", "author": "mtopolnik", "createdAt": "2020-03-25T13:16:10Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java", "diffHunk": "@@ -72,12 +72,25 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output is just like an SQL left-outer join: for each primary item\n- * there are N output items, one for each matching item in the enriching\n- * set. If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item. The join also allows\n+ * The output of {@code hashJoin} is just like an SQL left-outer join:\n+ * for each primary item there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item, the output will\n+ * have a {@code null} instead of the enriching item.\n+ * <p>\n+ * If SQL inner-join is needed,\n+ * then specialised {@code innerHashJoin} can be used, in which\n+ * for each primary item with at least one match, there are N output items,\n+ * one for each matching item in the enriching set.\n+ * If an enriching set doesn't have a matching item,\n+ * there will be no records with given primary item.\n+ * In this case output function's arguments are always non-null.", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e875aabb41969304f2410a700addc9810272fa7d", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\nindex 65eecb3cba..ffb569d354 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/package-info.java\n\n@@ -72,24 +72,21 @@\n  * hashtables (hence the name). It consumes the enriching streams in full\n  * before ingesting any data from the primary stream.\n  * <p>\n- * The output of {@code hashJoin} is just like an SQL left-outer join:\n- * for each primary item there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item, the output will\n- * have a {@code null} instead of the enriching item.\n+ * The output of {@code hashJoin} is just like an SQL left outer join:\n+ * for each primary item there are N output items,  one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, the output will have a {@code null} instead of the enriching item.\n  * <p>\n- * If SQL inner-join is needed,\n- * then specialised {@code innerHashJoin} can be used, in which\n- * for each primary item with at least one match, there are N output items,\n- * one for each matching item in the enriching set.\n- * If an enriching set doesn't have a matching item,\n- * there will be no records with given primary item.\n- * In this case output function's arguments are always non-null.\n+ * If you need SQL inner join, then you can use the specialised\n+ * {@code innerHashJoin} function, in which for each primary item with\n+ * at least one match, there are N output items, one for each matching\n+ * item in the enriching set. If an enriching set doesn't have a matching\n+ * item, there will be no records with given primary item. In this case\n+ * output function's arguments are always non-null.\n  *\n  * <p>\n- * The join also allows\n- * duplicate keys on both enriching and primary inputs: the output is a\n- * cartesian product of all the matching entries.\n+ * The join also allows duplicate keys on both enriching and primary inputs:\n+ * the output is a cartesian product of all the matching entries.\n \n  * <p>\n  * Example:<pre>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0NzMyNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397847325", "bodyText": "This claims to test that innerHashJoin filters out nulls, but it actually uses hashJoin and asserts that it does not filter out nulls.\nAbout method naming: we use _ only for special purposes like the structure when_predondition_then_postcondition. So this method should be when_hashJoin_then_dontFilterOutNulls or similar.", "author": "mtopolnik", "createdAt": "2020-03-25T13:21:42Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java", "diffHunk": "@@ -1035,6 +1035,35 @@ public void hashJoin_when_outputFnReturnsNull_then_filteredOut() {\n         assertEquals(emptyList(), new ArrayList<>(sinkList));\n     }\n \n+    @Test", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "52ed9207980bce7e7eedb9f0b91fd81c9cf7452a", "chunk": "diff --git a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\nindex 081b9d127b..00102972af 100644\n--- a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\n+++ b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\n\n@@ -1036,20 +1036,16 @@ public class BatchStageTest extends PipelineTestSupport {\n     }\n \n     @Test\n-    public void innerHashJoin_filter_out_nulls() {\n+    public void when_innerHashJoin_then_filterOutNulls() {\n         // Given\n-        int invalidIdStart = itemCount * 2;\n         List<Integer> input = sequence(itemCount);\n         String prefix = \"value-\";\n-        BatchStage<Entry<Integer, String>> enrichingStageMatching = batchStageFromList(input)\n+        BatchStage<Entry<Integer, String>> enrichingStage = batchStageFromList(input)\n+                .filter(i -> i % 2 == 0)\n                 .map(i -> entry(i, prefix + i));\n-        BatchStage<Entry<Integer, String>> enrichingStageNonMatching = batchStageFromList(input)\n-                .map(i -> entry(invalidIdStart + i, \"nope\"));\n-\n-        BatchStage<Entry<Integer, String>> enrichingStage = enrichingStageMatching.merge(enrichingStageNonMatching);\n \n         // When\n-        BatchStage<Entry<Integer, String>> joined = batchStageFromList(input).hashJoin(\n+        BatchStage<Entry<Integer, String>> joined = batchStageFromList(input).innerHashJoin(\n                 enrichingStage,\n                 joinMapEntries(wholeItem()),\n                 Util::entry);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0OTE1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r397849153", "bodyText": "This seems to test the behavior common to inner and outer join. The input has no nulls to begin with.", "author": "mtopolnik", "createdAt": "2020-03-25T13:24:16Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java", "diffHunk": "@@ -1253,6 +1253,39 @@ public void hashJoin() {\n         );\n     }\n \n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void innerHashJoin() {", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ce78bfad0b67eb1041b3559bc7fe0252873e7568", "chunk": "diff --git a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java\nindex 3121eae6eb..53487f8108 100644\n--- a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java\n+++ b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/StreamStageTest.java\n\n@@ -1259,8 +1259,9 @@ public class StreamStageTest extends PipelineStreamTestSupport {\n         // Given\n         List<Integer> input = sequence(itemCount);\n         String prefixA = \"A\";\n-        // entry(0, \"A-0000\"), entry(1, \"A-0001\"), ...\n-        BatchStage<Entry<Integer, String>> enrichingStage = enrichingStage(input, prefixA);\n+        // entry(0, \"A-0000\"), entry(2, \"A-0002\"), ...\n+        List<Integer> enrichingInputList = input.stream().filter(e -> e % 2 == 0).collect(toList());\n+        BatchStage<Entry<Integer, String>> enrichingStage = enrichingStage(enrichingInputList, prefixA);\n \n         // When\n         @SuppressWarnings(\"Convert2MethodRef\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r399630514", "bodyText": "We also have hashJoin2() and hashJoinBuilder(), they also need the same API extension. You could add a method to the hash join builder: buildInner.", "author": "mtopolnik", "createdAt": "2020-03-28T07:14:55Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/pipeline/BatchStageImpl.java", "diffHunk": "@@ -165,6 +165,21 @@ public BatchStageImpl(@Nonnull Transform transform, FunctionAdapter ignored, @No\n         return attachHashJoin(stage1, joinClause1, mapToOutputFn);\n     }\n \n+    @Nonnull @Override\n+    public <K, T1_IN, T1, R> BatchStage<R> innerHashJoin(\n+            @Nonnull BatchStage<T1_IN> stage1,\n+            @Nonnull JoinClause<K, ? super T, ? super T1_IN, ? extends T1> joinClause1,\n+            @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n+    ) {\n+        BiFunctionEx<T, T1, R> finalOutputFn = (leftSide, rightSide) -> {\n+            if (leftSide == null || rightSide == null) {\n+                return null;\n+            }\n+            return mapToOutputFn.apply(leftSide, rightSide);\n+        };\n+        return attachHashJoin(stage1, joinClause1, finalOutputFn);\n+    }\n+", "originalCommit": "e45f7b7cfd12f9438cbdb7a56773ee2e3b04bb81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4MTYxMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401781610", "bodyText": "Maybe not builderInner, but rather addInner? So you can have left outer and inner join in one builder", "author": "TomaszGaweda", "createdAt": "2020-04-01T17:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5Njg5OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r401796899", "bodyText": "Yes, sounds better than my idea.", "author": "mtopolnik", "createdAt": "2020-04-01T17:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYzMDUxNA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "52ed9207980bce7e7eedb9f0b91fd81c9cf7452a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/52ed9207980bce7e7eedb9f0b91fd81c9cf7452a", "message": "Fix test - intention was to show that innerHashJoin filter outs nulsl", "committedDate": "2020-04-01T16:43:50Z", "type": "commit"}, {"oid": "ce78bfad0b67eb1041b3559bc7fe0252873e7568", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ce78bfad0b67eb1041b3559bc7fe0252873e7568", "message": "Fix another test - show that innerHashJoin works in stream scenario", "committedDate": "2020-04-01T16:46:59Z", "type": "commit"}, {"oid": "e875aabb41969304f2410a700addc9810272fa7d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e875aabb41969304f2410a700addc9810272fa7d", "message": "Fixed JavaDoc as per CR Comments", "committedDate": "2020-04-01T16:58:08Z", "type": "commit"}, {"oid": "cfdea20ddc71021c38e807ab8666ceee8e2368d3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/cfdea20ddc71021c38e807ab8666ceee8e2368d3", "message": "Added The there needed", "committedDate": "2020-04-01T16:59:56Z", "type": "commit"}, {"oid": "f67c69299fad3ced5691b58408e95bc746221909", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f67c69299fad3ced5691b58408e95bc746221909", "message": "Fixed line length", "committedDate": "2020-04-01T17:12:39Z", "type": "commit"}, {"oid": "f840f2aba73e603efdfe608d7ef58974aeb7f6cc", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f840f2aba73e603efdfe608d7ef58974aeb7f6cc", "message": "Added missing since", "committedDate": "2020-04-02T13:40:39Z", "type": "commit"}, {"oid": "d41155e2fba0e77c42803d73d464c7ffcec5ca3f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d41155e2fba0e77c42803d73d464c7ffcec5ca3f", "message": "Added innerHashJoin2", "committedDate": "2020-04-16T18:32:30Z", "type": "commit"}, {"oid": "7690fea8d56a61e20f45d58608d2a45112f7a48f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7690fea8d56a61e20f45d58608d2a45112f7a48f", "message": "Added addInner to HashJoinBuilder", "committedDate": "2020-04-16T19:58:08Z", "type": "commit"}, {"oid": "a6f21975abae376d0af6069d08b12eb9e2ff9965", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a6f21975abae376d0af6069d08b12eb9e2ff9965", "message": "Fixed test and Reversed condition.", "committedDate": "2020-04-16T20:02:39Z", "type": "commit"}, {"oid": "5ff8d2ca545b11cfd4435f0e05d995106edc1c19", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5ff8d2ca545b11cfd4435f0e05d995106edc1c19", "message": "Added misssing since annotation", "committedDate": "2020-04-17T08:08:00Z", "type": "commit"}, {"oid": "af34d0de1ad6e745ad35a940044d3bf9e1264007", "url": "https://github.com/hazelcast/hazelcast-jet/commit/af34d0de1ad6e745ad35a940044d3bf9e1264007", "message": "Improved formatting and JavaDocs in general", "committedDate": "2020-04-17T08:14:33Z", "type": "commit"}, {"oid": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "url": "https://github.com/hazelcast/hazelcast-jet/commit/e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "message": "Fixed checkstyle errors", "committedDate": "2020-04-17T12:26:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyODQwMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410228402", "bodyText": "There's a double space here.", "author": "mtopolnik", "createdAt": "2020-04-17T13:38:42Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -752,7 +752,7 @@ public interface GeneralStage<T> extends Stage {\n \n     /**\n      * Attaches to both this and the supplied stage an inner hash-joining stage\n-     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n      * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTE2Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229163", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:39:49Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -839,9 +839,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to this and the two supplied stages a inner hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n-     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * Attaches to this and the two supplied stages a inner hash-joining stage\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n      * This sample joins a stream of users to streams of countries and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTQ3Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229477", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:40:20Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to streams of countries and\n+     * companies, and outputs a stream of users with the {@code country} and\n+     * {@code company} fields set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     * BatchStage<Map.Entry<Long, Company>> idAndCompany;\n+     *\n+     * users.innerHashJoin2(\n+     *     idAndCountry, JoinClause.joinMapEntries(User::getCountryId),\n+     *     idAndCompany, JoinClause.joinMapEntries(User::getCompanyId),\n+     *     (user, country, company) -> user.setCountry(country).setCompany(company)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin2(BatchStage, JoinClause, BatchStage, JoinClause, TriFunction)}", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -839,9 +839,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to this and the two supplied stages a inner hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n-     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * Attaches to this and the two supplied stages a inner hash-joining stage\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n      * This sample joins a stream of users to streams of countries and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyOTY4Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410229687", "bodyText": "Line too long. Note that you can just refer to a method name without parameters.", "author": "mtopolnik", "createdAt": "2020-04-17T13:40:40Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)}", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -752,7 +752,7 @@ public interface GeneralStage<T> extends Stage {\n \n     /**\n      * Attaches to both this and the supplied stage an inner hash-joining stage\n-     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n      * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDA2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230067", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:41:17Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java", "diffHunk": "@@ -82,7 +82,28 @@\n      */\n     public <K, T1_IN, T1> Tag<T1> add(BatchStage<T1_IN> stage, JoinClause<K, T0, T1_IN, T1> joinClause) {\n         Tag<T1> tag = tag(clauses.size());\n-        clauses.put(tag, new TransformAndClause<>(stage, joinClause));\n+        clauses.put(tag, new TransformAndClause<>(stage, joinClause, false));\n+        return tag;\n+    }\n+\n+    /**\n+     * Adds another contributing pipeline stage to the hash-join operation.\n+     *\n+     * If no matching items for returned {@linkplain Tag tag} is found, no records", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\nindex 4332647e53..96a42d12e6 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\n\n@@ -89,8 +89,8 @@ public abstract class GeneralHashJoinBuilder<T0> {\n     /**\n      * Adds another contributing pipeline stage to the hash-join operation.\n      *\n-     * If no matching items for returned {@linkplain Tag tag} is found, no records\n-     * for given key will be added.\n+     * If no matching items for returned {@linkplain Tag tag} is found, no\n+     * records for given key will be added.\n      *\n      * @param stage the contributing stage\n      * @param joinClause specifies how to join the contributing stage\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDcxOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230718", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:42:15Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -750,6 +750,49 @@\n             @Nonnull BiFunctionEx<T, T1, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to both this and the supplied stage an inner hash-joining stage\n+     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to a stream of countries and outputs\n+     * a stream of users with the {@code country} field set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     *\n+     * users.innerHashJoin(\n+     *     idAndCountry,\n+     *     JoinClause.joinMapEntries(User::getCountryId),\n+     *     (user, country) -> user.setCountry(country)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin(BatchStage, JoinClause, BiFunctionEx)}\n+     * method, but it guarantees that both input items will be not-null. Nulls will", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -752,7 +752,7 @@ public interface GeneralStage<T> extends Stage {\n \n     /**\n      * Attaches to both this and the supplied stage an inner hash-joining stage\n-     * and  returns it. This stage plays the role of the <em>primary stage</em>\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n      * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDk2OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410230968", "bodyText": "Line too long.", "author": "mtopolnik", "createdAt": "2020-04-17T13:42:40Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java", "diffHunk": "@@ -795,6 +838,58 @@\n             @Nonnull TriFunction<T, T1, T2, R> mapToOutputFn\n     );\n \n+    /**\n+     * Attaches to this and the two supplied stages a inner hash-joining stage and\n+     * returns it. This stage plays the role of the <em>primary stage</em> in\n+     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * package javadoc} for a detailed description of the hash-join transform.\n+     * <p>\n+     * This sample joins a stream of users to streams of countries and\n+     * companies, and outputs a stream of users with the {@code country} and\n+     * {@code company} fields set:\n+     * <pre>{@code\n+     * // Types of the input stages:\n+     * BatchStage<User> users;\n+     * BatchStage<Map.Entry<Long, Country>> idAndCountry;\n+     * BatchStage<Map.Entry<Long, Company>> idAndCompany;\n+     *\n+     * users.innerHashJoin2(\n+     *     idAndCountry, JoinClause.joinMapEntries(User::getCountryId),\n+     *     idAndCompany, JoinClause.joinMapEntries(User::getCompanyId),\n+     *     (user, country, company) -> user.setCountry(country).setCompany(company)\n+     * )\n+     * }</pre>\n+     *\n+     * <p>\n+     * This method is similar to {@link #hashJoin2(BatchStage, JoinClause, BatchStage, JoinClause, TriFunction)}\n+     * method, but it guarantees that both input items will be not-null. Nulls will", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1ODc4Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410258782", "bodyText": "All this comments are addressed. Limit of 72 chars in line will be my next nightmare I think :D", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzMDk2OA=="}], "type": "inlineReview", "revised_code": {"commit": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\nindex 863509f983..8407c40396 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralStage.java\n\n@@ -839,9 +839,9 @@ public interface GeneralStage<T> extends Stage {\n     );\n \n     /**\n-     * Attaches to this and the two supplied stages a inner hash-joining stage and\n-     * returns it. This stage plays the role of the <em>primary stage</em> in\n-     * the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n+     * Attaches to this and the two supplied stages a inner hash-joining stage\n+     * and returns it. This stage plays the role of the <em>primary stage</em>\n+     * in the hash-join. Please refer to the {@link com.hazelcast.jet.pipeline\n      * package javadoc} for a detailed description of the hash-join transform.\n      * <p>\n      * This sample joins a stream of users to streams of countries and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410241967", "bodyText": "Could you adjust this test so that one side is inner join and the other outer? I think that would test for the less trivial behavior. Or maybe duplicate and modify this test so we have both.", "author": "mtopolnik", "createdAt": "2020-04-17T13:59:35Z", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java", "diffHunk": "@@ -1035,6 +1035,75 @@ public void hashJoin_when_outputFnReturnsNull_then_filteredOut() {\n         assertEquals(emptyList(), new ArrayList<>(sinkList));\n     }\n \n+    @Test\n+    public void when_innerHashJoin_then_filterOutNulls() {\n+        // Given\n+        List<Integer> input = sequence(itemCount);\n+        String prefix = \"value-\";\n+        BatchStage<Entry<Integer, String>> enrichingStage = batchStageFromList(input)\n+                .filter(i -> i % 2 == 0)\n+                .map(i -> entry(i, prefix + i));\n+\n+        // When\n+        BatchStage<Entry<Integer, String>> joined = batchStageFromList(input).innerHashJoin(\n+                enrichingStage,\n+                joinMapEntries(wholeItem()),\n+                Util::entry);\n+\n+        // Then\n+        joined.writeTo(sink);\n+        execute();\n+        Function<Entry<Integer, String>, String> formatFn =\n+                e -> String.format(\"(%04d, %s)\", e.getKey(), e.getValue());\n+        assertEquals(\n+                streamToString(input.stream().filter(e -> e % 2 == 0).map(i -> tuple2(i, prefix + i)), formatFn),\n+                streamToString(sinkStreamOfEntry(), formatFn));\n+    }\n+\n+    @Test\n+    public void when_hashJoinBuilderAddInner_then_filterOutNulls() {\n+        // Given\n+        int itemCountLocal = itemCount;\n+        List<Integer> input = sequence(itemCountLocal);\n+        String prefixA = \"A-\";\n+        String prefixB = \"B-\";\n+        String prefixC = \"C-\";\n+        String prefixD = \"D-\";\n+        BatchStage<Entry<Integer, String>> enrichingStage1 =\n+                batchStageFromList(input)\n+                        .filter(e -> e <= itemCountLocal / 2)\n+                        .flatMap(i -> traverseItems(entry(i, prefixA + i), entry(i, prefixB + i)));\n+        BatchStage<Entry<Integer, String>> enrichingStage2 =\n+                batchStageFromList(input)\n+                        .filter(e -> e <= itemCountLocal / 4)\n+                        .flatMap(i -> traverseItems(entry(i, prefixC + i), entry(i, prefixD + i)));\n+\n+        // When\n+        HashJoinBuilder<Integer> b = batchStageFromList(input).hashJoinBuilder();\n+        Tag<String> tagA = b.addInner(enrichingStage1, joinMapEntries(wholeItem()));\n+        Tag<String> tagB = b.addInner(enrichingStage2, joinMapEntries(wholeItem()));", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NzA2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410247069", "bodyText": "Sure. BTW. One question - typically when we do\nx\nleft join y\njoin z\nthen join to y is also treated as inner join. Currently only no value on z will cause no tuple returned, the lack of y will be ignored. Is it ok or should we stay as compatible with SQL as possible?", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1NTA1Mw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410255053", "bodyText": "Treating each side separately seems more flexible and useful to me. You may legitimately need such a combination. SQL strictly follows relational algebra, and there we'd consider the whole expression as a composition of two joins, so if the first one is an inner join, the tuple is eliminated even before reaching the left join. Jet's transforms are not an implementation of relational algebra so I'm fine with going the more useful route.\n@viliam-durina what do you think?", "author": "mtopolnik", "createdAt": "2020-04-17T14:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0MTk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2e4803277a43a4ed6ecc0d9c0ee4c7c8950d590f", "chunk": "diff --git a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\nindex 23b43b4bd3..7a747b3b71 100644\n--- a/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\n+++ b/hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/BatchStageTest.java\n\n@@ -1063,7 +1065,7 @@ public class BatchStageTest extends PipelineTestSupport {\n     @Test\n     public void when_hashJoinBuilderAddInner_then_filterOutNulls() {\n         // Given\n-        int itemCountLocal = itemCount;\n+        int itemCountLocal = 16;\n         List<Integer> input = sequence(itemCountLocal);\n         String prefixA = \"A-\";\n         String prefixB = \"B-\";\n"}}, {"oid": "8601549d01a4b5c5674ed03375819143ac2d3a7a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/8601549d01a4b5c5674ed03375819143ac2d3a7a", "message": "Fixed line lengths", "committedDate": "2020-04-17T14:05:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1MDMwMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410250300", "bodyText": "I tried it, you can safely inline this into the usage below. The reason that joinClauses stream had to be extracted does not appear in this case.", "author": "mtopolnik", "createdAt": "2020-04-17T14:12:35Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java", "diffHunk": "@@ -98,17 +119,23 @@\n                         orderedClauses.stream().map(e -> e.getValue().transform())\n                 ).collect(toList());\n         // A probable javac bug forced us to extract this variable\n+        // and not using method reference\n         Stream<JoinClause<?, T0, ?, ?>> joinClauses = orderedClauses\n                 .stream()\n                 .map(e -> e.getValue().clause())\n-                .map(fnAdapter::adaptJoinClause);\n+                .map(joinClause -> fnAdapter.adaptJoinClause(joinClause));\n+        Stream<Boolean> whereNullNotAllowed = orderedClauses", "originalCommit": "e17611c89082f3325eacf9b2c47cab3fb6b9ccc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1ODM0MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2089#discussion_r410258340", "bodyText": "Done", "author": "TomaszGaweda", "createdAt": "2020-04-17T14:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1MDMwMA=="}], "type": "inlineReview", "revised_code": {"commit": "40f5d6199fb7c90f05d508177eeda82c773da9ce", "chunk": "diff --git a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\nindex 4332647e53..bde88da41c 100644\n--- a/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\n+++ b/hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/GeneralHashJoinBuilder.java\n\n@@ -124,9 +124,6 @@ public abstract class GeneralHashJoinBuilder<T0> {\n                 .stream()\n                 .map(e -> e.getValue().clause())\n                 .map(joinClause -> fnAdapter.adaptJoinClause(joinClause));\n-        Stream<Boolean> whereNullNotAllowed = orderedClauses\n-                .stream()\n-                .map(e -> e.getValue().inner);\n         BiFunctionEx<?, ? super ItemsByTag, ?> mapToOutputBiFn = fnAdapter.adaptHashJoinOutputFn(mapToOutputFn);\n         HashJoinTransform<T0, R> hashJoinTransform = new HashJoinTransform<>(\n                 upstream,\n"}}, {"oid": "2e4803277a43a4ed6ecc0d9c0ee4c7c8950d590f", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2e4803277a43a4ed6ecc0d9c0ee4c7c8950d590f", "message": "Extended the test to test inner and left join at the same time", "committedDate": "2020-04-17T14:23:16Z", "type": "commit"}, {"oid": "40f5d6199fb7c90f05d508177eeda82c773da9ce", "url": "https://github.com/hazelcast/hazelcast-jet/commit/40f5d6199fb7c90f05d508177eeda82c773da9ce", "message": "After CR: inlined variable", "committedDate": "2020-04-17T14:23:59Z", "type": "commit"}]}