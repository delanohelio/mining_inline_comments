{"pr_number": 8985, "pr_title": "VSDecoder: use symbolic constants in locations tables", "pr_createdAt": "2020-09-01T13:08:34Z", "pr_url": "https://github.com/JMRI/JMRI/pull/8985", "timeline": [{"oid": "4b253fd3e7e018b6cb87409133793d345f3586d1", "url": "https://github.com/JMRI/JMRI/commit/4b253fd3e7e018b6cb87409133793d345f3586d1", "message": "use symbolic constants in locations tables", "committedDate": "2020-09-01T13:01:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3ODk2Mw==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r481178963", "bodyText": "Have you checked the case when user name is null? getUserName() may return null if there is no user name, while getDisplayName() always return a string.", "author": "danielb987", "createdAt": "2020-09-01T14:26:59Z", "path": "java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java", "diffHunk": "@@ -53,51 +66,49 @@ public void actionPerformed(ActionEvent e) {\n             listenerLoc = VSDecoderManager.instance().getVSDecoderPreferences().getListenerPosition();\n \n             // Handle Reporters\n-            ReporterManager rmgr = jmri.InstanceManager.getDefault(jmri.ReporterManager.class);\n+            ReporterManager rmgr = jmri.InstanceManager.getDefault(ReporterManager.class);\n             Set<Reporter> reporterSet = rmgr.getNamedBeanSet();\n             Object[][] reporterTable = new Object[reporterSet.size()][7];\n             int i = 0;\n             for (Reporter r : reporterSet) {\n                 if (r != null) {\n                     if (r instanceof PhysicalLocationReporter) {\n                         PhysicalLocation p = ((PhysicalLocationReporter) r).getPhysicalLocation();\n-                        reporterTable[i][0] = r.getSystemName();\n-                        reporterTable[i][1] = r.getDisplayName();\n-                        reporterTable[i][2] = true;\n-                        reporterTable[i][3] = p.getX();\n-                        reporterTable[i][4] = p.getY();\n-                        reporterTable[i][5] = p.getZ();\n-                        reporterTable[i][6] = p.isTunnel();\n+                        reporterTable[i][SYSNAMECOL] = r.getSystemName();\n+                        reporterTable[i][USERNAMECOL] = r.getUserName();", "originalCommit": "4b253fd3e7e018b6cb87409133793d345f3586d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIyMzcwOA==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r481223708", "bodyText": "Yes, and it works for a jmri.Block and a jmri.Reporter. Will change it to getDisplayName(). Thanks!", "author": "klk32003", "createdAt": "2020-09-01T15:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3ODk2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "38017c7275529e6ab1d43007ac3f685f1627c971", "chunk": "diff --git a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\nindex bff79c3dd8..44642c73cb 100644\n--- a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\n+++ b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\n\n@@ -74,21 +61,21 @@ public class ManageLocationsAction extends AbstractAction {\n                 if (r != null) {\n                     if (r instanceof PhysicalLocationReporter) {\n                         PhysicalLocation p = ((PhysicalLocationReporter) r).getPhysicalLocation();\n-                        reporterTable[i][SYSNAMECOL] = r.getSystemName();\n-                        reporterTable[i][USERNAMECOL] = r.getUserName();\n-                        reporterTable[i][USECOL + 1] = true;\n-                        reporterTable[i][XCOL + 1] = p.getX();\n-                        reporterTable[i][YCOL + 1] = p.getY();\n-                        reporterTable[i][ZCOL + 1] = p.getZ();\n-                        reporterTable[i][TUNNELCOL + 1] = p.isTunnel();\n+                        reporterTable[i][ManageLocationsTableModel.SYSNAMECOL] = r.getSystemName();\n+                        reporterTable[i][ManageLocationsTableModel.USERNAMECOL] = r.getDisplayName();\n+                        reporterTable[i][ManageLocationsTableModel.USECOL + 1] = true;\n+                        reporterTable[i][ManageLocationsTableModel.XCOL + 1] = p.getX();\n+                        reporterTable[i][ManageLocationsTableModel.YCOL + 1] = p.getY();\n+                        reporterTable[i][ManageLocationsTableModel.ZCOL + 1] = p.getZ();\n+                        reporterTable[i][ManageLocationsTableModel.TUNNELCOL + 1] = p.isTunnel();\n                     } else {\n-                        reporterTable[i][SYSNAMECOL] = r.getSystemName();\n-                        reporterTable[i][USERNAMECOL] = r.getUserName();\n-                        reporterTable[i][USECOL + 1] = false;\n-                        reporterTable[i][XCOL + 1] = Float.valueOf(0.0f);\n-                        reporterTable[i][YCOL + 1] = Float.valueOf(0.0f);\n-                        reporterTable[i][ZCOL + 1] = Float.valueOf(0.0f);\n-                        reporterTable[i][TUNNELCOL + 1] = false;\n+                        reporterTable[i][ManageLocationsTableModel.SYSNAMECOL] = r.getSystemName();\n+                        reporterTable[i][ManageLocationsTableModel.USERNAMECOL] = r.getDisplayName();\n+                        reporterTable[i][ManageLocationsTableModel.USECOL + 1] = false;\n+                        reporterTable[i][ManageLocationsTableModel.XCOL + 1] = Float.valueOf(0.0f);\n+                        reporterTable[i][ManageLocationsTableModel.YCOL + 1] = Float.valueOf(0.0f);\n+                        reporterTable[i][ManageLocationsTableModel.ZCOL + 1] = Float.valueOf(0.0f);\n+                        reporterTable[i][ManageLocationsTableModel.TUNNELCOL + 1] = false;\n                     }\n                 }\n                 i++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE4NTI0Mg==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r481185242", "bodyText": "I think it would be better to move this class to its own file, ReporterBlockTableModel.java, instead of moving it to the ManageLocationsAction class.\nThere is no reference to ReporterBlockTableModel in the ManageLocationsAction class, so I don't think ReporterBlockTableModel should belong to ManageLocationsAction.", "author": "danielb987", "createdAt": "2020-09-01T14:34:57Z", "path": "java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java", "diffHunk": "@@ -131,4 +142,273 @@ public void actionPerformed(ActionEvent e) {\n \n     private final static Logger log = LoggerFactory.getLogger(ManageLocationsAction.class);\n \n+    /**\n+     * class to serve as TableModel for Reporters and Blocks\n+     */\n+    static class ReporterBlockTableModel extends AbstractTableModel {", "originalCommit": "4b253fd3e7e018b6cb87409133793d345f3586d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIyNTcxNw==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r481225717", "bodyText": "OK, will change it. Thanks!", "author": "klk32003", "createdAt": "2020-09-01T15:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE4NTI0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "38017c7275529e6ab1d43007ac3f685f1627c971", "chunk": "diff --git a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\nindex bff79c3dd8..44642c73cb 100644\n--- a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\n+++ b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsAction.java\n\n@@ -142,273 +131,4 @@ public class ManageLocationsAction extends AbstractAction {\n \n     private final static Logger log = LoggerFactory.getLogger(ManageLocationsAction.class);\n \n-    /**\n-     * class to serve as TableModel for Reporters and Blocks\n-     */\n-    static class ReporterBlockTableModel extends AbstractTableModel {\n-\n-        // These get internationalized at runtime in the constructor below.\n-        private String[] columnNames = new String[7];\n-        private Object[][] rowData;\n-\n-        public ReporterBlockTableModel(Object[][] dataMap) {\n-            super();\n-            // Use i18n-ized column titles.\n-            columnNames[SYSNAMECOL] = Bundle.getMessage(\"Name\");\n-            columnNames[USERNAMECOL] = Bundle.getMessage(\"ColumnUserName\");\n-            columnNames[USECOL + 1] = Bundle.getMessage(\"FieldTableUseColumn\");\n-            columnNames[XCOL + 1] = Bundle.getMessage(\"FieldTableXColumn\");\n-            columnNames[YCOL + 1] = Bundle.getMessage(\"FieldTableYColumn\");\n-            columnNames[ZCOL + 1] = Bundle.getMessage(\"FieldTableZColumn\");\n-            columnNames[TUNNELCOL + 1] = Bundle.getMessage(\"FieldTableIsTunnelColumn\");\n-            rowData = dataMap;\n-        }\n-\n-        public HashMap<String, PhysicalLocation> getDataMap() {\n-            // Includes only the ones with the checkbox made\n-            HashMap<String, PhysicalLocation> retv = new HashMap<>();\n-            for (Object[] row : rowData) {\n-                if ((Boolean) row[USECOL + 1]) {\n-                    if (row[XCOL + 1] == null) { \n-                        row[XCOL + 1] = 0.0f;\n-                    }\n-                    if (row[YCOL + 1] == null) { \n-                        row[YCOL + 1] = 0.0f;\n-                    }\n-                    if (row[ZCOL + 1] == null) { \n-                        row[ZCOL + 1] = 0.0f;\n-                    }\n-                    retv.put((String) row[SYSNAMECOL], \n-                            new PhysicalLocation((Float) row[XCOL + 1], (Float) row[YCOL + 1], (Float) row[ZCOL + 1], (Boolean) row[TUNNELCOL + 1]));\n-                }\n-            }\n-            return retv;\n-        }\n-\n-        @Override\n-        public String getColumnName(int col) {\n-            return columnNames[col];\n-        }\n-\n-        @Override\n-        public int getRowCount() {\n-            return rowData.length;\n-        }\n-\n-        @Override\n-        public int getColumnCount() {\n-            return columnNames.length;\n-        }\n-\n-        @Override\n-        public Object getValueAt(int row, int col) {\n-            return rowData[row][col];\n-        }\n-\n-        @Override\n-        public boolean isCellEditable(int row, int col) {\n-            return true;\n-        }\n-\n-        @Override\n-        public void setValueAt(Object value, int row, int col) {\n-            rowData[row][col] = value;\n-            fireTableCellUpdated(row, col);\n-        }\n-\n-        @Override\n-        public Class<?> getColumnClass(int columnIndex) {\n-            switch (columnIndex) {\n-                case USECOL + 1:\n-                case TUNNELCOL + 1:\n-                    return Boolean.class;\n-                case ZCOL + 1:\n-                case YCOL + 1:\n-                case XCOL + 1:\n-                    return Float.class;\n-                case USERNAMECOL:\n-                case SYSNAMECOL:\n-                default:\n-                    return super.getColumnClass(columnIndex);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * class to serve as TableModel for Ops Locations\n-     */\n-    static class LocationTableModel extends AbstractTableModel {\n-\n-        // These get internationalized at runtime in the constructor below.\n-        private String[] columnNames = new String[6];\n-        private Object[][] rowData;\n-\n-        public LocationTableModel(Object[][] dataMap) {\n-            super();\n-            // Use i18n-ized column titles.\n-            columnNames[NAMECOL] = Bundle.getMessage(\"Name\");\n-            columnNames[USECOL] = Bundle.getMessage(\"FieldTableUseColumn\");\n-            columnNames[XCOL] = Bundle.getMessage(\"FieldTableXColumn\");\n-            columnNames[YCOL] = Bundle.getMessage(\"FieldTableYColumn\");\n-            columnNames[ZCOL] = Bundle.getMessage(\"FieldTableZColumn\");\n-            columnNames[TUNNELCOL] = Bundle.getMessage(\"FieldTableIsTunnelColumn\");\n-            rowData = dataMap;\n-        }\n-\n-        public HashMap<String, PhysicalLocation> getDataMap() {\n-            // Includes only the ones with the checkbox made\n-            HashMap<String, PhysicalLocation> retv = new HashMap<>();\n-            for (Object[] row : rowData) {\n-                if ((Boolean) row[USECOL]) {\n-                    if (row[XCOL] == null) { \n-                        row[XCOL] = 0.0f;\n-                    }\n-                    if (row[YCOL] == null) { \n-                        row[YCOL] = 0.0f;\n-                    }\n-                    if (row[ZCOL] == null) { \n-                        row[ZCOL] = 0.0f;\n-                    }\n-                    retv.put((String) row[NAMECOL], \n-                            new PhysicalLocation((Float) row[XCOL], (Float) row[YCOL], (Float) row[ZCOL], (Boolean) row[TUNNELCOL]));\n-                }\n-            }\n-            return retv;\n-        }\n-\n-        @Override\n-        public String getColumnName(int col) {\n-            return columnNames[col];\n-        }\n-\n-        @Override\n-        public int getRowCount() {\n-            return rowData.length;\n-        }\n-\n-        @Override\n-        public int getColumnCount() {\n-            return columnNames.length;\n-        }\n-\n-        @Override\n-        public Object getValueAt(int row, int col) {\n-            return rowData[row][col];\n-        }\n-\n-        @Override\n-        public boolean isCellEditable(int row, int col) {\n-            return true;\n-        }\n-\n-        @Override\n-        public void setValueAt(Object value, int row, int col) {\n-            rowData[row][col] = value;\n-            fireTableCellUpdated(row, col);\n-        }\n-\n-        @Override\n-        public Class<?> getColumnClass(int columnIndex) {\n-            switch (columnIndex) {\n-                case USECOL:\n-                case TUNNELCOL:\n-                    return Boolean.class;\n-                case ZCOL:\n-                case YCOL:\n-                case XCOL:\n-                    return Float.class;\n-                case NAMECOL:\n-                default:\n-                    return super.getColumnClass(columnIndex);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * class for use as TableModel for Listener Locations\n-     */\n-    static class ListenerTableModel extends AbstractTableModel {\n-\n-        // These get internationalized at runtime in the constructor below.\n-        private String[] columnNames = new String[7];\n-        private Object[][] rowData = null;\n-\n-        public ListenerTableModel(Object[][] dataMap) {\n-            super();\n-            // Use i18n-ized column titles.\n-            columnNames[NAMECOL] = Bundle.getMessage(\"Name\");\n-            columnNames[USECOL] = Bundle.getMessage(\"FieldTableUseColumn\");\n-            columnNames[XCOL] = Bundle.getMessage(\"FieldTableXColumn\");\n-            columnNames[YCOL] = Bundle.getMessage(\"FieldTableYColumn\");\n-            columnNames[ZCOL] = Bundle.getMessage(\"FieldTableZColumn\");\n-            columnNames[BEARINGCOL] = Bundle.getMessage(\"FieldTableBearingColumn\");\n-            columnNames[AZIMUTHCOL] = Bundle.getMessage(\"FieldTableAzimuthColumn\");\n-            rowData = dataMap;\n-        }\n-\n-        @SuppressWarnings(\"unused\")\n-        public HashMap<String, ListeningSpot> getDataMap() {\n-            // Includes only the ones with the checkbox made\n-            HashMap<String, ListeningSpot> retv = new HashMap<>();\n-            ListeningSpot spot = null;\n-            for (Object[] row : rowData) {\n-                if ((Boolean) row[USECOL]) {\n-                    spot = new ListeningSpot();\n-                    spot.setName((String) row[NAMECOL]);\n-                    spot.setLocation((Double) row[XCOL], (Double) row[YCOL], (Double) row[ZCOL]);\n-                    spot.setOrientation((Double) row[BEARINGCOL], (Double) row[AZIMUTHCOL]);\n-                    retv.put((String) row[NAMECOL], spot);\n-                }\n-            }\n-            return retv;\n-        }\n-\n-        @Override\n-        public String getColumnName(int col) {\n-            return columnNames[col];\n-        }\n-\n-        @Override\n-        public int getRowCount() {\n-            return rowData.length;\n-        }\n-\n-        @Override\n-        public int getColumnCount() {\n-            return columnNames.length;\n-        }\n-\n-        @Override\n-        public Object getValueAt(int row, int col) {\n-            return rowData[row][col];\n-        }\n-\n-        @Override\n-        public boolean isCellEditable(int row, int col) {\n-            return true;\n-        }\n-\n-        @Override\n-        public void setValueAt(Object value, int row, int col) {\n-            rowData[row][col] = value;\n-            fireTableCellUpdated(row, col);\n-        }\n-\n-        @Override\n-        public Class<?> getColumnClass(int columnIndex) {\n-            switch (columnIndex) {\n-                case USECOL:\n-                    return Boolean.class;\n-                case AZIMUTHCOL:\n-                case BEARINGCOL:\n-                case ZCOL:\n-                case YCOL:\n-                case XCOL:\n-                    return Double.class;\n-                case NAMECOL:\n-                default:\n-                    return super.getColumnClass(columnIndex);\n-            }\n-        }\n-    }\n }\n"}}, {"oid": "38017c7275529e6ab1d43007ac3f685f1627c971", "url": "https://github.com/JMRI/JMRI/commit/38017c7275529e6ab1d43007ac3f685f1627c971", "message": "update due to the review", "committedDate": "2020-09-02T11:55:14Z", "type": "commit"}, {"oid": "6b04cb744a2258a5d10e4b357c13718ba08c62e7", "url": "https://github.com/JMRI/JMRI/commit/6b04cb744a2258a5d10e4b357c13718ba08c62e7", "message": "add JUnit test", "committedDate": "2020-09-02T11:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4ODQwOA==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r482088408", "bodyText": "This import is redundant. You don't need to import from the same package. Sometimes I have seen that the IDE (for example NetBeans) has added these wrongly.\nThe PR looks good, but the Static Analysis CI check complains about it so it needs to be fixed before the PR is merged.", "author": "danielb987", "createdAt": "2020-09-02T13:55:43Z", "path": "java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsFrame.java", "diffHunk": "@@ -33,6 +32,7 @@\n import jmri.jmrit.operations.setup.Setup;\n import jmri.jmrit.vsdecoder.VSDecoderManager;\n import jmri.jmrit.vsdecoder.listener.ListeningSpot;\n+import jmri.jmrit.vsdecoder.swing.ManageLocationsTableModel;", "originalCommit": "6b04cb744a2258a5d10e4b357c13718ba08c62e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNzM3MQ==", "url": "https://github.com/JMRI/JMRI/pull/8985#discussion_r482127371", "bodyText": "Thank you. Now fixed. It was my mistake.", "author": "klk32003", "createdAt": "2020-09-02T14:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4ODQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "26ac093b5d944c95dbe62f6ac599b499301d480a", "chunk": "diff --git a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsFrame.java b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsFrame.java\nindex 5d3861fd4a..ccb41e3ee0 100644\n--- a/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsFrame.java\n+++ b/java/src/jmri/jmrit/vsdecoder/swing/ManageLocationsFrame.java\n\n@@ -32,7 +32,6 @@ import jmri.jmrit.operations.locations.LocationManager;\n import jmri.jmrit.operations.setup.Setup;\n import jmri.jmrit.vsdecoder.VSDecoderManager;\n import jmri.jmrit.vsdecoder.listener.ListeningSpot;\n-import jmri.jmrit.vsdecoder.swing.ManageLocationsTableModel;\n import jmri.util.JmriJFrame;\n import jmri.util.PhysicalLocation;\n import org.slf4j.Logger;\n"}}, {"oid": "26ac093b5d944c95dbe62f6ac599b499301d480a", "url": "https://github.com/JMRI/JMRI/commit/26ac093b5d944c95dbe62f6ac599b499301d480a", "message": "remove not needed import", "committedDate": "2020-09-02T14:12:19Z", "type": "commit"}]}