{"pr_number": 342, "pr_title": "Kogito 2828 - catch exceptions in event processing to avoid global stop", "pr_createdAt": "2020-07-23T16:50:25Z", "pr_url": "https://github.com/kiegroup/kogito-apps/pull/342", "timeline": [{"oid": "0f1e95d0a5d732f1121ca38ffc46d749d42915f1", "url": "https://github.com/kiegroup/kogito-apps/commit/0f1e95d0a5d732f1121ca38ffc46d749d42915f1", "message": "surround event handling with try/catch", "committedDate": "2020-07-23T14:18:18Z", "type": "commit"}, {"oid": "4f3a18e8f0594923eb5fed2e36c7145ad32c0016", "url": "https://github.com/kiegroup/kogito-apps/commit/4f3a18e8f0594923eb5fed2e36c7145ad32c0016", "message": "implement tests", "committedDate": "2020-07-23T15:59:43Z", "type": "commit"}, {"oid": "0b114e5d0d853593bcb25dd38a5ea13a0a3e111a", "url": "https://github.com/kiegroup/kogito-apps/commit/0b114e5d0d853593bcb25dd38a5ea13a0a3e111a", "message": "implement tests", "committedDate": "2020-07-23T16:45:16Z", "type": "commit"}, {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268", "url": "https://github.com/kiegroup/kogito-apps/commit/9475c6e87a1f91339ae4a24c59ec43a9c604e268", "message": "add licence headers", "committedDate": "2020-07-23T16:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDEwMw==", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590103", "bodyText": "I've moved the old content of this class to TraceEventConsumerInfinispanIT since it's an integration test that uses also infinispan.", "author": "r00ta", "createdAt": "2020-07-23T16:51:29Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {", "originalCommit": "9475c6e87a1f91339ae4a24c59ec43a9c604e268", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDY1NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590654", "bodyText": "This is the new test that checks that both events are processed. With the old implementation only the first one was processed", "author": "r00ta", "createdAt": "2020-07-23T16:52:27Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {\n \n-    @Inject\n+    @InjectMock\n     TrustyService trustyService;\n \n-    @Inject\n-    TrustyStorageService trustyStorageService;\n-\n     KafkaProducer<String, String> producer;\n \n     @BeforeEach\n     public void setup() {\n-        trustyStorageService.getDecisionsStorage().clear();\n-\n-        System.err.println(\"kafka.bootstrap.servers: \" + System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"));\n-\n-        producer = KafkaProducer.create(Vertx.vertx(), Map.of(\n-                \"bootstrap.servers\", System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"),\n-                \"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"acks\", \"all\"\n-        ));\n+        producer = generateProducer();\n     }\n \n     @Test\n-    void testCorrectCloudEvent() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent()));\n-        Decision storedDecision = trustyService.getDecisionById(CORRECT_CLOUDEVENT_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildCorrectDecision(), storedDecision);\n-    }\n-\n-    @Test\n-    void testCloudEventWithErrors() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildTraceEventWithErrors()));\n-        Decision storedDecision = trustyService.getDecisionById(CLOUDEVENT_WITH_ERRORS_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildDecisionWithErrors(), storedDecision);\n-    }\n+    public void eventLoopIsNotStoppedWithException() throws Exception {\n+        String executionIdException = \"idException\";\n+        String executionIdNoException = \"idNoException\";\n+        doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeDecision(eq(executionIdException), any(Decision.class));\n+        doNothing().when(trustyService).storeDecision(eq(executionIdNoException), any(Decision.class));\n \n-    private CompletableFuture<Void> sendToKafka(String payload) {\n-        CompletableFuture<Void> future = new CompletableFuture<>();\n-        producer.write(KafkaProducerRecord.create(\"trusty-service-test\", payload), event -> {\n-            if (event.succeeded()) {\n-                future.complete(null);\n-            } else {\n-                future.completeExceptionally(event.cause());\n-            }\n-        });\n-        return future;\n-    }\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdException)), producer);\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdNoException)), producer);\n \n-    private void sendToKafkaAndWaitForCompletion(String payload) throws Exception {\n-        sendToKafka(payload)\n-                .thenRunAsync(() -> LOG.info(\"Sent payload to Kafka (length: {})\", payload.length()), CompletableFuture.delayedExecutor(2L, TimeUnit.SECONDS))\n-                .get(15L, TimeUnit.SECONDS);\n+        verify(trustyService, times(2)).storeDecision(any(String.class), any(Decision.class));", "originalCommit": "9475c6e87a1f91339ae4a24c59ec43a9c604e268", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "a55fc67be82e541fa7ebfc6a6cd650c6ac572023", "url": "https://github.com/kiegroup/kogito-apps/commit/a55fc67be82e541fa7ebfc6a6cd650c6ac572023", "message": "remove log statement", "committedDate": "2020-07-23T18:26:12Z", "type": "commit"}, {"oid": "a56d95a15004a33b511bd5468a58283c41371a0c", "url": "https://github.com/kiegroup/kogito-apps/commit/a56d95a15004a33b511bd5468a58283c41371a0c", "message": "add test on execution type", "committedDate": "2020-07-24T15:58:15Z", "type": "commit"}, {"oid": "d66afd6a5c7f124f6ab287c79b872114f299aa6f", "url": "https://github.com/kiegroup/kogito-apps/commit/d66afd6a5c7f124f6ab287c79b872114f299aa6f", "message": "Merge remote-tracking branch 'upstream/master' into KOGITO-2828-fix-processing-events", "committedDate": "2020-07-27T07:00:31Z", "type": "commit"}]}