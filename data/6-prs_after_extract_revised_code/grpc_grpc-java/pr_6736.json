{"pr_number": 6736, "pr_title": "xds: implement XdsRouting config parser", "pr_createdAt": "2020-02-20T22:53:49Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6736", "timeline": [{"oid": "cfe4520e480a61192300d06251a18528fa68323c", "url": "https://github.com/grpc/grpc-java/commit/cfe4520e480a61192300d06251a18528fa68323c", "message": "xds: implement XdsRouting config parser", "committedDate": "2020-02-20T22:54:14Z", "type": "forcePushed"}, {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "url": "https://github.com/grpc/grpc-java/commit/8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "message": "xds: implement XdsRouting config parser", "committedDate": "2020-02-21T18:39:49Z", "type": "commit"}, {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "url": "https://github.com/grpc/grpc-java/commit/8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "message": "xds: implement XdsRouting config parser", "committedDate": "2020-02-21T18:39:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzUxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385947511", "bodyText": "Little improvement: please rephrase this message. Also, the existing way of selecting policy does the logging more elegantly (It only log at most once).", "author": "voidzcy", "createdAt": "2020-02-28T22:15:55Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzkzMQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385947931", "bodyText": "nit: may not want to put white space after \\n. Apply to other places as well.", "author": "voidzcy", "createdAt": "2020-02-28T22:17:04Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NjI1NQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385956255", "bodyText": "Why not this(LoadBalancerRegistry.getDefaultRegistry()) and make lbRegistry non-null? Then you do not need the method loadBalancerRegistry().", "author": "voidzcy", "createdAt": "2020-02-28T22:43:42Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NTQ2MA==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385975460", "bodyText": "See the comment lines above.", "author": "dapengzhang0", "createdAt": "2020-02-29T00:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NjI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4MzA2MQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385983061", "bodyText": "Okay...", "author": "voidzcy", "createdAt": "2020-02-29T00:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NjI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDAwNQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385960005", "bodyText": "Little improvement: although I am not an opponent for writing giant methods, this one seems to be too big to read. This can be elegantly split into two helper methods: one for parsing route and one for parsing action. Each one returns a list or a map and throws exception.\nI am also fine if you just leave it as is.", "author": "voidzcy", "createdAt": "2020-02-28T22:57:00Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3OTY5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385979693", "bodyText": "It's kind of not easy because the current code eagerly returns a ConfigOrError whenever it fails.", "author": "dapengzhang0", "createdAt": "2020-02-29T00:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTIxMw==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961213", "bodyText": "s/methodName/method_name/g\nError message for input data, not implementation details.", "author": "voidzcy", "createdAt": "2020-02-28T23:01:15Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTQ2NQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961465", "bodyText": "nit: delete redundant empty line. Check other places.", "author": "voidzcy", "createdAt": "2020-02-28T23:02:11Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTY0Nw==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961647", "bodyText": "s/rout/route/g", "author": "voidzcy", "createdAt": "2020-02-28T23:02:55Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTc4OA==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961788", "bodyText": "s/methodName/method_name/g", "author": "voidzcy", "createdAt": "2020-02-28T23:03:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (methodNames.contains(parseMethodName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Duplicate methodName found in routes in xds_routing LB policy:\\n\" + rawConfig));", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MDI0NQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385970245", "bodyText": "Use XdsLogger? Whatever, can leave it as is and improve as things being stabilized.\nUpdate: don't need to change it, just leave it as is. Configuring log handler io.grpc.xds can still include this logger.", "author": "voidzcy", "createdAt": "2020-02-28T23:38:44Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NjQ4Ng==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385976486", "bodyText": "I think we should define a ParsedConfig class with policyName and config fields, similar to LbConfig. This could be useful for all hierarchical LB configs.", "author": "voidzcy", "createdAt": "2020-02-29T00:08:54Z", "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (methodNames.contains(parseMethodName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Duplicate methodName found in routes in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+        methodNames.add(parseMethodName);\n+\n+        parsedRoutes.add(new Route(actionName, parseMethodName));\n+      }\n+\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  static final class XdsRoutingConfig {\n+\n+    final List<Route> routes;\n+    final Map<String, ChildConfig> actions;\n+\n+    /**\n+     * Constructs a deeply parsed xds_routing config with the given non-empty list of routes, the\n+     * action of each of which is provided by the given map of actions.\n+     */\n+    @VisibleForTesting\n+    XdsRoutingConfig(List<Route> routes,\n+        Map<String, ChildConfig> actions) {\n+      this.routes = ImmutableList.copyOf(routes);\n+      this.actions = ImmutableMap.copyOf(actions);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      XdsRoutingConfig that = (XdsRoutingConfig) o;\n+      return Objects.equals(routes, that.routes)\n+          && Objects.equals(actions, that.actions);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(routes, actions);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"routes\", routes)\n+          .add(\"actions\", actions)\n+          .toString();\n+    }\n+  }\n+\n+  static final class Route {\n+\n+    final String actionName;\n+    final MethodName methodName;\n+\n+    @VisibleForTesting\n+    Route(String actionName, MethodName methodName) {\n+      this.actionName = actionName;\n+      this.methodName = methodName;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Route route = (Route) o;\n+      return Objects.equals(actionName, route.actionName)\n+          && Objects.equals(methodName, route.methodName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(actionName, methodName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"actionName\", actionName)\n+          .add(\"methodName\", methodName)\n+          .toString();\n+    }\n+  }\n+\n+  static final class MethodName {\n+\n+    final String service;\n+    final String method;\n+\n+    @VisibleForTesting\n+    MethodName(String service, String method) {\n+      this.service = service;\n+      this.method = method;\n+    }\n+\n+    boolean isDefault() {\n+      return service.isEmpty() && method.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      MethodName that = (MethodName) o;\n+      return Objects.equals(service, that.service)\n+          && Objects.equals(method, that.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(service, method);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"service\", service)\n+          .add(\"method\", method)\n+          .toString();\n+    }\n+  }\n+\n+  static final class ChildConfig {", "originalCommit": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NzU3NQ==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385977575", "bodyText": "Yes, that is also my plan, currently we have AutoConfiguredLoadBalancerFactory.PolicySelection which basically is the ParsedConfig. It has a deprecated field rawConfig just for the backward compatibility in legacy usecase.", "author": "dapengzhang0", "createdAt": "2020-02-29T00:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NTEyMA==", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385985120", "bodyText": "Also, defining types with name ChildXXX doesn't sound good, unless it's an internal implementation (private) or locally used. \"Child\" is meaningful only in the context of one policy's internal implementation.", "author": "voidzcy", "createdAt": "2020-02-29T01:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NjQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\nindex 1d2ef2705..2e4cf376e 100644\n--- a/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n+++ b/xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java\n\n@@ -98,21 +98,20 @@ public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n       Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n       if (actions == null || actions.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+            \"No actions provided for xds_routing LB policy: \" + rawConfig));\n       }\n       Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n       for (String name : actions.keySet()) {\n         Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n         if (rawAction == null) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+              \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-\n         List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n             JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n         if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n                   + rawConfig));\n         }\n         boolean targetParsingSucceeded = false;\n"}}, {"oid": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "url": "https://github.com/grpc/grpc-java/commit/f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "message": "fix messages", "committedDate": "2020-02-29T00:16:01Z", "type": "commit"}]}