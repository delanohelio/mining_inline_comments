{"pr_number": 7375, "pr_title": "core, api, benchmarks: Random acts of garbage reduction", "pr_createdAt": "2020-08-28T00:57:53Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7375", "timeline": [{"oid": "3e3e8af5d4ab7382602d58ceec7343620cd7322f", "url": "https://github.com/grpc/grpc-java/commit/3e3e8af5d4ab7382602d58ceec7343620cd7322f", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T02:26:17Z", "type": "forcePushed"}, {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T03:47:59Z", "type": "commit"}, {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths", "committedDate": "2020-08-28T03:47:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3NzI5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516377297", "bodyText": "So this avoids the copy constructor from allocating the object. Nice. Since this is zero-size, would it be even better to share a single copy cross-instance?", "author": "ejona86", "createdAt": "2020-11-03T01:05:19Z", "path": "api/src/main/java/io/grpc/CallOptions.java", "diffHunk": "@@ -61,7 +61,7 @@\n   @Nullable\n   private String compressorName;\n \n-  private Object[][] customOptions = new Object[0][2];\n+  private Object[][] customOptions;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTYzNg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981636", "bodyText": "It's already the case that there will be a single copy since the constructors are private and all instances derive from DEFAULT.", "author": "njhill", "createdAt": "2020-12-30T07:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3NzI5Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3ODY0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516378643", "bodyText": "I don't think we want to \"cheat\" with these benchmarks. Most users will pay these same costs.\nIf we really wanted to optimize this, we would have a single pre-created ByteString and use it to build a new one of the needed size. That would avoid allocating/copying any of the data. But then it is really a lie.", "author": "ejona86", "createdAt": "2020-11-03T01:09:48Z", "path": "benchmarks/src/main/java/io/grpc/benchmarks/Utils.java", "diffHunk": "@@ -252,7 +253,7 @@ public static SimpleResponse makeResponse(SimpleRequest request) {\n         throw Status.INTERNAL.augmentDescription(\"Error creating payload.\").asRuntimeException();\n       }\n \n-      ByteString body = ByteString.copyFrom(new byte[request.getResponseSize()]);\n+      ByteString body = UnsafeByteOperations.unsafeWrap(new byte[request.getResponseSize()]);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTY4OQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981689", "bodyText": "Sure I can revert it. I just thought it might help to isolate the actual grpc parts within the benchmarks, assuming that they're intended more for relative measurements than simulating a particular real-world use case.", "author": "njhill", "createdAt": "2020-12-30T07:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3ODY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/benchmarks/src/main/java/io/grpc/benchmarks/Utils.java b/benchmarks/src/main/java/io/grpc/benchmarks/Utils.java\nindex 40e3659c6..9a3d1f6bc 100644\n--- a/benchmarks/src/main/java/io/grpc/benchmarks/Utils.java\n+++ b/benchmarks/src/main/java/io/grpc/benchmarks/Utils.java\n\n@@ -253,7 +252,7 @@ public final class Utils {\n         throw Status.INTERNAL.augmentDescription(\"Error creating payload.\").asRuntimeException();\n       }\n \n-      ByteString body = UnsafeByteOperations.unsafeWrap(new byte[request.getResponseSize()]);\n+      ByteString body = ByteString.copyFrom(new byte[request.getResponseSize()]);\n       Messages.PayloadType type = request.getResponseType();\n \n       Payload payload = Payload.newBuilder().setType(type).setBody(body).build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3OTU1MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516379550", "bodyText": "Oh, interesting. I didn't realize IdentityHashMap avoided the Map.Entries.", "author": "ejona86", "createdAt": "2020-11-03T01:13:19Z", "path": "core/src/main/java/io/grpc/inprocess/InProcessTransport.java", "diffHunk": "@@ -96,7 +97,8 @@\n   @GuardedBy(\"this\")\n   private Status shutdownStatus;\n   @GuardedBy(\"this\")\n-  private Set<InProcessStream> streams = new HashSet<>();\n+  private Set<InProcessStream> streams = Collections.newSetFromMap(\n+          new IdentityHashMap<InProcessStream, Boolean>());", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMTE3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517031177", "bodyText": "Can do the same for CronetClientTransport.", "author": "voidzcy", "createdAt": "2020-11-04T00:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3OTU1MA=="}], "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/inprocess/InProcessTransport.java b/core/src/main/java/io/grpc/inprocess/InProcessTransport.java\nindex b4ee5c229..5967bf581 100644\n--- a/core/src/main/java/io/grpc/inprocess/InProcessTransport.java\n+++ b/core/src/main/java/io/grpc/inprocess/InProcessTransport.java\n\n@@ -97,7 +97,7 @@ final class InProcessTransport implements ServerTransport, ConnectionClientTrans\n   @GuardedBy(\"this\")\n   private Status shutdownStatus;\n   @GuardedBy(\"this\")\n-  private Set<InProcessStream> streams = Collections.newSetFromMap(\n+  private final Set<InProcessStream> streams = Collections.newSetFromMap(\n           new IdentityHashMap<InProcessStream, Boolean>());\n   @GuardedBy(\"this\")\n   private List<ServerStreamTracer.Factory> serverStreamTracerFactories;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380207", "bodyText": "What changed here? It looks the same. The old version grabbed a variable a few more times, but not only is the variable non-volatile, it's even final. So I can't believe it would actually make any difference.", "author": "ejona86", "createdAt": "2020-11-03T01:15:40Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -50,9 +58,9 @@ public void addBuffer(ReadableBuffer buffer) {\n     }\n \n     CompositeReadableBuffer compositeBuffer = (CompositeReadableBuffer) buffer;\n-    while (!compositeBuffer.buffers.isEmpty()) {\n-      ReadableBuffer subBuffer = compositeBuffer.buffers.remove();\n-      buffers.add(subBuffer);\n+    Queue<ReadableBuffer> otherBuffers = compositeBuffer.buffers;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MTgzNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549981837", "bodyText": "I agree it's unlikely to make much/any difference especially here, but seems cleaner and good general practice. I.e. in theory less pointer chasing in the loop. Or could be my OCD.", "author": "njhill", "createdAt": "2020-12-30T07:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3ODMwMw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550278303", "bodyText": "I don't think I agree with \"good general practice.\" I expect the optimizer to do loop invariant hoisting. For simple cases like this I'd put it in the same category as 'optimizing' /2 with >>1 or simplifying 1 + 2 to 3. But this isn't even that hot of a loop. With reasonably-sized buffers, it seems impossible to ever notice this optimization, even if we assume the processor isn't faster executing the later occurrences or the interpreter was being used.\nThe \"cleaner\" part for me was combining buffers.add() and the remove() onto the same line. But the original author could have done that and actively chose not to. But adding otherBuffers actually the change overall less clean to my eyes. In any case the original code seems reasonable as-is, so it seems best not to touch it.", "author": "ejona86", "createdAt": "2020-12-30T17:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU5MzA0MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550593040", "bodyText": "Sure, I'll revert it! Yes the \"cleanliness\" is probably subjective, I have a general preference for minimizing indirections, other things being equal (regardless of perf implications). I don't quite agree that it's in the same category as >>1, 1 + 2 -> 3 since those have a more obvious readability tradeoff.", "author": "njhill", "createdAt": "2020-12-31T17:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -58,9 +58,9 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n     }\n \n     CompositeReadableBuffer compositeBuffer = (CompositeReadableBuffer) buffer;\n-    Queue<ReadableBuffer> otherBuffers = compositeBuffer.buffers;\n-    while (!otherBuffers.isEmpty()) {\n-      buffers.add(otherBuffers.remove());\n+    while (!compositeBuffer.buffers.isEmpty()) {\n+      ReadableBuffer subBuffer = compositeBuffer.buffers.remove();\n+      buffers.add(subBuffer);\n     }\n     readableBytes += compositeBuffer.readableBytes;\n     compositeBuffer.readableBytes = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDYwMw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380603", "bodyText": "I was not a fan of the previous behavior. I prefer an approach like this... although this may not provide any benefit. Since execute() didn't leak the reference to op, I'd expect op to be allocated on the stack. Although maybe the interface being called messes things up (since an op could leak a reference to itself when called). I'd be willing to take this anyway.", "author": "ejona86", "createdAt": "2020-11-03T01:17:21Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -72,73 +72,78 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n     return readableBytes;\n   }\n \n-  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n-      return buffer.readUnsignedByte();\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> UBYTE_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+          return buffer.readUnsignedByte();\n+        }\n+      };\n \n   @Override\n   public int readUnsignedByte() {\n     return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n-  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n-      buffer.skipBytes(length);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> SKIP_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+          buffer.skipBytes(length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n   public void skipBytes(int length) {\n     executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n-  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n-      buffer.readBytes(dest, offset, length);\n-      return offset + length;\n-    }\n-  };\n+  private static final NoThrowReadOperation<byte[]> BYTE_ARRAY_OP =\n+      new NoThrowReadOperation<byte[]>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+          buffer.readBytes(dest, offset, length);\n+          return offset + length;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final byte[] dest, final int destOffset, int length) {\n+  public void readBytes(byte[] dest, int destOffset, int length) {\n     executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n-  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n-      // Change the limit so that only lengthToCopy bytes are available.\n-      int prevLimit = dest.limit();\n-      ((Buffer) dest).limit(dest.position() + length);\n-      // Write the bytes and restore the original limit.\n-      buffer.readBytes(dest);\n-      ((Buffer) dest).limit(prevLimit);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<ByteBuffer> BYTE_BUF_OP =\n+      new NoThrowReadOperation<ByteBuffer>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+          // Change the limit so that only lengthToCopy bytes are available.\n+          int prevLimit = dest.limit();\n+          ((Buffer) dest).limit(dest.position() + length);\n+          // Write the bytes and restore the original limit.\n+          buffer.readBytes(dest);\n+          ((Buffer) dest).limit(prevLimit);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final ByteBuffer dest) {\n+  public void readBytes(ByteBuffer dest) {\n     executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+  private static final ReadOperation<OutputStream> STREAM_OP =\n+      new ReadOperation<OutputStream>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n             throws IOException {\n-        buffer.readBytes(dest, length);\n-        return 0;\n-    }\n-  };\n+          buffer.readBytes(dest, length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n+  public void readBytes(OutputStream dest, int length) throws IOException {\n     execute(STREAM_OP, length, dest, 0);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjQwOQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516382409", "bodyText": "Name this as one, since it is not truly immutable.", "author": "ejona86", "createdAt": "2020-11-03T01:24:39Z", "path": "core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java", "diffHunk": "@@ -97,10 +97,12 @@ static boolean isAvailable() {\n     return initializationException == null;\n   }\n \n+  private static final Object[] ONE = new Object[] { 1L };", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java b/core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java\nindex 1922d0507..fddeee82c 100644\n--- a/core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java\n+++ b/core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java\n\n@@ -97,12 +97,12 @@ public final class ReflectionLongAdderCounter implements LongCounter {\n     return initializationException == null;\n   }\n \n-  private static final Object[] ONE = new Object[] { 1L };\n+  private static final Object[] one = new Object[] { 1L };\n \n   @Override\n   public void add(long delta) {\n     try {\n-      addMethod.invoke(instance, delta == 1L ? ONE : new Object[] { delta });\n+      addMethod.invoke(instance, delta == 1L ? one : new Object[] { delta });\n     } catch (IllegalAccessException e) {\n       throw new RuntimeException(e);\n     } catch (InvocationTargetException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzEwMg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516393102", "bodyText": "It's unclear if this change improves or worsens performance. Now the type of the return value changes, so the JIT will not optimize the calling code as much. On the other hand, there is less indirection when length is present in a single buffer.", "author": "ejona86", "createdAt": "2020-11-03T02:09:50Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {\n-    execute(new ReadOperation() {\n-      int currentOffset = destOffset;\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.readBytes(dest, currentOffset, length);\n-        currentOffset += length;\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n+  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+      // Change the limit so that only lengthToCopy bytes are available.\n+      int prevLimit = dest.limit();\n+      ((Buffer) dest).limit(dest.position() + length);\n+      // Write the bytes and restore the original limit.\n+      buffer.readBytes(dest);\n+      ((Buffer) dest).limit(prevLimit);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final ByteBuffer dest) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        // Change the limit so that only lengthToCopy bytes are available.\n-        int prevLimit = dest.limit();\n-        ((Buffer) dest).limit(dest.position() + length);\n-\n-        // Write the bytes and restore the original limit.\n-        buffer.readBytes(dest);\n-        ((Buffer) dest).limit(prevLimit);\n-        return 0;\n-      }\n-    }, dest.remaining());\n+    executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) throws IOException {\n+  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+            throws IOException {\n         buffer.readBytes(dest, length);\n         return 0;\n-      }\n-    };\n-    execute(op, length);\n-\n-    // If an exception occurred, throw it.\n-    if (op.isError()) {\n-      throw op.ex;\n     }\n+  };\n+\n+  @Override\n+  public void readBytes(final OutputStream dest, int length) throws IOException {\n+    execute(STREAM_OP, length, dest, 0);\n   }\n \n   @Override\n-  public CompositeReadableBuffer readBytes(int length) {\n+  public ReadableBuffer readBytes(int length) {\n+    if (length <= 0) {\n+      return ReadableBuffers.empty();", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -72,73 +72,78 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n     return readableBytes;\n   }\n \n-  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n-      return buffer.readUnsignedByte();\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> UBYTE_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+          return buffer.readUnsignedByte();\n+        }\n+      };\n \n   @Override\n   public int readUnsignedByte() {\n     return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n-  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n-      buffer.skipBytes(length);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> SKIP_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+          buffer.skipBytes(length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n   public void skipBytes(int length) {\n     executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n-  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n-      buffer.readBytes(dest, offset, length);\n-      return offset + length;\n-    }\n-  };\n+  private static final NoThrowReadOperation<byte[]> BYTE_ARRAY_OP =\n+      new NoThrowReadOperation<byte[]>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+          buffer.readBytes(dest, offset, length);\n+          return offset + length;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final byte[] dest, final int destOffset, int length) {\n+  public void readBytes(byte[] dest, int destOffset, int length) {\n     executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n-  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n-      // Change the limit so that only lengthToCopy bytes are available.\n-      int prevLimit = dest.limit();\n-      ((Buffer) dest).limit(dest.position() + length);\n-      // Write the bytes and restore the original limit.\n-      buffer.readBytes(dest);\n-      ((Buffer) dest).limit(prevLimit);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<ByteBuffer> BYTE_BUF_OP =\n+      new NoThrowReadOperation<ByteBuffer>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+          // Change the limit so that only lengthToCopy bytes are available.\n+          int prevLimit = dest.limit();\n+          ((Buffer) dest).limit(dest.position() + length);\n+          // Write the bytes and restore the original limit.\n+          buffer.readBytes(dest);\n+          ((Buffer) dest).limit(prevLimit);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final ByteBuffer dest) {\n+  public void readBytes(ByteBuffer dest) {\n     executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+  private static final ReadOperation<OutputStream> STREAM_OP =\n+      new ReadOperation<OutputStream>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n             throws IOException {\n-        buffer.readBytes(dest, length);\n-        return 0;\n-    }\n-  };\n+          buffer.readBytes(dest, length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n+  public void readBytes(OutputStream dest, int length) throws IOException {\n     execute(STREAM_OP, length, dest, 0);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDA3MA==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394070", "bodyText": "We use AssertionError for impossible internally-guaranteed conditions.", "author": "ejona86", "createdAt": "2020-11-03T02:14:02Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -189,6 +211,16 @@ private void execute(ReadOperation op, int length) {\n       // Should never get here.\n       throw new AssertionError(\"Failed executing read operation\");\n     }\n+\n+    return value;\n+  }\n+\n+  private <T> int executeNoThrow(ReadOperation<T> op, int length, T dest, int value) {\n+    try {\n+      return execute(op, length, dest, value);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e); // shouldn't happen", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -215,11 +220,11 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n     return value;\n   }\n \n-  private <T> int executeNoThrow(ReadOperation<T> op, int length, T dest, int value) {\n+  private <T> int executeNoThrow(NoThrowReadOperation<T> op, int length, T dest, int value) {\n     try {\n       return execute(op, length, dest, value);\n     } catch (IOException e) {\n-      throw new RuntimeException(e); // shouldn't happen\n+      throw new AssertionError(e); // shouldn't happen\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394635", "bodyText": "Don't know if we care, but we could have a NonThrowingReadOperation that extends this interface and doesn't have throws IOException. executeNoThrow() could then have that as a parameter. That would preserve the checked exception checking.", "author": "ejona86", "createdAt": "2020-11-03T02:16:43Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MjM2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r549982365", "bodyText": "I may not completely follow, but I don't see that this would buy much. Unless we wanted to also duplicate the execute() method contents which wouldn't be ideal.", "author": "njhill", "createdAt": "2020-12-30T07:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2MjMwMg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r550262302", "bodyText": "No need to duplicate execute(). execute() and executeNoThrow() would work as you have it here. The difference is that executeNoThrow() could only be called with a ReadOperation that actually doesn't throw IOExceptions.", "author": "ejona86", "createdAt": "2020-12-30T17:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -239,6 +244,18 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n    * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n   private interface ReadOperation<T> {\n+    /**\n+     * This method can also be used to simultaneously perform operation-specific int-valued\n+     * aggregation over the sequence of buffers in a {@link CompositeReadableBuffer}.\n+     * {@code value} is the return value from the prior buffer, or the \"initial\" value passed\n+     * to {@code execute()} in the case of the first buffer. {@code execute()} returns the value\n+     * returned by the operation called on the last buffer.\n+     */\n     int read(ReadableBuffer buffer, int length, T dest, int value) throws IOException;\n   }\n+\n+  private interface NoThrowReadOperation<T> extends ReadOperation<T> {\n+    @Override\n+    int read(ReadableBuffer buffer, int length, T dest, int value);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTQ1OQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516395459", "bodyText": "You might want to clean up the now-unnecessary finals. Not a big deal.", "author": "ejona86", "createdAt": "2020-11-03T02:20:14Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -72,73 +72,78 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n     return readableBytes;\n   }\n \n-  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n-      return buffer.readUnsignedByte();\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> UBYTE_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+          return buffer.readUnsignedByte();\n+        }\n+      };\n \n   @Override\n   public int readUnsignedByte() {\n     return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n-  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n-      buffer.skipBytes(length);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<Void> SKIP_OP =\n+      new NoThrowReadOperation<Void>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+          buffer.skipBytes(length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n   public void skipBytes(int length) {\n     executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n-  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n-      buffer.readBytes(dest, offset, length);\n-      return offset + length;\n-    }\n-  };\n+  private static final NoThrowReadOperation<byte[]> BYTE_ARRAY_OP =\n+      new NoThrowReadOperation<byte[]>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+          buffer.readBytes(dest, offset, length);\n+          return offset + length;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final byte[] dest, final int destOffset, int length) {\n+  public void readBytes(byte[] dest, int destOffset, int length) {\n     executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n-  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n-      // Change the limit so that only lengthToCopy bytes are available.\n-      int prevLimit = dest.limit();\n-      ((Buffer) dest).limit(dest.position() + length);\n-      // Write the bytes and restore the original limit.\n-      buffer.readBytes(dest);\n-      ((Buffer) dest).limit(prevLimit);\n-      return 0;\n-    }\n-  };\n+  private static final NoThrowReadOperation<ByteBuffer> BYTE_BUF_OP =\n+      new NoThrowReadOperation<ByteBuffer>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+          // Change the limit so that only lengthToCopy bytes are available.\n+          int prevLimit = dest.limit();\n+          ((Buffer) dest).limit(dest.position() + length);\n+          // Write the bytes and restore the original limit.\n+          buffer.readBytes(dest);\n+          ((Buffer) dest).limit(prevLimit);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final ByteBuffer dest) {\n+  public void readBytes(ByteBuffer dest) {\n     executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n-    @Override\n-    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+  private static final ReadOperation<OutputStream> STREAM_OP =\n+      new ReadOperation<OutputStream>() {\n+        @Override\n+        public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n             throws IOException {\n-        buffer.readBytes(dest, length);\n-        return 0;\n-    }\n-  };\n+          buffer.readBytes(dest, length);\n+          return 0;\n+        }\n+      };\n \n   @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n+  public void readBytes(OutputStream dest, int length) throws IOException {\n     execute(STREAM_OP, length, dest, 0);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzM2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516397365", "bodyText": "Somewhere the relationship between value and the returned int needs to be mentioned, since that might be surprising and doesn't \"jump out\" obviously in the code.", "author": "ejona86", "createdAt": "2020-11-03T02:29:05Z", "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {\n+    int read(ReadableBuffer buffer, int length, T dest, int value) throws IOException;", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\nindex 50c6ccaaf..34021d8a8 100644\n--- a/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n+++ b/core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java\n\n@@ -239,6 +244,18 @@ public class CompositeReadableBuffer extends AbstractReadableBuffer {\n    * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n   private interface ReadOperation<T> {\n+    /**\n+     * This method can also be used to simultaneously perform operation-specific int-valued\n+     * aggregation over the sequence of buffers in a {@link CompositeReadableBuffer}.\n+     * {@code value} is the return value from the prior buffer, or the \"initial\" value passed\n+     * to {@code execute()} in the case of the first buffer. {@code execute()} returns the value\n+     * returned by the operation called on the last buffer.\n+     */\n     int read(ReadableBuffer buffer, int length, T dest, int value) throws IOException;\n   }\n+\n+  private interface NoThrowReadOperation<T> extends ReadOperation<T> {\n+    @Override\n+    int read(ReadableBuffer buffer, int length, T dest, int value);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516902906", "bodyText": "FWIW, this allocation should exist on the stack.", "author": "ejona86", "createdAt": "2020-11-03T19:23:49Z", "path": "core/src/main/java/io/grpc/internal/MessageFramer.java", "diffHunk": "@@ -218,28 +218,26 @@ private int writeKnownLengthUncompressed(InputStream message, int messageLength)\n               String.format(\"message too large %d > %d\", messageLength , maxOutboundMessageSize))\n           .asRuntimeException();\n     }\n-    ByteBuffer header = ByteBuffer.wrap(headerScratch);", "originalCommit": "f661a1c522faf479eb905f48d1e826603a20b75d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMzMzNw==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517023337", "bodyText": "FWIW, this allocation should exist on the stack.\n\nWhat do you mean by \"this allocation\"?", "author": "voidzcy", "createdAt": "2020-11-03T23:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMzU5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r517023596", "bodyText": "ByteBuffer.wrap() creates a new object.", "author": "ejona86", "createdAt": "2020-11-03T23:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "url": "https://github.com/grpc/grpc-java/commit/04f4e98298c8d7fd23c5b455468b62ff2100bb37", "message": "Address review comments from @ejona86 and @voidzcy", "committedDate": "2021-01-01T01:31:26Z", "type": "commit"}, {"oid": "be28523602b5f0a7eb7bae474ac6588248bf5364", "url": "https://github.com/grpc/grpc-java/commit/be28523602b5f0a7eb7bae474ac6588248bf5364", "message": "Fix missing imports in CronetClientTransport.java", "committedDate": "2021-01-18T21:36:10Z", "type": "commit"}]}