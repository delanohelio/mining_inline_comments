{"pr_number": 7666, "pr_title": "xds: fix the new server API for ServerXdsClient", "pr_createdAt": "2020-11-25T07:20:38Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7666", "timeline": [{"oid": "cd6dc3a1fe797a953b2f4cac3ebaff71e11f3845", "url": "https://github.com/grpc/grpc-java/commit/cd6dc3a1fe797a953b2f4cac3ebaff71e11f3845", "message": "xds: fix the new server API for ServerXdsClient", "committedDate": "2020-11-25T07:19:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NjUwNA==", "url": "https://github.com/grpc/grpc-java/pull/7666#discussion_r530656504", "bodyText": "This becomes really messy. You could have fixed the resource name in the constructor instead of keeping recomputing it. That's much much cleaner.", "author": "voidzcy", "createdAt": "2020-11-25T21:42:14Z", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -101,15 +101,21 @@ public void run() {\n   @Override\n   Collection<String> getSubscribedResources(ResourceType type) {\n     if (newServerApi) {\n-      String listeningAddress = instanceIp + \":\" + listenerPort;\n-      String resourceName =\n-          grpcServerResourceId + \"?udpa.resource.listening_address=\" + listeningAddress;\n-      return ImmutableList.<String>of(resourceName);\n+      return ImmutableList.<String>of(getResourceNameForListener());\n     } else {\n       return Collections.emptyList();\n     }\n   }\n \n+  private String getResourceNameForListener() {", "originalCommit": "cd6dc3a1fe797a953b2f4cac3ebaff71e11f3845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5MzA3OQ==", "url": "https://github.com/grpc/grpc-java/pull/7666#discussion_r530693079", "bodyText": "The port is not known in the constrictor so this can be built in watchListenerData which is where I compute it.", "author": "sanjaypujare", "createdAt": "2020-11-25T23:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1NjUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c4c75eeb79c7aa24f018889fd9cb431c97e7f289", "chunk": "diff --git a/xds/src/main/java/io/grpc/xds/ServerXdsClient.java b/xds/src/main/java/io/grpc/xds/ServerXdsClient.java\nindex 634ad0aeb..2f27d62ff 100644\n--- a/xds/src/main/java/io/grpc/xds/ServerXdsClient.java\n+++ b/xds/src/main/java/io/grpc/xds/ServerXdsClient.java\n\n@@ -101,21 +108,12 @@ final class ServerXdsClient extends AbstractXdsClient {\n   @Override\n   Collection<String> getSubscribedResources(ResourceType type) {\n     if (newServerApi) {\n-      return ImmutableList.<String>of(getResourceNameForListener());\n+      return ImmutableList.<String>of(grpcServerResourceId);\n     } else {\n       return Collections.emptyList();\n     }\n   }\n \n-  private String getResourceNameForListener() {\n-    if (newServerApi) {\n-      String listeningAddress = instanceIp + \":\" + listenerPort;\n-      return grpcServerResourceId + \"?udpa.resource.listening_address=\" + listeningAddress;\n-    } else {\n-      return \":\" + listenerPort;\n-    }\n-  }\n-\n   /** In case of Listener watcher metadata to be updated to include port. */\n   private void updateNodeMetadataForListenerRequest(int port) {\n     Map<String, Object> newMetadata = new HashMap<>();\n"}}, {"oid": "c4c75eeb79c7aa24f018889fd9cb431c97e7f289", "url": "https://github.com/grpc/grpc-java/commit/c4c75eeb79c7aa24f018889fd9cb431c97e7f289", "message": "address review comments", "committedDate": "2020-11-25T23:28:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5ODI5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7666#discussion_r530698293", "bodyText": "Not related too this PR, but some comment on the code:\nThis is really an abused usage of Comparator. All you need is just a static helper method returning true if two filter chains are equivalent. Comparator is for implementing objects total ordering, the overridden compare method makes zero sense for ordering a collection of FilterChain objects.", "author": "voidzcy", "createdAt": "2020-11-25T23:52:37Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -180,7 +182,8 @@ private DownstreamTlsContext getDownstreamTlsContext(InetSocketAddress localInet\n       FilterChainComparator comparator = new FilterChainComparator(localInetAddr);\n       FilterChain bestMatch =\n           filterChains.isEmpty() ? null : Collections.max(filterChains, comparator);\n-      if (bestMatch != null && comparator.isMatching(bestMatch.getFilterChainMatch())) {\n+      if (bestMatch != null\n+          && (newServerApi || comparator.isMatching(bestMatch.getFilterChainMatch()))) {", "originalCommit": "c4c75eeb79c7aa24f018889fd9cb431c97e7f289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwOTI1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7666#discussion_r530709257", "bodyText": "Let me explain what this is doing: it is not for comparing 2 filter chains. It is for ordering the filters in a filter chain based on the attributes of the channel such as IP address and port (both local and remote). So the Comparator is used to rank the filters in the filter chain to find the best match for the given channel e.g. An exact IP address match is better than a match with IP_any (0.0.0.0). Admittedly we don't need a complex Comparator to achieve this and a simple scoring based algorithm would have worked but the reviewer wanted it.\nSince the Comparator just ranks the filters in the chain we still need to make sure the top ranked filter fits the current channel which is where the comparator.isMatching() is made on the bestMatch.", "author": "sanjaypujare", "createdAt": "2020-11-26T00:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY5ODI5Mw=="}], "type": "inlineReview", "revised_code": null}]}