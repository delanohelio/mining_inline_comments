{"pr_number": 7610, "pr_title": "api,core: interceptor-based config selector", "pr_createdAt": "2020-11-10T19:31:15Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7610", "timeline": [{"oid": "4109af437a41635cd2f833821838592962b9603e", "url": "https://github.com/grpc/grpc-java/commit/4109af437a41635cd2f833821838592962b9603e", "message": "api,core: interceptor-based config selector", "committedDate": "2020-11-10T19:23:38Z", "type": "commit"}, {"oid": "73be1d92ea1cd49339b1728b0ffc84cd713bfe6b", "url": "https://github.com/grpc/grpc-java/commit/73be1d92ea1cd49339b1728b0ffc84cd713bfe6b", "message": "add missing file", "committedDate": "2020-11-10T19:34:44Z", "type": "commit"}, {"oid": "2769a0630247bb298993f202c8281f255ca966b1", "url": "https://github.com/grpc/grpc-java/commit/2769a0630247bb298993f202c8281f255ca966b1", "message": "apply method config prior to applying interceptor", "committedDate": "2020-11-10T21:13:46Z", "type": "commit"}, {"oid": "a97cbd209c37d44a731c805565e4a9970881e109", "url": "https://github.com/grpc/grpc-java/commit/a97cbd209c37d44a731c805565e4a9970881e109", "message": "add unit tests", "committedDate": "2020-11-10T21:13:59Z", "type": "commit"}, {"oid": "75aee8a19785af6126840500cea6b07d1c11b5c3", "url": "https://github.com/grpc/grpc-java/commit/75aee8a19785af6126840500cea6b07d1c11b5c3", "message": "add selection error test", "committedDate": "2020-11-10T22:48:36Z", "type": "commit"}, {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc", "url": "https://github.com/grpc/grpc-java/commit/d55b0d078e1f53e7cef8bc03533041df215ac3cc", "message": "add trivial coverage", "committedDate": "2020-11-10T23:13:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NzgyOA==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521587828", "bodyText": "I don't think we should actually apply the config here. I think we should continue applying the config in ClientCallImpl. That most closely mirrors Envoy and makes it easier to avoiding relying on CallOptions (e.g., outbound max message size should be removed from call options eventually).", "author": "ejona86", "createdAt": "2020-11-11T19:27:03Z", "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A client call for a given channel that applies a given config selector when it starts.\n+ */\n+final class ConfigSelectingClientCall<ReqT, RespT> extends ForwardingClientCall<ReqT, RespT> {\n+\n+  private final InternalConfigSelector configSelector;\n+  private final Channel channel;\n+  private final Executor callExecutor;\n+  private final MethodDescriptor<ReqT, RespT> method;\n+  private final Context context;\n+  private CallOptions callOptions;\n+\n+  private ClientCall<ReqT, RespT> delegate;\n+\n+  ConfigSelectingClientCall(\n+      InternalConfigSelector configSelector, Channel channel, Executor channelExecutor,\n+      MethodDescriptor<ReqT, RespT> method,\n+      CallOptions callOptions) {\n+    this.configSelector = configSelector;\n+    this.channel = channel;\n+    this.method = method;\n+    this.callOptions = callOptions;\n+    this.callExecutor =\n+        callOptions.getExecutor() == null ? channelExecutor : callOptions.getExecutor();\n+    this.context = Context.current();\n+  }\n+\n+  @Override\n+  protected ClientCall<ReqT, RespT> delegate() {\n+    return delegate;\n+  }\n+\n+  @Override\n+  public void start(Listener<RespT> observer, Metadata headers) {\n+    PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n+    InternalConfigSelector.Result result = configSelector.selectConfig(args);\n+    Status status = result.getStatus();\n+    if (!status.isOk()) {\n+      executeCloseObserverInContext(observer, status);\n+      return;\n+    }\n+    ClientInterceptor interceptor = result.getInterceptor();\n+    ManagedChannelServiceConfig config = (ManagedChannelServiceConfig) result.getConfig();\n+    MethodInfo methodInfo = config.getMethodConfig(method);\n+    applyMethodConfig(methodInfo);", "originalCommit": "d55b0d078e1f53e7cef8bc03533041df215ac3cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMjM0OA==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521832348", "bodyText": "Propagated methodInfo to ClientCallImpl via CallOptions now.", "author": "dapengzhang0", "createdAt": "2020-11-12T04:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NzgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "889d30798f4da82699c29727aca5d6952a5a0fc3", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java b/core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java\nindex f277189a7..7c2e85e73 100644\n--- a/core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java\n+++ b/core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java\n\n@@ -21,7 +21,6 @@ import io.grpc.Channel;\n import io.grpc.ClientCall;\n import io.grpc.ClientInterceptor;\n import io.grpc.Context;\n-import io.grpc.Deadline;\n import io.grpc.ForwardingClientCall;\n import io.grpc.InternalConfigSelector;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MjgwMA==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521592800", "bodyText": "We need a fast path for when the selector is set, but it is a ManagedChannelServiceConfig.getDefaultConfigSelector(). We should only pay the indirection cost when it is necessary.", "author": "ejona86", "createdAt": "2020-11-11T19:36:36Z", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1071,17 +1095,12 @@ public void run() {\n \n     private <ReqT, RespT> ClientCall<ReqT, RespT> newClientCall(\n         MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer,\n-          configSelector.get())\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+      InternalConfigSelector selector = configSelector.get();\n+      if (selector == null) {", "originalCommit": "d55b0d078e1f53e7cef8bc03533041df215ac3cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMTE4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521831185", "bodyText": "Added a fast path for this below.", "author": "dapengzhang0", "createdAt": "2020-11-12T04:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MjgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "ee17afcdd36a752aee9e233b04e07c090ed4d69b", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\nindex 18dfb442d..be4df2f78 100644\n--- a/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ManagedChannelImpl.java\n\n@@ -1099,6 +1100,14 @@ final class ManagedChannelImpl extends ManagedChannel implements\n       if (selector == null) {\n         return clientCallImplChannel.newCall(method, callOptions);\n       }\n+      if (selector instanceof ServiceConfigConvertedSelector) {\n+        MethodInfo methodInfo =\n+            ((ServiceConfigConvertedSelector) selector).config.getMethodConfig(method);\n+        if (methodInfo != null) {\n+          callOptions = callOptions.withOption(MethodInfo.KEY, methodInfo);\n+        }\n+        return clientCallImplChannel.newCall(method, callOptions);\n+      }\n       return new ConfigSelectingClientCall<>(\n           selector, clientCallImplChannel, executor, method, callOptions);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTU2NQ==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521599565", "bodyText": "I'm concerned about this double-picking and it assuming we get the same results both times. Could you either migrate the current user of the committedCallback or convert the callback to an interceptor in ConfigSelectingClientCall? It seems that should be really easy. If not, then maybe disable this flow if the CallOptions contain the service config.", "author": "ejona86", "createdAt": "2020-11-11T19:49:42Z", "path": "core/src/main/java/io/grpc/internal/ClientCallImpl.java", "diffHunk": "@@ -221,6 +222,7 @@ public void runInContext() {\n       return;\n     }\n \n+    // TODO(zdapeng): remove this after migration to interceptor based config selector.\n     if (configSelector != null) {\n       PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n       InternalConfigSelector.Result result = configSelector.selectConfig(args);", "originalCommit": "d55b0d078e1f53e7cef8bc03533041df215ac3cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMTQ4NQ==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521831485", "bodyText": "I converted the callback to an interceptor for the moment.  (It seems not working to disable this flow if the CallOptions contain the service config)", "author": "dapengzhang0", "createdAt": "2020-11-12T04:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0b7fdceee7a1102f3b93d45628d4b423b3317cb0", "chunk": "diff --git a/core/src/main/java/io/grpc/internal/ClientCallImpl.java b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\nindex c511e2dc7..921c5869c 100644\n--- a/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n+++ b/core/src/main/java/io/grpc/internal/ClientCallImpl.java\n\n@@ -222,8 +222,9 @@ final class ClientCallImpl<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n       return;\n     }\n \n+    MethodInfo methodInfo = callOptions.getOption(MethodInfo.KEY);\n     // TODO(zdapeng): remove this after migration to interceptor based config selector.\n-    if (configSelector != null) {\n+    if (configSelector != null && methodInfo == null) {\n       PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n       InternalConfigSelector.Result result = configSelector.selectConfig(args);\n       Status status = result.getStatus();\n"}}, {"oid": "889d30798f4da82699c29727aca5d6952a5a0fc3", "url": "https://github.com/grpc/grpc-java/commit/889d30798f4da82699c29727aca5d6952a5a0fc3", "message": "not to apply method config in interceptor", "committedDate": "2020-11-11T22:55:44Z", "type": "commit"}, {"oid": "0b7fdceee7a1102f3b93d45628d4b423b3317cb0", "url": "https://github.com/grpc/grpc-java/commit/0b7fdceee7a1102f3b93d45628d4b423b3317cb0", "message": "partially avoud double selection", "committedDate": "2020-11-11T23:09:39Z", "type": "commit"}, {"oid": "ee17afcdd36a752aee9e233b04e07c090ed4d69b", "url": "https://github.com/grpc/grpc-java/commit/ee17afcdd36a752aee9e233b04e07c090ed4d69b", "message": "avoid indirection when possible", "committedDate": "2020-11-12T00:14:06Z", "type": "commit"}, {"oid": "2c01799347416c9f5662f613d63cf8b7812de60f", "url": "https://github.com/grpc/grpc-java/commit/2c01799347416c9f5662f613d63cf8b7812de60f", "message": "Revert \"partially avoud double selection\"\n\nThis reverts commit 0b7fdceee7a1102f3b93d45628d4b423b3317cb0.", "committedDate": "2020-11-12T00:29:40Z", "type": "commit"}, {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561", "url": "https://github.com/grpc/grpc-java/commit/0c8ea16eea9c98eb82ae975827bbf40568083561", "message": "convert the callback to an interceptor", "committedDate": "2020-11-12T04:21:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NTQ3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522165477", "bodyText": "If you want, you can extend NoopClientCall.", "author": "ejona86", "createdAt": "2020-11-12T14:52:44Z", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;\n+\n+  @Test\n+  public void configSelectorInterceptsCall() {\n+    Map<String, ?> rawMethodConfig = ImmutableMap.of(\n+        \"retryPolicy\",\n+        ImmutableMap.of(\n+            \"maxAttempts\", 3.0D,\n+            \"initialBackoff\", \"1s\",\n+            \"maxBackoff\", \"10s\",\n+            \"backoffMultiplier\", 1.5D,\n+            \"retryableStatusCodes\", ImmutableList.of(\"UNAVAILABLE\")\n+        ));\n+    final MethodInfo methodInfo = new MethodInfo(rawMethodConfig, true, 4, 4);\n+    final Metadata.Key<String> metadataKey =\n+        Metadata.Key.of(\"test\", Metadata.ASCII_STRING_MARSHALLER);\n+    final CallOptions.Key<String> callOptionsKey = CallOptions.Key.create(\"test\");\n+    InternalConfigSelector configSelector = new InternalConfigSelector() {\n+      @Override\n+      public Result selectConfig(final PickSubchannelArgs args) {\n+        ManagedChannelServiceConfig config = new ManagedChannelServiceConfig(\n+            methodInfo,\n+            ImmutableMap.<String, MethodInfo>of(),\n+            ImmutableMap.<String, MethodInfo>of(),\n+            null,\n+            null,\n+            null);\n+        return Result.newBuilder()\n+            .setConfig(config)\n+            .setInterceptor(\n+                // An interceptor that mutates CallOptions base on headers value.\n+                new ClientInterceptor() {\n+                  String value = args.getHeaders().get(metadataKey);\n+                  @Override\n+                  public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+                      MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+                    callOptions = callOptions.withOption(callOptionsKey, value);\n+                    return next.newCall(method, callOptions);\n+                  }\n+                })\n+            .build();\n+      }\n+    };\n+\n+    ClientCall<Void, Void> configSelectingClientCall = new ConfigSelectingClientCall<>(\n+        configSelector,\n+        channel,\n+        MoreExecutors.directExecutor(),\n+        method,\n+        CallOptions.DEFAULT.withAuthority(\"bar.authority\"));\n+    Metadata metadata = new Metadata();\n+    metadata.put(metadataKey, \"fooValue\");\n+    configSelectingClientCall.start(callListener, metadata);\n+\n+    assertThat(call.callOptions.getAuthority()).isEqualTo(\"bar.authority\");\n+    assertThat(call.callOptions.getOption(MethodInfo.KEY)).isEqualTo(methodInfo);\n+    assertThat(call.callOptions.getOption(callOptionsKey)).isEqualTo(\"fooValue\");\n+  }\n+\n+  @Test\n+  public void selectionErrorPropagatedToListener() {\n+    InternalConfigSelector configSelector = new InternalConfigSelector() {\n+      @Override\n+      public Result selectConfig(PickSubchannelArgs args) {\n+        return Result.forError(Status.FAILED_PRECONDITION);\n+      }\n+    };\n+\n+    ClientCall<Void, Void> configSelectingClientCall = new ConfigSelectingClientCall<>(\n+        configSelector,\n+        channel,\n+        MoreExecutors.directExecutor(),\n+        method,\n+        CallOptions.DEFAULT);\n+    configSelectingClientCall.start(callListener, new Metadata());\n+    ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(null);\n+    verify(callListener).onClose(statusCaptor.capture(), any(Metadata.class));\n+    assertThat(statusCaptor.getValue().getCode()).isEqualTo(Status.Code.FAILED_PRECONDITION);\n+  }\n+\n+  private final class TestChannel extends Channel {\n+\n+    @SuppressWarnings(\"unchecked\") // Don't care\n+    @Override\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        MethodDescriptor<ReqT, RespT> methodDescriptor, CallOptions callOptions) {\n+      TestCall<ReqT, RespT> clientCall = new TestCall<>(callOptions);\n+      call = (TestCall<Void, Void>) clientCall;\n+      return clientCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return \"foo.authority\";\n+    }\n+  }\n+\n+  private static final class TestCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {", "originalCommit": "0c8ea16eea9c98eb82ae975827bbf40568083561", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf5741f90dc615877f768591135ecec24e9eae93", "chunk": "diff --git a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\nindex 859c280af..cd94b0ce7 100644\n--- a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n+++ b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n\n@@ -18,6 +18,8 @@ package io.grpc.internal;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.verify;\n \n import com.google.common.collect.ImmutableList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522167755", "bodyText": "It's not clear to me why you are storing the CallOptions in the ClientCall instead of just storing the CallOptions in a test field directly.", "author": "ejona86", "createdAt": "2020-11-12T14:55:34Z", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;", "originalCommit": "0c8ea16eea9c98eb82ae975827bbf40568083561", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MjY5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522372697", "bodyText": "I wanted to verify the CallOptions that the underlying call (TestCall) received is as expected, so the CallOption is kind of belonging to the underlying call. I agree it's not so clear by reading the code. Now I use a mock channel instead.", "author": "dapengzhang0", "createdAt": "2020-11-12T19:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MTg2MA==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522381860", "bodyText": "Oh, I preferred how you had it instead of using a Mock. A concrete Channel implementation is far more readable and more useful as tests are added. And argument captures are harder to follow.", "author": "ejona86", "createdAt": "2020-11-12T19:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5Njc3Mw==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522396773", "bodyText": "Reverted mock channel and added some explanation comments.", "author": "dapengzhang0", "createdAt": "2020-11-12T20:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bf5741f90dc615877f768591135ecec24e9eae93", "chunk": "diff --git a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\nindex 859c280af..cd94b0ce7 100644\n--- a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n+++ b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n\n@@ -18,6 +18,8 @@ package io.grpc.internal;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.verify;\n \n import com.google.common.collect.ImmutableList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MTk2OQ==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522171969", "bodyText": "Use TestMethodDescriptors.voidMethod()? I assumed this was done so you could clearly define the method name for service config, but it seems your using the wildcard.", "author": "ejona86", "createdAt": "2020-11-12T15:00:52Z", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()", "originalCommit": "0c8ea16eea9c98eb82ae975827bbf40568083561", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bf5741f90dc615877f768591135ecec24e9eae93", "chunk": "diff --git a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\nindex 859c280af..cd94b0ce7 100644\n--- a/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n+++ b/core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java\n\n@@ -18,6 +18,8 @@ package io.grpc.internal;\n \n import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.verify;\n \n import com.google.common.collect.ImmutableList;\n"}}, {"oid": "bf5741f90dc615877f768591135ecec24e9eae93", "url": "https://github.com/grpc/grpc-java/commit/bf5741f90dc615877f768591135ecec24e9eae93", "message": "address comments", "committedDate": "2020-11-12T19:27:38Z", "type": "commit"}, {"oid": "5a5cb97b2fa9eaa9390f4e88e93fe0f503f424b4", "url": "https://github.com/grpc/grpc-java/commit/5a5cb97b2fa9eaa9390f4e88e93fe0f503f424b4", "message": "revert mock channel", "committedDate": "2020-11-12T20:16:05Z", "type": "commit"}, {"oid": "a1cc804492b8774d7721354000f6f22ec1ea213a", "url": "https://github.com/grpc/grpc-java/commit/a1cc804492b8774d7721354000f6f22ec1ea213a", "message": "fix typo", "committedDate": "2020-11-12T20:21:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyODg5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522428896", "bodyText": "I don't see any usefulness of such a test, except it trivially increases the code coverage...", "author": "voidzcy", "createdAt": "2020-11-12T21:11:37Z", "path": "api/src/test/java/io/grpc/InternalConfigSelectorTest.java", "diffHunk": "@@ -55,6 +56,18 @@ public void run() {}\n     assertThat(result.getCommittedCallback()).isSameInstanceAs(committedCallback);\n   }\n \n+  @Test\n+  public void resultBuilder_interceptorBased() {", "originalCommit": "a1cc804492b8774d7721354000f6f22ec1ea213a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQzNzM0OA==", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522437348", "bodyText": "nit: This class looks simple and small (after the interceptor for wrapping the existing committed callback is deleted), so maybe just embedded it in ManagedChannelImpl? But anyway, I am fine with either.", "author": "voidzcy", "createdAt": "2020-11-12T21:28:43Z", "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.Context;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener.SimpleForwardingClientCallListener;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import java.util.concurrent.Executor;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A client call for a given channel that applies a given config selector when it starts.\n+ */\n+final class ConfigSelectingClientCall<ReqT, RespT> extends ForwardingClientCall<ReqT, RespT> {", "originalCommit": "a1cc804492b8774d7721354000f6f22ec1ea213a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}