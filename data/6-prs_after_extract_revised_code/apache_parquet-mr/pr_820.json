{"pr_number": 820, "pr_title": "PARQUET-1917: Don't write values for oneOf fields that aren't set", "pr_createdAt": "2020-09-29T18:38:16Z", "pr_url": "https://github.com/apache/parquet-mr/pull/820", "timeline": [{"oid": "e8674f885fc2af5b3bec257f3da32e50365a2f43", "url": "https://github.com/apache/parquet-mr/commit/e8674f885fc2af5b3bec257f3da32e50365a2f43", "message": "PARQUET-1917 Don't write values for oneOf fields that aren't actually set", "committedDate": "2020-09-29T18:36:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTQwMA==", "url": "https://github.com/apache/parquet-mr/pull/820#discussion_r496959400", "bodyText": "Maybe this approach is too simplistic, but it does seem like exactly the behavior needed.", "author": "dossett", "createdAt": "2020-09-29T18:43:24Z", "path": "parquet-protobuf/src/main/java/org/apache/parquet/proto/ProtoWriteSupport.java", "diffHunk": "@@ -337,6 +337,12 @@ private void writeAllFields(MessageOrBuilder pb) {\n         List<FieldDescriptor> fieldDescriptors = messageDescriptor.getFields();\n         for (FieldDescriptor fieldDescriptor : fieldDescriptors) {\n           FieldDescriptor.Type type = fieldDescriptor.getType();\n+\n+          //For a field in a oneOf that isn't set don't write anything\n+          if (fieldDescriptor.getContainingOneof() != null && !pb.hasField(fieldDescriptor)) {\n+            continue;\n+          }", "originalCommit": "e8674f885fc2af5b3bec257f3da32e50365a2f43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0MjgwMw==", "url": "https://github.com/apache/parquet-mr/pull/820#discussion_r497642803", "bodyText": "What about the read side?  Is there going to be any issue there?  Currently a value is always written, so there is always a value to read.  With this change, the value is not written.  Can the read-side handle this?", "author": "belugabehr", "createdAt": "2020-09-30T16:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MDQwMw==", "url": "https://github.com/apache/parquet-mr/pull/820#discussion_r498250403", "bodyText": "@belugabehr That's a great question.  Everything seems ok when I tested it out locally. I wrote some data out to a parquet file with this change, read the data back into protobuf messages, and then wrote the data back to a second parquet file.  The two parquet files were identical, so everything round tripped successfully.\nI am struggling a bit to write unit tests for this case, but that's probably me getting up the parquet API learning curve.", "author": "dossett", "createdAt": "2020-10-01T13:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1MTM1OQ==", "url": "https://github.com/apache/parquet-mr/pull/820#discussion_r498251359", "bodyText": "To be clear, I will try to add tests for this to my PR.", "author": "dossett", "createdAt": "2020-10-01T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTQwMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "e81f8e5413142387025d0666f04dcab99180c729", "url": "https://github.com/apache/parquet-mr/commit/e81f8e5413142387025d0666f04dcab99180c729", "message": "cleanups", "committedDate": "2020-09-29T20:01:44Z", "type": "commit"}, {"oid": "f4779149bdd1516d2e92f47f6e519420dd05147b", "url": "https://github.com/apache/parquet-mr/commit/f4779149bdd1516d2e92f47f6e519420dd05147b", "message": "add tests", "committedDate": "2020-10-01T15:31:46Z", "type": "commit"}, {"oid": "dbf2dfe5f1785c1b54d4aaafca4f9bc28455a189", "url": "https://github.com/apache/parquet-mr/commit/dbf2dfe5f1785c1b54d4aaafca4f9bc28455a189", "message": "revise and extend tests", "committedDate": "2020-10-01T16:51:25Z", "type": "commit"}, {"oid": "9d7a36459e928064d6ffaa0df2ddf1609efce0ba", "url": "https://github.com/apache/parquet-mr/commit/9d7a36459e928064d6ffaa0df2ddf1609efce0ba", "message": "comment cleanup", "committedDate": "2020-10-01T16:58:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxODk1MQ==", "url": "https://github.com/apache/parquet-mr/pull/820#discussion_r498818951", "bodyText": "Bit of a nit here, but if you find yourself putting in comments like \"this is test 1, this is test 2, this is test 3, etc.\" that is a clear sign that you need to break the test into multiple test methods.\nIf a test fails, it will be much easier to figure out exactly what broke instead of having to step through all this code.  It also ensure that the tests are testing what is intended and that there aren't any side-effects/artifacts of the other test scenarios interfering.", "author": "belugabehr", "createdAt": "2020-10-02T13:24:48Z", "path": "parquet-protobuf/src/test/java/org/apache/parquet/proto/ProtoWriteSupportTest.java", "diffHunk": "@@ -913,4 +918,62 @@ public void testMessageWithExtensions() throws Exception {\n \n     instance.write(msg.build());\n   }\n+\n+  @Test\n+  public void testMessageOneOf() {\n+    RecordConsumer readConsumerMock =  Mockito.mock(RecordConsumer.class);\n+    ProtoWriteSupport<TestProto3.OneOfTestMessage> spyWriter = createReadConsumerInstance(TestProto3.OneOfTestMessage.class, readConsumerMock);\n+    final int theInt = 99;\n+\n+    TestProto3.OneOfTestMessage.Builder msg = TestProto3.OneOfTestMessage.newBuilder();\n+    msg.setSecond(theInt);\n+    spyWriter.write(msg.build());\n+\n+    InOrder inOrder = Mockito.inOrder(readConsumerMock);\n+\n+    inOrder.verify(readConsumerMock).startMessage();\n+    inOrder.verify(readConsumerMock).startField(\"second\", 1);\n+    inOrder.verify(readConsumerMock).addInteger(theInt);\n+    inOrder.verify(readConsumerMock).endField(\"second\", 1);\n+    inOrder.verify(readConsumerMock).endMessage();\n+    Mockito.verifyNoMoreInteractions(readConsumerMock);\n+  }\n+\n+  /**\n+   * Ensure that a message with a oneOf gets written out correctly and can be\n+   * read back as expected.\n+   */\n+  @Test\n+  public void testMessageOneOfRoundTrip() throws IOException {\n+\n+    TestProto3.OneOfTestMessage.Builder msgBuilder = TestProto3.OneOfTestMessage.newBuilder();\n+    msgBuilder.setSecond(99);\n+    TestProto3.OneOfTestMessage theMessage = msgBuilder.build();\n+\n+    TestProto3.OneOfTestMessage.Builder msgBuilder2 = TestProto3.OneOfTestMessage.newBuilder();\n+    TestProto3.OneOfTestMessage theMessageNothingSet = msgBuilder2.build();\n+\n+    TestProto3.OneOfTestMessage.Builder msgBuilder3 = TestProto3.OneOfTestMessage.newBuilder();\n+    msgBuilder3.setFirst(42);\n+    TestProto3.OneOfTestMessage theMessageFirstSet = msgBuilder3.build();\n+\n+    //Write them out and read them back\n+    Path tmpFilePath = TestUtils.writeMessages(theMessage, theMessageNothingSet, theMessageFirstSet);\n+    List<TestProto3.OneOfTestMessage> gotBack = TestUtils.readMessages(tmpFilePath, TestProto3.OneOfTestMessage.class);\n+\n+    //First message", "originalCommit": "9d7a36459e928064d6ffaa0df2ddf1609efce0ba", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}