{"pr_number": 2815, "pr_title": "[F] Moving derived product from pool to product (ENT-2628)", "pr_createdAt": "2020-10-02T20:39:45Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2815", "timeline": [{"oid": "d261c6ad37027fd8047c9dcb7c226ac6fb3819bf", "url": "https://github.com/candlepin/candlepin/commit/d261c6ad37027fd8047c9dcb7c226ac6fb3819bf", "message": "SQUASH ME: WIP: Moving derived product from pool to product", "committedDate": "2020-10-09T20:56:58Z", "type": "forcePushed"}, {"oid": "8532d87803702edbc3760b318eb99930c6fe3ec7", "url": "https://github.com/candlepin/candlepin/commit/8532d87803702edbc3760b318eb99930c6fe3ec7", "message": "SQUASH ME: WIP: Moving derived product from pool to product", "committedDate": "2020-10-26T21:05:07Z", "type": "forcePushed"}, {"oid": "0301553f97b2da7f3deaeccebbe31eb777fb63d9", "url": "https://github.com/candlepin/candlepin/commit/0301553f97b2da7f3deaeccebbe31eb777fb63d9", "message": "SQUASH ME: WIP: Moving derived product from pool to product", "committedDate": "2020-10-27T13:42:42Z", "type": "forcePushed"}, {"oid": "898f98e993efb6320e5450dc455c29f2ad581fa5", "url": "https://github.com/candlepin/candlepin/commit/898f98e993efb6320e5450dc455c29f2ad581fa5", "message": "Moved derived product from pool to product\n\n- The derived product (and derived provided products) have been removed\n  from pool and moved to product\n- Derived provided products are now no longer an explicit field on any\n  model object, instead, the provided products on the derived product\n  are to be used for derived provided products\n- Removed all JSON/XML serialization annotations from Pool\n- Removed the Pool product caching functionality and serialization module\n- ProductManager and ContentManager have been completely rewritten and\n  no longer explicitly require the deprecated product and content DTOs\n  as input to their methods, instead using the service API interface\n- ProductManager and ContentManager no longer have bulk operations,\n  as the functionality was only ever used by refresh, and has been\n  moved to the refresher\n- Updated EventFactory to use DTOs for system purpose compliance\n  status\n- Several model objects have been updated to have fluent-style\n  mutators for method chaining, and have had large constructors\n  removed\n- Removed some unused methods which would have broken with the changes\n  listed above\n- Updated some file operations to use the try-with-resources structure", "committedDate": "2020-10-27T14:32:04Z", "type": "commit"}, {"oid": "83f0d0dfc16f88532c158e2dc7eae39cb2e17855", "url": "https://github.com/candlepin/candlepin/commit/83f0d0dfc16f88532c158e2dc7eae39cb2e17855", "message": "Updated unit tests to support moving derived products from pool to product", "committedDate": "2020-10-27T14:46:04Z", "type": "commit"}, {"oid": "16411c2bb725aff507025ab91906d743ff263907", "url": "https://github.com/candlepin/candlepin/commit/16411c2bb725aff507025ab91906d743ff263907", "message": "Updated spec tests to support moving derived products from pool to product", "committedDate": "2020-10-27T14:48:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTE5OQ==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514381199", "bodyText": "Looks like this class is no longer used. We should probably delete it.", "author": "Januson", "createdAt": "2020-10-29T16:07:42Z", "path": "server/src/main/java/org/candlepin/model/ProductEntitlements.java", "diffHunk": "@@ -33,18 +33,25 @@\n \n     public ProductEntitlements(Collection<Entitlement> entitlements, ProductCurator productCurator) {", "originalCommit": "16411c2bb725aff507025ab91906d743ff263907", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDIyMA==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030220", "bodyText": "Removed", "author": "Ceiu", "createdAt": "2020-11-06T22:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTE5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/ProductEntitlements.java b/server/src/main/java/org/candlepin/model/ProductEntitlements.java\ndeleted file mode 100644\nindex 289e1f897..000000000\n--- a/server/src/main/java/org/candlepin/model/ProductEntitlements.java\n+++ /dev/null\n\n@@ -1,99 +0,0 @@\n-/**\n- * Copyright (c) 2009 - 2012 Red Hat, Inc.\n- *\n- * This software is licensed to you under the GNU General Public License,\n- * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n- * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n- * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n- * along with this software; if not, see\n- * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n- *\n- * Red Hat trademarks are not licensed under GPLv2. No permission is\n- * granted to use or replicate Red Hat trademarks that are incorporated\n- * in this software or its documentation.\n- */\n-package org.candlepin.model;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-\n-/**\n- * This data class is a container for Entitlements mapped by their provided\n- * Products. The reason to have this class is to be able to easily answer query:\n- * Given a product, which entitlements provide it?\n- * @author fnguyen\n- *\n- */\n-public class ProductEntitlements {\n-    private Map<String, Set<Entitlement>> entsByProductIds = new HashMap<>();\n-\n-    public ProductEntitlements(Collection<Entitlement> entitlements, ProductCurator productCurator) {\n-        for (Entitlement ent : entitlements) {\n-            Pool entPool = ent.getPool();\n-            Product poolProduct = entPool.getProduct();\n-\n-            if (poolProduct != null) {\n-                this.mapEntitlementByProduct(ent, poolProduct);\n-\n-                Collection<Product> providedProducts = poolProduct.getProvidedProducts();\n-                if (providedProducts != null) {\n-                    for (Product provided : providedProducts) {\n-                        this.mapEntitlementByProduct(ent, provided);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private void mapEntitlementByProduct(Entitlement entitlement, Product product) {\n-        this.entsByProductIds.computeIfAbsent(product.getId(), key -> new HashSet<>())\n-            .add(entitlement);\n-    }\n-\n-    public boolean isEmpty() {\n-        return entsByProductIds.isEmpty();\n-    }\n-\n-    public Collection<String> getAllProductIds() {\n-        return entsByProductIds.keySet();\n-    }\n-\n-    public Collection<? extends Entitlement> getEntitlementsByProductId(String id) {\n-        return entsByProductIds.get(id);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-\n-        sb.append(\"Entitlement ids by products map: [\");\n-        for (Entry<String, Set<Entitlement>> entry : entsByProductIds.entrySet()) {\n-            sb.append(\"    \" + entry.getKey() + \" -> \" + entSetToString(entry.getValue()) + \"\\n\");\n-        }\n-\n-        sb.append(\"]\");\n-        return sb.toString();\n-    }\n-\n-    private String entSetToString(Set<Entitlement> value) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{\");\n-        boolean first = true;\n-        for (Entitlement ent : value) {\n-            if (!first) {\n-                sb.append(\", \");\n-            }\n-            else {\n-                first = false;\n-            }\n-\n-            sb.append(ent.getId());\n-        }\n-        sb.append(\"}\");\n-        return sb.toString();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MTQzNg==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514391436", "bodyText": "You can use Objects::nonNull", "author": "Januson", "createdAt": "2020-10-29T16:21:11Z", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -952,85 +608,86 @@ public static boolean isChangedBy(Product entity, ProductDTO dto) {\n         // case-insensitive key/value comparison and similiarities (i.e. management_enabled: 1 is\n         // functionally identical to Management_Enabled: true, but it will be detected as a change\n         // in attributes.\n-        Map<String, String> attributes = dto.getAttributes();\n+        Map<String, String> attributes = update.getAttributes();\n         if (attributes != null && !attributes.equals(entity.getAttributes())) {\n             return true;\n         }\n \n-        Collection<ProductContentDTO> productContent = dto.getProductContent();\n-        if (productContent != null) {\n-            Comparator comparator = (lhs, rhs) -> {\n-                ProductContent existing = (ProductContent) lhs;\n-                ProductContentDTO update = (ProductContentDTO) rhs;\n-\n-                if (existing != null && update != null) {\n-                    Content content = existing.getContent();\n-                    ContentDTO cdto = update.getContent();\n-\n-                    if (content != null && cdto != null) {\n-                        if (cdto.getUuid() != null ?\n-                            cdto.getUuid().equals(content.getUuid()) :\n-                            (cdto.getId() != null && cdto.getId().equals(content.getId()))) {\n-                            // At this point, we've either matched the UUIDs (which means we're\n-                            // referencing identical products) or the UUID isn't present on the DTO, but\n-                            // the IDs match (which means we're pointing toward the same product).\n-\n-                            return (update.isEnabled() != null &&\n-                                !update.isEnabled().equals(existing.isEnabled())) ||\n-                                ContentManager.isChangedBy(content, cdto) ? 1 : 0;\n-                        }\n-                    }\n-                }\n+        Collection<String> dependentProductIds = update.getDependentProductIds();\n+        if (dependentProductIds != null &&\n+            !Util.collectionsAreEqual(entity.getDependentProductIds(), dependentProductIds)) {\n+            return true;\n+        }\n \n-                return 1;\n-            };\n+        // Complex stuff\n+        // product content\n+        if (update.getProductContent() != null) {\n+            Map<String, Boolean> entityContentMap = entity.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n-            if (!Util.collectionsAreEqual((Collection) entity.getProductContent(),\n-                (Collection) productContent, comparator)) {\n+            Map<String, Boolean> updateContentMap = update.getProductContent().stream()\n+                .filter(pc -> pc != null && pc.getContent() != null)\n+                .collect(Collectors.toMap(pc -> pc.getContent().getId(), pc -> pc.isEnabled()));\n \n+            if (!entityContentMap.equals(updateContentMap)) {\n                 return true;\n             }\n         }\n \n-        Collection<BrandingDTO> brandingDTOs = dto.getBranding();\n-        if (brandingDTOs != null) {\n-            Comparator<BrandingInfo> comparator = BrandingInfo.getBrandingInfoComparator();\n-            if (!Util.collectionsAreEqual((Collection) entity.getBranding(), (Collection) brandingDTOs,\n-                comparator)) {\n+        // derived product\n+        ProductInfo derivedProduct = update.getDerivedProduct();\n+        Product existingDerived = entity.getDerivedProduct();\n+\n+        if (derivedProduct != null) {\n+            if (existingDerived == null || !existingDerived.getId().equals(derivedProduct.getId())) {\n                 return true;\n             }\n         }\n+        else if (existingDerived != null) {\n+            return true;\n+        }\n \n-        Collection<ProductDTO> providedProducts = dto.getProvidedProducts();\n-\n-        if (providedProducts != null) {\n-            // Quick Id Check\n-            if (!Util.collectionsAreEqual(entity.getProvidedProducts().stream()\n+        // provided products\n+        Collection<? extends ProductInfo> updateProvidedProducts = update.getProvidedProducts();\n+        if (updateProvidedProducts != null) {\n+            Set<String> entityProvidedPids = entity.getProvidedProducts().stream()\n+                .filter(pp -> pp != null)", "originalCommit": "16411c2bb725aff507025ab91906d743ff263907", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDE4NQ==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030185", "bodyText": "Done", "author": "Ceiu", "createdAt": "2020-11-06T22:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MTQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ProductManager.java b/server/src/main/java/org/candlepin/controller/ProductManager.java\nindex 0d76ff4eb..7deefffac 100755\n--- a/server/src/main/java/org/candlepin/controller/ProductManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ProductManager.java\n\n@@ -652,12 +650,12 @@ public class ProductManager {\n         Collection<? extends ProductInfo> updateProvidedProducts = update.getProvidedProducts();\n         if (updateProvidedProducts != null) {\n             Set<String> entityProvidedPids = entity.getProvidedProducts().stream()\n-                .filter(pp -> pp != null)\n+                .filter(Objects::nonNull)\n                 .map(Product::getId)\n                 .collect(Collectors.toSet());\n \n             Set<String> updateProvidedPids = updateProvidedProducts.stream()\n-                .filter(pp -> pp != null)\n+                .filter(Objects::nonNull)\n                 .map(ProductInfo::getId)\n                 .collect(Collectors.toSet());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NjMzNw==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r514396337", "bodyText": "+1 ... We should do something similar for the IllegalStateException that's scattered around here.", "author": "Januson", "createdAt": "2020-10-29T16:27:54Z", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +74,255 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                    throw new IllegalArgumentException(\"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n+                throw new IllegalArgumentException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> cids = new HashSet<>();\n+        Map<String, Content> output;\n+\n+        Collection<? extends ProductContentInfo> productContent = pinfo.getProductContent();\n+        if (productContent != null) {\n+            for (ProductContentInfo pcinfo : productContent) {\n+                ContentInfo cinfo = pcinfo != null ? pcinfo.getContent() : null;\n+\n+                if (cinfo == null) {\n+                    // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?", "originalCommit": "16411c2bb725aff507025ab91906d743ff263907", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMDQ1Mg==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r519030452", "bodyText": "I didn't touch the ISEs since I feel that's still a decent enough fit, but the TODOs have been addressed with the new MalformedEntityReferenceException.", "author": "Ceiu", "createdAt": "2020-11-06T22:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NjMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ProductManager.java b/server/src/main/java/org/candlepin/controller/ProductManager.java\nindex 0d76ff4eb..7deefffac 100755\n--- a/server/src/main/java/org/candlepin/controller/ProductManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ProductManager.java\n\n@@ -94,8 +95,7 @@ public class ProductManager {\n         ProductInfo derived = pinfo.getDerivedProduct();\n         if (derived != null) {\n             if (derived.getId() == null || derived.getId().isEmpty()) {\n-                // TODO: Make this a custom exception. MalformedChildReferenceException, perhaps?\n-                throw new IllegalArgumentException(\"product reference lacks a valid ID\");\n+                throw new MalformedEntityReferenceException(\"product reference lacks a valid ID\");\n             }\n \n             pids.add(derived.getId());\n"}}, {"oid": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "url": "https://github.com/candlepin/candlepin/commit/8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "message": "Updated spec tests to support moving derived products from pool to product", "committedDate": "2020-11-06T22:08:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODk4Ng==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531128986", "bodyText": "I don't think that's needed, since they are recursively added by addProducts", "author": "nikosmoum", "createdAt": "2020-11-26T16:17:13Z", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -162,7 +162,10 @@ public RefreshWorker addSubscriptions(Collection<? extends SubscriptionInfo> sub\n                 this.poolMapper.addImportedEntity(subscription);\n \n                 // Add any products attached to this subscription...\n-                this.addProducts(subscription.getProduct(), subscription.getDerivedProduct());\n+                this.addProducts(subscription.getProduct());\n+\n+                // Should we still add derivedProduct and the provided/derived provided collections here\n+                // for backward compatibility?", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzOTM4MA==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533439380", "bodyText": "Removed", "author": "Ceiu", "createdAt": "2020-12-01T14:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODk4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5abfa63e17a4457a87b1e52b0f70497f198546ee", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java b/server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java\nindex 5942f5ca1..ee849d3b2 100644\n--- a/server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java\n+++ b/server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java\n\n@@ -163,9 +163,6 @@ public class RefreshWorker {\n \n                 // Add any products attached to this subscription...\n                 this.addProducts(subscription.getProduct());\n-\n-                // Should we still add derivedProduct and the provided/derived provided collections here\n-                // for backward compatibility?\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjEzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531606139", "bodyText": "the derived product was appended twice here", "author": "nikosmoum", "createdAt": "2020-11-27T13:36:08Z", "path": "server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java", "diffHunk": "@@ -1064,10 +1096,12 @@ public int hashCode() {\n             .append(this.getMultiplier())\n             .append(this.getHref())\n             .append(this.getAttributes())\n+            .append(this.getDerivedProduct())\n+            .append(this.getProvidedProducts())\n+            .append(this.getDerivedProduct())", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzODg1Nw==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533438857", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-12-01T14:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjEzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5abfa63e17a4457a87b1e52b0f70497f198546ee", "chunk": "diff --git a/server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java b/server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java\nindex 01278f39c..99e1d73d6 100644\n--- a/server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java\n+++ b/server/src/main/java/org/candlepin/dto/api/v1/ProductDTO.java\n\n@@ -1098,7 +1098,6 @@ public class ProductDTO extends TimestampedCandlepinDTO<ProductDTO> implements P\n             .append(this.getAttributes())\n             .append(this.getDerivedProduct())\n             .append(this.getProvidedProducts())\n-            .append(this.getDerivedProduct())\n             .append(this.getDependentProductIds())\n             .append(this.getBranding())\n             .append(this.isLocked())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531659997", "bodyText": "Not something to change, but just an observation: We'll now be exporting more product data than before. We currently export a flat structure: 1 json file for each product, no matter which type it is, e.g. provided, derived, derived provided, while with this, each product json file will also include all of the product hierarchy below it.\nA good question is, how/when (if ever) can we finally update the manifest API, by removing these redundant json files, and only exporting every top-level (root) product?", "author": "nikosmoum", "createdAt": "2020-11-27T15:24:14Z", "path": "server/src/main/java/org/candlepin/dto/manifest/v1/ProductTranslator.java", "diffHunk": "@@ -69,17 +71,37 @@ public ProductDTO populate(ModelTranslator modelTranslator, Product source, Prod\n         destination.setAttributes(source.getAttributes());\n         destination.setDependentProductIds(source.getDependentProductIds());\n \n-        if (modelTranslator != null) {\n+        // Translate children products (recursive op)", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NjgyMg==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533456822", "bodyText": "That's a very good question -- one we should answer eventually. The manifest API is ancient, and is at the root of a lot of awkward bits of code surrounding import and, to a lesser extent, export.\nWe should do something where we specify the version in the manifest somehow (manifest file, perhaps), and if it's not present or doesn't match what we expect, we drop down to this current method. That should at least lay the groundwork for removing the current API and supporting code.", "author": "Ceiu", "createdAt": "2020-12-01T14:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0Njk3Ng==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r534146976", "bodyText": "Using a version variable in the manifest for an if/else flow would mean that we would still have to export all the now-redundant data, because some candlepin-0.9 doing an import still has to do it the old way. The genuine question I have is, is there a limit to how old candlepin imports we need to support?\nIf we knew for example, that in 4 years time our manifest api does not need to support importing below candlepin-4.0 or whatever the provided products epic will be released in, then the manifest version makes sense. Otherwise, if we have to support all candlepins no matter how old, there is no point.", "author": "nikosmoum", "createdAt": "2020-12-02T12:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY1OTk5Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r531688684", "bodyText": "This method, and the clone method itself is not cloning the Red Hat product ID, but the method javadoc implies it does. Was this missed?", "author": "nikosmoum", "createdAt": "2020-11-27T16:28:59Z", "path": "server/src/main/java/org/candlepin/resource/OwnerProductResource.java", "diffHunk": "@@ -297,11 +294,28 @@ else if (!StringUtils.equals(update.getId(), productId)) {\n             throw new ForbiddenException(i18n.tr(\"product \\\"{0}\\\" is locked\", existing.getId()));\n         }\n \n-        Product updated = this.productManager.updateProduct(update, owner, true);\n+        Product updated = this.productManager.updateProduct(owner, update, true);\n \n         return this.translator.translate(updated, ProductDTO.class);\n     }\n \n+    /**\n+     * Creates an new, unmanaged product instance using the Red Hat product ID and content of the\n+     * given product entity.\n+     *\n+     * @param entity\n+     *  the product instance from which to copy the Red Hat product ID and content\n+     *\n+     * @return\n+     *  an unmanaged product instance\n+     */\n+    private Product buildProductForBatchContentChange(Product entity) {\n+        // Impl note: we need to fully clone the object to ensure we don't make any changes to any\n+        // other fields; or we need to create a new product implementation that returns the correct\n+        // no-change value for every other field.\n+        return (Product) entity.clone();", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzODE4NA==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533438184", "bodyText": "Cloning the product does all of the above, in a rather heavy-handed way.\nIn the first implementation, this did little more than exactly what the javadoc said; but I ran into an issue where adding the content to the new product actually made changes to the original product and caused a lot of headaches tracking it down.\nAdditionally, default field values started overwriting other areas that were not intended to be changed by the operation.\nThe other option I had considered here, and noted in the comment, is adding a custom pass-through Product interface that only passes through or stores the RHID and content references.", "author": "Ceiu", "createdAt": "2020-12-01T14:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzOTA2OQ==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533539069", "bodyText": "Ok, if the current solution is to just clone the entity, which is a single line, do we need to wrap it in a method?", "author": "nikosmoum", "createdAt": "2020-12-01T16:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2OTg4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533569882", "bodyText": "I suppose not. The intent here is to eventually revisit it and do something better -- most of the data we're copying doesn't need to be copied.\nI could go either way on this. What's your stance on it?", "author": "Ceiu", "createdAt": "2020-12-01T16:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MjgxNw==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533962817", "bodyText": "If we want to do more with it, then the method & comments on it have some value, so its fine if we leave it", "author": "nikosmoum", "createdAt": "2020-12-02T07:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4ODY4NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njc2Nw==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r532596767", "bodyText": "Method signature & javadoc comment don't match", "author": "nikosmoum", "createdAt": "2020-11-30T13:29:55Z", "path": "server/src/main/java/org/candlepin/controller/ProductManager.java", "diffHunk": "@@ -84,121 +75,252 @@ public ProductManager(EntitlementCertificateGenerator entitlementCertGenerator,\n     }\n \n     /**\n-     * Creates a new Product for the given owner, potentially using a different version than the\n-     * entity provided if a matching entity has already been registered for another owner.\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n      *\n-     * @param dto\n-     *  A product DTO instance representing the product to create\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n-     * @param owner\n-     *  The owner for which to create the product\n+     * @throws IllegalArgumentException\n+     *  if the product provided references a product which cannot be resolved\n+     *\n+     * @return\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n+     */\n+    private Map<String, Product> resolveProductRefs(Owner owner, ProductInfo pinfo) {\n+        Set<String> pids = new HashSet<>();\n+        Map<String, Product> output;\n+\n+        ProductInfo derived = pinfo.getDerivedProduct();\n+        if (derived != null) {\n+            if (derived.getId() == null || derived.getId().isEmpty()) {\n+                throw new MalformedEntityReferenceException(\"product reference lacks a valid ID\");\n+            }\n+\n+            pids.add(derived.getId());\n+        }\n+\n+        Collection<? extends ProductInfo> provided = pinfo.getProvidedProducts();\n+        if (provided != null) {\n+            for (ProductInfo pp : provided) {\n+                if (pp == null) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product contains null provided product reference\");\n+                }\n+\n+                if (pp.getId() == null || pp.getId().isEmpty()) {\n+                    throw new MalformedEntityReferenceException(\n+                        \"product references a product that lacks a valid ID\");\n+                }\n+\n+                pids.add(pp.getId());\n+            }\n+        }\n+\n+        if (!pids.isEmpty()) {\n+            output = this.ownerProductCurator.getProductsByIds(owner, pids).list().stream()\n+                .collect(Collectors.toMap(Product::getId, Function.identity()));\n+\n+            pids.removeAll(output.keySet());\n+            if (!pids.isEmpty()) {\n+                throw new MalformedEntityReferenceException(\n+                    \"product references one or more non-existent products: \" + pids);\n+            }\n+        }\n+        else {\n+            output = new HashMap<>();\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Resolves all of the products referenced by the given product info, returning a map that\n+     * contains all resolved product entities mapped by product ID. If a product reference cannot\n+     * be resolved, this method throws an exception.\n+     *\n+     * @param pinfo\n+     *  the product info for which to resolve product references\n      *\n      * @throws IllegalArgumentException\n-     *  if dto is null or incomplete, or owner is null\n+     *  if the product provided references a product which cannot be resolved\n      *\n      * @return\n-     *  a new Product instance representing the specified product for the given owner\n+     *  a map containing all of the resolved products referenced, mapped by product ID\n      */\n-    public Product createProduct(ProductDTO dto, Owner owner) {\n-        if (dto == null) {\n-            throw new IllegalArgumentException(\"dto is null\");\n+    private Map<String, Content> resolveContentRefs(Owner owner, ProductInfo pinfo) {", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMjEwOQ==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533432109", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-12-01T14:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU5Njc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5abfa63e17a4457a87b1e52b0f70497f198546ee", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ProductManager.java b/server/src/main/java/org/candlepin/controller/ProductManager.java\nindex 7deefffac..a96cfbf28 100755\n--- a/server/src/main/java/org/candlepin/controller/ProductManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ProductManager.java\n\n@@ -140,6 +140,9 @@ public class ProductManager {\n      * contains all resolved product entities mapped by product ID. If a product reference cannot\n      * be resolved, this method throws an exception.\n      *\n+     * @param owner\n+     *  the owner of the product whose content is being resolved\n+     *\n      * @param pinfo\n      *  the product info for which to resolve product references\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcyMTg1Ng==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r532721856", "bodyText": "Shouldn't this be pool.getProduct().getDerivedProduct()? (or are we leaving this change for the other jira task which is about removing the derived product field from Pool all together?)", "author": "nikosmoum", "createdAt": "2020-11-30T16:20:41Z", "path": "server/src/main/java/org/candlepin/policy/js/pool/PoolHelper.java", "diffHunk": "@@ -83,11 +83,13 @@ public static PoolOperationCallback createHostRestrictedPools(PoolManager poolMa\n         List<Pool> poolsToUpdateFromStack = new ArrayList<>();\n         for (Pool pool : pools) {\n             Product product = pool.getProduct();\n-            Pool consumerSpecificPool = null;\n+            Product derivedProduct = pool.getDerivedProduct();", "originalCommit": "8a8a4b7b36c1bf2d829c7ad6787a5cf777abfc34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMTI2MA==", "url": "https://github.com/candlepin/candlepin/pull/2815#discussion_r533431260", "bodyText": "pool.getDerivedProduct() does what you suggested. A lot of those ended up being way too tedious to change and it seemed apt to update the methods on pool to be helper methods.", "author": "Ceiu", "createdAt": "2020-12-01T14:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcyMTg1Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "5abfa63e17a4457a87b1e52b0f70497f198546ee", "url": "https://github.com/candlepin/candlepin/commit/5abfa63e17a4457a87b1e52b0f70497f198546ee", "message": "Updated spec tests to support moving derived products from pool to product", "committedDate": "2020-12-01T14:35:22Z", "type": "commit"}, {"oid": "5abfa63e17a4457a87b1e52b0f70497f198546ee", "url": "https://github.com/candlepin/candlepin/commit/5abfa63e17a4457a87b1e52b0f70497f198546ee", "message": "Updated spec tests to support moving derived products from pool to product", "committedDate": "2020-12-01T14:35:22Z", "type": "forcePushed"}]}