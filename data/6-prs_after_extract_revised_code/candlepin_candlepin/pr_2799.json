{"pr_number": 2799, "pr_title": "ENT-2806: Only add content from active pools on the SCA certificate", "pr_createdAt": "2020-09-08T08:14:55Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2799", "timeline": [{"oid": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "url": "https://github.com/candlepin/candlepin/commit/9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-11T08:32:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTAxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489209018", "bodyText": "This logic is repeated across multiple methods. We should refactor this into reusable pieces.", "author": "Januson", "createdAt": "2020-09-16T07:04:00Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2006,217 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds != null && !poolIds.isEmpty()) {\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n+            javax.persistence.Query query = null;\n+\n+            int blockSize = getInBlockSize();\n+            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+\n+            if (blockCount > 1) {\n+                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+\n+                for (int i = 0; i < blockCount; ++i) {\n+                    if (i != 0) {\n+                        builder.append(\" OR\");\n+                    }\n+\n+                    builder.append(\" p.id IN (:block\").append(i).append(')');\n+                }\n+\n+                query = this.getEntityManager().createQuery(builder.toString());\n+                int i = -1;\n+\n+                for (List<String> block : blocks) {\n+                    query.setParameter(\"block\" + ++i, block);\n+                }\n+            }\n+            else {\n+                builder.append(\" p.id IN (:pids)\");\n+                query = this.getEntityManager().createQuery(builder.toString())\n+                    .setParameter(\"pids\", poolIds);\n+            }\n+\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n+                }\n+\n+                providedProducts.add((String) cols[1]);\n+            }", "originalCommit": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2OTI1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489369253", "bodyText": "Refactored the logic.", "author": "wolfdale", "createdAt": "2020-09-16T11:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "2ad2d679526ff4f19b014b407338456dda763da3", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex 53961cb77..6e02af04e 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2007,130 +2027,6 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n         return output;\n     }\n \n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product UUIDS\n-     *\n-     * @return\n-     *  A mapping of pool IDs to provided product UUIDs\n-     */\n-    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> providedProductMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n-\n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n-\n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n-                    }\n-\n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n-                }\n-\n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n-            }\n-\n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n-            }\n-        }\n-\n-        return providedProductMap;\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUIDs representing the derived provided products of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch derived provided product UUIDs\n-     *\n-     * @return\n-     *  A mapping of pool IDs to provided product UUIDs\n-     */\n-    public Map<String, Set<String>> getDerivedProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> providedProductMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, dpp.uuid FROM Pool p JOIN p.derivedProvidedProducts dpp\" +\n-                \" WHERE\");\n-\n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n-\n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n-\n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n-                    }\n-\n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n-                }\n-\n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n-            }\n-\n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n-            }\n-        }\n-\n-        return providedProductMap;\n-    }\n-\n     /**\n      * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n      * are present, an empty collection will be returned.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTc0Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489209742", "bodyText": "This could be Map.computeIfAbsent.", "author": "Januson", "createdAt": "2020-09-16T07:05:32Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2006,217 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds != null && !poolIds.isEmpty()) {\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n+            javax.persistence.Query query = null;\n+\n+            int blockSize = getInBlockSize();\n+            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+\n+            if (blockCount > 1) {\n+                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+\n+                for (int i = 0; i < blockCount; ++i) {\n+                    if (i != 0) {\n+                        builder.append(\" OR\");\n+                    }\n+\n+                    builder.append(\" p.id IN (:block\").append(i).append(')');\n+                }\n+\n+                query = this.getEntityManager().createQuery(builder.toString());\n+                int i = -1;\n+\n+                for (List<String> block : blocks) {\n+                    query.setParameter(\"block\" + ++i, block);\n+                }\n+            }\n+            else {\n+                builder.append(\" p.id IN (:pids)\");\n+                query = this.getEntityManager().createQuery(builder.toString())\n+                    .setParameter(\"pids\", poolIds);\n+            }\n+\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {", "originalCommit": "9960c2ac86f4afc640c5eb5d8a8412a94a1a9f6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2OTMyMg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r489369322", "bodyText": "Done.", "author": "wolfdale", "createdAt": "2020-09-16T11:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwOTc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2ad2d679526ff4f19b014b407338456dda763da3", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex 53961cb77..6e02af04e 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2007,130 +2027,6 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n         return output;\n     }\n \n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product UUIDS\n-     *\n-     * @return\n-     *  A mapping of pool IDs to provided product UUIDs\n-     */\n-    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> providedProductMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE\");\n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n-\n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n-\n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n-                    }\n-\n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n-                }\n-\n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n-            }\n-\n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n-            }\n-        }\n-\n-        return providedProductMap;\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUIDs representing the derived provided products of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch derived provided product UUIDs\n-     *\n-     * @return\n-     *  A mapping of pool IDs to provided product UUIDs\n-     */\n-    public Map<String, Set<String>> getDerivedProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> providedProductMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, dpp.uuid FROM Pool p JOIN p.derivedProvidedProducts dpp\" +\n-                \" WHERE\");\n-\n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n-\n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n-\n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n-                    }\n-\n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n-                }\n-\n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n-            }\n-\n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n-            }\n-        }\n-\n-        return providedProductMap;\n-    }\n-\n     /**\n      * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n      * are present, an empty collection will be returned.\n"}}, {"oid": "2ad2d679526ff4f19b014b407338456dda763da3", "url": "https://github.com/candlepin/candlepin/commit/2ad2d679526ff4f19b014b407338456dda763da3", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-16T11:37:25Z", "type": "forcePushed"}, {"oid": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "url": "https://github.com/candlepin/candlepin/commit/5c6cee6723e8913a082089e5dc9cb7276cdb90de", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-09-16T11:44:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODgwMw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494308803", "bodyText": "Nack on this.\nThis completely changes the typing on our output, which is very bad. Consistency is more important than code reuse.", "author": "Ceiu", "createdAt": "2020-09-24T13:17:56Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1684,26 +1685,40 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n         }\n \n-        return this.getProvidedProductIdsByPoolIds(poolIds);\n+        return this.getProvidedProductByPoolIds(poolIds, true);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs\n+     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n+     *\n+     * @param fetchMode", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjEwNw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976107", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -1685,40 +1686,26 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n             }\n         }\n \n-        return this.getProvidedProductByPoolIds(poolIds, true);\n+        return this.getProvidedProductIdsByPoolIds(poolIds);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n-     *\n-     * @param fetchMode\n-     *  Boolean field.\n-     *  True  -> Returns mapping of Pool IDs & provided product IDs\n-     *  False -> Returns mapping of Pool IDs & provided product UUIDs\n+     *  A collection of pool IDs for which to fetch provided product IDs\n      *\n      * @return\n-     *  A mapping of pool IDs to provided product IDs or UUIDs\n+     *  A mapping of pool IDs to provided product IDs\n      */\n-    public Map<String, Set<String>> getProvidedProductByPoolIds(Collection<String> poolIds,\n-        boolean fetchMode) {\n+    public Map<String, Set<String>> getProvidedProductIdsByPoolIds(Collection<String> poolIds) {\n         Map<String, Set<String>> providedProductMap = new HashMap<>();\n-        StringBuilder builder = new StringBuilder();\n \n         if (poolIds != null && !poolIds.isEmpty()) {\n-            if (fetchMode) {\n-                // Fetch via Product IDs\n-                builder.append(\"SELECT p.id, pp.id FROM Pool p JOIN p.providedProducts pp WHERE \");\n-            }\n-            else {\n-                // Fetch via Product UUIDs\n-                builder.append(\"SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE \");\n-            }\n-\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, pp.id FROM Pool p JOIN p.providedProducts pp WHERE\");\n             javax.persistence.Query query = null;\n \n             int blockSize = getInBlockSize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMjY4NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494312685", "bodyText": "Incorrect use of computeIfAbsent. The method will generate a new value if not present and return whatever ends up in the field in either case. This saves us an interaction with the map by making the fetch, generation, and storage operations all atomic and packaged in a single call. You can then use method chaining and the knowledge that you'll never get a null value out of the map to eliminate the need for explicit declaration. It should look like this:\nprovidedProductMap.computeIfAbsent((String) cols[0], key -> new HashSet<>())\n    .add((String) cols[1]);", "author": "Ceiu", "createdAt": "2020-09-24T13:23:32Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1735,14 +1750,10 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n \n             for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n-\n-                if (providedProducts == null) {\n-                    providedProducts = new HashSet<>();\n-                    providedProductMap.put((String) cols[0], providedProducts);\n-                }\n-\n-                providedProducts.add((String) cols[1]);\n+                providedProductMap.computeIfAbsent((String) cols[0],", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjE1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976153", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMjY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -1750,10 +1737,14 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n             }\n \n             for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                providedProductMap.computeIfAbsent((String) cols[0],\n-                    k -> providedProductMap.put((String) cols[0], Util.asSet((String) cols[1])));\n-                providedProductMap.computeIfPresent((String) cols[0],\n-                    (k, v) -> { v.add((String) cols[1]); return v; });\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n+                }\n+\n+                providedProducts.add((String) cols[1]);\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzIxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494313218", "bodyText": "Again, nack on these changes -- we don't want to completely swing a method's operation and output on a single boolean input. Rewrite the method and make changes as necessary.", "author": "Ceiu", "createdAt": "2020-09-24T13:24:17Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -1772,26 +1783,39 @@ public Boolean providesDerived(Pool pool, String derivedProvidedProductId) {\n             }\n         }\n \n-        return this.getDerivedProvidedProductIdsByPoolIds(poolIds);\n+        return this.getDerivedProvidedProductByPoolIds(poolIds, true);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs\n+     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n+     *\n+     * @param fetchMode\n+     *  Boolean field.\n+     *  True  -> Returns mapping of Pool IDs & provided product IDs\n+     *  False -> Returns mapping of Pool IDs & provided product UUIDs\n      *\n      * @return\n-     *  A mapping of pool IDs to provided product IDs\n+     *  A mapping of pool IDs to provided product IDs or UUIDs\n      */\n-    public Map<String, Set<String>> getDerivedProvidedProductIdsByPoolIds(Collection<String> poolIds) {\n+    public Map<String, Set<String>> getDerivedProvidedProductByPoolIds(Collection<String> poolIds,", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjE4NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976184", "bodyText": "Removed this piece of code from here.", "author": "wolfdale", "createdAt": "2020-10-01T04:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -1783,39 +1774,26 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n             }\n         }\n \n-        return this.getDerivedProvidedProductByPoolIds(poolIds, true);\n+        return this.getDerivedProvidedProductIdsByPoolIds(poolIds);\n     }\n \n     /**\n-     * Fetches a mapping of pool IDs to sets of product IDs or UUIDs representing the provided products of\n+     * Fetches a mapping of pool IDs to sets of product IDs representing the provided products of\n      * the given pool. The returned map will only contain mappings for pools specified in the given\n      * collection of pool IDs.\n      *\n      * @param poolIds\n-     *  A collection of pool IDs for which to fetch provided product IDs or UUIDs\n-     *\n-     * @param fetchMode\n-     *  Boolean field.\n-     *  True  -> Returns mapping of Pool IDs & provided product IDs\n-     *  False -> Returns mapping of Pool IDs & provided product UUIDs\n+     *  A collection of pool IDs for which to fetch provided product IDs\n      *\n      * @return\n-     *  A mapping of pool IDs to provided product IDs or UUIDs\n+     *  A mapping of pool IDs to provided product IDs\n      */\n-    public Map<String, Set<String>> getDerivedProvidedProductByPoolIds(Collection<String> poolIds,\n-        boolean fetchMode) {\n+    public Map<String, Set<String>> getDerivedProvidedProductIdsByPoolIds(Collection<String> poolIds) {\n         Map<String, Set<String>> providedProductMap = new HashMap<>();\n-        StringBuilder builder = new StringBuilder();\n \n         if (poolIds != null && !poolIds.isEmpty()) {\n-            if (fetchMode) {\n-                // Fetch via Products IDs\n-                builder.append(\"SELECT p.id, dpp.id FROM Pool p JOIN p.derivedProvidedProducts dpp WHERE \");\n-            }\n-            else {\n-                // Fetch via Products UUIDs\n-                builder.append(\"SELECT p.id, dpp.uuid FROM Pool p JOIN p.derivedProvidedProducts dpp WHERE \");\n-            }\n+            StringBuilder builder =\n+                new StringBuilder(\"SELECT p.id, dpp.id FROM Pool p JOIN p.derivedProvidedProducts dpp WHERE\");\n \n             javax.persistence.Query query = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzkzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494313939", "bodyText": "This should be named \"getActivePoolIdsByOwnerId\", as it is fetching multiple pool IDs, not a single pool.", "author": "Ceiu", "createdAt": "2020-09-24T13:25:14Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTg2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975862", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxMzkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2028,91 +2010,113 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n-     * are present, an empty collection will be returned.\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n      *\n      * @param ownerId\n-     *  The ID of the owner for which to fetch active Pool IDs\n+     *  Owner Id\n      *\n      * @return\n-     *  A collection of active Pool IDs belonging to the given owner.\n+     *  A Set of product content associated with active pool.\n      */\n-    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n         Date currentDate = new Date();\n-        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n-            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n-\n-        List<String> uuids = this.getEntityManager()\n-            .createQuery(jpql, String.class)\n-            .setParameter(\"owner_id\", ownerId)\n-            .setParameter(\"endDate\", currentDate)\n-            .setParameter(\"startDate\", currentDate)\n-            .getResultList();\n-\n-        return uuids != null ? uuids : Collections.<String>emptyList();\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n-     *\n-     * @return\n-     *  A mapping of pool IDs to product & derived product UUIDs\n-     */\n-    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> productMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, product.uuid, derivedProduct.uuid FROM Pool p WHERE \");\n \n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)\n+                    .getResultList();\n+\n+                for (Pool p : pools) {\n+                    productsContent.addAll(p.getProduct().getProductContent());\n+\n+                    if (p.getDerivedProduct() != null) {\n+                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                    }\n \n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+                    for (Product product : p.getProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n+                    }\n \n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n+                    for (Product product : p.getDerivedProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n                     }\n \n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n                 }\n \n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                log.info(\"Main Product {}\", builder.toString());\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n+                offset += blockSize;\n+                blockCount--;\n             }\n+        }\n+        else {\n+            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n+            for (Pool p : pools) {\n+                productsContent.addAll(p.getProduct().getProductContent());\n \n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> product = new HashSet<>();\n-                product.add((String) cols[1]);\n+                if (p.getDerivedProduct() != null) {\n+                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                }\n \n-                // Derived product\n-                if ((String) cols[2] != null) {\n-                    product.add((String) cols[2]);\n+                for (Product product : p.getProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n                 }\n \n-                productMap.put((String) cols[0], product);\n+                for (Product product : p.getDerivedProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n+                }\n             }\n         }\n \n-        return productMap;\n+        return productsContent;\n+    }\n+\n+    /**\n+     * Returns the count of active pool for an owner.\n+     *\n+     * @param ownerId\n+     *  Id of an owner.\n+     *\n+     * @return\n+     *  Number of active pool for an owner.\n+     */\n+    public Long getActivePoolCountByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(criteriaBuilder.count(pool));\n+\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+\n+        return this.getEntityManager().createQuery(query).getSingleResult();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDI2OQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494314269", "bodyText": "This should be \"ids\" rather than \"uuids\"", "author": "Ceiu", "createdAt": "2020-09-24T13:25:38Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTg4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975882", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDI2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2028,91 +2010,113 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n-     * are present, an empty collection will be returned.\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n      *\n      * @param ownerId\n-     *  The ID of the owner for which to fetch active Pool IDs\n+     *  Owner Id\n      *\n      * @return\n-     *  A collection of active Pool IDs belonging to the given owner.\n+     *  A Set of product content associated with active pool.\n      */\n-    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n         Date currentDate = new Date();\n-        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n-            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n-\n-        List<String> uuids = this.getEntityManager()\n-            .createQuery(jpql, String.class)\n-            .setParameter(\"owner_id\", ownerId)\n-            .setParameter(\"endDate\", currentDate)\n-            .setParameter(\"startDate\", currentDate)\n-            .getResultList();\n-\n-        return uuids != null ? uuids : Collections.<String>emptyList();\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n-     *\n-     * @return\n-     *  A mapping of pool IDs to product & derived product UUIDs\n-     */\n-    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> productMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, product.uuid, derivedProduct.uuid FROM Pool p WHERE \");\n \n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)\n+                    .getResultList();\n+\n+                for (Pool p : pools) {\n+                    productsContent.addAll(p.getProduct().getProductContent());\n+\n+                    if (p.getDerivedProduct() != null) {\n+                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                    }\n \n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+                    for (Product product : p.getProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n+                    }\n \n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n+                    for (Product product : p.getDerivedProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n                     }\n \n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n                 }\n \n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                log.info(\"Main Product {}\", builder.toString());\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n+                offset += blockSize;\n+                blockCount--;\n             }\n+        }\n+        else {\n+            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n+            for (Pool p : pools) {\n+                productsContent.addAll(p.getProduct().getProductContent());\n \n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> product = new HashSet<>();\n-                product.add((String) cols[1]);\n+                if (p.getDerivedProduct() != null) {\n+                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                }\n \n-                // Derived product\n-                if ((String) cols[2] != null) {\n-                    product.add((String) cols[2]);\n+                for (Product product : p.getProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n                 }\n \n-                productMap.put((String) cols[0], product);\n+                for (Product product : p.getDerivedProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n+                }\n             }\n         }\n \n-        return productMap;\n+        return productsContent;\n+    }\n+\n+    /**\n+     * Returns the count of active pool for an owner.\n+     *\n+     * @param ownerId\n+     *  Id of an owner.\n+     *\n+     * @return\n+     *  Number of active pool for an owner.\n+     */\n+    public Long getActivePoolCountByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(criteriaBuilder.count(pool));\n+\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+\n+        return this.getEntityManager().createQuery(query).getSingleResult();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNTMwNA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494315304", "bodyText": "Try not to put line breaks for continuations in the middle of a statement or clause. There's enough space for the :owner_id part of the first WHERE clause, or the WHERE portion should move down to the line with it.", "author": "Ceiu", "createdAt": "2020-09-24T13:26:57Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTgyOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975828", "bodyText": "Noted", "author": "wolfdale", "createdAt": "2020-10-01T04:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNTMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2028,91 +2010,113 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n-     * are present, an empty collection will be returned.\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n      *\n      * @param ownerId\n-     *  The ID of the owner for which to fetch active Pool IDs\n+     *  Owner Id\n      *\n      * @return\n-     *  A collection of active Pool IDs belonging to the given owner.\n+     *  A Set of product content associated with active pool.\n      */\n-    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n         Date currentDate = new Date();\n-        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n-            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n-\n-        List<String> uuids = this.getEntityManager()\n-            .createQuery(jpql, String.class)\n-            .setParameter(\"owner_id\", ownerId)\n-            .setParameter(\"endDate\", currentDate)\n-            .setParameter(\"startDate\", currentDate)\n-            .getResultList();\n-\n-        return uuids != null ? uuids : Collections.<String>emptyList();\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n-     *\n-     * @return\n-     *  A mapping of pool IDs to product & derived product UUIDs\n-     */\n-    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> productMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, product.uuid, derivedProduct.uuid FROM Pool p WHERE \");\n \n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)\n+                    .getResultList();\n+\n+                for (Pool p : pools) {\n+                    productsContent.addAll(p.getProduct().getProductContent());\n+\n+                    if (p.getDerivedProduct() != null) {\n+                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                    }\n \n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+                    for (Product product : p.getProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n+                    }\n \n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n+                    for (Product product : p.getDerivedProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n                     }\n \n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n                 }\n \n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                log.info(\"Main Product {}\", builder.toString());\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n+                offset += blockSize;\n+                blockCount--;\n             }\n+        }\n+        else {\n+            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n+            for (Pool p : pools) {\n+                productsContent.addAll(p.getProduct().getProductContent());\n \n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> product = new HashSet<>();\n-                product.add((String) cols[1]);\n+                if (p.getDerivedProduct() != null) {\n+                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                }\n \n-                // Derived product\n-                if ((String) cols[2] != null) {\n-                    product.add((String) cols[2]);\n+                for (Product product : p.getProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n                 }\n \n-                productMap.put((String) cols[0], product);\n+                for (Product product : p.getDerivedProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n+                }\n             }\n         }\n \n-        return productMap;\n+        return productsContent;\n+    }\n+\n+    /**\n+     * Returns the count of active pool for an owner.\n+     *\n+     * @param ownerId\n+     *  Id of an owner.\n+     *\n+     * @return\n+     *  Number of active pool for an owner.\n+     */\n+    public Long getActivePoolCountByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(criteriaBuilder.count(pool));\n+\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+\n+        return this.getEntityManager().createQuery(query).getSingleResult();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTMxNA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494319314", "bodyText": "Let's try to find a better way to write this. This method looks heavily derived from the bulkSQL[update|delete] methods from AbstractHibernateCurator which should be flagged as deprecated if they're not already. Building raw SQL can be dangerous, and runs into potential problems with parameter limits (as this implementation does here).", "author": "Ceiu", "createdAt": "2020-09-24T13:32:16Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2026,93 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n+     *\n+     * @param ownerId\n+     *  The ID of the owner for which to fetch active Pool IDs\n+     *\n+     * @return\n+     *  A collection of active Pool IDs belonging to the given owner.\n+     */\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()\n+            .createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"endDate\", currentDate)\n+            .setParameter(\"startDate\", currentDate)\n+            .getResultList();\n+\n+        return uuids != null ? uuids : Collections.<String>emptyList();\n+    }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n+     *\n+     * @return\n+     *  A mapping of pool IDs to product & derived product UUIDs\n+     */\n+    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTgxOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975819", "bodyText": "Noted. Changed the logic here.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTMxNA=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex f5d33ef71..2917b89ce 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2028,91 +2010,113 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n-     * are present, an empty collection will be returned.\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n      *\n      * @param ownerId\n-     *  The ID of the owner for which to fetch active Pool IDs\n+     *  Owner Id\n      *\n      * @return\n-     *  A collection of active Pool IDs belonging to the given owner.\n+     *  A Set of product content associated with active pool.\n      */\n-    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n         Date currentDate = new Date();\n-        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n-            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n-\n-        List<String> uuids = this.getEntityManager()\n-            .createQuery(jpql, String.class)\n-            .setParameter(\"owner_id\", ownerId)\n-            .setParameter(\"endDate\", currentDate)\n-            .setParameter(\"startDate\", currentDate)\n-            .getResultList();\n-\n-        return uuids != null ? uuids : Collections.<String>emptyList();\n-    }\n-\n-    /**\n-     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n-     * the given pool. The returned map will only contain mappings for pools specified in the given\n-     * collection of pool IDs.\n-     *\n-     * @param poolIds\n-     *  A collection of pool IDs for which to fetch product & derived product UUIDs.\n-     *\n-     * @return\n-     *  A mapping of pool IDs to product & derived product UUIDs\n-     */\n-    public Map<String, Set<String>> getProductAndDerivedProductUuidsByPoolIds(Collection<String> poolIds) {\n-        Map<String, Set<String>> productMap = new HashMap<>();\n-\n-        if (poolIds != null && !poolIds.isEmpty()) {\n-            StringBuilder builder =\n-                new StringBuilder(\"SELECT p.id, product.uuid, derivedProduct.uuid FROM Pool p WHERE \");\n \n-            javax.persistence.Query query = null;\n-\n-            int blockSize = getInBlockSize();\n-            int blockCount = (int) Math.ceil(poolIds.size() / (float) blockSize);\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)\n+                    .getResultList();\n+\n+                for (Pool p : pools) {\n+                    productsContent.addAll(p.getProduct().getProductContent());\n+\n+                    if (p.getDerivedProduct() != null) {\n+                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                    }\n \n-            if (blockCount > 1) {\n-                Iterable<List<String>> blocks = Iterables.partition(poolIds, blockSize);\n+                    for (Product product : p.getProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n+                    }\n \n-                for (int i = 0; i < blockCount; ++i) {\n-                    if (i != 0) {\n-                        builder.append(\" OR\");\n+                    for (Product product : p.getDerivedProvidedProducts()) {\n+                        productsContent.addAll(product.getProductContent());\n                     }\n \n-                    builder.append(\" p.id IN (:block\").append(i).append(')');\n                 }\n \n-                query = this.getEntityManager().createQuery(builder.toString());\n-                int i = -1;\n-\n-                for (List<String> block : blocks) {\n-                    query.setParameter(\"block\" + ++i, block);\n-                }\n-            }\n-            else {\n-                builder.append(\" p.id IN (:pids)\");\n-                log.info(\"Main Product {}\", builder.toString());\n-                query = this.getEntityManager().createQuery(builder.toString())\n-                    .setParameter(\"pids\", poolIds);\n+                offset += blockSize;\n+                blockCount--;\n             }\n+        }\n+        else {\n+            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n+            for (Pool p : pools) {\n+                productsContent.addAll(p.getProduct().getProductContent());\n \n-            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n-                Set<String> product = new HashSet<>();\n-                product.add((String) cols[1]);\n+                if (p.getDerivedProduct() != null) {\n+                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n+                }\n \n-                // Derived product\n-                if ((String) cols[2] != null) {\n-                    product.add((String) cols[2]);\n+                for (Product product : p.getProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n                 }\n \n-                productMap.put((String) cols[0], product);\n+                for (Product product : p.getDerivedProvidedProducts()) {\n+                    productsContent.addAll(product.getProductContent());\n+                }\n             }\n         }\n \n-        return productMap;\n+        return productsContent;\n+    }\n+\n+    /**\n+     * Returns the count of active pool for an owner.\n+     *\n+     * @param ownerId\n+     *  Id of an owner.\n+     *\n+     * @return\n+     *  Number of active pool for an owner.\n+     */\n+    public Long getActivePoolCountByOwnerId(String ownerId) {\n+        Date currentDate = new Date();\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(criteriaBuilder.count(pool));\n+\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+\n+        return this.getEntityManager().createQuery(query).getSingleResult();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMDMwNQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494320305", "bodyText": "This is a functional duplication of listAllByUuid", "author": "Ceiu", "createdAt": "2020-09-24T13:33:40Z", "path": "server/src/main/java/org/candlepin/model/ProductCurator.java", "diffHunk": "@@ -505,4 +505,25 @@ public boolean productHasSubscriptions(Owner owner, Product product) {\n \n         return this.cpQueryFactory.<Product>buildQuery();\n     }\n+\n+    /**\n+     * Fetches products by product UUIDs.\n+     *\n+     * @param productUuids\n+     *  The Collection of product UUIDs\n+     *\n+     * @return\n+     *  Query collection of Products\n+     */\n+    public CandlepinQuery<Product> getProductsByProductUuids(Collection<String> productUuids) {", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTY3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975673", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMDMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "30360c541a1ee227cb77b529d71f1bb26c5f2aa1", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/ProductCurator.java b/server/src/main/java/org/candlepin/model/ProductCurator.java\nindex 5fb58d5eb..3a0a385df 100755\n--- a/server/src/main/java/org/candlepin/model/ProductCurator.java\n+++ b/server/src/main/java/org/candlepin/model/ProductCurator.java\n\n@@ -505,25 +505,4 @@ public class ProductCurator extends AbstractHibernateCurator<Product> {\n \n         return this.cpQueryFactory.<Product>buildQuery();\n     }\n-\n-    /**\n-     * Fetches products by product UUIDs.\n-     *\n-     * @param productUuids\n-     *  The Collection of product UUIDs\n-     *\n-     * @return\n-     *  Query collection of Products\n-     */\n-    public CandlepinQuery<Product> getProductsByProductUuids(Collection<String> productUuids) {\n-        Session session = this.currentSession();\n-        if (productUuids != null && !productUuids.isEmpty()) {\n-            DetachedCriteria criteria = this.createSecureDetachedCriteria(Product.class, null)\n-                .add(CPRestrictions.in(\"uuid\", productUuids));\n-\n-            return this.cpQueryFactory.<Product>buildQuery(session, criteria);\n-        }\n-\n-        return this.cpQueryFactory.<Product>buildQuery();\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMjI2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494322263", "bodyText": "CandlepinQuery is deprecated, we shouldn't introduce new code that uses it.", "author": "Ceiu", "createdAt": "2020-09-24T13:36:13Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -509,7 +518,35 @@ private String createDN(Consumer consumer, Owner owner) {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        CandlepinQuery<Product> ownerProduct = ownerProductCurator.getProductsByOwner(owner);\n+        Set<String> productUuids = new HashSet<>();\n+\n+        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());\n+        Map<String, Set<String>> products =\n+            poolCurator.getProductAndDerivedProductUuidsByPoolIds(activePoolIds);\n+\n+        Map<String, Set<String>> providedProducts =\n+            poolCurator.getProvidedProductByPoolIds(activePoolIds, false);\n+\n+        Map<String, Set<String>> derivedProvidedProducts =\n+            poolCurator.getDerivedProvidedProductByPoolIds(activePoolIds, false);\n+\n+        for (String poolId : activePoolIds) {\n+            if (providedProducts.get(poolId) != null) {\n+                productUuids.addAll(providedProducts.get(poolId));\n+            }\n+\n+            if (derivedProvidedProducts.get(poolId) != null) {\n+                productUuids.addAll(derivedProvidedProducts.get(poolId));\n+            }\n+\n+            if (products.get(poolId) != null) {\n+                productUuids.addAll(products.get(poolId));\n+            }\n+        }\n+\n+        CandlepinQuery<Product> productsToConsider =", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NTY1NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497975654", "bodyText": "Removed.", "author": "wolfdale", "createdAt": "2020-10-01T04:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMjI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\nindex f8e8a36e8..95a277aac 100644\n--- a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n\n@@ -518,34 +512,6 @@ public class ContentAccessManager {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        Set<String> productUuids = new HashSet<>();\n-\n-        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());\n-        Map<String, Set<String>> products =\n-            poolCurator.getProductAndDerivedProductUuidsByPoolIds(activePoolIds);\n-\n-        Map<String, Set<String>> providedProducts =\n-            poolCurator.getProvidedProductByPoolIds(activePoolIds, false);\n-\n-        Map<String, Set<String>> derivedProvidedProducts =\n-            poolCurator.getDerivedProvidedProductByPoolIds(activePoolIds, false);\n-\n-        for (String poolId : activePoolIds) {\n-            if (providedProducts.get(poolId) != null) {\n-                productUuids.addAll(providedProducts.get(poolId));\n-            }\n-\n-            if (derivedProvidedProducts.get(poolId) != null) {\n-                productUuids.addAll(derivedProvidedProducts.get(poolId));\n-            }\n-\n-            if (products.get(poolId) != null) {\n-                productUuids.addAll(products.get(poolId));\n-            }\n-        }\n-\n-        CandlepinQuery<Product> productsToConsider =\n-            productCurator.getProductsByProductUuids(productUuids);\n \n         Set<String> entitledProductIds = new HashSet<>();\n         List<org.candlepin.model.dto.Product> productModels = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzU0Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r494323542", "bodyText": "This is an expensive way to fetch the product information for active pools. If the goal here is to fetch products for active pools, we should do exactly that: fetch active pools and then pull the products from them in code (functionally identical to what we're doing here), or write a new curator method that fetches only products from active entitlements of a given organization.", "author": "Ceiu", "createdAt": "2020-09-24T13:38:02Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -509,7 +518,35 @@ private String createDN(Consumer consumer, Owner owner) {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        CandlepinQuery<Product> ownerProduct = ownerProductCurator.getProductsByOwner(owner);\n+        Set<String> productUuids = new HashSet<>();\n+\n+        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());", "originalCommit": "5c6cee6723e8913a082089e5dc9cb7276cdb90de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3NjY5NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r497976695", "bodyText": "Changed the logic to pull products & it's content directly in the code from active pools.\nNot sure if we can use active entitlement to pull product's contents here, since active pool can exists without any active entitlement.", "author": "wolfdale", "createdAt": "2020-10-01T04:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzU0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\nindex f8e8a36e8..95a277aac 100644\n--- a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n\n@@ -518,34 +512,6 @@ public class ContentAccessManager {\n     private byte[] createContentAccessDataPayload(Owner owner, Environment environment) throws IOException {\n         // fake a product dto as a container for the org content\n         Set<Product> containerSet = new HashSet<>();\n-        Set<String> productUuids = new HashSet<>();\n-\n-        Collection<String> activePoolIds = poolCurator.getActivePoolByOwnerId(owner.getId());\n-        Map<String, Set<String>> products =\n-            poolCurator.getProductAndDerivedProductUuidsByPoolIds(activePoolIds);\n-\n-        Map<String, Set<String>> providedProducts =\n-            poolCurator.getProvidedProductByPoolIds(activePoolIds, false);\n-\n-        Map<String, Set<String>> derivedProvidedProducts =\n-            poolCurator.getDerivedProvidedProductByPoolIds(activePoolIds, false);\n-\n-        for (String poolId : activePoolIds) {\n-            if (providedProducts.get(poolId) != null) {\n-                productUuids.addAll(providedProducts.get(poolId));\n-            }\n-\n-            if (derivedProvidedProducts.get(poolId) != null) {\n-                productUuids.addAll(derivedProvidedProducts.get(poolId));\n-            }\n-\n-            if (products.get(poolId) != null) {\n-                productUuids.addAll(products.get(poolId));\n-            }\n-        }\n-\n-        CandlepinQuery<Product> productsToConsider =\n-            productCurator.getProductsByProductUuids(productUuids);\n \n         Set<String> entitledProductIds = new HashSet<>();\n         List<org.candlepin.model.dto.Product> productModels = new ArrayList<>();\n"}}, {"oid": "a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "url": "https://github.com/candlepin/candlepin/commit/a9c8ae6db5c8b0d1fa63fe5bdd047bb4fc00b15b", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:07:41Z", "type": "forcePushed"}, {"oid": "30360c541a1ee227cb77b529d71f1bb26c5f2aa1", "url": "https://github.com/candlepin/candlepin/commit/30360c541a1ee227cb77b529d71f1bb26c5f2aa1", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:15:27Z", "type": "forcePushed"}, {"oid": "aaa786f5451251159a706baf05e5501d11ab5314", "url": "https://github.com/candlepin/candlepin/commit/aaa786f5451251159a706baf05e5501d11ab5314", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:20:12Z", "type": "forcePushed"}, {"oid": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "url": "https://github.com/candlepin/candlepin/commit/7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-01T04:29:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ4NDA1NA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r502484054", "bodyText": "setMaxResults called twice with different values here (blockCount looks to be extraneous)", "author": "Ceiu", "createdAt": "2020-10-09T14:50:54Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2008,115 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n+     *\n+     * @param ownerId\n+     *  Owner Id\n+     *\n+     * @return\n+     *  A Set of product content associated with active pool.\n+     */\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n+        Date currentDate = new Date();\n+\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {\n+                List<Pool> pools = this.getEntityManager()\n+                    .createQuery(query)\n+                    .setMaxResults(blockCount)\n+                    .setFirstResult(offset)\n+                    .setMaxResults(blockSize)", "originalCommit": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1Mzg4MQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r514053881", "bodyText": "Not needed anymore.", "author": "wolfdale", "createdAt": "2020-10-29T07:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ4NDA1NA=="}], "type": "inlineReview", "revised_code": {"commit": "17c419cdaf4f8f456aaaf16732eecde57a792f2a", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex 2917b89ce..deb634347 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2010,113 +2009,156 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches the product content of all products (including provided & derived provided\n-     * products) associated with active pool.\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n      *\n-     * @param ownerId\n-     *  Owner Id\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n      *\n      * @return\n-     *  A Set of product content associated with active pool.\n+     *  A mapping of pool IDs to provided product UUIDs\n      */\n-    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n-        Set<ProductContent> productsContent = new HashSet<>();\n-        Date currentDate = new Date();\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n \n-        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n-        int blockSize = getBatchBlockSize();\n-        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+        if (poolIds == null || poolIds.isEmpty()) {\n+            return providedProductMap;\n+        }\n \n-        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n-        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n-        Root<Pool> pool = query.from(Pool.class);\n-        query.select(pool);\n-        List<Predicate> predicates = new ArrayList<>();\n-        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n-        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n-        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n-        Predicate[] predicateArray = new Predicate[predicates.size()];\n-        query.where(predicates.toArray(predicateArray));\n-        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n-        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n-        query.orderBy(orderList);\n-        int offset = 0;\n-\n-        if (blockCount > 1) {\n-            while (blockCount > 0) {\n-                List<Pool> pools = this.getEntityManager()\n-                    .createQuery(query)\n-                    .setMaxResults(blockCount)\n-                    .setFirstResult(offset)\n-                    .setMaxResults(blockSize)\n-                    .getResultList();\n-\n-                for (Pool p : pools) {\n-                    productsContent.addAll(p.getProduct().getProductContent());\n-\n-                    if (p.getDerivedProduct() != null) {\n-                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n-                    }\n+        StringBuilder builder =\n+            new StringBuilder(\" SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE \");\n \n-                    for (Product product : p.getProvidedProducts()) {\n-                        productsContent.addAll(product.getProductContent());\n-                    }\n+        javax.persistence.Query query = null;\n \n-                    for (Product product : p.getDerivedProvidedProducts()) {\n-                        productsContent.addAll(product.getProductContent());\n-                    }\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            builder.append(\" p.id IN (:pids)\");\n+            query = this.getEntityManager().createQuery(builder.toString())\n+                .setParameter(\"pids\", block);\n \n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n                 }\n \n-                offset += blockSize;\n-                blockCount--;\n+                providedProducts.add((String) cols[1]);\n             }\n         }\n-        else {\n-            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n-            for (Pool p : pools) {\n-                productsContent.addAll(p.getProduct().getProductContent());\n \n-                if (p.getDerivedProduct() != null) {\n-                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n-                }\n+        return providedProductMap;\n+    }\n \n-                for (Product product : p.getProvidedProducts()) {\n-                    productsContent.addAll(product.getProductContent());\n-                }\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the derived provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch derived provided product UUIDs\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getDerivedProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds == null || poolIds.isEmpty()) {\n+            return providedProductMap;\n+        }\n+\n+        StringBuilder builder =\n+            new StringBuilder(\" SELECT p.id, dpp.uuid FROM Pool p JOIN p.derivedProvidedProducts dpp \" +\n+            \" WHERE \");\n+\n+        javax.persistence.Query query = null;\n+\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            builder.append(\" p.id IN (:pids)\");\n+            query = this.getEntityManager().createQuery(builder.toString())\n+                .setParameter(\"pids\", block);\n \n-                for (Product product : p.getDerivedProvidedProducts()) {\n-                    productsContent.addAll(product.getProductContent());\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n                 }\n+\n+                providedProducts.add((String) cols[1]);\n             }\n         }\n \n-        return productsContent;\n+        return providedProductMap;\n     }\n \n     /**\n-     * Returns the count of active pool for an owner.\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n      *\n      * @param ownerId\n-     *  Id of an owner.\n+     *  The ID of the owner for which to fetch active Pool IDs\n      *\n      * @return\n-     *  Number of active pool for an owner.\n+     *  A collection of active Pool IDs belonging to the given owner.\n      */\n-    public Long getActivePoolCountByOwnerId(String ownerId) {\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n         Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()\n+            .createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"endDate\", currentDate)\n+            .setParameter(\"startDate\", currentDate)\n+            .getResultList();\n+\n+        return uuids != null ? uuids : Collections.<String>emptyList();\n+    }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch product & derived product UUID.\n+     *\n+     * @return\n+     *  A mapping of pool IDs to product & derived product UUID\n+     */\n+    public Map<String, Set<String>> getProductAndDerivedProductByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> productMap = new HashMap<>();\n+\n+        if (poolIds == null && poolIds.isEmpty()) {\n+            return productMap;\n+        }\n+\n         CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n-        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n-        Root<Pool> pool = query.from(Pool.class);\n-        query.select(criteriaBuilder.count(pool));\n-\n-        List<Predicate> predicates = new ArrayList<>();\n-        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n-        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n-        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n-        Predicate[] predicateArray = new Predicate[predicates.size()];\n-        query.where(predicates.toArray(predicateArray));\n-\n-        return this.getEntityManager().createQuery(query).getSingleResult();\n+        CriteriaQuery<Pool> criteriaQuery = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> poolRoot = criteriaQuery.from(Pool.class);\n+\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            criteriaQuery.select(poolRoot).where(poolRoot.get(\"id\").in(block));\n+            List<Pool> pools = this.getEntityManager().createQuery(criteriaQuery).getResultList();\n+\n+            for (Pool p : pools) {\n+                Set<String> products = new HashSet<>();\n+                products.add(p.getProduct().getUuid());\n+\n+                if (p.getDerivedProduct() != null) {\n+                    products.add(p.getDerivedProduct().getUuid());\n+                }\n+\n+                productMap.put(p.getId(), products);\n+            }\n+\n+        }\n+\n+        return productMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r502503929", "bodyText": "The blocking here probably isn't critical in our general case, but it also doesn't hurt anything.\nHowever, the code goes out of its way to have special handling for the 1 block case, when that's unnecessary -- even with only a single block, setting the max results and first result in the query won't change the performance of the query enough to justify having separate branches for each case.\nAdditionally, the block count bit is largely unnecessary. Once you have the element count, block size, and keep track of the offset, the counting of blocks becomes extraneous -- just check that your offset is lower than your element count. Even without the element count, you can achieve the same level of performance by just querying until you get a batch that has zero elements.\nThat said, fetching the element count is basically the same query here except without returning the pool information -- the DB work is effectively the same. Moreover, the collection processing below runs into not one, but two n+1 problems of doing a ton of extra queries to fetch the product and content collections. I would bet this is overall slower than just fetching all of the \"active\" pool IDs, then using those to get the related product UUIDs, and then using that to get the content objects. You'd get the whole thing done in three queries, rather than the 2n^p+b+1 queries we have here.", "author": "Ceiu", "createdAt": "2020-10-09T15:20:16Z", "path": "server/src/main/java/org/candlepin/model/PoolCurator.java", "diffHunk": "@@ -2006,4 +2008,115 @@ public void clearPoolSourceEntitlementRefs(Iterable<String> poolIds) {\n \n         return output;\n     }\n+\n+    /**\n+     * Fetches the product content of all products (including provided & derived provided\n+     * products) associated with active pool.\n+     *\n+     * @param ownerId\n+     *  Owner Id\n+     *\n+     * @return\n+     *  A Set of product content associated with active pool.\n+     */\n+    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n+        Set<ProductContent> productsContent = new HashSet<>();\n+        Date currentDate = new Date();\n+\n+        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n+        int blockSize = getBatchBlockSize();\n+        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+\n+        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n+        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> pool = query.from(Pool.class);\n+        query.select(pool);\n+        List<Predicate> predicates = new ArrayList<>();\n+        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n+        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n+        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n+        Predicate[] predicateArray = new Predicate[predicates.size()];\n+        query.where(predicates.toArray(predicateArray));\n+        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n+        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n+        query.orderBy(orderList);\n+        int offset = 0;\n+\n+        if (blockCount > 1) {\n+            while (blockCount > 0) {", "originalCommit": "7c5f7762cd132b1e59bd51a75169b7e9afe544b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIyMjkxMg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r503222912", "bodyText": "Yes it is slower, firing extra queries under the hood to fetch product & contents, this is what I was afraid of hence I chose to execute queries to get Product UUIDs.\n\nIf the goal here is to fetch products for active pools, we should do exactly that: fetch active pools and then pull the products from them in code.\n\nFrom your previous comment I thought you meant to get the products (and content) of active pool right from the code.\nMaybe we can go back to previous approach of having direct queries to fetch all associated products UUIDs of active pools and then fetch the product's content. What are your thoughts on that ? Also do we care if fetch these UUIDs in batch or not ?", "author": "wolfdale", "createdAt": "2020-10-12T11:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0MzcxOA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r507743718", "bodyText": "Sorry, Github isn't showing me the old code, so I'm going from memory here...\nAnyway, IIRC, the old code did pool iteration as a one-off in the method itself, so my assumption was that it would be augmented to simply pull the objects off it there and we'd drop the custom SQL builder code derived from a deprecated method that had a very dangerous oversight in it. My overall stance is that if we're going to add a method to do this operation at the curator level, it's something that should be generalized and as efficient as reasonably possible since it will be available to the rest of the code base at that point, and we might attempt to use it elsewhere in the future.\nOnce we are working at the curator level, the three queries I mentioned above can be used to fetch the information quicker than object iteration, and with minimal fetching of DB data. One of them will require raw SQL, but we should avoid constructing SQL statements via string concatenation without careful consideration of all the problems that introduces.\nRegarding the batching question, there are two cases we want to do requests in batches:\n\nif the number of input parameters would exceed the limits of either an IN operator or the overall query parameter limit (this is the most common scenario)\noptimizing lookups when fetching lazy collections off of certain entities (rare thus far in Candlepin)\n\nI believe in this case, once we move the operation to the curator level, we will need to batch each query due to the nature of the operation (N pools, M products, O content). The easiest way to do this is with the partition method provided by AbstractHibernateCurator, or you can use the partitioning functionality directly. There are other ways to batch, but I would recommend them only in specific cases where your data store(s) or operations don't lend themselves nicely to the partitioning functionality.\nHope that helps, and my apologies for seemingly going back and forth here.", "author": "Ceiu", "createdAt": "2020-10-19T13:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NDI1NQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r514054255", "bodyText": "Changes made to cut back the complex batching logic & to simplify the SQL queries with JPA criteria queries. I broke the steps into multiple parts of pulling the active PoolIDs, then product & derived product UUIDs, provided product UUIDs and finally derived provided product UUIDs. In between these queries we process for product content so that we can avoid holding everything in-memory.", "author": "wolfdale", "createdAt": "2020-10-29T07:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMzkyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "17c419cdaf4f8f456aaaf16732eecde57a792f2a", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/PoolCurator.java b/server/src/main/java/org/candlepin/model/PoolCurator.java\nindex 2917b89ce..deb634347 100644\n--- a/server/src/main/java/org/candlepin/model/PoolCurator.java\n+++ b/server/src/main/java/org/candlepin/model/PoolCurator.java\n\n@@ -2010,113 +2009,156 @@ public class PoolCurator extends AbstractHibernateCurator<Pool> {\n     }\n \n     /**\n-     * Fetches the product content of all products (including provided & derived provided\n-     * products) associated with active pool.\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n      *\n-     * @param ownerId\n-     *  Owner Id\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch provided product UUIDS\n      *\n      * @return\n-     *  A Set of product content associated with active pool.\n+     *  A mapping of pool IDs to provided product UUIDs\n      */\n-    public Set<ProductContent> getProductContentOfActivePoolsByOwnerId(String ownerId) {\n-        Set<ProductContent> productsContent = new HashSet<>();\n-        Date currentDate = new Date();\n+    public Map<String, Set<String>> getProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n \n-        long activePoolCount = this.getActivePoolCountByOwnerId(ownerId);\n-        int blockSize = getBatchBlockSize();\n-        int blockCount = (int) Math.ceil(activePoolCount / (float) blockSize);\n+        if (poolIds == null || poolIds.isEmpty()) {\n+            return providedProductMap;\n+        }\n \n-        CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n-        CriteriaQuery<Pool> query = criteriaBuilder.createQuery(Pool.class);\n-        Root<Pool> pool = query.from(Pool.class);\n-        query.select(pool);\n-        List<Predicate> predicates = new ArrayList<>();\n-        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n-        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n-        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n-        Predicate[] predicateArray = new Predicate[predicates.size()];\n-        query.where(predicates.toArray(predicateArray));\n-        List<javax.persistence.criteria.Order> orderList = new ArrayList();\n-        orderList.add(criteriaBuilder.desc(pool.get(\"startDate\")));\n-        query.orderBy(orderList);\n-        int offset = 0;\n-\n-        if (blockCount > 1) {\n-            while (blockCount > 0) {\n-                List<Pool> pools = this.getEntityManager()\n-                    .createQuery(query)\n-                    .setMaxResults(blockCount)\n-                    .setFirstResult(offset)\n-                    .setMaxResults(blockSize)\n-                    .getResultList();\n-\n-                for (Pool p : pools) {\n-                    productsContent.addAll(p.getProduct().getProductContent());\n-\n-                    if (p.getDerivedProduct() != null) {\n-                        productsContent.addAll(p.getDerivedProduct().getProductContent());\n-                    }\n+        StringBuilder builder =\n+            new StringBuilder(\" SELECT p.id, pp.uuid FROM Pool p JOIN p.providedProducts pp WHERE \");\n \n-                    for (Product product : p.getProvidedProducts()) {\n-                        productsContent.addAll(product.getProductContent());\n-                    }\n+        javax.persistence.Query query = null;\n \n-                    for (Product product : p.getDerivedProvidedProducts()) {\n-                        productsContent.addAll(product.getProductContent());\n-                    }\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            builder.append(\" p.id IN (:pids)\");\n+            query = this.getEntityManager().createQuery(builder.toString())\n+                .setParameter(\"pids\", block);\n \n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n                 }\n \n-                offset += blockSize;\n-                blockCount--;\n+                providedProducts.add((String) cols[1]);\n             }\n         }\n-        else {\n-            List<Pool> pools = this.getEntityManager().createQuery(query).getResultList();\n-            for (Pool p : pools) {\n-                productsContent.addAll(p.getProduct().getProductContent());\n \n-                if (p.getDerivedProduct() != null) {\n-                    productsContent.addAll(p.getDerivedProduct().getProductContent());\n-                }\n+        return providedProductMap;\n+    }\n \n-                for (Product product : p.getProvidedProducts()) {\n-                    productsContent.addAll(product.getProductContent());\n-                }\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUIDs representing the derived provided products of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch derived provided product UUIDs\n+     *\n+     * @return\n+     *  A mapping of pool IDs to provided product UUIDs\n+     */\n+    public Map<String, Set<String>> getDerivedProvidedProductUuidsByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> providedProductMap = new HashMap<>();\n+\n+        if (poolIds == null || poolIds.isEmpty()) {\n+            return providedProductMap;\n+        }\n+\n+        StringBuilder builder =\n+            new StringBuilder(\" SELECT p.id, dpp.uuid FROM Pool p JOIN p.derivedProvidedProducts dpp \" +\n+            \" WHERE \");\n+\n+        javax.persistence.Query query = null;\n+\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            builder.append(\" p.id IN (:pids)\");\n+            query = this.getEntityManager().createQuery(builder.toString())\n+                .setParameter(\"pids\", block);\n \n-                for (Product product : p.getDerivedProvidedProducts()) {\n-                    productsContent.addAll(product.getProductContent());\n+            for (Object[] cols : (List<Object[]>) query.getResultList()) {\n+                Set<String> providedProducts = providedProductMap.get((String) cols[0]);\n+\n+                if (providedProducts == null) {\n+                    providedProducts = new HashSet<>();\n+                    providedProductMap.put((String) cols[0], providedProducts);\n                 }\n+\n+                providedProducts.add((String) cols[1]);\n             }\n         }\n \n-        return productsContent;\n+        return providedProductMap;\n     }\n \n     /**\n-     * Returns the count of active pool for an owner.\n+     * Fetches a collection of active pool IDs mapped to a given owner. If no such pool\n+     * are present, an empty collection will be returned.\n      *\n      * @param ownerId\n-     *  Id of an owner.\n+     *  The ID of the owner for which to fetch active Pool IDs\n      *\n      * @return\n-     *  Number of active pool for an owner.\n+     *  A collection of active Pool IDs belonging to the given owner.\n      */\n-    public Long getActivePoolCountByOwnerId(String ownerId) {\n+    public Collection<String> getActivePoolByOwnerId(String ownerId) {\n         Date currentDate = new Date();\n+        String jpql = \"SELECT p.id FROM Pool p WHERE p.owner.id = \" +\n+            \" :owner_id AND p.endDate >= :endDate AND p.startDate <= :startDate\";\n+\n+        List<String> uuids = this.getEntityManager()\n+            .createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"endDate\", currentDate)\n+            .setParameter(\"startDate\", currentDate)\n+            .getResultList();\n+\n+        return uuids != null ? uuids : Collections.<String>emptyList();\n+    }\n+\n+    /**\n+     * Fetches a mapping of pool IDs to sets of product UUID & derived product UUID of\n+     * the given pool. The returned map will only contain mappings for pools specified in the given\n+     * collection of pool IDs.\n+     *\n+     * @param poolIds\n+     *  A collection of pool IDs for which to fetch product & derived product UUID.\n+     *\n+     * @return\n+     *  A mapping of pool IDs to product & derived product UUID\n+     */\n+    public Map<String, Set<String>> getProductAndDerivedProductByPoolIds(Collection<String> poolIds) {\n+        Map<String, Set<String>> productMap = new HashMap<>();\n+\n+        if (poolIds == null && poolIds.isEmpty()) {\n+            return productMap;\n+        }\n+\n         CriteriaBuilder criteriaBuilder = this.getEntityManager().getCriteriaBuilder();\n-        CriteriaQuery<Long> query = criteriaBuilder.createQuery(Long.class);\n-        Root<Pool> pool = query.from(Pool.class);\n-        query.select(criteriaBuilder.count(pool));\n-\n-        List<Predicate> predicates = new ArrayList<>();\n-        predicates.add(criteriaBuilder.equal(pool.get(\"owner\").get(\"id\"), ownerId));\n-        predicates.add(criteriaBuilder.greaterThanOrEqualTo(pool.get(\"endDate\"), currentDate));\n-        predicates.add(criteriaBuilder.lessThanOrEqualTo(pool.get(\"startDate\"), currentDate));\n-        Predicate[] predicateArray = new Predicate[predicates.size()];\n-        query.where(predicates.toArray(predicateArray));\n-\n-        return this.getEntityManager().createQuery(query).getSingleResult();\n+        CriteriaQuery<Pool> criteriaQuery = criteriaBuilder.createQuery(Pool.class);\n+        Root<Pool> poolRoot = criteriaQuery.from(Pool.class);\n+\n+        for (Collection<String> block : this.partition(poolIds)) {\n+            criteriaQuery.select(poolRoot).where(poolRoot.get(\"id\").in(block));\n+            List<Pool> pools = this.getEntityManager().createQuery(criteriaQuery).getResultList();\n+\n+            for (Pool p : pools) {\n+                Set<String> products = new HashSet<>();\n+                products.add(p.getProduct().getUuid());\n+\n+                if (p.getDerivedProduct() != null) {\n+                    products.add(p.getDerivedProduct().getUuid());\n+                }\n+\n+                productMap.put(p.getId(), products);\n+            }\n+\n+        }\n+\n+        return productMap;\n     }\n }\n"}}, {"oid": "17c419cdaf4f8f456aaaf16732eecde57a792f2a", "url": "https://github.com/candlepin/candlepin/commit/17c419cdaf4f8f456aaaf16732eecde57a792f2a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-28T11:28:38Z", "type": "forcePushed"}, {"oid": "eced13855f2bc10749ee6a07daf50cdc546a229f", "url": "https://github.com/candlepin/candlepin/commit/eced13855f2bc10749ee6a07daf50cdc546a229f", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-29T07:32:36Z", "type": "forcePushed"}, {"oid": "d91cbb7efbc18b2001112d2fdb6688f174c833e2", "url": "https://github.com/candlepin/candlepin/commit/d91cbb7efbc18b2001112d2fdb6688f174c833e2", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-29T08:20:23Z", "type": "forcePushed"}, {"oid": "d743b82aadc7cff2a4c27694d2023e144cb28f45", "url": "https://github.com/candlepin/candlepin/commit/d743b82aadc7cff2a4c27694d2023e144cb28f45", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-30T08:46:44Z", "type": "forcePushed"}, {"oid": "757f391be364206a7650b3b12d6748fd9daa8456", "url": "https://github.com/candlepin/candlepin/commit/757f391be364206a7650b3b12d6748fd9daa8456", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-10-30T08:53:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNzg2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515307862", "bodyText": "I realize looking at this now there's a bug with how this query is partitioned. We need to use the minimum value between the in block limit or one fourth of the query parameter limit, since we'll be passing the block in four times. As it is now, if we happen to have a block of pools right at the in-block limit, we'll run clear over the overall parameter limit and crash out all the same.", "author": "Ceiu", "createdAt": "2020-10-30T18:44:21Z", "path": "server/src/main/java/org/candlepin/model/OwnerContentCurator.java", "diffHunk": "@@ -548,4 +554,60 @@ public void removeOwnerContentReferences(Owner owner, Collection<String> content\n         }\n     }\n \n+    /**\n+     * Fetches all the product content for active pools by owner Id.\n+     *\n+     * @param ownerId\n+     *  Id of an owner\n+     *\n+     * @return\n+     *  Set of product content.\n+     */\n+    public Set<ProductContent> getProductContentsOfActivePoolByOwner(String ownerId) {\n+        EntityManager entityManager = this.getEntityManager();\n+        Date now = new Date();\n+\n+        // Get all the active pools\n+\n+        String jpql = \"SELECT p.id FROM Pool p \" +\n+            \"WHERE p.owner.id = :owner_id AND p.startDate <= :start_date AND p.endDate >= :end_date\";\n+\n+        List<String> poolIds = entityManager.createQuery(jpql, String.class)\n+            .setParameter(\"owner_id\", ownerId)\n+            .setParameter(\"start_date\", now)\n+            .setParameter(\"end_date\", now)\n+            .getResultList();\n+\n+        // Use the pool IDs to select all related product UUIDs\n+        // Note: we have to start partitioning now to safely handle any number of active pools\n+\n+        String sql = \"SELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (:pool_ids) \" +\n+            \"UNION \" +\n+            \"SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (:pool_ids) \";\n+\n+        Query prodQuery = entityManager.createNativeQuery(sql);\n+        Set<String> prodIds = new HashSet<>();\n+\n+        for (List<String> block : this.partition(poolIds)) {", "originalCommit": "757f391be364206a7650b3b12d6748fd9daa8456", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNDQ1OQ==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515834459", "bodyText": "This is superb fix. I was not aware of this.\nint blockSize = Math.min(this.getInBlockSize(), this.getQueryParameterLimit() / 4);", "author": "wolfdale", "createdAt": "2020-11-02T09:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNzg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "chunk": "diff --git a/server/src/main/java/org/candlepin/model/OwnerContentCurator.java b/server/src/main/java/org/candlepin/model/OwnerContentCurator.java\nindex c1dd67320..4ca6b4bb2 100644\n--- a/server/src/main/java/org/candlepin/model/OwnerContentCurator.java\n+++ b/server/src/main/java/org/candlepin/model/OwnerContentCurator.java\n\n@@ -555,20 +555,23 @@ public class OwnerContentCurator extends AbstractHibernateCurator<OwnerContent>\n     }\n \n     /**\n-     * Fetches all the product content for active pools by owner Id.\n+     * Returns a mapping of content and content enabled flag.\n+     *\n+     * Note - If same content (say C1) is being enabled/disabled by two or more products, with at least\n+     * one of the product enabling the content C1 then, content (C1) with enabled (true)\n+     * state will have precedence.\n      *\n      * @param ownerId\n      *  Id of an owner\n      *\n      * @return\n-     *  Set of product content.\n+     *  Returns a mapping of content and content enabled flag.\n      */\n-    public Set<ProductContent> getProductContentsOfActivePoolByOwner(String ownerId) {\n+    public Map<Content, Boolean> getActiveContentByOwner(String ownerId) {\n         EntityManager entityManager = this.getEntityManager();\n         Date now = new Date();\n \n         // Get all the active pools\n-\n         String jpql = \"SELECT p.id FROM Pool p \" +\n             \"WHERE p.owner.id = :owner_id AND p.startDate <= :start_date AND p.endDate >= :end_date\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDczMA==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515324730", "bodyText": "Ah ha. I remember this discussion now.\nSo we need to include all \"active\" content for a given org, but we need to flag it as enabled properly, resolving any conflicts to enabled.\nThat complicates things a bit, but is something we can still solve efficiently.\nSince ProductContent is a join object, we don't want to fetch it directly if we can help it -- especially since the object we actually care about is the Content instance, which we have to fetch even if we try to use the ProductContent mutators of Product directly. Using ProductContent like this results in another N+1 issue, where examining the content field results in another query. Running the spec test for this method, for instance, results in the following queries:\nselect pool0_.id as col_0_0_ from cp_pool pool0_ where pool0_.owner_id=? and pool0_.startDate<=? and pool0_.endDate>=?\n\nSELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (?, ?) UNION SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (?, ?) \n\nselect productcon0_.id as id1_12_, productcon0_.created as created2_12_, productcon0_.updated as updated3_12_, productcon0_.content_uuid as content_5_12_, productcon0_.enabled as enabled4_12_, productcon0_.product_uuid as product_6_12_ from cp2_product_content productcon0_ where productcon0_.product_uuid in (? , ? , ?)\n\nselect content0_.uuid as uuid1_1_0_, content0_.created as created2_1_0_, content0_.updated as updated3_1_0_, content0_.arches as arches4_1_0_, content0_.contentUrl as contentU5_1_0_, content0_.entity_version as entity_v6_1_0_, content0_.gpgUrl as gpgUrl7_1_0_, content0_.content_id as content_8_1_0_, content0_.label as label9_1_0_, content0_.locked as locked10_1_0_, content0_.metadataExpire as metadat11_1_0_, content0_.name as name12_1_0_, content0_.releaseVer as release13_1_0_, content0_.requiredTags as require14_1_0_, content0_.type as type15_1_0_, content0_.vendor as vendor16_1_0_ from cp2_content content0_ where content0_.uuid=?\n\nselect content0_.uuid as uuid1_1_0_, content0_.created as created2_1_0_, content0_.updated as updated3_1_0_, content0_.arches as arches4_1_0_, content0_.contentUrl as contentU5_1_0_, content0_.entity_version as entity_v6_1_0_, content0_.gpgUrl as gpgUrl7_1_0_, content0_.content_id as content_8_1_0_, content0_.label as label9_1_0_, content0_.locked as locked10_1_0_, content0_.metadataExpire as metadat11_1_0_, content0_.name as name12_1_0_, content0_.releaseVer as release13_1_0_, content0_.requiredTags as require14_1_0_, content0_.type as type15_1_0_, content0_.vendor as vendor16_1_0_ from cp2_content content0_ where content0_.uuid=?\n\nNote the two content queries at the end -- that's invoked once for each ProductContent fetched by the getProductContentsOfActivePoolsByOwner* method when getContent is invoked. Side note: that method name is a bit wordy -- getActiveProductContentByOwner would suffice, and even that's a tad long due to specifying the return type in the method name.\nSo, that means we need to solve this in the curator method.\nMy first thought was to use a DISTINCT with ORDER BY on the enabled field in ascending order, and then collect the content objects in order. This would put all the enabled content at the end, and would overwrite any disabled entries with an enabled one:\njpql = \"SELECT DISTINCT pc.content, pc.enabled FROM ProductContent pc WHERE pc.product.uuid IN (:product_uuids) ORDER BY pc.enabled ASC\";\n\nThis would work perfectly if it wasn't for one small hiccup: since we're partitioning, we have to assume we'll be running this query at least twice; and if we're running it twice, our order is no longer guaranteed between queries, and we run the risk of clobbering our \"enabled\" entries from the end of previous query with \"disabled\" entries in the next. We can work around this with some logic similar to what is outlined in the method this comment hangs on, but at that point, the ordering does literally nothing for us -- so we can omit it entirely.\n    // OwnerContentCurator.java\n    public Map<Content, Boolean> getActiveContentByOwner(String ownerId) {\n        EntityManager entityManager = this.getEntityManager();\n        Date now = new Date();\n\n        // Get all the active pools\n\n        String jpql = \"SELECT p.id FROM Pool p \" +\n            \"WHERE p.owner.id = :owner_id AND p.startDate <= :start_date AND p.endDate >= :end_date\";\n\n        List<String> poolIds = entityManager.createQuery(jpql, String.class)\n            .setParameter(\"owner_id\", ownerId)\n            .setParameter(\"start_date\", now)\n            .setParameter(\"end_date\", now)\n            .getResultList();\n\n        // Use the pool IDs to select all related product UUIDs\n        // Note: we have to start partitioning now to safely handle any number of active pools\n\n        String sql = \"SELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (:pool_ids) \" +\n            \"UNION \" +\n            \"SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (:pool_ids) \";\n\n        Query prodQuery = entityManager.createNativeQuery(sql);\n        Set<String> prodIds = new HashSet<>();\n\n        int blockSize = Math.min(this.getInBlockSize(), this.getQueryParameterLimit() / 4);\n\n        for (List<String> block : Iterables.partition(poolIds, blockSize)) {\n            prodIds.addAll(prodQuery.setParameter(\"pool_ids\", block).getResultList());\n        }\n\n        // Use the product UUIDs to select all related enabled content\n        jpql = \"SELECT DISTINCT pc.content, pc.enabled FROM ProductContent pc \" +\n            \"WHERE pc.product.uuid IN (:product_uuids)\";\n\n        Query contentQuery = entityManager.createQuery(jpql);\n\n        HashMap<Content, Boolean> activeContent = new HashMap<>();\n\n        for (List<String> block : this.partition(prodIds)) {\n            contentQuery.setParameter(\"product_uuids\", block)\n                .getResultList()\n                .forEach(col -> {\n                    Content content = (Content) ((Object[]) col)[0];\n                    Boolean enabled = (Boolean) ((Object[]) col)[1];\n\n                    activeContent.merge(content, enabled, (v1, v2) ->\n                        v1 != null && v1.booleanValue() ? v1 : v2);\n                });\n        }\n\n        return activeContent;\n    }\n\n    ...\n\n    // ContentAccessManager.java\n    this.ownerContentCurator.getActiveContentByOwner(owner.getId())\n        .forEach((content, enabled) -> container.addContent(content, enabled));\n\n\nThis avoids the N+1 problem entirely, as we can verify by checking the output during the same spec test:\nselect pool0_.id as col_0_0_ from cp_pool pool0_ where pool0_.owner_id=? and pool0_.startDate<=? and pool0_.endDate>=?\n\nSELECT pool.product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pool.derived_product_uuid FROM cp_pool pool WHERE pool.id IN (?, ?) UNION SELECT pp.product_uuid FROM cp2_pool_provided_products pp WHERE pp.pool_id IN (?, ?) UNION SELECT dpp.product_uuid FROM cp2_pool_derprov_products dpp WHERE dpp.pool_id IN (?, ?) \n\nselect distinct productcon0_.content_uuid as col_0_0_, productcon0_.enabled as col_1_0_, content1_.uuid as uuid1_1_, content1_.created as created2_1_, content1_.updated as updated3_1_, content1_.arches as arches4_1_, content1_.contentUrl as contentU5_1_, content1_.entity_version as entity_v6_1_, content1_.gpgUrl as gpgUrl7_1_, content1_.content_id as content_8_1_, content1_.label as label9_1_, content1_.locked as locked10_1_, content1_.metadataExpire as metadat11_1_, content1_.name as name12_1_, content1_.releaseVer as release13_1_, content1_.requiredTags as require14_1_, content1_.type as type15_1_, content1_.vendor as vendor16_1_ from cp2_product_content productcon0_ inner join cp2_content content1_ on productcon0_.content_uuid=content1_.uuid where productcon0_.product_uuid in (? , ? , ?)\n\nNote that this also keeps the logic for this problem in one place.", "author": "Ceiu", "createdAt": "2020-10-30T19:21:07Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -559,6 +543,32 @@ else if (pc.isEnabled() && !contentEnabledMap.get(pc.getContent().getUuid())) {\n             emptyConsumer, emptyPool, null);\n     }\n \n+    /**\n+     * To process product content and added it to container product.\n+     *\n+     * @param container\n+     *  Product container\n+     *\n+     * @param ownerId\n+     *  Id of an owner\n+     *\n+     */\n+    private void processOwnerContent(Product container, String ownerId) {", "originalCommit": "757f391be364206a7650b3b12d6748fd9daa8456", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNDU3Mg==", "url": "https://github.com/candlepin/candlepin/pull/2799#discussion_r515834572", "bodyText": "This look very good and efficient. This certainty avoids the N+1 problem.\nthank for help me out with this.", "author": "wolfdale", "createdAt": "2020-11-02T09:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDczMA=="}], "type": "inlineReview", "revised_code": {"commit": "43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "chunk": "diff --git a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\nindex 94d2589e2..2ec3fc1ae 100644\n--- a/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n+++ b/server/src/main/java/org/candlepin/controller/ContentAccessManager.java\n\n@@ -542,33 +543,6 @@ public class ContentAccessManager {\n         return v3extensionUtil.createEntitlementDataPayload(productModels,\n             emptyConsumer, emptyPool, null);\n     }\n-\n-    /**\n-     * To process product content and added it to container product.\n-     *\n-     * @param container\n-     *  Product container\n-     *\n-     * @param ownerId\n-     *  Id of an owner\n-     *\n-     */\n-    private void processOwnerContent(Product container, String ownerId) {\n-        Map<String, Boolean> contentEnabledMap = new HashMap<>();\n-\n-        for (ProductContent pc : ownerContentCurator.getProductContentsOfActivePoolByOwner(ownerId)) {\n-            if (!contentEnabledMap.containsKey(pc.getContent().getUuid())) {\n-                container.addContent(pc.getContent(), pc.isEnabled());\n-                contentEnabledMap.put(pc.getContent().getUuid(), pc.isEnabled());\n-            }\n-            else if (pc.isEnabled() && !contentEnabledMap.get(pc.getContent().getUuid())) {\n-                // Overwrite the content\n-                container.addContent(pc.getContent(), pc.isEnabled());\n-                contentEnabledMap.put(pc.getContent().getUuid(), pc.isEnabled());\n-            }\n-        }\n-    }\n-\n     public boolean hasCertChangedSince(Consumer consumer, Date date) {\n         if (date == null) {\n             return true;\n"}}, {"oid": "43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "url": "https://github.com/candlepin/candlepin/commit/43e9e0a2f4d8f01630fbf6b28567a6738bc311a8", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T09:19:18Z", "type": "forcePushed"}, {"oid": "0ddf504bee894971cacdf1eedfdbdbc4cdd97951", "url": "https://github.com/candlepin/candlepin/commit/0ddf504bee894971cacdf1eedfdbdbc4cdd97951", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T10:37:31Z", "type": "forcePushed"}, {"oid": "d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "url": "https://github.com/candlepin/candlepin/commit/d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T11:24:45Z", "type": "commit"}, {"oid": "d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "url": "https://github.com/candlepin/candlepin/commit/d2951ebb1b4f3d9bac4cd13575004e42c625a35a", "message": "ENT-2806: Only add content from active pools on the SCA certificate", "committedDate": "2020-11-02T11:24:45Z", "type": "forcePushed"}]}