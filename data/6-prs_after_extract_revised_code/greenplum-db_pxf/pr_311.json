{"pr_number": 311, "pr_title": "JDBC: Validate batchsize only on write", "pr_createdAt": "2020-03-04T17:41:46Z", "pr_url": "https://github.com/greenplum-db/pxf/pull/311", "timeline": [{"oid": "551c363873a62443d95b2680e49c49c15513f191", "url": "https://github.com/greenplum-db/pxf/commit/551c363873a62443d95b2680e49c49c15513f191", "message": "JDBC: Validate batchsize only on write\n\nThis property is only needed for the write case.\n\nAuthored-by: Oliver Albertini <oalbertini@pivotal.io>", "committedDate": "2020-03-04T19:16:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390528533", "bodyText": "this file has formatting issues. Can you fix it before reviewing?", "author": "frankgh", "createdAt": "2020-03-10T18:35:29Z", "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "diffHunk": "@@ -1,582 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\r\n-\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.greenplum.pxf.api.model.BasePlugin;\r\n-import org.greenplum.pxf.api.model.RequestContext;\r\n-import org.greenplum.pxf.api.security.SecureLogin;\r\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\r\n-import org.greenplum.pxf.api.utilities.Utilities;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import java.security.PrivilegedExceptionAction;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.stream.Collectors;\r\n-\r\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\r\n-\r\n-/**\r\n- * JDBC tables plugin (base class)\r\n- * <p>\r\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\r\n- */\r\n-public class JdbcBasePlugin extends BasePlugin {\r\n-\r\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\r\n-\r\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\r\n-    private static final int DEFAULT_BATCH_SIZE = 100;\r\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\r\n-    private static final int DEFAULT_POOL_SIZE = 1;\r\n-\r\n-    // configuration parameter names\r\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\r\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\r\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\r\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\r\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\r\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\r\n-\r\n-    // connection parameter names\r\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\r\n-\r\n-    // statement properties\r\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\r\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\r\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\r\n-\r\n-    // connection pool properties\r\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\r\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\r\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\r\n-\r\n-    // DDL option names\r\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\r\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\r\n-\r\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\r\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\r\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\r\n-\r\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\r\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\r\n-\r\n-    private enum TransactionIsolation {\r\n-        READ_UNCOMMITTED(1),\r\n-        READ_COMMITTED(2),\r\n-        REPEATABLE_READ(4),\r\n-        SERIALIZABLE(8),\r\n-        NOT_PROVIDED(-1);\r\n-\r\n-        private int isolationLevel;\r\n-\r\n-        TransactionIsolation(int transactionIsolation) {\r\n-            isolationLevel = transactionIsolation;\r\n-        }\r\n-\r\n-        public int getLevel() {\r\n-            return isolationLevel;\r\n-        }\r\n-\r\n-        public static TransactionIsolation typeOf(String str) {\r\n-            return valueOf(str);\r\n-        }\r\n-    }\r\n-\r\n-    // JDBC parameters from config file or specified in DDL\r\n-\r\n-    private String jdbcUrl;\r\n-\r\n-    protected String tableName;\r\n-\r\n-    // Write batch size\r\n-    protected int batchSize;\r\n-    protected boolean batchSizeIsSetByUser = false;\r\n-\r\n-    // Read batch size\r\n-    protected int fetchSize;\r\n-\r\n-    // Thread pool size\r\n-    protected int poolSize;\r\n-\r\n-    // Query timeout.\r\n-    protected Integer queryTimeout;\r\n-\r\n-    // Quote columns setting set by user (three values are possible)\r\n-    protected Boolean quoteColumns = null;\r\n-\r\n-    // Environment variables to SET before query execution\r\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\r\n-\r\n-    // Properties object to pass to JDBC Driver when connection is created\r\n-    protected Properties connectionConfiguration = new Properties();\r\n-\r\n-    // Transaction isolation level that a user can configure\r\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\r\n-\r\n-    // Columns description\r\n-    protected List<ColumnDescriptor> columns = null;\r\n-\r\n-    // Name of query to execute for read flow (optional)\r\n-    protected String queryName;\r\n-\r\n-    // connection pool fields\r\n-    private boolean isConnectionPoolUsed;\r\n-    private Properties poolConfiguration;\r\n-    private String poolQualifier;\r\n-\r\n-    private ConnectionManager connectionManager;\r\n-\r\n-    static {\r\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\r\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\r\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\r\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\r\n-     */\r\n-    public JdbcBasePlugin() {\r\n-        this(ConnectionManager.getInstance());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with the given ConnectionManager.\r\n-     *\r\n-     * @param connectionManager connection manager instance\r\n-     */\r\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\r\n-        this.connectionManager = connectionManager;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize(RequestContext context) {\r\n-        super.initialize(context);\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\r\n-        try {\r\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\r\n-            Class.forName(jdbcDriver);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\r\n-\r\n-        // Required metadata\r\n-        String dataSource = context.getDataSource();\r\n-        if (StringUtils.isBlank(dataSource)) {\r\n-            throw new IllegalArgumentException(\"Data source must be provided\");\r\n-        }\r\n-\r\n-        // Determine if the datasource is a table name or a query name\r\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\r\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\r\n-            if (StringUtils.isBlank(queryName)) {\r\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\r\n-            }\r\n-            LOG.debug(\"Query name is {}\", queryName);\r\n-        } else {\r\n-            tableName = dataSource;\r\n-            LOG.debug(\"Table name is {}\", tableName);\r\n-        }\r\n-\r\n-        // Required metadata\r\n-        columns = context.getTupleDescription();\r\n-\r\n-        // Optional parameters\r\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\r\n-        batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\r\n-\r\n-        if (batchSize == 0) {\r\n-            batchSize = 1; // if user set to 0, it is the same as batchSize of 1\r\n-        } else if (batchSize < 0) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\r\n-        }\r\n-\r\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\r\n-\r\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\r\n-\r\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\r\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\r\n-            try {\r\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\r\n-            } catch (NumberFormatException e) {\r\n-                throw new IllegalArgumentException(String.format(\r\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\r\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\r\n-            }\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is null\r\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\r\n-        if (quoteColumnsRaw != null) {\r\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\r\n-        // Check forbidden symbols\r\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\r\n-        // However, SET queries cannot be executed this way. This is why we do this check\r\n-        if (sessionConfiguration.entrySet().stream()\r\n-                .anyMatch(\r\n-                        entry ->\r\n-                                StringUtils.containsAny(\r\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                ) ||\r\n-                                        StringUtils.containsAny(\r\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                        )\r\n-                )\r\n-        ) {\r\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\r\n-        }\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Session configuration: {}\",\r\n-                    sessionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\r\n-\r\n-        // Optional parameter. The default value depends on the database\r\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\r\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\r\n-\r\n-        // Set optional user parameter, taking into account impersonation setting for the server.\r\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\r\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\r\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\r\n-        if (impersonationEnabledForServer) {\r\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\r\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\r\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\r\n-                jdbcUrl = updatedJdbcUrl;\r\n-            } else {\r\n-                // the jdbcUser is the GPDB user\r\n-                jdbcUser = context.getUser();\r\n-            }\r\n-        }\r\n-        if (jdbcUser != null) {\r\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\r\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\r\n-        } else {\r\n-            LOG.debug(\"JDBC user has not been set\");\r\n-        }\r\n-\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Connection configuration: {}\",\r\n-                    connectionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\r\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\r\n-        if (jdbcUser != null) {\r\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\r\n-            if (jdbcPassword != null) {\r\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\r\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\r\n-            }\r\n-        }\r\n-\r\n-        // connection pool is optional, enabled by default\r\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\r\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\r\n-        if (isConnectionPoolUsed) {\r\n-            poolConfiguration = new Properties();\r\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\r\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\r\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\r\n-            // apply values read from the template\r\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\r\n-\r\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\r\n-            // connectionTestQuery parameter in this case, unless already set by the user\r\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\r\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\r\n-            }\r\n-\r\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\r\n-            // to switch effective user once connection is established\r\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Open a new JDBC connection\r\n-     *\r\n-     * @return {@link Connection}\r\n-     * @throws SQLException if a database access or connection error occurs\r\n-     */\r\n-    public Connection getConnection() throws SQLException {\r\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-        Connection connection = null;\r\n-        try {\r\n-            connection = getConnectionInternal();\r\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-            prepareConnection(connection);\r\n-        } catch (Exception e) {\r\n-            closeConnection(connection);\r\n-            if (e instanceof SQLException) {\r\n-                throw (SQLException) e;\r\n-            } else {\r\n-                String msg = e.getMessage();\r\n-                if (msg == null) {\r\n-                    Throwable t = e.getCause();\r\n-                    if (t != null) msg = t.getMessage();\r\n-                }\r\n-                throw new SQLException(msg, e);\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare a JDBC PreparedStatement\r\n-     *\r\n-     * @param connection connection to use for creating the statement\r\n-     * @param query      query to execute\r\n-     * @return PreparedStatement\r\n-     * @throws SQLException if a database access error occurs\r\n-     */\r\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\r\n-        if ((connection == null) || (query == null)) {\r\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\r\n-        }\r\n-        PreparedStatement statement = connection.prepareStatement(query);\r\n-        if (queryTimeout != null) {\r\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\r\n-            statement.setQueryTimeout(queryTimeout);\r\n-        }\r\n-        return statement;\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC statement and underlying {@link Connection}\r\n-     *\r\n-     * @param statement statement to close\r\n-     * @throws SQLException\r\n-     */\r\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\r\n-        if (statement == null) {\r\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\r\n-            return;\r\n-        }\r\n-\r\n-        SQLException exception = null;\r\n-        Connection connection = null;\r\n-\r\n-        try {\r\n-            connection = statement.getConnection();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            LOG.debug(\"Closing statement for connection {}\", connection);\r\n-            statement.close();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when closing Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            closeConnection(connection);\r\n-        } catch (SQLException e) {\r\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        if (exception != null) {\r\n-            throw exception;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     *\r\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     * @throws Exception\r\n-     */\r\n-    private Connection getConnectionInternal() throws Exception {\r\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\r\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\r\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\r\n-\r\n-        } else {\r\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC connection\r\n-     *\r\n-     * @param connection connection to close\r\n-     * @throws SQLException\r\n-     */\r\n-    private static void closeConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\r\n-            return;\r\n-        }\r\n-        try {\r\n-            if (!connection.isClosed() &&\r\n-                    connection.getMetaData().supportsTransactions() &&\r\n-                    !connection.getAutoCommit()) {\r\n-\r\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\r\n-                connection.commit();\r\n-            }\r\n-        } finally {\r\n-            try {\r\n-                LOG.debug(\"Closing connection {}\", connection);\r\n-                connection.close();\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare JDBC connection by setting session-level variables in external database\r\n-     *\r\n-     * @param connection {@link Connection} to prepare\r\n-     */\r\n-    private void prepareConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            throw new IllegalArgumentException(\"The provided connection is null\");\r\n-        }\r\n-\r\n-        DatabaseMetaData metadata = connection.getMetaData();\r\n-\r\n-        // Handle optional connection transaction isolation level\r\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\r\n-            // user wants to set isolation level explicitly\r\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\r\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\r\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\r\n-            } else {\r\n-                throw new RuntimeException(\r\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\r\n-                );\r\n-            }\r\n-        }\r\n-\r\n-        // Disable autocommit\r\n-        if (metadata.supportsTransactions()) {\r\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\r\n-            connection.setAutoCommit(false);\r\n-        }\r\n-\r\n-        // Prepare session (process sessionConfiguration)\r\n-        if (!sessionConfiguration.isEmpty()) {\r\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\r\n-\r\n-            try (Statement statement = connection.createStatement()) {\r\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\r\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\r\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\r\n-                    statement.execute(sessionQuery);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\r\n-     *\r\n-     * @param value      value to check\r\n-     * @param paramName  parameter name\r\n-     * @param optionName name of the option for a given parameter\r\n-     */\r\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\r\n-        if (StringUtils.isBlank(value)) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\r\n-            );\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\r\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\r\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\r\n-     * work with JDBC profile.\r\n-     *\r\n-     * @param configuration configuration map\r\n-     * @param confPrefix    configuration prefix\r\n-     * @return mapping of configuration properties with prefix stripped\r\n-     */\r\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\r\n-        Map<String, String> configMap = new HashMap<>();\r\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\r\n-        while (it.hasNext()) {\r\n-            String propertyName = it.next().getKey();\r\n-            if (propertyName.startsWith(confPrefix)) {\r\n-                // do not use value from the iterator as it might not come with variable substitution\r\n-                String value = configuration.get(propertyName);\r\n-                String keyName = propertyName.substring(confPrefix.length());\r\n-                configMap.put(keyName, value);\r\n-            }\r\n-        }\r\n-        return configMap;\r\n-    }\r\n-\r\n-}\r\n+package org.greenplum.pxf.plugins.jdbc;", "originalCommit": "057403a900e5da7a67dda63e9ebdb1e20467f0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MzQyMA==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390593420", "bodyText": "yes, in the second commit I stripped carriage returns (^M) but the first commit has the changes.", "author": "oliverralbertini", "createdAt": "2020-03-10T20:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjI3OA==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390606278", "bodyText": "any functional reason we want to do that? I find it useful to be able to do a \"blame/annotate\" to look at a code in the change. However, when doing these changes, we make it more difficult to quickly determine changes in the source code", "author": "frankgh", "createdAt": "2020-03-10T20:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxNjk5Nw==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390616997", "bodyText": "OK, switched back to carriage returns.", "author": "oliverralbertini", "createdAt": "2020-03-10T21:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "9b7f7436fe1f533ca3d1f19999cb962272cda385", "chunk": "diff --git a/server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java b/server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java\nindex 6030697b..829174a2 100644\n--- a/server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java\n+++ b/server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java\n\n@@ -1,584 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\n-\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.hadoop.conf.Configuration;\n-import org.greenplum.pxf.api.model.BasePlugin;\n-import org.greenplum.pxf.api.model.RequestContext;\n-import org.greenplum.pxf.api.security.SecureLogin;\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\n-import org.greenplum.pxf.api.utilities.Utilities;\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.security.PrivilegedExceptionAction;\n-import java.sql.Connection;\n-import java.sql.DatabaseMetaData;\n-import java.sql.PreparedStatement;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.stream.Collectors;\n-\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\n-\n-/**\n- * JDBC tables plugin (base class)\n- * <p>\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\n- */\n-public class JdbcBasePlugin extends BasePlugin {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\n-\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\n-    private static final int DEFAULT_BATCH_SIZE = 100;\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\n-    private static final int DEFAULT_POOL_SIZE = 1;\n-\n-    // configuration parameter names\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\n-\n-    // connection parameter names\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\n-\n-    // statement properties\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\n-\n-    // connection pool properties\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\n-\n-    // DDL option names\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\n-\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\n-\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\n-\n-    private enum TransactionIsolation {\n-        READ_UNCOMMITTED(1),\n-        READ_COMMITTED(2),\n-        REPEATABLE_READ(4),\n-        SERIALIZABLE(8),\n-        NOT_PROVIDED(-1);\n-\n-        private int isolationLevel;\n-\n-        TransactionIsolation(int transactionIsolation) {\n-            isolationLevel = transactionIsolation;\n-        }\n-\n-        public int getLevel() {\n-            return isolationLevel;\n-        }\n-\n-        public static TransactionIsolation typeOf(String str) {\n-            return valueOf(str);\n-        }\n-    }\n-\n-    // JDBC parameters from config file or specified in DDL\n-\n-    private String jdbcUrl;\n-\n-    protected String tableName;\n-\n-    // Write batch size\n-    protected int batchSize;\n-    protected boolean batchSizeIsSetByUser = false;\n-\n-    // Read batch size\n-    protected int fetchSize;\n-\n-    // Thread pool size\n-    protected int poolSize;\n-\n-    // Query timeout.\n-    protected Integer queryTimeout;\n-\n-    // Quote columns setting set by user (three values are possible)\n-    protected Boolean quoteColumns = null;\n-\n-    // Environment variables to SET before query execution\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\n-\n-    // Properties object to pass to JDBC Driver when connection is created\n-    protected Properties connectionConfiguration = new Properties();\n-\n-    // Transaction isolation level that a user can configure\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\n-\n-    // Columns description\n-    protected List<ColumnDescriptor> columns = null;\n-\n-    // Name of query to execute for read flow (optional)\n-    protected String queryName;\n-\n-    // connection pool fields\n-    private boolean isConnectionPoolUsed;\n-    private Properties poolConfiguration;\n-    private String poolQualifier;\n-\n-    private ConnectionManager connectionManager;\n-\n-    static {\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\n-    }\n-\n-    /**\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\n-     */\n-    public JdbcBasePlugin() {\n-        this(ConnectionManager.getInstance());\n-    }\n-\n-    /**\n-     * Creates a new instance with the given ConnectionManager.\n-     *\n-     * @param connectionManager connection manager instance\n-     */\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\n-        this.connectionManager = connectionManager;\n-    }\n-\n-    @Override\n-    public void initialize(RequestContext context) {\n-        super.initialize(context);\n-\n-        // Required parameter. Can be auto-overwritten by user options\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\n-        try {\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\n-            Class.forName(jdbcDriver);\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        // Required parameter. Can be auto-overwritten by user options\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\n-\n-        // Required metadata\n-        String dataSource = context.getDataSource();\n-        if (StringUtils.isBlank(dataSource)) {\n-            throw new IllegalArgumentException(\"Data source must be provided\");\n-        }\n-\n-        // Determine if the datasource is a table name or a query name\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\n-            if (StringUtils.isBlank(queryName)) {\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\n-            }\n-            LOG.debug(\"Query name is {}\", queryName);\n-        } else {\n-            tableName = dataSource;\n-            LOG.debug(\"Table name is {}\", tableName);\n-        }\n-\n-        // Required metadata\n-        columns = context.getTupleDescription();\n-\n-        // Optional parameters\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\n-        if (context.getRequestType() == RequestContext.RequestType.WRITE_BRIDGE) {\n-            batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\n-\n-            if (batchSize == 0) {\n-                batchSize = 1; // if user set to 0, it is the same as batchSize of 1\n-            } else if (batchSize < 0) {\n-                throw new IllegalArgumentException(String.format(\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\n-            }\n-        }\n-\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\n-\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\n-\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\n-            try {\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\n-            } catch (NumberFormatException e) {\n-                throw new IllegalArgumentException(String.format(\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\n-            }\n-        }\n-\n-        // Optional parameter. The default value is null\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\n-        if (quoteColumnsRaw != null) {\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\n-        }\n-\n-        // Optional parameter. The default value is empty map\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\n-        // Check forbidden symbols\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\n-        // However, SET queries cannot be executed this way. This is why we do this check\n-        if (sessionConfiguration.entrySet().stream()\n-                .anyMatch(\n-                        entry ->\n-                                StringUtils.containsAny(\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\n-                                ) ||\n-                                        StringUtils.containsAny(\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\n-                                        )\n-                )\n-        ) {\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\n-        }\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Session configuration: {}\",\n-                    sessionConfiguration.entrySet().stream()\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\n-                            .collect(Collectors.joining(\", \"))\n-            );\n-        }\n-\n-        // Optional parameter. The default value is empty map\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\n-\n-        // Optional parameter. The default value depends on the database\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\n-\n-        // Set optional user parameter, taking into account impersonation setting for the server.\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\n-        if (impersonationEnabledForServer) {\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\n-                jdbcUrl = updatedJdbcUrl;\n-            } else {\n-                // the jdbcUser is the GPDB user\n-                jdbcUser = context.getUser();\n-            }\n-        }\n-        if (jdbcUser != null) {\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\n-        } else {\n-            LOG.debug(\"JDBC user has not been set\");\n-        }\n-\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Connection configuration: {}\",\n-                    connectionConfiguration.entrySet().stream()\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\n-                            .collect(Collectors.joining(\", \"))\n-            );\n-        }\n-\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\n-        if (jdbcUser != null) {\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\n-            if (jdbcPassword != null) {\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\n-            }\n-        }\n-\n-        // connection pool is optional, enabled by default\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\n-        if (isConnectionPoolUsed) {\n-            poolConfiguration = new Properties();\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\n-            // apply values read from the template\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\n-\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\n-            // connectionTestQuery parameter in this case, unless already set by the user\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\n-            }\n-\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\n-            // to switch effective user once connection is established\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\n-        }\n-    }\n-\n-    /**\n-     * Open a new JDBC connection\n-     *\n-     * @return {@link Connection}\n-     * @throws SQLException if a database access or connection error occurs\n-     */\n-    public Connection getConnection() throws SQLException {\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\n-\n-        Connection connection = null;\n-        try {\n-            connection = getConnectionInternal();\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\n-\n-            prepareConnection(connection);\n-        } catch (Exception e) {\n-            closeConnection(connection);\n-            if (e instanceof SQLException) {\n-                throw (SQLException) e;\n-            } else {\n-                String msg = e.getMessage();\n-                if (msg == null) {\n-                    Throwable t = e.getCause();\n-                    if (t != null) msg = t.getMessage();\n-                }\n-                throw new SQLException(msg, e);\n-            }\n-        }\n-\n-        return connection;\n-    }\n-\n-    /**\n-     * Prepare a JDBC PreparedStatement\n-     *\n-     * @param connection connection to use for creating the statement\n-     * @param query      query to execute\n-     * @return PreparedStatement\n-     * @throws SQLException if a database access error occurs\n-     */\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\n-        if ((connection == null) || (query == null)) {\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\n-        }\n-        PreparedStatement statement = connection.prepareStatement(query);\n-        if (queryTimeout != null) {\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\n-            statement.setQueryTimeout(queryTimeout);\n-        }\n-        return statement;\n-    }\n-\n-    /**\n-     * Close a JDBC statement and underlying {@link Connection}\n-     *\n-     * @param statement statement to close\n-     * @throws SQLException\n-     */\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\n-        if (statement == null) {\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\n-            return;\n-        }\n-\n-        SQLException exception = null;\n-        Connection connection = null;\n-\n-        try {\n-            connection = statement.getConnection();\n-        } catch (SQLException e) {\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\n-            exception = e;\n-        }\n-\n-        try {\n-            LOG.debug(\"Closing statement for connection {}\", connection);\n-            statement.close();\n-        } catch (SQLException e) {\n-            LOG.error(\"Exception when closing Statement\", e);\n-            exception = e;\n-        }\n-\n-        try {\n-            closeConnection(connection);\n-        } catch (SQLException e) {\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\n-            exception = e;\n-        }\n-\n-        if (exception != null) {\n-            throw exception;\n-        }\n-    }\n-\n-    /**\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\n-     * Otherwise, it returns a new connection.\n-     *\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\n-     * Otherwise, it returns a new connection.\n-     * @throws Exception\n-     */\n-    private Connection getConnectionInternal() throws Exception {\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\n-\n-        } else {\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\n-        }\n-    }\n-\n-    /**\n-     * Close a JDBC connection\n-     *\n-     * @param connection connection to close\n-     * @throws SQLException\n-     */\n-    private static void closeConnection(Connection connection) throws SQLException {\n-        if (connection == null) {\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\n-            return;\n-        }\n-        try {\n-            if (!connection.isClosed() &&\n-                    connection.getMetaData().supportsTransactions() &&\n-                    !connection.getAutoCommit()) {\n-\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\n-                connection.commit();\n-            }\n-        } finally {\n-            try {\n-                LOG.debug(\"Closing connection {}\", connection);\n-                connection.close();\n-            } catch (Exception e) {\n-                // ignore\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Prepare JDBC connection by setting session-level variables in external database\n-     *\n-     * @param connection {@link Connection} to prepare\n-     */\n-    private void prepareConnection(Connection connection) throws SQLException {\n-        if (connection == null) {\n-            throw new IllegalArgumentException(\"The provided connection is null\");\n-        }\n-\n-        DatabaseMetaData metadata = connection.getMetaData();\n-\n-        // Handle optional connection transaction isolation level\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\n-            // user wants to set isolation level explicitly\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\n-            } else {\n-                throw new RuntimeException(\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\n-                );\n-            }\n-        }\n-\n-        // Disable autocommit\n-        if (metadata.supportsTransactions()) {\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\n-            connection.setAutoCommit(false);\n-        }\n-\n-        // Prepare session (process sessionConfiguration)\n-        if (!sessionConfiguration.isEmpty()) {\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\n-\n-            try (Statement statement = connection.createStatement()) {\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\n-                    statement.execute(sessionQuery);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\n-     *\n-     * @param value      value to check\n-     * @param paramName  parameter name\n-     * @param optionName name of the option for a given parameter\n-     */\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\n-        if (StringUtils.isBlank(value)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\n-     * work with JDBC profile.\n-     *\n-     * @param configuration configuration map\n-     * @param confPrefix    configuration prefix\n-     * @return mapping of configuration properties with prefix stripped\n-     */\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\n-        Map<String, String> configMap = new HashMap<>();\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\n-        while (it.hasNext()) {\n-            String propertyName = it.next().getKey();\n-            if (propertyName.startsWith(confPrefix)) {\n-                // do not use value from the iterator as it might not come with variable substitution\n-                String value = configuration.get(propertyName);\n-                String keyName = propertyName.substring(confPrefix.length());\n-                configMap.put(keyName, value);\n-            }\n-        }\n-        return configMap;\n-    }\n-\n-}\n+package org.greenplum.pxf.plugins.jdbc;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.greenplum.pxf.api.model.BasePlugin;\n+import org.greenplum.pxf.api.model.RequestContext;\n+import org.greenplum.pxf.api.security.SecureLogin;\n+import org.greenplum.pxf.api.utilities.ColumnDescriptor;\n+import org.greenplum.pxf.api.utilities.Utilities;\n+import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\n+import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\n+import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\n+\n+/**\n+ * JDBC tables plugin (base class)\n+ * <p>\n+ * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\n+ */\n+public class JdbcBasePlugin extends BasePlugin {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\n+\n+    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\n+    private static final int DEFAULT_BATCH_SIZE = 100;\n+    private static final int DEFAULT_FETCH_SIZE = 1000;\n+    private static final int DEFAULT_POOL_SIZE = 1;\n+\n+    // configuration parameter names\n+    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\n+    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\n+    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\n+    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\n+    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\n+    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\n+\n+    // connection parameter names\n+    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\n+\n+    // statement properties\n+    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\n+    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\n+    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\n+\n+    // connection pool properties\n+    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\n+    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\n+    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\n+\n+    // DDL option names\n+    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\n+    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\n+\n+    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\n+    private static final String QUERY_NAME_PREFIX = \"query:\";\n+    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\n+\n+    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\n+    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\n+\n+    private enum TransactionIsolation {\n+        READ_UNCOMMITTED(1),\n+        READ_COMMITTED(2),\n+        REPEATABLE_READ(4),\n+        SERIALIZABLE(8),\n+        NOT_PROVIDED(-1);\n+\n+        private int isolationLevel;\n+\n+        TransactionIsolation(int transactionIsolation) {\n+            isolationLevel = transactionIsolation;\n+        }\n+\n+        public int getLevel() {\n+            return isolationLevel;\n+        }\n+\n+        public static TransactionIsolation typeOf(String str) {\n+            return valueOf(str);\n+        }\n+    }\n+\n+    // JDBC parameters from config file or specified in DDL\n+\n+    private String jdbcUrl;\n+\n+    protected String tableName;\n+\n+    // Write batch size\n+    protected int batchSize;\n+    protected boolean batchSizeIsSetByUser = false;\n+\n+    // Read batch size\n+    protected int fetchSize;\n+\n+    // Thread pool size\n+    protected int poolSize;\n+\n+    // Query timeout.\n+    protected Integer queryTimeout;\n+\n+    // Quote columns setting set by user (three values are possible)\n+    protected Boolean quoteColumns = null;\n+\n+    // Environment variables to SET before query execution\n+    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\n+\n+    // Properties object to pass to JDBC Driver when connection is created\n+    protected Properties connectionConfiguration = new Properties();\n+\n+    // Transaction isolation level that a user can configure\n+    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\n+\n+    // Columns description\n+    protected List<ColumnDescriptor> columns = null;\n+\n+    // Name of query to execute for read flow (optional)\n+    protected String queryName;\n+\n+    // connection pool fields\n+    private boolean isConnectionPoolUsed;\n+    private Properties poolConfiguration;\n+    private String poolQualifier;\n+\n+    private ConnectionManager connectionManager;\n+\n+    static {\n+        // Deprecated as of Oct 22, 2019 in version 5.9.2+\n+        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\n+                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\n+                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\n+    }\n+\n+    /**\n+     * Creates a new instance with default (singleton) instance of ConnectionManager.\n+     */\n+    public JdbcBasePlugin() {\n+        this(ConnectionManager.getInstance());\n+    }\n+\n+    /**\n+     * Creates a new instance with the given ConnectionManager.\n+     *\n+     * @param connectionManager connection manager instance\n+     */\n+    JdbcBasePlugin(ConnectionManager connectionManager) {\n+        this.connectionManager = connectionManager;\n+    }\n+\n+    @Override\n+    public void initialize(RequestContext context) {\n+        super.initialize(context);\n+\n+        // Required parameter. Can be auto-overwritten by user options\n+        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\n+        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\n+        try {\n+            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\n+            Class.forName(jdbcDriver);\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        // Required parameter. Can be auto-overwritten by user options\n+        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\n+        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\n+\n+        // Required metadata\n+        String dataSource = context.getDataSource();\n+        if (StringUtils.isBlank(dataSource)) {\n+            throw new IllegalArgumentException(\"Data source must be provided\");\n+        }\n+\n+        // Determine if the datasource is a table name or a query name\n+        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\n+            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\n+            if (StringUtils.isBlank(queryName)) {\n+                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\n+            }\n+            LOG.debug(\"Query name is {}\", queryName);\n+        } else {\n+            tableName = dataSource;\n+            LOG.debug(\"Table name is {}\", tableName);\n+        }\n+\n+        // Required metadata\n+        columns = context.getTupleDescription();\n+\n+        // Optional parameters\n+        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\n+        if (context.getRequestType() == RequestContext.RequestType.WRITE_BRIDGE) {\n+            batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\n+\n+            if (batchSize == 0) {\n+                batchSize = 1; // if user set to 0, it is the same as batchSize of 1\n+            } else if (batchSize < 0) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\n+            }\n+        }\n+\n+        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\n+\n+        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\n+\n+        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\n+        if (StringUtils.isNotBlank(queryTimeoutString)) {\n+            try {\n+                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\n+            } catch (NumberFormatException e) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Property %s has incorrect value %s : must be a non-negative integer\",\n+                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\n+            }\n+        }\n+\n+        // Optional parameter. The default value is null\n+        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\n+        if (quoteColumnsRaw != null) {\n+            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\n+        }\n+\n+        // Optional parameter. The default value is empty map\n+        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\n+        // Check forbidden symbols\n+        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\n+        // However, SET queries cannot be executed this way. This is why we do this check\n+        if (sessionConfiguration.entrySet().stream()\n+                .anyMatch(\n+                        entry ->\n+                                StringUtils.containsAny(\n+                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\n+                                ) ||\n+                                        StringUtils.containsAny(\n+                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\n+                                        )\n+                )\n+        ) {\n+            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\n+        }\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Session configuration: {}\",\n+                    sessionConfiguration.entrySet().stream()\n+                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\n+                            .collect(Collectors.joining(\", \"))\n+            );\n+        }\n+\n+        // Optional parameter. The default value is empty map\n+        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\n+\n+        // Optional parameter. The default value depends on the database\n+        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\n+        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\n+\n+        // Set optional user parameter, taking into account impersonation setting for the server.\n+        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\n+        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\n+        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\n+        if (impersonationEnabledForServer) {\n+            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\n+                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\n+                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\n+                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\n+                jdbcUrl = updatedJdbcUrl;\n+            } else {\n+                // the jdbcUser is the GPDB user\n+                jdbcUser = context.getUser();\n+            }\n+        }\n+        if (jdbcUser != null) {\n+            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\n+            connectionConfiguration.setProperty(\"user\", jdbcUser);\n+        } else {\n+            LOG.debug(\"JDBC user has not been set\");\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Connection configuration: {}\",\n+                    connectionConfiguration.entrySet().stream()\n+                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\n+                            .collect(Collectors.joining(\", \"))\n+            );\n+        }\n+\n+        // This must be the last parameter parsed, as we output connectionConfiguration earlier\n+        // Optional parameter. By default, corresponding connectionConfiguration property is not set\n+        if (jdbcUser != null) {\n+            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\n+            if (jdbcPassword != null) {\n+                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\n+                connectionConfiguration.setProperty(\"password\", jdbcPassword);\n+            }\n+        }\n+\n+        // connection pool is optional, enabled by default\n+        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\n+        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\n+        if (isConnectionPoolUsed) {\n+            poolConfiguration = new Properties();\n+            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\n+            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\n+            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\n+            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\n+            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\n+            // apply values read from the template\n+            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\n+\n+            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\n+            // connectionTestQuery parameter in this case, unless already set by the user\n+            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\n+                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\n+            }\n+\n+            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\n+            // to switch effective user once connection is established\n+            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\n+        }\n+    }\n+\n+    /**\n+     * Open a new JDBC connection\n+     *\n+     * @return {@link Connection}\n+     * @throws SQLException if a database access or connection error occurs\n+     */\n+    public Connection getConnection() throws SQLException {\n+        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\n+\n+        Connection connection = null;\n+        try {\n+            connection = getConnectionInternal();\n+            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\n+\n+            prepareConnection(connection);\n+        } catch (Exception e) {\n+            closeConnection(connection);\n+            if (e instanceof SQLException) {\n+                throw (SQLException) e;\n+            } else {\n+                String msg = e.getMessage();\n+                if (msg == null) {\n+                    Throwable t = e.getCause();\n+                    if (t != null) msg = t.getMessage();\n+                }\n+                throw new SQLException(msg, e);\n+            }\n+        }\n+\n+        return connection;\n+    }\n+\n+    /**\n+     * Prepare a JDBC PreparedStatement\n+     *\n+     * @param connection connection to use for creating the statement\n+     * @param query      query to execute\n+     * @return PreparedStatement\n+     * @throws SQLException if a database access error occurs\n+     */\n+    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\n+        if ((connection == null) || (query == null)) {\n+            throw new IllegalArgumentException(\"The provided query or connection is null\");\n+        }\n+        PreparedStatement statement = connection.prepareStatement(query);\n+        if (queryTimeout != null) {\n+            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\n+            statement.setQueryTimeout(queryTimeout);\n+        }\n+        return statement;\n+    }\n+\n+    /**\n+     * Close a JDBC statement and underlying {@link Connection}\n+     *\n+     * @param statement statement to close\n+     * @throws SQLException\n+     */\n+    public static void closeStatementAndConnection(Statement statement) throws SQLException {\n+        if (statement == null) {\n+            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\n+            return;\n+        }\n+\n+        SQLException exception = null;\n+        Connection connection = null;\n+\n+        try {\n+            connection = statement.getConnection();\n+        } catch (SQLException e) {\n+            LOG.error(\"Exception when retrieving Connection from Statement\", e);\n+            exception = e;\n+        }\n+\n+        try {\n+            LOG.debug(\"Closing statement for connection {}\", connection);\n+            statement.close();\n+        } catch (SQLException e) {\n+            LOG.error(\"Exception when closing Statement\", e);\n+            exception = e;\n+        }\n+\n+        try {\n+            closeConnection(connection);\n+        } catch (SQLException e) {\n+            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\n+            exception = e;\n+        }\n+\n+        if (exception != null) {\n+            throw exception;\n+        }\n+    }\n+\n+    /**\n+     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\n+     * Otherwise, it returns a new connection.\n+     *\n+     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\n+     * Otherwise, it returns a new connection.\n+     * @throws Exception\n+     */\n+    private Connection getConnectionInternal() throws Exception {\n+        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\n+            return SecureLogin.getInstance().getLoginUser(context, configuration).\n+                    doAs((PrivilegedExceptionAction<Connection>) () ->\n+                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\n+\n+        } else {\n+            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\n+        }\n+    }\n+\n+    /**\n+     * Close a JDBC connection\n+     *\n+     * @param connection connection to close\n+     * @throws SQLException\n+     */\n+    private static void closeConnection(Connection connection) throws SQLException {\n+        if (connection == null) {\n+            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\n+            return;\n+        }\n+        try {\n+            if (!connection.isClosed() &&\n+                    connection.getMetaData().supportsTransactions() &&\n+                    !connection.getAutoCommit()) {\n+\n+                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\n+                connection.commit();\n+            }\n+        } finally {\n+            try {\n+                LOG.debug(\"Closing connection {}\", connection);\n+                connection.close();\n+            } catch (Exception e) {\n+                // ignore\n+                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Prepare JDBC connection by setting session-level variables in external database\n+     *\n+     * @param connection {@link Connection} to prepare\n+     */\n+    private void prepareConnection(Connection connection) throws SQLException {\n+        if (connection == null) {\n+            throw new IllegalArgumentException(\"The provided connection is null\");\n+        }\n+\n+        DatabaseMetaData metadata = connection.getMetaData();\n+\n+        // Handle optional connection transaction isolation level\n+        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\n+            // user wants to set isolation level explicitly\n+            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\n+                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\n+                connection.setTransactionIsolation(transactionIsolation.getLevel());\n+            } else {\n+                throw new RuntimeException(\n+                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\n+                );\n+            }\n+        }\n+\n+        // Disable autocommit\n+        if (metadata.supportsTransactions()) {\n+            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\n+            connection.setAutoCommit(false);\n+        }\n+\n+        // Prepare session (process sessionConfiguration)\n+        if (!sessionConfiguration.isEmpty()) {\n+            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\n+\n+            try (Statement statement = connection.createStatement()) {\n+                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\n+                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\n+                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\n+                    statement.execute(sessionQuery);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\n+     *\n+     * @param value      value to check\n+     * @param paramName  parameter name\n+     * @param optionName name of the option for a given parameter\n+     */\n+    private void assertMandatoryParameter(String value, String paramName, String optionName) {\n+        if (StringUtils.isBlank(value)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Constructs a mapping of configuration and includes all properties that start with the specified\n+     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\n+     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\n+     * work with JDBC profile.\n+     *\n+     * @param configuration configuration map\n+     * @param confPrefix    configuration prefix\n+     * @return mapping of configuration properties with prefix stripped\n+     */\n+    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\n+        Map<String, String> configMap = new HashMap<>();\n+        Iterator<Map.Entry<String, String>> it = configuration.iterator();\n+        while (it.hasNext()) {\n+            String propertyName = it.next().getKey();\n+            if (propertyName.startsWith(confPrefix)) {\n+                // do not use value from the iterator as it might not come with variable substitution\n+                String value = configuration.get(propertyName);\n+                String keyName = propertyName.substring(confPrefix.length());\n+                configMap.put(keyName, value);\n+            }\n+        }\n+        return configMap;\n+    }\n+\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390541462", "bodyText": "while this is fine, using @rule method would allow to check for the error message as well.", "author": "denalex", "createdAt": "2020-03-10T18:56:45Z", "path": "server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java", "diffHunk": "@@ -189,7 +193,35 @@ public void testBatchSize2() throws Exception {\n \n         // Checks\n         assertEquals(2, getInternalState(plugin, \"batchSize\"));\n-        assertTrue((boolean)getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+        assertTrue((boolean) getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+    }\n+\n+    @Test\n+    public void testBatchSizeOnRead() throws Exception {\n+        // Configuration\n+        Configuration configuration = makeConfiguration();\n+        configuration.set(\"jdbc.statement.batchSize\", \"foobar\");\n+\n+        // Initialize plugin\n+        prepareBaseConfigurationFactory(configuration);\n+        JdbcBasePlugin plugin = new JdbcBasePlugin();\n+        RequestContext context = makeContext();\n+        context.setRequestType(RequestContext.RequestType.READ_BRIDGE);\n+        plugin.initialize(context);\n+\n+        // should not error because we don't validate this on the READ path\n+    }\n+\n+    @Test(expected = NumberFormatException.class)", "originalCommit": "057403a900e5da7a67dda63e9ebdb1e20467f0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MzYyMA==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390593620", "bodyText": "How'd I know you would say this?", "author": "oliverralbertini", "createdAt": "2020-03-10T20:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjUxMg==", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390606512", "bodyText": "I switched all the tests to use @Rule", "author": "oliverralbertini", "createdAt": "2020-03-10T20:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9b7f7436fe1f533ca3d1f19999cb962272cda385", "chunk": "diff --git a/server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java b/server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java\nindex d34e0334..9cda024f 100644\n--- a/server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java\n+++ b/server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java\n\n@@ -212,8 +212,10 @@ public class JdbcBasePluginTestInitialize {\n         // should not error because we don't validate this on the READ path\n     }\n \n-    @Test(expected = NumberFormatException.class)\n+    @Test\n     public void testBatchSizeOnWrite() throws Exception {\n+        thrown.expect(NumberFormatException.class);\n+        thrown.expectMessage(\"For input string: \\\"foobar\\\"\");\n         // Configuration\n         Configuration configuration = makeConfiguration();\n         configuration.set(\"jdbc.statement.batchSize\", \"foobar\");\n"}}, {"oid": "9b7f7436fe1f533ca3d1f19999cb962272cda385", "url": "https://github.com/greenplum-db/pxf/commit/9b7f7436fe1f533ca3d1f19999cb962272cda385", "message": "JDBC: Validate batchsize only on write\n\nThis property is only needed for the write case.\n\nAlso convert all exception tests to @Rule in\nJdbcBasePluginTestInitialize.java.\n\nAuthored-by: Oliver Albertini <oalbertini@pivotal.io>", "committedDate": "2020-03-10T21:15:32Z", "type": "commit"}, {"oid": "9b7f7436fe1f533ca3d1f19999cb962272cda385", "url": "https://github.com/greenplum-db/pxf/commit/9b7f7436fe1f533ca3d1f19999cb962272cda385", "message": "JDBC: Validate batchsize only on write\n\nThis property is only needed for the write case.\n\nAlso convert all exception tests to @Rule in\nJdbcBasePluginTestInitialize.java.\n\nAuthored-by: Oliver Albertini <oalbertini@pivotal.io>", "committedDate": "2020-03-10T21:15:32Z", "type": "forcePushed"}]}