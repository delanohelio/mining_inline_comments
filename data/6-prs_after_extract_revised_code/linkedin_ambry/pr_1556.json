{"pr_number": 1556, "pr_title": "Parallelize cloud compaction", "pr_createdAt": "2020-06-08T20:35:45Z", "pr_url": "https://github.com/linkedin/ambry/pull/1556", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDI1Mw==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437084253", "bodyText": "Is the idea to wait until all the threads are done before assigning any new work?  That won't be optimal since a long running partition can keep the other threads idle for a while.", "author": "lightningrob", "createdAt": "2020-06-09T01:17:12Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java", "diffHunk": "@@ -103,47 +106,80 @@ public int compactPartitions() {\n       logger.info(\"Skipping compaction as no partitions are assigned.\");\n       return 0;\n     }\n+    List<PartitionId> partitionSnapshot = new ArrayList<>(partitions);\n+    long compactionStartTime = System.currentTimeMillis();\n+    long timeToQuit = System.currentTimeMillis() + compactionTimeLimitMs;\n+    int compactionInProgress = 0;\n+    doneLatch.set(new CountDownLatch(1));\n+    int totalBlobsPurged = 0;\n+    int compactedPartitionCount = 0;\n+    try {\n+      while (true) {\n+        while (compactionInProgress < numThreads) {\n+          if (partitionSnapshot.isEmpty()) {\n+            break;\n+          }\n+          PartitionId partitionId = partitionSnapshot.remove(0);\n+          executorCompletionService.submit(() -> compactPartition(partitionId));\n+          compactionInProgress++;\n+        }\n+        totalBlobsPurged += executorCompletionService.take().get();\n+        compactionInProgress--;\n+        compactedPartitionCount++;\n+        if (System.currentTimeMillis() >= timeToQuit) {\n+          logger.info(\"Compaction terminated due to time limit exceeded.\");\n+          break;\n+        }\n+        if (isShuttingDown()) {\n+          logger.info(\"Compaction terminated due to shut down.\");\n+          break;\n+        }\n+        if (partitionSnapshot.isEmpty()) {\n+          break;\n+        }\n+      }\n+      while (compactionInProgress > 0) {\n+        totalBlobsPurged += executorCompletionService.take().get();", "originalCommit": "0320d1b6d51326803c2c81dc582f84d19b25c691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODIwNA==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437108204", "bodyText": "No.. the idea is not to wait until all threads are done. The idea to wait for any one of the threads to return, and then assign it new work immediately. executorCompletionService.take() retrieves and removes the Future representing the next completed task, waiting if none are yet present. Calling .get() on the future just returns the result.\nSo basically first we assign work to all threads. Then wait for any single thread to complete its work in the executorCompletionService.take().get() call. And then we loop over to assign work to this thread.", "author": "ankagrawal", "createdAt": "2020-06-09T02:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExMTM5Ng==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437111396", "bodyText": "Note that the final while loop while (compactionInProgress > 0) does loop through all the threads. This happens when all the partitions have been taken care of, and we have come out of the initial while(true) loop. Here we are just making sure that all the threads get completed before ending the compaction run.\nThis loop also takes care of the case where we encounter a compaction shutdown. In that case too, we break out of the while(true) loop, and wait for all the threads to complete work, before releasing the done latch.", "author": "ankagrawal", "createdAt": "2020-06-09T03:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTAyMQ==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437651021", "bodyText": "Okay, I see that now.", "author": "lightningrob", "createdAt": "2020-06-09T18:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDI1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "472691225e9ebd3124e50feb8eeacf7734ff447c", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\nindex 35b16207a..f8571e8c2 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n\n@@ -114,7 +114,7 @@ public class CloudStorageCompactor implements Runnable {\n     int totalBlobsPurged = 0;\n     int compactedPartitionCount = 0;\n     try {\n-      while (true) {\n+      while (!partitionSnapshot.isEmpty()) {\n         while (compactionInProgress < numThreads) {\n           if (partitionSnapshot.isEmpty()) {\n             break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDU0NQ==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437084545", "bodyText": "This could be: while (!partitionSnapshot.isEmpty())", "author": "lightningrob", "createdAt": "2020-06-09T01:18:19Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java", "diffHunk": "@@ -103,47 +106,80 @@ public int compactPartitions() {\n       logger.info(\"Skipping compaction as no partitions are assigned.\");\n       return 0;\n     }\n+    List<PartitionId> partitionSnapshot = new ArrayList<>(partitions);\n+    long compactionStartTime = System.currentTimeMillis();\n+    long timeToQuit = System.currentTimeMillis() + compactionTimeLimitMs;\n+    int compactionInProgress = 0;\n+    doneLatch.set(new CountDownLatch(1));\n+    int totalBlobsPurged = 0;\n+    int compactedPartitionCount = 0;\n+    try {\n+      while (true) {", "originalCommit": "0320d1b6d51326803c2c81dc582f84d19b25c691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzA4Ng==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437107086", "bodyText": "yes.. will fix this.", "author": "ankagrawal", "createdAt": "2020-06-09T02:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "472691225e9ebd3124e50feb8eeacf7734ff447c", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\nindex 35b16207a..f8571e8c2 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n\n@@ -114,7 +114,7 @@ public class CloudStorageCompactor implements Runnable {\n     int totalBlobsPurged = 0;\n     int compactedPartitionCount = 0;\n     try {\n-      while (true) {\n+      while (!partitionSnapshot.isEmpty()) {\n         while (compactionInProgress < numThreads) {\n           if (partitionSnapshot.isEmpty()) {\n             break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0NzI1Mg==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437647252", "bodyText": "Typo: reassigned", "author": "lightningrob", "createdAt": "2020-06-09T18:52:05Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java", "diffHunk": "@@ -103,47 +106,77 @@ public int compactPartitions() {\n       logger.info(\"Skipping compaction as no partitions are assigned.\");\n       return 0;\n     }\n+    List<PartitionId> partitionSnapshot = new ArrayList<>(partitions);\n+    long compactionStartTime = System.currentTimeMillis();\n+    long timeToQuit = System.currentTimeMillis() + compactionTimeLimitMs;\n+    int compactionInProgress = 0;\n+    doneLatch.set(new CountDownLatch(1));\n+    int totalBlobsPurged = 0;\n+    int compactedPartitionCount = 0;\n+    try {\n+      while (!partitionSnapshot.isEmpty()) {\n+        while (compactionInProgress < numThreads) {\n+          if (partitionSnapshot.isEmpty()) {\n+            break;\n+          }\n+          PartitionId partitionId = partitionSnapshot.remove(0);\n+          executorCompletionService.submit(() -> compactPartition(partitionId));\n+          compactionInProgress++;\n+        }\n+        totalBlobsPurged += executorCompletionService.take().get();\n+        compactionInProgress--;\n+        compactedPartitionCount++;\n+        if (System.currentTimeMillis() >= timeToQuit) {\n+          logger.info(\"Compaction terminated due to time limit exceeded.\");\n+          break;\n+        }\n+        if (isShuttingDown()) {\n+          logger.info(\"Compaction terminated due to shut down.\");\n+          break;\n+        }\n+      }\n+      while (compactionInProgress > 0) {\n+        totalBlobsPurged += executorCompletionService.take().get();\n+        compactionInProgress--;\n+        compactedPartitionCount++;\n+      }\n+      doneLatch.get().countDown();\n+    } catch (Throwable th) {\n+      logger.error(\"Hit exception running compaction task\", th);\n+    } finally {\n+      long compactionTime = (System.currentTimeMillis() - compactionStartTime) / 1000;\n+      logger.info(\"Purged {} blobs in {} partitions taking {} seconds\", totalBlobsPurged, compactedPartitionCount,\n+          compactionTime);\n+    }\n+    return totalBlobsPurged;\n+  }\n+\n+  /**\n+   * Purge the inactive blobs in the specified partitions.\n+   * @param partition the {@link PartitionId} to compact.\n+   * @return the total number of blobs purged in the partition.\n+   */\n+  private int compactPartition(PartitionId partition) {\n     if (isShuttingDown()) {\n       logger.info(\"Skipping compaction due to shut down.\");\n       return 0;\n     }\n \n-    // TODO: adjust count when compaction uses multiple threads\n-    doneLatch.set(new CountDownLatch(1));\n-\n-    Set<PartitionId> partitionsSnapshot = new HashSet<>(partitions);\n-    logger.info(\"Beginning dead blob compaction for {} partitions\", partitions.size());\n-    long now = System.currentTimeMillis();\n-    long compactionStartTime = now;\n-    long timeToQuit = now + compactionTimeLimitMs;\n-    int totalBlobsPurged = 0;\n-    for (PartitionId partitionId : partitionsSnapshot) {\n-      String partitionPath = partitionId.toPathString();\n-      if (!partitions.contains(partitionId)) {\n-        // Looks like partition was reassigned since the loop started, so skip it\n-        continue;\n-      }\n+    logger.info(\"Beginning dead blob compaction for partition {}\", partition);\n \n-      try {\n-        totalBlobsPurged += cloudDestination.compactPartition(partitionPath);\n-      } catch (CloudStorageException ex) {\n-        logger.error(\"Compaction failed for partition {}\", partitionPath, ex);\n-        vcrMetrics.compactionFailureCount.inc();\n-      }\n+    String partitionPath = partition.toPathString();\n+    if (!partitions.contains(partition)) {\n+      // Looks like partition was reassigned since the loop started, so skip it\n+      logger.warn(\"Skipping compaction of Partition {} as the partition was reassgined\", partition);", "originalCommit": "a3178926f4ba04ef42c320ddc7fadf05d9961c8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2MzgwNg==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437663806", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-06-09T19:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0NzI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8f25b253c7bd0f1d170c33f2302878b7cfc385dd", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\nindex f8571e8c2..35b16207a 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n\n@@ -114,7 +114,7 @@ public class CloudStorageCompactor implements Runnable {\n     int totalBlobsPurged = 0;\n     int compactedPartitionCount = 0;\n     try {\n-      while (!partitionSnapshot.isEmpty()) {\n+      while (true) {\n         while (compactionInProgress < numThreads) {\n           if (partitionSnapshot.isEmpty()) {\n             break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDE5Nw==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437650197", "bodyText": "Could we let compactPartition throw exception on error, and catch it here in the get() call?  Then we can increment compactedPartitionCount only in success case.", "author": "lightningrob", "createdAt": "2020-06-09T18:57:05Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java", "diffHunk": "@@ -103,47 +106,77 @@ public int compactPartitions() {\n       logger.info(\"Skipping compaction as no partitions are assigned.\");\n       return 0;\n     }\n+    List<PartitionId> partitionSnapshot = new ArrayList<>(partitions);\n+    long compactionStartTime = System.currentTimeMillis();\n+    long timeToQuit = System.currentTimeMillis() + compactionTimeLimitMs;\n+    int compactionInProgress = 0;\n+    doneLatch.set(new CountDownLatch(1));\n+    int totalBlobsPurged = 0;\n+    int compactedPartitionCount = 0;\n+    try {\n+      while (!partitionSnapshot.isEmpty()) {\n+        while (compactionInProgress < numThreads) {\n+          if (partitionSnapshot.isEmpty()) {\n+            break;\n+          }\n+          PartitionId partitionId = partitionSnapshot.remove(0);\n+          executorCompletionService.submit(() -> compactPartition(partitionId));\n+          compactionInProgress++;\n+        }\n+        totalBlobsPurged += executorCompletionService.take().get();", "originalCommit": "a3178926f4ba04ef42c320ddc7fadf05d9961c8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NTgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437675821", "bodyText": "done.", "author": "ankagrawal", "createdAt": "2020-06-09T19:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8f25b253c7bd0f1d170c33f2302878b7cfc385dd", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\nindex f8571e8c2..35b16207a 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java\n\n@@ -114,7 +114,7 @@ public class CloudStorageCompactor implements Runnable {\n     int totalBlobsPurged = 0;\n     int compactedPartitionCount = 0;\n     try {\n-      while (!partitionSnapshot.isEmpty()) {\n+      while (true) {\n         while (compactionInProgress < numThreads) {\n           if (partitionSnapshot.isEmpty()) {\n             break;\n"}}, {"oid": "8f25b253c7bd0f1d170c33f2302878b7cfc385dd", "url": "https://github.com/linkedin/ambry/commit/8f25b253c7bd0f1d170c33f2302878b7cfc385dd", "message": "Parallelize cloud compaction", "committedDate": "2020-06-09T20:09:01Z", "type": "commit"}, {"oid": "472691225e9ebd3124e50feb8eeacf7734ff447c", "url": "https://github.com/linkedin/ambry/commit/472691225e9ebd3124e50feb8eeacf7734ff447c", "message": "Address review comment.", "committedDate": "2020-06-09T20:09:01Z", "type": "commit"}, {"oid": "857a86ce481288aa3c612c81bc18362eab861876", "url": "https://github.com/linkedin/ambry/commit/857a86ce481288aa3c612c81bc18362eab861876", "message": "Address review comments.", "committedDate": "2020-06-09T20:09:01Z", "type": "commit"}, {"oid": "fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "url": "https://github.com/linkedin/ambry/commit/fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "message": "Add test.", "committedDate": "2020-06-09T20:09:01Z", "type": "commit"}, {"oid": "fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "url": "https://github.com/linkedin/ambry/commit/fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "message": "Add test.", "committedDate": "2020-06-09T20:09:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxOTE1Mg==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437719152", "bodyText": "nit: remove a partition from map", "author": "jsjtzyy", "createdAt": "2020-06-09T20:59:31Z", "path": "ambry-cloud/src/test/java/com/github/ambry/cloud/CloudStorageCompactorTest.java", "diffHunk": "@@ -65,27 +64,23 @@ public void testCompactPartitions() throws Exception {\n     verify(mockDest, times(0)).purgeBlobs(any());\n     */\n \n-    // add 2 partitions to map\n-    int partition1 = 101, partition2 = 102;\n-    long compactionEndTime = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(CloudConfig.DEFAULT_RETENTION_DAYS);\n-    String partitionPath1 = String.valueOf(partition1), partitionPath2 = String.valueOf(partition2);\n+    // add 100 partitions to map\n     String defaultClass = MockClusterMap.DEFAULT_PARTITION_CLASS;\n-    partitionMap.put(new MockPartitionId(partition1, defaultClass), null);\n-    partitionMap.put(new MockPartitionId(partition2, defaultClass), null);\n-\n-    when(mockDest.compactPartition(eq(partitionPath1))).thenReturn(pageSize);\n-    when(mockDest.compactPartition(eq(partitionPath2))).thenReturn(pageSize * 2);\n-    assertEquals(pageSize * 3, compactor.compactPartitions());\n+    for (int i = 0; i < 100; i++) {\n+      partitionMap.put(new MockPartitionId(i, defaultClass), null);\n+      when(mockDest.compactPartition(eq(Integer.toString(i)))).thenReturn(pageSize);\n+    }\n \n+    assertEquals(pageSize * 100, compactor.compactPartitions());\n \n-    // remove partition2 from map\n-    partitionMap.remove(new MockPartitionId(partition2, defaultClass));\n-    assertEquals(pageSize, compactor.compactPartitions());\n+    // remove a from map", "originalCommit": "fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjQ1NA==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437742454", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-06-09T21:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxOTE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "962bdd16ee38316558b27cba5f469d9ffcb71f10", "chunk": "diff --git a/ambry-cloud/src/test/java/com/github/ambry/cloud/CloudStorageCompactorTest.java b/ambry-cloud/src/test/java/com/github/ambry/cloud/CloudStorageCompactorTest.java\nindex 2bb999e5a..bbfec8399 100644\n--- a/ambry-cloud/src/test/java/com/github/ambry/cloud/CloudStorageCompactorTest.java\n+++ b/ambry-cloud/src/test/java/com/github/ambry/cloud/CloudStorageCompactorTest.java\n\n@@ -73,7 +73,7 @@ public class CloudStorageCompactorTest {\n \n     assertEquals(pageSize * 100, compactor.compactPartitions());\n \n-    // remove a from map\n+    // remove a partition from map\n     partitionMap.remove(new MockPartitionId(0, defaultClass));\n     assertEquals(pageSize * 99, compactor.compactPartitions());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437726964", "bodyText": "I wonder if exception occurs in this method before we call executorCompletionService.take().get(), what will happen? Looks like it may not be captured at line 130, line 147. If it is captured by line 153 catch (Throwable th), will the whole batch compaction be terminated? What about some outstanding threads that are already assigned compaction task?", "author": "jsjtzyy", "createdAt": "2020-06-09T21:15:20Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudStorageCompactor.java", "diffHunk": "@@ -103,47 +107,84 @@ public int compactPartitions() {\n       logger.info(\"Skipping compaction as no partitions are assigned.\");\n       return 0;\n     }\n-    if (isShuttingDown()) {\n+    List<PartitionId> partitionSnapshot = new ArrayList<>(partitions);\n+    long compactionStartTime = System.currentTimeMillis();\n+    long timeToQuit = System.currentTimeMillis() + compactionTimeLimitMs;\n+    int compactionInProgress = 0;\n+    doneLatch.set(new CountDownLatch(1));\n+    int totalBlobsPurged = 0;\n+    int compactedPartitionCount = 0;\n+    try {\n+      while (!partitionSnapshot.isEmpty()) {\n+        while (compactionInProgress < numThreads) {\n+          if (partitionSnapshot.isEmpty()) {\n+            break;\n+          }\n+          PartitionId partitionId = partitionSnapshot.remove(0);\n+          executorCompletionService.submit(() -> compactPartition(partitionId));\n+          compactionInProgress++;\n+        }\n+        try {\n+          totalBlobsPurged += executorCompletionService.take().get();\n+          compactedPartitionCount++;\n+        } catch (ExecutionException ex) {\n+          vcrMetrics.compactionFailureCount.inc();\n+        }\n+        compactionInProgress--;\n+        if (System.currentTimeMillis() >= timeToQuit) {\n+          logger.info(\"Compaction terminated due to time limit exceeded.\");\n+          break;\n+        }\n+        if (isShutDown()) {\n+          logger.info(\"Compaction terminated due to shut down.\");\n+          break;\n+        }\n+      }\n+      while (compactionInProgress > 0) {\n+        try {\n+          totalBlobsPurged += executorCompletionService.take().get();\n+          compactedPartitionCount++;\n+        } catch (ExecutionException ex) {\n+          vcrMetrics.compactionFailureCount.inc();\n+        }\n+        compactionInProgress--;\n+      }\n+      doneLatch.get().countDown();\n+    } catch (Throwable th) {\n+      logger.error(\"Hit exception running compaction task\", th);\n+    } finally {\n+      long compactionTime = (System.currentTimeMillis() - compactionStartTime) / 1000;\n+      logger.info(\"Purged {} blobs in {} partitions taking {} seconds\", totalBlobsPurged, compactedPartitionCount,\n+          compactionTime);\n+    }\n+    return totalBlobsPurged;\n+  }\n+\n+  /**\n+   * Purge the inactive blobs in the specified partitions.\n+   * @param partition the {@link PartitionId} to compact.\n+   * @return the total number of blobs purged in the partition.\n+   */\n+  private int compactPartition(PartitionId partition) throws CloudStorageException {\n+    if (isShutDown()) {\n       logger.info(\"Skipping compaction due to shut down.\");\n       return 0;\n     }\n \n-    // TODO: adjust count when compaction uses multiple threads\n-    doneLatch.set(new CountDownLatch(1));\n-\n-    Set<PartitionId> partitionsSnapshot = new HashSet<>(partitions);\n-    logger.info(\"Beginning dead blob compaction for {} partitions\", partitions.size());\n-    long now = System.currentTimeMillis();\n-    long compactionStartTime = now;\n-    long timeToQuit = now + compactionTimeLimitMs;\n-    int totalBlobsPurged = 0;\n-    for (PartitionId partitionId : partitionsSnapshot) {\n-      String partitionPath = partitionId.toPathString();\n-      if (!partitions.contains(partitionId)) {\n-        // Looks like partition was reassigned since the loop started, so skip it\n-        continue;\n-      }\n+    logger.info(\"Beginning dead blob compaction for partition {}\", partition);\n \n-      try {\n-        totalBlobsPurged += cloudDestination.compactPartition(partitionPath);\n-      } catch (CloudStorageException ex) {\n-        logger.error(\"Compaction failed for partition {}\", partitionPath, ex);\n-        vcrMetrics.compactionFailureCount.inc();\n-      }\n+    String partitionPath = partition.toPathString();\n+    if (!partitions.contains(partition)) {\n+      // Looks like partition was reassigned since the loop started, so skip it\n+      logger.warn(\"Skipping compaction of Partition {} as the partition was reassigned\", partition);\n+      return 0;\n+    }\n \n-      if (System.currentTimeMillis() >= timeToQuit) {\n-        logger.info(\"Compaction terminated due to time limit exceeded.\");\n-        break;\n-      }\n-      if (isShuttingDown()) {\n-        logger.info(\"Compaction terminated due to shut down.\");\n-        break;\n-      }\n+    try {\n+      return cloudDestination.compactPartition(partitionPath);\n+    } catch (CloudStorageException ex) {\n+      logger.error(\"Compaction failed for partition {}\", partitionPath, ex);\n+      throw ex;", "originalCommit": "fbd1e9f1619f2a2c33380e1a761239d764fe8b5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjAyNQ==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437742025", "bodyText": "If exception would happen in compactPartition(), it would be thrown only when take().get() is called. It would have been ignored silently if there was no call to take().get.", "author": "ankagrawal", "createdAt": "2020-06-09T21:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NjcxOA==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437786718", "bodyText": "I am ok with it as I don't see any issue regarding ignoring exception silently.", "author": "jsjtzyy", "createdAt": "2020-06-10T00:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNTE3Mw==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437805173", "bodyText": "thanks.. one thing I wanted to note is that this code will actually never ignore the exception silently.\nThe way ExecutorCompletionService::take  works is that if any thread throws exception, it keeps the exception in its state without throwing out. But then when we call take() it looks at the state of the thread, and if the thread has returned some value, then it gives out the value with .get() call or if the thread has thrown exception, then it throws that exception on the take() call.\nSo in our code, we will never miss any exception, as we make sure to drain all the threads before shutdown.", "author": "ankagrawal", "createdAt": "2020-06-10T01:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MjE3Mg==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437842172", "bodyText": "Thanks for clarification. You mentioned \"The way ExecutorCompletionService::take works is that if any thread throws exception, it keeps the exception in its state without throwing out.\".\nI would like to know if this also applies to executorCompletionService.submit() and executor.execute() inside ExecutorCompletionService. If I understand correctly, once the task is submitted, executor.execute() may happen before ExecutorCompletionService::take and at that moment, is any occurred exception still held internally (without being thrown out)?  Correct me if I am wrong, thanks.", "author": "jsjtzyy", "createdAt": "2020-06-10T03:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2MjEwMw==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437862103", "bodyText": "Your understanding is right. Once the task is submitted, executor.execute() may happen anytime. However, if the user task that runs inside the execute() throws an exception, execute doesn't immediately throw the exception. It catches all the exception (including RunTimeException) and keeps it in its internal state. When take().get() is called, the Future::get method retrieves the outcome of the user task, figures out if the outcome of the task is an exception, and either throws the exception, or returns the result (outcome).\nSo until the get method is called no outcome (either exception or result) of user task is reported.\nFor more reference, do take a look at the ThreadPoolExecutor::runWorker and FutureTask::report methods of java executor library.", "author": "ankagrawal", "createdAt": "2020-06-10T05:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2NDk2NA==", "url": "https://github.com/linkedin/ambry/pull/1556#discussion_r437864964", "bodyText": "Thanks for thorough explanation, this clarifies everything. I am asking this because I had some issues with ScheduledExecutorService due to didn't catch exception correctly.", "author": "jsjtzyy", "createdAt": "2020-06-10T05:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjk2NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "962bdd16ee38316558b27cba5f469d9ffcb71f10", "url": "https://github.com/linkedin/ambry/commit/962bdd16ee38316558b27cba5f469d9ffcb71f10", "message": "Fix a comment.", "committedDate": "2020-06-09T21:50:45Z", "type": "commit"}, {"oid": "488c2a42a7f620f4b71cde3812c25df241784d45", "url": "https://github.com/linkedin/ambry/commit/488c2a42a7f620f4b71cde3812c25df241784d45", "message": "Make sure to shutdown the executor service.", "committedDate": "2020-06-09T21:54:47Z", "type": "commit"}]}