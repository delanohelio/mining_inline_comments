{"pr_number": 1452, "pr_title": "Misc fixes in adaptive tracker, cluster manager and partition state model", "pr_createdAt": "2020-04-02T05:31:35Z", "pr_url": "https://github.com/linkedin/ambry/pull/1452", "timeline": [{"oid": "b82a6d5b6b30c38207cd476cf8f7d417bfaa42b3", "url": "https://github.com/linkedin/ambry/commit/b82a6d5b6b30c38207cd476cf8f7d417bfaa42b3", "message": "Misc fixes in adaptive tracker, cluster manager and partition state model\n\n1. make adaptive tracker to support newly added partition/disk/node;\nOtherwise, it will throw NPE when handling new resouce.\n2. make DynamicClusterChangeHandler gracefully handle invalid string in\nInstanceConfig\n3. add ERROR -> OFFLINE state transition for resetting partition.", "committedDate": "2020-04-03T23:58:43Z", "type": "commit"}, {"oid": "e676f74236646b16bbd3402e9b227ac6c259ceda", "url": "https://github.com/linkedin/ambry/commit/e676f74236646b16bbd3402e9b227ac6c259ceda", "message": "more test cases for histogram NPE issue", "committedDate": "2020-04-04T04:27:24Z", "type": "commit"}, {"oid": "e676f74236646b16bbd3402e9b227ac6c259ceda", "url": "https://github.com/linkedin/ambry/commit/e676f74236646b16bbd3402e9b227ac6c259ceda", "message": "more test cases for histogram NPE issue", "committedDate": "2020-04-04T04:27:24Z", "type": "forcePushed"}, {"oid": "6020f92e842e50ca0df507e2e2c8d6ea984f84aa", "url": "https://github.com/linkedin/ambry/commit/6020f92e842e50ca0df507e2e2c8d6ea984f84aa", "message": "added some unit tests", "committedDate": "2020-04-05T06:24:14Z", "type": "commit"}, {"oid": "063e68351bdb66ab43d4665613439b207e0bb665", "url": "https://github.com/linkedin/ambry/commit/063e68351bdb66ab43d4665613439b207e0bb665", "message": "move helix participant metrics out of partition state model", "committedDate": "2020-04-05T20:56:04Z", "type": "commit"}, {"oid": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "url": "https://github.com/linkedin/ambry/commit/b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "message": "minor changes", "committedDate": "2020-04-06T17:06:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2OTAwMw==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404469003", "bodyText": "minor: logger.warn maybe?", "author": "ankagrawal", "createdAt": "2020-04-07T00:34:51Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java", "diffHunk": "@@ -333,7 +333,8 @@ private void addOrUpdateInstanceInfos(List<InstanceConfig> instanceConfigs) thro\n       Map<String, String> diskInfo = entry.getValue();\n       AmbryDisk disk = mountPathToDisk.getOrDefault(mountPath, null);\n       if (disk == null) {\n-        logger.info(\"Temporarily don't support adding new disk to existing node.\");\n+        logger.info(\"{} is a new disk or unrecognizable disk which is not supported on existing node {}.\", mountPath,", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java\nindex 94c1cf532..5a4c6735b 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/DynamicClusterChangeHandler.java\n\n@@ -333,7 +333,7 @@ public class DynamicClusterChangeHandler implements HelixClusterChangeHandler {\n       Map<String, String> diskInfo = entry.getValue();\n       AmbryDisk disk = mountPathToDisk.getOrDefault(mountPath, null);\n       if (disk == null) {\n-        logger.info(\"{} is a new disk or unrecognizable disk which is not supported on existing node {}.\", mountPath,\n+        logger.warn(\"{} is a new disk or unrecognizable disk which is not supported on existing node {}.\", mountPath,\n             instanceName);\n         // TODO support dynamically adding disk in the future\n         continue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDY0Nw==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470647", "bodyText": "For all the metrics related changes in this file, it might be cleaner to update the participantMetrics in finally block.", "author": "ankagrawal", "createdAt": "2020-04-07T00:40:46Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -481,11 +481,11 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n         statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n       }\n     } catch (Exception e) {\n-      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n       participantMetrics.errorStateCount.addAndGet(1);\n       throw e;\n+    } finally {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     }\n-    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     participantMetrics.bootstrapCount.addAndGet(1);\n     // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n     localPartitions.add(partitionName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDcxMQ==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470711", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:41:01Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.bootstrapCount.addAndGet(-1);\n+    participantMetrics.standbyCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeLeaderFromStandby(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.standbyCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -481,11 +481,11 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n         statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n       }\n     } catch (Exception e) {\n-      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n       participantMetrics.errorStateCount.addAndGet(1);\n       throw e;\n+    } finally {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     }\n-    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     participantMetrics.bootstrapCount.addAndGet(1);\n     // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n     localPartitions.add(partitionName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MDczMw==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404470733", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:41:07Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -454,62 +458,97 @@ boolean setStoppedReplicas(List<String> stoppedReplicas) {\n \n   @Override\n   public void onPartitionBecomeBootstrapFromOffline(String partitionName) {\n-    // 1. take actions in storage manager (add new replica if necessary)\n-    PartitionStateChangeListener storageManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 2. take actions in replication manager (add new replica if necessary)\n-    PartitionStateChangeListener replicationManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n-    // 3. take actions in stats manager (add new replica if necessary)\n-    PartitionStateChangeListener statsManagerListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n-    if (statsManagerListener != null) {\n-      statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n-    }\n+    // this method may be called when dynamically adding a new replica that is not present on local node previously. In\n+    // this case we don't change offline count as the metric was set to initial number of local partitions during startup.\n+    int offlineCountChange = localPartitions.contains(partitionName) ? -1 : 0;\n+    try {\n+      // 1. take actions in storage manager (add new replica if necessary)\n+      PartitionStateChangeListener storageManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n+      if (storageManagerListener != null) {\n+        storageManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 2. take actions in replication manager (add new replica if necessary)\n+      PartitionStateChangeListener replicationManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n+      if (replicationManagerListener != null) {\n+        replicationManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+      // 3. take actions in stats manager (add new replica if necessary)\n+      PartitionStateChangeListener statsManagerListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.StatsManagerListener);\n+      if (statsManagerListener != null) {\n+        statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    }\n+    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n+    participantMetrics.bootstrapCount.addAndGet(1);\n+    // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n+    localPartitions.add(partitionName);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromBootstrap(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n-      // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n-      // caught up with enough peer replicas.\n       try {\n+        replicationManagerListener.onPartitionBecomeStandbyFromBootstrap(partitionName);\n+        // after bootstrap is initiated in ReplicationManager, transition is blocked here and wait until local replica has\n+        // caught up with enough peer replicas.\n         replicaSyncUpManager.waitBootstrapCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Bootstrap was interrupted on partition {}\", partitionName);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Bootstrap failed or was interrupted\", BootstrapFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Bootstrap didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.bootstrapCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.bootstrapCount.addAndGet(-1);\n+    participantMetrics.standbyCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeLeaderFromStandby(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeLeaderFromStandby(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.standbyCount.addAndGet(-1);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);\n+    participantMetrics.leaderCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeStandbyFromLeader(String partitionName) {\n-    PartitionStateChangeListener cloudToStoreReplicationListener =\n-        partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n-    if (cloudToStoreReplicationListener != null) {\n-      cloudToStoreReplicationListener.onPartitionBecomeStandbyFromLeader(partitionName);\n+    try {\n+      PartitionStateChangeListener cloudToStoreReplicationListener =\n+          partitionStateChangeListeners.get(StateModelListenerType.CloudToStoreReplicationManagerListener);\n+      if (cloudToStoreReplicationListener != null) {\n+        cloudToStoreReplicationListener.onPartitionBecomeStandbyFromLeader(partitionName);\n+      }\n+    } catch (Exception e) {\n+      participantMetrics.leaderCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -481,11 +481,11 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n         statsManagerListener.onPartitionBecomeBootstrapFromOffline(partitionName);\n       }\n     } catch (Exception e) {\n-      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n       participantMetrics.errorStateCount.addAndGet(1);\n       throw e;\n+    } finally {\n+      participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     }\n-    participantMetrics.offlineCount.addAndGet(offlineCountChange);\n     participantMetrics.bootstrapCount.addAndGet(1);\n     // Here we directly add the partition into set even though it may already exit because the op should be idempotent)\n     localPartitions.add(partitionName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTIzNQ==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471235", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:42:51Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -568,26 +568,26 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      try {\n+    try {\n+      if (replicationManagerListener != null) {\n+\n         replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n         // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n         // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n-      } catch (InterruptedException e) {\n-        logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n-      } catch (StateTransitionException e) {\n-        logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw e;\n       }\n+    } catch (InterruptedException e) {\n+      logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n+    } catch (StateTransitionException e) {\n+      logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    } finally {\n+      participantMetrics.standbyCount.addAndGet(-1);\n     }\n-    participantMetrics.standbyCount.addAndGet(-1);\n     participantMetrics.inactiveCount.addAndGet(1);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTI2Mw==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471263", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:42:57Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n-      // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n-      // replicas have caught up with last PUT in local store.\n       try {\n+        replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+        // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n+        // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -568,26 +568,26 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      try {\n+    try {\n+      if (replicationManagerListener != null) {\n+\n         replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n         // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n         // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n-      } catch (InterruptedException e) {\n-        logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n-      } catch (StateTransitionException e) {\n-        logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw e;\n       }\n+    } catch (InterruptedException e) {\n+      logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n+    } catch (StateTransitionException e) {\n+      logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    } finally {\n+      participantMetrics.standbyCount.addAndGet(-1);\n     }\n-    participantMetrics.standbyCount.addAndGet(-1);\n     participantMetrics.inactiveCount.addAndGet(1);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTM5NQ==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471395", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:43:29Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -518,55 +557,79 @@ public void onPartitionBecomeInactiveFromStandby(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n-      // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n-      // replicas have caught up with last PUT in local store.\n       try {\n+        replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n+        // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n+        // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+        participantMetrics.standbyCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n+    participantMetrics.standbyCount.addAndGet(-1);\n+    participantMetrics.inactiveCount.addAndGet(1);\n   }\n \n   @Override\n   public void onPartitionBecomeOfflineFromInactive(String partitionName) {\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n     if (replicationManagerListener != null) {\n-      // 1. take actions in replication manager\n-      //    (1) set local store state to OFFLINE\n-      //    (2) initiate disconnection in ReplicaSyncUpManager\n-      replicationManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n-      // 2. wait until peer replicas have caught up with local replica\n       try {\n+        // 1. take actions in replication manager\n+        //    (1) set local store state to OFFLINE\n+        //    (2) initiate disconnection in ReplicaSyncUpManager\n+        replicationManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+        // 2. wait until peer replicas have caught up with local replica\n         // TODO considering moving wait disconnection logic into replication manager listener\n         replicaSyncUpManager.waitDisconnectionCompleted(partitionName);\n       } catch (InterruptedException e) {\n         logger.error(\"Disconnection was interrupted on partition {}\", partitionName);\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw new StateTransitionException(\"Disconnection failed or was interrupted\", DisconnectionFailure);\n       } catch (StateTransitionException e) {\n         logger.error(\"Disconnection didn't complete \", e);\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n         throw e;\n       }\n     }\n     // 3. take actions in storage manager (stop the store and update instanceConfig)\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeOfflineFromInactive(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.inactiveCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n+    participantMetrics.inactiveCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -568,26 +568,26 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n     // 2. replication manager initiates deactivation\n     PartitionStateChangeListener replicationManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.ReplicationManagerListener);\n-    if (replicationManagerListener != null) {\n-      try {\n+    try {\n+      if (replicationManagerListener != null) {\n+\n         replicationManagerListener.onPartitionBecomeInactiveFromStandby(partitionName);\n         // after deactivation is initiated in ReplicationManager, transition is blocked here and wait until enough peer\n         // replicas have caught up with last PUT in local store.\n         // TODO considering moving wait deactivation logic into replication manager listener\n         replicaSyncUpManager.waitDeactivationCompleted(partitionName);\n-      } catch (InterruptedException e) {\n-        logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n-      } catch (StateTransitionException e) {\n-        logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n-        participantMetrics.standbyCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw e;\n       }\n+    } catch (InterruptedException e) {\n+      logger.error(\"Deactivation was interrupted on partition {}\", partitionName);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw new StateTransitionException(\"Deactivation failed or was interrupted\", DeactivationFailure);\n+    } catch (StateTransitionException e) {\n+      logger.error(\"Deactivation didn't complete on partition {}\", partitionName, e);\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    } finally {\n+      participantMetrics.standbyCount.addAndGet(-1);\n     }\n-    participantMetrics.standbyCount.addAndGet(-1);\n     participantMetrics.inactiveCount.addAndGet(1);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3MTQ0MA==", "url": "https://github.com/linkedin/ambry/pull/1452#discussion_r404471440", "bodyText": "see above about finally.", "author": "ankagrawal", "createdAt": "2020-04-07T00:43:36Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -576,7 +639,32 @@ public void onPartitionBecomeDroppedFromOffline(String partitionName) {\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n     if (storageManagerListener != null) {\n-      storageManagerListener.onPartitionBecomeDroppedFromOffline(partitionName);\n+      try {\n+        storageManagerListener.onPartitionBecomeDroppedFromOffline(partitionName);\n+      } catch (Exception e) {\n+        participantMetrics.offlineCount.addAndGet(-1);\n+        participantMetrics.errorStateCount.addAndGet(1);\n+        throw e;\n+      }\n     }\n+    participantMetrics.offlineCount.addAndGet(-1);", "originalCommit": "b2699ff2c28bd5f48bd95e2132f6bfb81e5e6f85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 41a3c6f98..27e7e751e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -638,16 +631,16 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n     // failure and remove old replica from replication/stats manager)\n     PartitionStateChangeListener storageManagerListener =\n         partitionStateChangeListeners.get(StateModelListenerType.StorageManagerListener);\n-    if (storageManagerListener != null) {\n-      try {\n+    try {\n+      if (storageManagerListener != null) {\n         storageManagerListener.onPartitionBecomeDroppedFromOffline(partitionName);\n-      } catch (Exception e) {\n-        participantMetrics.offlineCount.addAndGet(-1);\n-        participantMetrics.errorStateCount.addAndGet(1);\n-        throw e;\n       }\n+    } catch (Exception e) {\n+      participantMetrics.errorStateCount.addAndGet(1);\n+      throw e;\n+    } finally {\n+      participantMetrics.offlineCount.addAndGet(-1);\n     }\n-    participantMetrics.offlineCount.addAndGet(-1);\n     participantMetrics.partitionDroppedCount.inc();\n   }\n \n"}}, {"oid": "62ed6718d418e35ea05cbcdf28f86367934d6f2f", "url": "https://github.com/linkedin/ambry/commit/62ed6718d418e35ea05cbcdf28f86367934d6f2f", "message": "address comments", "committedDate": "2020-04-07T16:24:31Z", "type": "commit"}]}