{"pr_number": 1580, "pr_title": "Add Iterator to index segment to reduce memory footprint in blobStoreStats", "pr_createdAt": "2020-07-01T20:09:19Z", "pr_url": "https://github.com/linkedin/ambry/pull/1580", "timeline": [{"oid": "628e63b27172545546bfbf91167575b15731e031", "url": "https://github.com/linkedin/ambry/commit/628e63b27172545546bfbf91167575b15731e031", "message": "Remove something", "committedDate": "2020-07-02T17:47:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTAwMA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449309000", "bodyText": "Is the purpose of copying the entries here to create a snapshot and avoid issues with the unsealed segment becoming sealed while iterating through it?", "author": "cgtz", "createdAt": "2020-07-02T23:31:42Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);\n         throw new IllegalStateException(message, e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;\n+    }\n+\n+    @Override\n+    public IndexEntry previous() {\n+      try {\n+        int i = cursor - 1;\n+        StoreKey key = getKeyAt(mmap, i);\n+        mmap.get(valueBuf);\n+        return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n+      } catch (Exception e) {\n+        String message = \"Failed to read index entry at \" + cursor;\n+        logger.error(message, e);\n+        throw new IllegalStateException(message, e);\n+      } finally {\n+        cursor--;\n+      }\n+    }\n+\n+    @Override\n+    public int nextIndex() {\n+      return cursor;\n+    }\n+\n+    @Override\n+    public int previousIndex() {\n+      return cursor - 1;\n+    }\n+\n+    @Override\n+    public void remove() {\n+      throw new UnsupportedOperationException(\"Remove unsupported\");\n+    }\n+\n+    @Override\n+    public void set(IndexEntry indexEntry) {\n+      throw new UnsupportedOperationException(\"Set unsupported\");\n+    }\n+\n+    @Override\n+    public void add(IndexEntry indexEntry) {\n+      throw new UnsupportedOperationException(\"Add unsupported\");\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link Iterator} for a unsealed {@link IndexSegment}.\n+   */\n+  private class UnsealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected final ArrayList<IndexEntry> entries = new ArrayList<>();\n+    protected final Iterator<IndexEntry> it;\n+\n+    UnsealedIndexSegmentEntryIterator() {\n+      NavigableMap<StoreKey, ConcurrentSkipListSet<IndexValue>> indexMap = index;\n+      StoreKey keyCursor = indexMap.firstKey();\n+      while (keyCursor != null) {\n+        ConcurrentSkipListSet<IndexValue> indexValues = indexMap.get(keyCursor);\n+        Iterator<IndexValue> it = indexValues.iterator();\n+        while (it.hasNext()) {\n+          entries.add(new IndexEntry(keyCursor, it.next()));", "originalCommit": "628e63b27172545546bfbf91167575b15731e031", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMTk1Mg==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449311952", "bodyText": "not really, we can keep a reference to the index map in the iterator so that even if it becomes sealed, we still have all the data we need in the memory. The reason really is for listiterator. Iterator iterate through entries from the smallest to the largest ( ordered by key then by offset), but what we need in the blobstorestats is a ListIterator that can iterate through entries from the largest to the smallest. There are ways to create iterator without making an arraylist of entries, but this is by far the easiest way. And it does not take up too much memory since there is no copy of IndexEntry while creating this list", "author": "justinlin-linkedin", "createdAt": "2020-07-02T23:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM2NjQzMQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r455366431", "bodyText": "agreed that this is probably the easiest way for now. I guess if we specifically wanted a reverse iterator (and not a general listiterator), you may be able to useindex.descendingMap() but we don't have to go this route unless we see a perf problem with the current approach.", "author": "cgtz", "createdAt": "2020-07-15T21:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex dc9ef6c81..8d70b4b37 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -1248,7 +1248,7 @@ class IndexSegment {\n \n     @Override\n     public IndexEntry next() {\n-      if (cursor < 0 || cursor > numberOfEntries) {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n         throw new NoSuchElementException();\n       }\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTgzNA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449309834", "bodyText": "If this exception thrown is caught and logged by the caller already, it may be better to remove these log messages to prevent double logging.", "author": "cgtz", "createdAt": "2020-07-02T23:35:18Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);", "originalCommit": "628e63b27172545546bfbf91167575b15731e031", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNjU1MA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r453806550", "bodyText": "removed", "author": "justinlin-linkedin", "createdAt": "2020-07-13T17:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMwOTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex dc9ef6c81..8d70b4b37 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -1248,7 +1248,7 @@ class IndexSegment {\n \n     @Override\n     public IndexEntry next() {\n-      if (cursor < 0 || cursor > numberOfEntries) {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n         throw new NoSuchElementException();\n       }\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMDg3MQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449310871", "bodyText": "add NoSuchElementCondition check to this method", "author": "cgtz", "createdAt": "2020-07-02T23:40:04Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n+        String message = \"Failed to read index entry at \" + cursor;\n         logger.error(message, e);\n         throw new IllegalStateException(message, e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;\n+    }\n+\n+    @Override\n+    public IndexEntry previous() {", "originalCommit": "628e63b27172545546bfbf91167575b15731e031", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNjQ3Ng==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r453806476", "bodyText": "updated", "author": "justinlin-linkedin", "createdAt": "2020-07-13T17:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMDg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex dc9ef6c81..8d70b4b37 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -1248,7 +1248,7 @@ class IndexSegment {\n \n     @Override\n     public IndexEntry next() {\n-      if (cursor < 0 || cursor > numberOfEntries) {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n         throw new NoSuchElementException();\n       }\n       try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMTI4MQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r449311281", "bodyText": "Is cursor < 0 possible?", "author": "cgtz", "createdAt": "2020-07-02T23:41:32Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,33 +1233,173 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor > numberOfEntries) {", "originalCommit": "628e63b27172545546bfbf91167575b15731e031", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4OTU2OA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r453789568", "bodyText": "SealedIndexSegmentEntryListIterator inherits this class, and it has method previous that would decrement cursor. I suppose it's possible, so put this statement here just in case.", "author": "justinlin-linkedin", "createdAt": "2020-07-13T16:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMTI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex dc9ef6c81..8d70b4b37 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -1248,7 +1248,7 @@ class IndexSegment {\n \n     @Override\n     public IndexEntry next() {\n-      if (cursor < 0 || cursor > numberOfEntries) {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n         throw new NoSuchElementException();\n       }\n       try {\n"}}, {"oid": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "url": "https://github.com/linkedin/ambry/commit/e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "message": "Comments", "committedDate": "2020-07-13T17:19:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjgyNQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r453986825", "bodyText": "Not a relevant comment but I feel a bit of confused about getSlice method (maybe you can clarify it for me). It basically does some throttling and returns a MAX_VALUE. I didn't see the reason to return permissible I/O value there (it seems the return value is never used in production code). If it's not used, the method is not straightforward to me.", "author": "jsjtzyy", "createdAt": "2020-07-13T22:37:51Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -427,10 +426,11 @@ public void close() {\n             StoreErrorCodes.Store_Shutting_Down);\n       }\n       long indexSegmentStartProcessTimeMs = time.milliseconds();\n-      forEachValidIndexEntry(indexSegment, getIndexEntries(indexSegment), referenceTimeInMs, deletedKeys, entry -> {\n+      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,", "originalCommit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwOTY3NA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454709674", "bodyText": "diskIOScheduler is for reading IndexEntries from indexSegment. Every time we read an index segment, we need to call getSlice method for throttling. This method doesn't return \"how much bytes you can read\", rather, it takes the number of bytes to read (operation to perform) as the last parameter and sleep within the method while the requested bytes exceed the allowance. That's why it always returns long.MAX_VALUE.", "author": "justinlin-linkedin", "createdAt": "2020-07-14T23:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1Njg4OA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r455256888", "bodyText": "I think when this was implemented, there were some ideas about eventually doing fancier things, like removing the sleep but instead giving the caller an allowance that they could use. This idea was never implemented, though, so none of the callers use the return value right now and just rely on the internal sleep.", "author": "cgtz", "createdAt": "2020-07-15T18:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4NjgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java b/ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java\nindex 98147ed84..c9e09b452 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java\n\n@@ -430,7 +433,8 @@ class BlobStoreStats implements StoreStats, Closeable {\n           indexSegment.size());\n       forEachValidIndexEntry(indexSegment, referenceTimeInMs, deletedKeys, entry -> {\n         IndexValue indexValue = entry.getValue();\n-        if (!indexValue.isDelete() && !indexValue.isTtlUpdate()) {\n+        if (!indexValue.isFlagSet(IndexValue.Flags.Ttl_Update_Index) && !indexValue.isFlagSet(\n+            IndexValue.Flags.Delete_Index)) {\n           // delete and TTL update records does not count towards valid data size for usage (containers)\n           updateNestedMapHelper(validDataSizePerContainer, \"A[\" + indexValue.getAccountId() + \"]\",\n               \"C[\" + indexValue.getContainerId() + \"]\", indexValue.getSize());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTM2Ng==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454019366", "bodyText": "I still don't quite understand why previously it needs a sort here, in case it's an unsealed index segment?\nAlso KEY_OFFSET_COMPARATOR can be removed.", "author": "jsjtzyy", "createdAt": "2020-07-14T00:08:48Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -484,100 +486,22 @@ public void close() {\n     return validSizePerLogSegment;\n   }\n \n-  /**\n-   * Get all {@link IndexEntry} in a given {@link IndexSegment}. There may be multiple entries for the same key\n-   * @param indexSegment the {@link IndexSegment} to fetch the index entries from\n-   * @return a {@link List} of all {@link IndexEntry} in the given {@link IndexSegment}. The returned list can have\n-   * multiple entries for the same key and is sorted in the ascending order of key,offset\n-   * @throws StoreException\n-   */\n-  private List<IndexEntry> getIndexEntries(IndexSegment indexSegment) throws StoreException {\n-    List<IndexEntry> indexEntries = new ArrayList<>();\n-    try {\n-      indexSegment.getIndexEntriesSince(null, new FindEntriesCondition(Long.MAX_VALUE), indexEntries, new AtomicLong(0),\n-          false);\n-      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,\n-          indexEntries.size());\n-      addPutEntriesForDelete(indexSegment.getStartOffset().getOffset(), indexEntries);\n-      indexEntries.sort(KEY_OFFSET_COMPARATOR);", "originalCommit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxMTkwNg==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454711906", "bodyText": "I have no idea either. After getIndexEntriesSince method, the list of index entries should be sorted according the the key_offset_comparator. After addPutEntriesForDelete, the order might be disturbed. But here we don't need to add put entries for the deleted. Put entries will be processed later.", "author": "justinlin-linkedin", "createdAt": "2020-07-14T23:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3NTE5Nw==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r455275197", "bodyText": "This comparator was added in PR #1011 related to supporting ttl updates.", "author": "cgtz", "createdAt": "2020-07-15T19:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3OTMzMA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r455279330", "bodyText": "I've always wondered why we used to have getPutValueFromDeleteEntry method, when we can't find the PUT entry for a given key using persistentIndex.findKey.", "author": "justinlin-linkedin", "createdAt": "2020-07-15T19:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxOTM2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyNjc2OQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454026769", "bodyText": "getPutRecordForDeletedKey can be removed as well", "author": "jsjtzyy", "createdAt": "2020-07-14T00:33:26Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreStats.java", "diffHunk": "@@ -484,100 +486,22 @@ public void close() {\n     return validSizePerLogSegment;\n   }\n \n-  /**\n-   * Get all {@link IndexEntry} in a given {@link IndexSegment}. There may be multiple entries for the same key\n-   * @param indexSegment the {@link IndexSegment} to fetch the index entries from\n-   * @return a {@link List} of all {@link IndexEntry} in the given {@link IndexSegment}. The returned list can have\n-   * multiple entries for the same key and is sorted in the ascending order of key,offset\n-   * @throws StoreException\n-   */\n-  private List<IndexEntry> getIndexEntries(IndexSegment indexSegment) throws StoreException {\n-    List<IndexEntry> indexEntries = new ArrayList<>();\n-    try {\n-      indexSegment.getIndexEntriesSince(null, new FindEntriesCondition(Long.MAX_VALUE), indexEntries, new AtomicLong(0),\n-          false);\n-      diskIOScheduler.getSlice(BlobStoreStats.IO_SCHEDULER_JOB_TYPE, BlobStoreStats.IO_SCHEDULER_JOB_ID,\n-          indexEntries.size());\n-      addPutEntriesForDelete(indexSegment.getStartOffset().getOffset(), indexEntries);\n-      indexEntries.sort(KEY_OFFSET_COMPARATOR);\n-      updateExpiryTimeForAllPuts(indexEntries);\n-    } catch (StoreException e) {\n-      throw new StoreException(\n-          String.format(\"Exception while getting entries from index segment for store %s : %s\", storeId,\n-              e.getMessage()), e, e.getErrorCode());\n-    }\n-    return indexEntries;\n-  }\n-\n-  /**\n-   * Adds put entries for any delete entries that may have squashed put entries in the same segment. Requires that a\n-   * put entry (if it exists) should occur before a delete entry for the same key in {@code indexEntries}\n-   * @param indexSegmentStartOffset the start offset of the {@link IndexSegment} from which {@code indexEntries} was\n-   *                                obtained\n-   * @param indexEntries the list of {@link IndexEntry} from the same {@link IndexSegment}. This list will be sorted\n-   *                     in the ascending order of key,offset\n-   * @throws StoreException if there are problems accessing the index\n-   */\n-  private void addPutEntriesForDelete(long indexSegmentStartOffset, List<IndexEntry> indexEntries)\n-      throws StoreException {\n-    Set<StoreKey> seenPuts = new HashSet<>();\n-    List<IndexEntry> newEntries = new ArrayList<>();\n-    for (IndexEntry entry : indexEntries) {\n-      IndexValue value = entry.getValue();\n-      if (value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-        if (value.getOriginalMessageOffset() != IndexValue.UNKNOWN_ORIGINAL_MESSAGE_OFFSET\n-            && value.getOriginalMessageOffset() < value.getOffset().getOffset()\n-            && value.getOriginalMessageOffset() >= indexSegmentStartOffset && !seenPuts.contains(entry.getKey())) {\n-          // We need to find the original put (if it has not already been processed)\n-          IndexValue originalPutValue = getPutRecordForDeletedKey(entry.getKey(), value);", "originalCommit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxMTk0OQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454711949", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-07-14T23:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyNjc2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTk0OA==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454035948", "bodyText": "why not cursor > 0 ?", "author": "jsjtzyy", "createdAt": "2020-07-14T01:02:31Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -1185,34 +1233,175 @@ static Offset getIndexSegmentStartOffset(String filename) {\n   }\n \n   /**\n-   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}. This {@link Iterator} should\n-   * only be used in the compaction so that the {@link IndexSegment} should be sealed already.\n+   * An {@link IndexEntry} {@link Iterator} for a sealed {@link IndexSegment}.\n    */\n-  class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n-    private int currentIdx = 0;\n-    private ByteBuffer mmap = serEntries.duplicate();\n-    private int numberOfEntries = numberOfEntries(mmap);\n-    private byte[] valueBuf = new byte[valueSize];\n+  private class SealedIndexSegmentEntryIterator implements Iterator<IndexEntry> {\n+    protected int cursor = 0;\n+    protected ByteBuffer mmap = serEntries.duplicate();\n+    protected int numberOfEntries = numberOfEntries(mmap);\n+    protected byte[] valueBuf = new byte[valueSize];\n \n     @Override\n     public boolean hasNext() {\n-      return currentIdx < numberOfEntries;\n+      return cursor < numberOfEntries;\n     }\n \n     @Override\n     public IndexEntry next() {\n+      if (cursor < 0 || cursor >= numberOfEntries) {\n+        throw new NoSuchElementException();\n+      }\n       try {\n-        StoreKey key = getKeyAt(mmap, currentIdx);\n+        StoreKey key = getKeyAt(mmap, cursor);\n         mmap.get(valueBuf);\n         return new IndexEntry(key, new IndexValue(startOffset.getName(), ByteBuffer.wrap(valueBuf), getVersion()));\n       } catch (Exception e) {\n-        String message = \"Failed to read index entry at \" + currentIdx;\n-        logger.error(message, e);\n-        throw new IllegalStateException(message, e);\n+        throw new IllegalStateException(\n+            \"Failed to read index entry at \" + cursor + \" in index segment file \" + indexFile.getAbsolutePath(), e);\n       } finally {\n-        currentIdx++;\n+        cursor++;\n       }\n     }\n   }\n+\n+  /**\n+   * An {@link IndexEntry} {@link ListIterator} for a sealed {@link IndexSegment}.\n+   */\n+  private class SealedIndexSegmentEntryListIterator extends SealedIndexSegmentEntryIterator\n+      implements ListIterator<IndexEntry> {\n+\n+    SealedIndexSegmentEntryListIterator(int currentIndex) {\n+      this.cursor = currentIndex;\n+    }\n+\n+    @Override\n+    public boolean hasPrevious() {\n+      return cursor != 0;", "originalCommit": "e7d6d2b3a5b2df11c9719bb6c933e045b79b4dba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxMTk4MQ==", "url": "https://github.com/linkedin/ambry/pull/1580#discussion_r454711981", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-07-14T23:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzNTk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex 8d70b4b37..dc9ef6c81 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -1248,7 +1248,7 @@ class IndexSegment implements Iterable<IndexEntry> {\n \n     @Override\n     public IndexEntry next() {\n-      if (cursor < 0 || cursor >= numberOfEntries) {\n+      if (cursor < 0 || cursor > numberOfEntries) {\n         throw new NoSuchElementException();\n       }\n       try {\n"}}, {"oid": "0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "url": "https://github.com/linkedin/ambry/commit/0d373b5711cf4fab83a1da60e6f999d9d38df8f7", "message": "Add Iterator to index segment to reduce memory footprint in blobstorestats", "committedDate": "2020-07-14T23:24:11Z", "type": "commit"}, {"oid": "39e13b4910a177a4c01a184ac11458c6ba792cbb", "url": "https://github.com/linkedin/ambry/commit/39e13b4910a177a4c01a184ac11458c6ba792cbb", "message": "change flags", "committedDate": "2020-07-14T23:24:11Z", "type": "commit"}, {"oid": "86c3663389bcb440651ef91caf7de55ac85c023e", "url": "https://github.com/linkedin/ambry/commit/86c3663389bcb440651ef91caf7de55ac85c023e", "message": "Remove something", "committedDate": "2020-07-14T23:24:11Z", "type": "commit"}, {"oid": "6ffbb26b3636b393d400c0f10cc5543bd4aa759c", "url": "https://github.com/linkedin/ambry/commit/6ffbb26b3636b393d400c0f10cc5543bd4aa759c", "message": "Comments", "committedDate": "2020-07-14T23:24:11Z", "type": "commit"}, {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2", "url": "https://github.com/linkedin/ambry/commit/2671631c45460971625a6b89ea0057f405cfb3c2", "message": "Comments", "committedDate": "2020-07-14T23:47:01Z", "type": "commit"}, {"oid": "2671631c45460971625a6b89ea0057f405cfb3c2", "url": "https://github.com/linkedin/ambry/commit/2671631c45460971625a6b89ea0057f405cfb3c2", "message": "Comments", "committedDate": "2020-07-14T23:47:01Z", "type": "forcePushed"}]}