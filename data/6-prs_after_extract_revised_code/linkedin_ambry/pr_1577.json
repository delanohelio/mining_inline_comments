{"pr_number": 1577, "pr_title": "Use DataNodeConfigSource in participant", "pr_createdAt": "2020-06-24T22:11:06Z", "pr_url": "https://github.com/linkedin/ambry/pull/1577", "timeline": [{"oid": "722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "url": "https://github.com/linkedin/ambry/commit/722b39b2fd1f5c4b4c57bbf41a2219e10d5cca25", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.", "committedDate": "2020-06-24T22:15:51Z", "type": "forcePushed"}, {"oid": "e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "url": "https://github.com/linkedin/ambry/commit/e3f00728b47c4b3abf8a4dcde11b42d70ff38c9a", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.", "committedDate": "2020-07-01T00:37:04Z", "type": "forcePushed"}, {"oid": "403650eac329d767ad651d9a2e13a9e4328ac7c4", "url": "https://github.com/linkedin/ambry/commit/403650eac329d767ad651d9a2e13a9e4328ac7c4", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.", "committedDate": "2020-07-13T17:21:14Z", "type": "forcePushed"}, {"oid": "684a4f90a115b29110839b5529a6534f80677cd1", "url": "https://github.com/linkedin/ambry/commit/684a4f90a115b29110839b5529a6534f80677cd1", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready.", "committedDate": "2020-07-16T21:34:34Z", "type": "forcePushed"}, {"oid": "5a8c5e329053687b3569f64e3306666982bd25e1", "url": "https://github.com/linkedin/ambry/commit/5a8c5e329053687b3569f64e3306666982bd25e1", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready.", "committedDate": "2020-07-16T21:52:08Z", "type": "forcePushed"}, {"oid": "22705eeb8f9c757bc367e4a626171842f9029e29", "url": "https://github.com/linkedin/ambry/commit/22705eeb8f9c757bc367e4a626171842f9029e29", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready.", "committedDate": "2020-07-16T22:27:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456215041", "bodyText": "I was thinking to use concurrent hashmap for this part but then realized that handling exception in lambda expression would be complicated (we might have to implement ThrowBiFunction and convert exception to runtime exception which is not elegant).", "author": "jsjtzyy", "createdAt": "2020-07-17T04:43:25Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -33,15 +40,73 @@\n    */\n   public HelixManager getZKHelixManager(String clusterName, String instanceName, InstanceType instanceType,\n       String zkAddr) {\n-    return HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    ManagerKey managerKey = new ManagerKey(clusterName, instanceName, instanceType, zkAddr);\n+    return helixManagers.computeIfAbsent(managerKey,\n+        k -> HelixManagerFactory.getZKHelixManager(clusterName, instanceName, instanceType, zkAddr));\n   }\n \n   /**\n-   * Get a reference to a {@link HelixAdmin}\n+   * Get a reference to a {@link HelixManager} and connect to it, if not already connected\n+   * @param clusterName the name of the cluster for which the manager is to be gotten.\n+   * @param instanceName the name of the instance on whose behalf the manager is to be gotten.\n+   * @param instanceType the {@link InstanceType} of the requester.\n    * @param zkAddr the address identifying the zk service to which this request is to be made.\n-   * @return the constructed {@link HelixAdmin}.\n+   * @return the constructed and connected {@link HelixManager}.\n+   * @throws Exception if connecting failed.\n+   */\n+  public HelixManager getZkHelixManagerAndConnect(String clusterName, String instanceName, InstanceType instanceType,\n+      String zkAddr) throws Exception {\n+    HelixManager manager = getZKHelixManager(clusterName, instanceName, instanceType, zkAddr);\n+    synchronized (manager) {\n+      if (!manager.isConnected()) {\n+        LOGGER.info(\"Connecting to HelixManager at {}\", zkAddr);\n+        manager.connect();\n+        LOGGER.info(\"Established connection to HelixManager at {}\", zkAddr);\n+      } else {\n+        LOGGER.info(\"HelixManager at {} already connected\", zkAddr);\n+      }\n+    }", "originalCommit": "22705eeb8f9c757bc367e4a626171842f9029e29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjk0NQ==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456216945", "bodyText": "Is there any case where two threads are attempting connecting same HelixManager concurrently?", "author": "jsjtzyy", "createdAt": "2020-07-17T04:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzNjUwMg==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456536502", "bodyText": "There should not be such a case in production since we would never start HelixClusterManager and HelixFactory in parallel. I put this here since there is nothing that strictly guarantees that will always be the case. If you feel that this is unneeded for now I could take it out.\nWe could move this into a Map.compute lambda, but I felt that this approach allowed for finer grained locking as we don't need the construction and connection to be atomic, we just need to make sure that after construction and adding to the map, only one thread does the check connected, connect sequence at a time.", "author": "cgtz", "createdAt": "2020-07-17T16:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODMxNQ==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456588315", "bodyText": "I am okay with this approach after more clarification. Let's keep it as it is.", "author": "jsjtzyy", "createdAt": "2020-07-17T17:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTA0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e14164eba031e90a8f4abf01072d45eadcae385e", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java\nindex 1f1a3aa6c..50d5c3c2e 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java\n\n@@ -102,11 +102,5 @@ public class HelixFactory {\n     public int hashCode() {\n       return Objects.hash(clusterName, instanceName, instanceType, zkAddr);\n     }\n-\n-    @Override\n-    public String toString() {\n-      return \"ManagerKey{\" + \"clusterName='\" + clusterName + '\\'' + \", instanceName='\" + instanceName + '\\''\n-          + \", instanceType=\" + instanceType + \", zkAddr='\" + zkAddr + '\\'' + '}';\n-    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNzI4OQ==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456217289", "bodyText": "nit: formate this file, thanks", "author": "jsjtzyy", "createdAt": "2020-07-17T04:52:40Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -21,7 +21,6 @@\n import com.github.ambry.utils.Utils;\n import java.io.IOException;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;", "originalCommit": "22705eeb8f9c757bc367e4a626171842f9029e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 1a7acc0fb..940833581 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -14,8 +14,11 @@\n package com.github.ambry.clustermap;\n \n import com.codahale.metrics.MetricRegistry;\n-import com.github.ambry.config.ClusterMapConfig;\n import com.github.ambry.commons.Callback;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n import com.github.ambry.server.AmbryHealthReport;\n import com.github.ambry.server.StatsSnapshot;\n import com.github.ambry.utils.Utils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNDA1Ng==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456224056", "bodyText": "minor: skipping removing it from config in Helix.\"", "author": "jsjtzyy", "createdAt": "2020-07-17T05:20:54Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -279,135 +278,81 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n \n       // 3. set InstanceConfig in Helix to persist replica disabled state\n       helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+      // TODO Have this method use DataNodeConfig for disabled replicas and InstanceConfig for enabled instances.\n       logger.info(\"Disabled state of partition {} is updated\", partitionName);\n     }\n   }\n \n   /**\n+   * Exposed for testing\n    * @return {@link HelixAdmin} that manages current data node.\n    */\n   public HelixAdmin getHelixAdmin() {\n     return helixAdmin;\n   }\n \n   /**\n-   * Add new replica info into {@link InstanceConfig} of current data node.\n-   * @param replicaId new replica whose info should be added into {@link InstanceConfig}.\n-   * @param instanceConfig the {@link InstanceConfig} to update.\n+   * Add new replica info into {@link DataNodeConfig} of current data node.\n+   * @param replicaId new replica whose info should be added into {@link DataNodeConfig}.\n+   * @param dataNodeConfig the {@link DataNodeConfig} to update.\n    * @return {@code true} replica info is successfully added. {@code false} otherwise.\n    */\n-  private boolean addNewReplicaInfo(ReplicaId replicaId, InstanceConfig instanceConfig) {\n+  private boolean addNewReplicaInfo(ReplicaId replicaId, DataNodeConfig dataNodeConfig) {\n     boolean additionResult = true;\n     String partitionName = replicaId.getPartitionId().toPathString();\n-    String newReplicaInfo =\n-        String.join(REPLICAS_STR_SEPARATOR, partitionName, String.valueOf(replicaId.getCapacityInBytes()),\n-            replicaId.getPartitionId().getPartitionClass()) + REPLICAS_DELIM_STR;\n-    Map<String, Map<String, String>> mountPathToDiskInfos = instanceConfig.getRecord().getMapFields();\n-    Map<String, String> diskInfo = mountPathToDiskInfos.get(replicaId.getMountPath());\n+    DataNodeConfig.ReplicaConfig replicaConfigToAdd = new DataNodeConfig.ReplicaConfig(replicaId.getCapacityInBytes(),\n+        replicaId.getPartitionId().getPartitionClass());\n+    DataNodeConfig.DiskConfig diskConfig = dataNodeConfig.getDiskConfigs().get(replicaId.getMountPath());\n     boolean newReplicaInfoAdded = false;\n-    boolean duplicateFound = false;\n-    if (diskInfo != null) {\n-      // add replica to an existing disk (need to sort replicas by partition id)\n-      String replicasStr = diskInfo.get(REPLICAS_STR);\n-      String[] replicaInfos = replicasStr.split(REPLICAS_DELIM_STR);\n-      StringBuilder replicasStrBuilder = new StringBuilder();\n-      long idToAdd = Long.parseLong(partitionName);\n-      for (String replicaInfo : replicaInfos) {\n-        String[] infos = replicaInfo.split(REPLICAS_STR_SEPARATOR);\n-        long currentId = Long.parseLong(infos[0]);\n-        if (currentId == idToAdd) {\n-          logger.info(\"Partition {} is already on instance {}, skipping adding it into InstanceConfig in Helix.\",\n-              partitionName, instanceName);\n-          duplicateFound = true;\n-          break;\n-        } else if (currentId < idToAdd || newReplicaInfoAdded) {\n-          replicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-        } else {\n-          // newReplicaInfo already contains delimiter, no need to append REPLICAS_DELIM_STR\n-          replicasStrBuilder.append(newReplicaInfo);\n-          replicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-          newReplicaInfoAdded = true;\n-        }\n-      }\n-      if (!duplicateFound && !newReplicaInfoAdded) {\n-        // this means new replica id is larger than all existing replicas' ids\n-        replicasStrBuilder.append(newReplicaInfo);\n+    if (diskConfig != null) {\n+      // add replica to an existing disk\n+      if (diskConfig.getReplicaConfigs().containsKey(partitionName)) {\n+        logger.info(\"Partition {} is already on instance {}, skipping adding it into configs in Helix.\", partitionName,\n+            instanceName);\n+      } else {\n+        diskConfig.getReplicaConfigs().put(partitionName, replicaConfigToAdd);\n         newReplicaInfoAdded = true;\n       }\n-      if (newReplicaInfoAdded) {\n-        diskInfo.put(REPLICAS_STR, replicasStrBuilder.toString());\n-        mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfo);\n-      }\n     } else {\n       // add replica onto a brand new disk\n       logger.info(\"Adding info of new replica {} to the new disk {}\", replicaId.getPartitionId().toPathString(),\n           replicaId.getDiskId());\n-      Map<String, String> diskInfoToAdd = new HashMap<>();\n-      diskInfoToAdd.put(DISK_CAPACITY_STR, Long.toString(replicaId.getDiskId().getRawCapacityInBytes()));\n-      diskInfoToAdd.put(DISK_STATE, AVAILABLE_STR);\n-      diskInfoToAdd.put(REPLICAS_STR, newReplicaInfo);\n-      mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfoToAdd);\n+      DataNodeConfig.DiskConfig diskConfigToAdd =\n+          new DataNodeConfig.DiskConfig(HardwareState.AVAILABLE, replicaId.getDiskId().getRawCapacityInBytes());\n+      diskConfigToAdd.getReplicaConfigs().put(partitionName, replicaConfigToAdd);\n+      dataNodeConfig.getDiskConfigs().put(replicaId.getMountPath(), diskConfigToAdd);\n       newReplicaInfoAdded = true;\n     }\n     if (newReplicaInfoAdded) {\n-      // we update InstanceConfig only when new replica info is added (skip updating if replica is already present)\n-      instanceConfig.getRecord().setMapFields(mountPathToDiskInfos);\n-      logger.info(\"Updating config: {} in Helix by adding partition {}\", instanceConfig, partitionName);\n-      additionResult = helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+      logger.info(\"Updating config: {} in Helix by adding partition {}\", dataNodeConfig, partitionName);\n+      additionResult = dataNodeConfigSource.set(dataNodeConfig);\n     }\n     return additionResult;\n   }\n \n   /**\n-   * Remove old/existing replica info from {@link InstanceConfig} that associates with current data node.\n+   * Remove old/existing replica info from {@link DataNodeConfig} that associates with current data node.\n    * @param replicaId the {@link ReplicaId} whose info should be removed.\n-   * @param instanceConfig {@link InstanceConfig} to update.\n+   * @param dataNodeConfig {@link DataNodeConfig} to update.\n    * @return {@code true} replica info is successfully removed. {@code false} otherwise.\n    */\n-  private boolean removeOldReplicaInfo(ReplicaId replicaId, InstanceConfig instanceConfig) {\n+  private boolean removeOldReplicaInfo(ReplicaId replicaId, DataNodeConfig dataNodeConfig) {\n     boolean removalResult = true;\n-    boolean instanceConfigUpdated = false;\n-    boolean replicaFound;\n+    boolean dataNodeConfigUpdated = false;\n     String partitionName = replicaId.getPartitionId().toPathString();\n-    List<String> stoppedReplicas = instanceConfig.getRecord().getListField(STOPPED_REPLICAS_STR);\n-    List<String> sealedReplicas = instanceConfig.getRecord().getListField(SEALED_STR);\n-    stoppedReplicas = stoppedReplicas == null ? new ArrayList<>() : stoppedReplicas;\n-    sealedReplicas = sealedReplicas == null ? new ArrayList<>() : sealedReplicas;\n-    if (stoppedReplicas.remove(partitionName) || sealedReplicas.remove(partitionName)) {\n+    boolean removedFromStopped = dataNodeConfig.getStoppedReplicas().remove(partitionName);\n+    boolean removedFromSealed = dataNodeConfig.getSealedReplicas().remove(partitionName);\n+    if (removedFromStopped || removedFromSealed) {\n       logger.info(\"Removing partition {} from stopped and sealed list\", partitionName);\n-      instanceConfig.getRecord().setListField(STOPPED_REPLICAS_STR, stoppedReplicas);\n-      instanceConfig.getRecord().setListField(SEALED_STR, sealedReplicas);\n-      instanceConfigUpdated = true;\n+      dataNodeConfigUpdated = true;\n     }\n-    Map<String, Map<String, String>> mountPathToDiskInfos = instanceConfig.getRecord().getMapFields();\n-    Map<String, String> diskInfo = mountPathToDiskInfos.get(replicaId.getMountPath());\n-    if (diskInfo != null) {\n-      String replicasStr = diskInfo.get(REPLICAS_STR);\n-      if (!replicasStr.isEmpty()) {\n-        List<String> replicaInfos = new ArrayList<>(Arrays.asList(replicasStr.split(REPLICAS_DELIM_STR)));\n-        // if any element is removed, that means old replica is found in replicasStr.\n-        replicaFound = replicaInfos.removeIf(info -> (info.split(REPLICAS_STR_SEPARATOR)[0]).equals(partitionName));\n-\n-        // We update InstanceConfig only when replica is found in current instanceConfig. (This is to avoid unnecessary\n-        // notification traffic due to InstanceConfig change)\n-        if (replicaFound) {\n-          StringBuilder newReplicasStrBuilder = new StringBuilder();\n-          // note that old replica info has been removed from \"replicaInfos\"\n-          for (String replicaInfo : replicaInfos) {\n-            newReplicasStrBuilder.append(replicaInfo).append(REPLICAS_DELIM_STR);\n-          }\n-          // update diskInfo and MountPathToDisk map\n-          diskInfo.put(REPLICAS_STR, newReplicasStrBuilder.toString());\n-          mountPathToDiskInfos.put(replicaId.getMountPath(), diskInfo);\n-          // update InstanceConfig\n-          instanceConfig.getRecord().setMapFields(mountPathToDiskInfos);\n-          instanceConfigUpdated = true;\n-        }\n-      }\n+    DataNodeConfig.DiskConfig diskConfig = dataNodeConfig.getDiskConfigs().get(replicaId.getMountPath());\n+    if (diskConfig != null) {\n+      dataNodeConfigUpdated = diskConfig.getReplicaConfigs().remove(partitionName) != null;\n     }\n-    if (instanceConfigUpdated) {\n-      logger.info(\"Updating config: {} in Helix by removing partition {}\", instanceConfig, partitionName);\n-      removalResult = helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig);\n+    if (dataNodeConfigUpdated) {\n+      logger.info(\"Updating config: {} in Helix by removing partition {}\", dataNodeConfig, partitionName);\n+      removalResult = dataNodeConfigSource.set(dataNodeConfig);\n     } else {\n       logger.warn(\"Partition {} is not found on instance {}, skipping removing it from InstanceConfig in Helix.\",", "originalCommit": "22705eeb8f9c757bc367e4a626171842f9029e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "chunk": "diff --git a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\nindex 1a7acc0fb..940833581 100644\n--- a/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n+++ b/ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java\n\n@@ -291,14 +297,21 @@ public class HelixParticipant implements ClusterParticipant, PartitionStateChang\n     return helixAdmin;\n   }\n \n+  /**\n+   * Mark disablePartitionsComplete = true, this is exposed for testing only.\n+   */\n+  protected void markDisablePartitionComplete() {\n+    disablePartitionsComplete = true;\n+  }\n+\n   /**\n    * Add new replica info into {@link DataNodeConfig} of current data node.\n    * @param replicaId new replica whose info should be added into {@link DataNodeConfig}.\n-   * @param dataNodeConfig the {@link DataNodeConfig} to update.\n    * @return {@code true} replica info is successfully added. {@code false} otherwise.\n    */\n-  private boolean addNewReplicaInfo(ReplicaId replicaId, DataNodeConfig dataNodeConfig) {\n+  private boolean addNewReplicaInfo(ReplicaId replicaId) {\n     boolean additionResult = true;\n+    DataNodeConfig dataNodeConfig = getDataNodeConfig();\n     String partitionName = replicaId.getPartitionId().toPathString();\n     DataNodeConfig.ReplicaConfig replicaConfigToAdd = new DataNodeConfig.ReplicaConfig(replicaId.getCapacityInBytes(),\n         replicaId.getPartitionId().getPartitionClass());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNTU1Nw==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456225557", "bodyText": "minor: new line", "author": "jsjtzyy", "createdAt": "2020-07-17T05:26:22Z", "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java", "diffHunk": "@@ -109,10 +108,5 @@ public void testSetGetListener() throws Exception {\n       assertEquals(\"get() call returned incorrect result\", config, source.get(config.getInstanceName()));\n     }\n     assertNull(\"Should not receive non-existent instance\", source.get(\"abc\"));\n-\n-    source.setHelixAdmin(null);\n-    TestUtils.assertException(NullPointerException.class, () -> source.set(createConfig(1, 1)), null);\n-    String firstInstance = allConfigs.iterator().next().getInstanceName();\n-    TestUtils.assertException(NullPointerException.class, () -> source.get(firstInstance), null);\n   }\n }", "originalCommit": "22705eeb8f9c757bc367e4a626171842f9029e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "chunk": "diff --git a/ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java b/ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java\nindex 2b8ab1c2b..15b7049f3 100644\n--- a/ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java\n+++ b/ambry-clustermap/src/test/java/com/github/ambry/clustermap/InstanceConfigToDataNodeConfigAdapterTest.java\n\n@@ -109,4 +108,4 @@ public class InstanceConfigToDataNodeConfigAdapterTest extends DataNodeConfigSou\n     }\n     assertNull(\"Should not receive non-existent instance\", source.get(\"abc\"));\n   }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNTk4Nw==", "url": "https://github.com/linkedin/ambry/pull/1577#discussion_r456225987", "bodyText": "Package private? (If this method will be called in int-test, just ignore this comment)", "author": "jsjtzyy", "createdAt": "2020-07-17T05:28:12Z", "path": "ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java", "diffHunk": "@@ -398,6 +400,13 @@ long getTotalDiskCapacity() {\n     return totalDiskCapacity;\n   }\n \n+  /**\n+   * @return the number of calls to the {@link #setInstanceConfig} method.\n+   */\n+  public int getSetInstanceConfigCallCount() {", "originalCommit": "22705eeb8f9c757bc367e4a626171842f9029e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "chunk": "diff --git a/ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java b/ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java\nindex cad47d410..c4b17eea8 100644\n--- a/ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java\n+++ b/ambry-clustermap/src/test/java/com/github/ambry/clustermap/MockHelixAdmin.java\n\n@@ -403,7 +403,7 @@ public class MockHelixAdmin implements HelixAdmin {\n   /**\n    * @return the number of calls to the {@link #setInstanceConfig} method.\n    */\n-  public int getSetInstanceConfigCallCount() {\n+  int getSetInstanceConfigCallCount() {\n     return setInstanceConfigCallCount;\n   }\n \n"}}, {"oid": "c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "url": "https://github.com/linkedin/ambry/commit/c9cbddb942c4ba3d91a1703e34f9adafd1cdc282", "message": "Use DataNodeConfigSource in participant\n\nUse DataNodeConfigSource as an abstraction around HelixAdmin and\nInstanceConfigs in HelixParticipant to allow for future configurable\nimplementations to be plugged into this class.\n\nFor now, this only supports InstanceConfigToDataNodeConfigAdapter, but\nwill be modified to allow configuration in future commits.\n\nThis commit switches HelixParticipant to use a shared spectator\nHelixManager instance for any config manipulation. This\navoids the need to construct a temporary HelixAdmin before the\n\"official\" admin is ready.", "committedDate": "2020-07-17T19:13:16Z", "type": "commit"}, {"oid": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "url": "https://github.com/linkedin/ambry/commit/5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "message": "Address Yingyi's comments", "committedDate": "2020-07-17T19:34:00Z", "type": "commit"}, {"oid": "5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "url": "https://github.com/linkedin/ambry/commit/5be1f1d6c9b4a4f840bb5d33b8a3595a8f19412e", "message": "Address Yingyi's comments", "committedDate": "2020-07-17T19:34:00Z", "type": "forcePushed"}, {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e", "url": "https://github.com/linkedin/ambry/commit/e14164eba031e90a8f4abf01072d45eadcae385e", "message": "Fix erasure of HELIX_DISABLED_PARTITIONS field", "committedDate": "2020-07-20T20:15:47Z", "type": "commit"}, {"oid": "e14164eba031e90a8f4abf01072d45eadcae385e", "url": "https://github.com/linkedin/ambry/commit/e14164eba031e90a8f4abf01072d45eadcae385e", "message": "Fix erasure of HELIX_DISABLED_PARTITIONS field", "committedDate": "2020-07-20T20:15:47Z", "type": "forcePushed"}]}