{"pr_number": 1444, "pr_title": "Change BlobStore so records can have a lifeVersion rather than -1", "pr_createdAt": "2020-03-28T00:27:05Z", "pr_url": "https://github.com/linkedin/ambry/pull/1444", "timeline": [{"oid": "2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "url": "https://github.com/linkedin/ambry/commit/2e96b748115a07cbbf83e8dabcd81ef8bff4da3e", "message": "Fix", "committedDate": "2020-04-01T20:03:28Z", "type": "forcePushed"}, {"oid": "a8eb308915b60225a55fbb9b8eb204880df5343a", "url": "https://github.com/linkedin/ambry/commit/a8eb308915b60225a55fbb9b8eb204880df5343a", "message": "Change BlobStore so records can have a lifeVersion rather than -1", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "1451543b9e79cd4ab783631a43af5a3dd51b56d8", "url": "https://github.com/linkedin/ambry/commit/1451543b9e79cd4ab783631a43af5a3dd51b56d8", "message": "Fix test", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "57e6bb055e2a8a542372fa7e991e247bf86966b7", "url": "https://github.com/linkedin/ambry/commit/57e6bb055e2a8a542372fa7e991e247bf86966b7", "message": "Fix the test failure again", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "3c3a7c428027fbc61567f9766eb917f7dd95ec90", "url": "https://github.com/linkedin/ambry/commit/3c3a7c428027fbc61567f9766eb917f7dd95ec90", "message": "Fix the test", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "message": "Fix", "committedDate": "2020-04-01T20:40:22Z", "type": "commit"}, {"oid": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "url": "https://github.com/linkedin/ambry/commit/bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "message": "Fix", "committedDate": "2020-04-01T20:40:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA1NzMwNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r401057307", "bodyText": "nit: is triggered", "author": "jsjtzyy", "createdAt": "2020-03-31T16:40:04Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java", "diffHunk": "@@ -22,6 +22,8 @@\n  */\n public class MessageInfo {\n \n+  // The life version when the operation is trigger by the requests from frontend.", "originalCommit": "2f279b259571be0c1fd1d7590388d67b2ecdb1ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java b/ambry-api/src/main/java/com/github/ambry/store/MessageInfo.java\nsimilarity index 99%\nrename from ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java\nrename to ambry-api/src/main/java/com/github/ambry/store/MessageInfo.java\nindex ead4738e0..8d9e51749 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/MessageInfo.java\n+++ b/ambry-api/src/main/java/com/github/ambry/store/MessageInfo.java\n\n@@ -22,7 +22,7 @@ import java.util.Objects;\n  */\n public class MessageInfo {\n \n-  // The life version when the operation is trigger by the requests from frontend.\n+  // The life version when the operation is triggered by the requests from frontend.\n   public final static short LIFE_VERSION_FROM_FRONTEND = -1;\n   private final StoreKey key;\n   private final long size;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjE2OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722168", "bodyText": "This can be INFO level. (I finally understand this after reading your comment in BlobIdTransformer)", "author": "jsjtzyy", "createdAt": "2020-04-03T03:50:26Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NDYyNg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402764626", "bodyText": "I will change this to trace. This doesn't seem like an important message to have. I set this to warn when testing.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\nindex 68d335952..3a288739e 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\n\n@@ -69,7 +69,7 @@ public class ValidatingTransformer implements Transformer {\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n         if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n-          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+          logger.trace(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n               + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n         }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402722917", "bodyText": "Any concern to use msgInfo.isUndeleted() instead of false here ? The reason I am asking is in the future we probably forget to update this hard coded value.", "author": "jsjtzyy", "createdAt": "2020-04-03T03:54:01Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java", "diffHunk": "@@ -65,24 +68,29 @@ public TransformationOutput transform(Message message) {\n       MessageHeader_Format header = getMessageHeader(version, headerBuffer);\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n+        if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n+          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+              + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n+        }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n         props = deserializeBlobProperties(msgStream);\n         metadata = deserializeUserMetadata(msgStream);\n         blobData = deserializeBlob(msgStream);\n       } else {\n-        throw new IllegalStateException(\"Message cannot be a deleted record \");\n+        throw new IllegalStateException(\"Message cannot be anything rather than put record \");\n       }\n       if (msgInfo.getStoreKey().equals(keyInStream)) {\n         // BlobIDTransformer only exists on ambry-server and replication between servers is relying on blocking channel\n         // which is still using java ByteBuffer. So, no need to consider releasing stuff.\n         // @todo, when netty Bytebuf is adopted for blocking channel on ambry-server, remember to release this ByteBuf.\n         PutMessageFormatInputStream transformedStream =\n             new PutMessageFormatInputStream(keyInStream, encryptionKey, props, metadata,\n-                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType());\n+                new ByteBufInputStream(blobData.content(), true), blobData.getSize(), blobData.getBlobType(),\n+                msgInfo.getLifeVersion());\n         MessageInfo transformedMsgInfo =\n             new MessageInfo(keyInStream, transformedStream.getSize(), msgInfo.isDeleted(), msgInfo.isTtlUpdated(),\n-                msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(), msgInfo.getContainerId(),\n-                msgInfo.getOperationTimeMs());\n+                false, msgInfo.getExpirationTimeInMs(), msgInfo.getCrc(), msgInfo.getAccountId(),", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNTYxMA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402725610", "bodyText": "Actually, after second thought, shouldn't this be false for all three boolean variables (deleted, ttlUpdated, undeleted)? Since this is PUT record only, hmm, probably isTtlUpdated() is still required. (Correct me if I am wrong)", "author": "jsjtzyy", "createdAt": "2020-04-03T04:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NTAwNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402765007", "bodyText": "you are right, this is a put, all the flags would e nullified anyway in the PersistentIndex anyway. But we still have to keep ttl update flag to be the same value as in the messageinfo since we will latter use it to apply a ttl update record.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\nindex 68d335952..3a288739e 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/ValidatingTransformer.java\n\n@@ -69,7 +69,7 @@ public class ValidatingTransformer implements Transformer {\n       StoreKey keyInStream = storeKeyFactory.getStoreKey(new DataInputStream(msgStream));\n       if (header.isPutRecord()) {\n         if (header.hasLifeVersion() && header.getLifeVersion() != msgInfo.getLifeVersion()) {\n-          logger.warn(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n+          logger.trace(\"LifeVersion in stream: \" + header.getLifeVersion() + \" failed to match lifeVersion from Index: \"\n               + msgInfo.getLifeVersion() + \" for key \" + keyInStream);\n         }\n         encryptionKey = header.hasEncryptionKeyRecord() ? deserializeBlobEncryptionKey(msgStream) : null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyODMxOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402728319", "bodyText": "Why do we need this log? Can it be debug level?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:19:06Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -182,6 +182,7 @@ public void handlePutRequest(NetworkRequest request) throws IOException, Interru\n         metrics.blobSizeInBytes.update(receivedRequest.getBlobSize());\n         metrics.blobUserMetadataSizeInBytes.update(receivedRequest.getUsermetadata().limit());\n         if (notification != null) {\n+          logger.info(\"AmbryRequests: write key \" + receivedRequest.getBlobId() + \" at port \" + currentNode.getPort());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NTU1OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402765558", "bodyText": "sorry this is for testing, will remove it", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyODMxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java b/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\nindex 622a65937..776baf9c5 100644\n--- a/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\n+++ b/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\n\n@@ -182,7 +182,6 @@ public class AmbryRequests implements RequestAPI {\n         metrics.blobSizeInBytes.update(receivedRequest.getBlobSize());\n         metrics.blobUserMetadataSizeInBytes.update(receivedRequest.getUsermetadata().limit());\n         if (notification != null) {\n-          logger.info(\"AmbryRequests: write key \" + receivedRequest.getBlobId() + \" at port \" + currentNode.getPort());\n           notification.onBlobReplicaCreated(currentNode.getHostname(), currentNode.getPort(),\n               receivedRequest.getBlobId().getID(), BlobReplicaSourceType.PRIMARY);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402729785", "bodyText": "Sorry, I forgot why we use this ctor of MessageInfo when handling undelete request, in which undeleted is false. Could you explain again?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:26:04Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java", "diffHunk": "@@ -651,7 +654,7 @@ public void handleUndeleteRequest(NetworkRequest request) throws IOException, In\n         BlobId convertedBlobId = (BlobId) convertedStoreKey;\n         MessageInfo info =\n             new MessageInfo(convertedBlobId, -1, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n-                undeleteRequest.getOperationTimeMs());\n+                undeleteRequest.getOperationTimeMs(), MessageInfo.LIFE_VERSION_FROM_FRONTEND);", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NjkwMA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402766900", "bodyText": "The message info serves different purposes in different components. When transmitting it between server and server or between server and frontend, it carries the current state of the blob, so it has to has undelete/delete/ttl update flags. When passing it to blobstore method, it only carries the key, operation timestamp and the the lifeVersion. For example, then passing message info to blobstore.undelete, we know we have to undelete this blob so the undelete flag will be ignored.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyODI2Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403128267", "bodyText": "This makes sense, but it doesn't have any side effect if we explicitly specify undelete is true in the ctor, does it?", "author": "jsjtzyy", "createdAt": "2020-04-03T16:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1NzE2Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403157167", "bodyText": "it doesn't matter. I will update and add more comments.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T17:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyOTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "chunk": "diff --git a/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java b/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\nindex 622a65937..41a0af72a 100644\n--- a/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\n+++ b/ambry-protocol/src/main/java/com/github/ambry/protocol/AmbryRequests.java\n\n@@ -652,9 +651,9 @@ public class AmbryRequests implements RequestAPI {\n         response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n       } else {\n         BlobId convertedBlobId = (BlobId) convertedStoreKey;\n-        MessageInfo info =\n-            new MessageInfo(convertedBlobId, -1, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n-                undeleteRequest.getOperationTimeMs(), MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+        MessageInfo info = new MessageInfo(convertedBlobId, -1, false, false, true, Utils.Infinite_Time, null,\n+            convertedBlobId.getAccountId(), convertedBlobId.getContainerId(), undeleteRequest.getOperationTimeMs(),\n+            MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n         Store storeToUndelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n         short lifeVersion = storeToUndelete.undelete(info);\n         response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMDczNw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402730737", "bodyText": "can be INFO level", "author": "jsjtzyy", "createdAt": "2020-04-03T04:30:18Z", "path": "ambry-replication/src/main/java/com/github/ambry/replication/BlobIdTransformer.java", "diffHunk": "@@ -157,6 +160,12 @@ private Message newMessage(InputStream inputStream, StoreKey newKey, MessageInfo\n     BlobId newBlobId = (BlobId) newKey;\n \n     if (headerFormat.isPutRecord()) {\n+      if (headerFormat.hasLifeVersion() && headerFormat.getLifeVersion() != oldMessageInfo.getLifeVersion()) {\n+        // The original Put buffer might have lifeVersion as 0, but the message info might have a higher lifeVersion.\n+        logger.trace(", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2NzM1OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402767358", "bodyText": "I will keep it as trace, this is not really important.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMDczNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjUxNQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732515", "bodyText": "Try to understand why we don't insert infoFound.getLifeVersion() into constructed new message info.", "author": "jsjtzyy", "createdAt": "2020-04-03T04:38:00Z", "path": "ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java", "diffHunk": "@@ -204,6 +204,11 @@ public void send(Send request) {\n                 infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), true, false,\n                     putMsgInfo.getExpirationTimeInMs(), putMsgInfo.getAccountId(), putMsgInfo.getContainerId(),\n                     putMsgInfo.getOperationTimeMs());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2ODY2MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402768660", "bodyText": "oh, we should, will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java b/ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java\nindex e95ed8754..1e1d9d901 100644\n--- a/ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java\n+++ b/ambry-replication/src/test/java/com/github/ambry/replication/MockConnectionPool.java\n\n@@ -201,9 +201,9 @@ public class MockConnectionPool implements ConnectionPool {\n               // looks for. Just set the deleted flag to true for the constructed MessageInfo from Put.\n               if (infoFound.isDeleted()) {\n                 MessageInfo putMsgInfo = getMessageInfo(infoFound.getStoreKey(), messageInfoList, false, false, false);\n-                infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), true, false,\n-                    putMsgInfo.getExpirationTimeInMs(), putMsgInfo.getAccountId(), putMsgInfo.getContainerId(),\n-                    putMsgInfo.getOperationTimeMs());\n+                infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), true, false, false,\n+                    putMsgInfo.getExpirationTimeInMs(), null, putMsgInfo.getAccountId(), putMsgInfo.getContainerId(),\n+                    putMsgInfo.getOperationTimeMs(), infoFound.getLifeVersion());\n               } else if (infoFound.isUndeleted()) {\n                 MessageInfo putMsgInfo = getMessageInfo(infoFound.getStoreKey(), messageInfoList, false, false, false);\n                 infoFound = new MessageInfo(putMsgInfo.getStoreKey(), putMsgInfo.getSize(), false, false, true,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402732991", "bodyText": "I am curious how much difference it has with this minor change.", "author": "jsjtzyy", "createdAt": "2020-04-03T04:40:13Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java", "diffHunk": "@@ -488,7 +488,7 @@ void trackUpdate(String host, int port, UpdateType updateType) {\n    * @throws InterruptedException\n    */\n   boolean awaitBlobCreations() throws InterruptedException {\n-    return creationHelper.await(10, TimeUnit.SECONDS);\n+    return creationHelper.await(11, TimeUnit.SECONDS);", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc2OTM5Mw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402769393", "bodyText": "typo", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMjk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java b/ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java\nindex d89fe7652..9c1eac488 100644\n--- a/ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java\n+++ b/ambry-server/src/integration-test/java/com/github/ambry/server/MockCluster.java\n\n@@ -488,7 +488,7 @@ class EventTracker {\n    * @throws InterruptedException\n    */\n   boolean awaitBlobCreations() throws InterruptedException {\n-    return creationHelper.await(11, TimeUnit.SECONDS);\n+    return creationHelper.await(10, TimeUnit.SECONDS);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQyNg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733426", "bodyText": "if this is no longer valid, can we remove it?", "author": "jsjtzyy", "createdAt": "2020-04-03T04:42:15Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -141,10 +141,11 @@ public void run() {\n                     System.out.println(exceptionMsg);\n                     throw new IllegalStateException(exceptionMsg);\n                   }\n-                  checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput));\n+                  // blob property doesn't have the correct expiration time after ttl update.\n+                  //checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput), \"blobproperty\");", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3MDU3MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402770570", "bodyText": "yeap", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQyNg=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java b/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\nindex 7a6697237..a2139f073 100644\n--- a/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\n+++ b/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\n\n@@ -141,8 +141,6 @@ class Verifier implements Runnable {\n                     System.out.println(exceptionMsg);\n                     throw new IllegalStateException(exceptionMsg);\n                   }\n-                  // blob property doesn't have the correct expiration time after ttl update.\n-                  //checkExpiryTimeMatch(payload, ServerTestUtil.getExpiryTimeMs(propertyOutput), \"blobproperty\");\n                   long actualExpiryTimeMs =\n                       resp.getPartitionResponseInfoList().get(0).getMessageInfoList().get(0).getExpirationTimeInMs();\n                   checkExpiryTimeMatch(payload, actualExpiryTimeMs, \"messageinfo in blobproperty\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczMzQ4OA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402733488", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-04-03T04:42:30Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java", "diffHunk": "@@ -240,22 +241,27 @@ public void run() {\n                   if (ByteBuffer.wrap(blobout).compareTo(ByteBuffer.wrap(payload.blob)) != 0) {\n                     throw new IllegalStateException();\n                   }\n-                  checkExpiryTimeMatch(payload,\n-                      ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()));\n+                  //checkExpiryTimeMatch(payload,\n+                  //    ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()),\n+                  //    \"blobproperty in bloball\");", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java b/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\nindex 7a6697237..a2139f073 100644\n--- a/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\n+++ b/ambry-server/src/integration-test/java/com/github/ambry/server/Verifier.java\n\n@@ -241,9 +239,6 @@ class Verifier implements Runnable {\n                   if (ByteBuffer.wrap(blobout).compareTo(ByteBuffer.wrap(payload.blob)) != 0) {\n                     throw new IllegalStateException();\n                   }\n-                  //checkExpiryTimeMatch(payload,\n-                  //    ServerTestUtil.getExpiryTimeMs(blobAll.getBlobInfo().getBlobProperties()),\n-                  //    \"blobproperty in bloball\");\n                   long actualExpiryTimeMs =\n                       resp.getPartitionResponseInfoList().get(0).getMessageInfoList().get(0).getExpirationTimeInMs();\n                   checkExpiryTimeMatch(payload, actualExpiryTimeMs, \"messageinfo in bloball\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDA2OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402740069", "bodyText": "Is this for debug purpose? If it's really worth logging, how about using logger.trace ?", "author": "jsjtzyy", "createdAt": "2020-04-03T05:10:45Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -410,15 +409,21 @@ public void put(MessageWriteSet messageSetToWrite) throws StoreException {\n             ArrayList<IndexEntry> indexEntries = new ArrayList<>(messageInfo.size());\n             for (MessageInfo info : messageInfo) {\n               FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-              IndexValue value = new IndexValue(info.getSize(), fileSpan.getStartOffset(), info.getExpirationTimeInMs(),\n-                  info.getOperationTimeMs(), info.getAccountId(), info.getContainerId());\n+              // Put from frontend should always use 0 as lifeVersion. (0 is the starting life version number for any data).\n+              // Put from replication or recovery should use liferVersion as it's.\n+              short lifeVersion = IndexValue.hasLifeVersion(info.getLifeVersion()) ? info.getLifeVersion() : (short) 0;\n+              IndexValue value =\n+                  new IndexValue(info.getSize(), fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE,\n+                      info.getExpirationTimeInMs(), info.getOperationTimeMs(), info.getAccountId(),\n+                      info.getContainerId(), lifeVersion);\n               IndexEntry entry = new IndexEntry(info.getStoreKey(), value, info.getCrc());\n               indexEntries.add(entry);\n               endOffsetOfLastMessage = fileSpan.getEndOffset();\n             }\n             FileSpan fileSpan = new FileSpan(indexEntries.get(0).getValue().getOffset(), endOffsetOfLastMessage);\n             index.addToIndex(indexEntries, fileSpan);\n             for (IndexEntry newEntry : indexEntries) {\n+              System.out.println(\"Handle new put Entry for key \" + newEntry.getKey());", "originalCommit": "bbd8268be5c03b39c2242a1162b2cb07632d5fdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3MDcwNA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r402770704", "bodyText": "will remove, for debug purpose.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T06:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\nindex 2d2972c57..9a0b48b03 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n\n@@ -423,7 +423,6 @@ public class BlobStore implements Store {\n             FileSpan fileSpan = new FileSpan(indexEntries.get(0).getValue().getOffset(), endOffsetOfLastMessage);\n             index.addToIndex(indexEntries, fileSpan);\n             for (IndexEntry newEntry : indexEntries) {\n-              System.out.println(\"Handle new put Entry for key \" + newEntry.getKey());\n               blobStoreStats.handleNewPutEntry(newEntry.getValue());\n             }\n             logger.trace(\"Store : {} message set written to index \", dataDir);\n"}}, {"oid": "a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "url": "https://github.com/linkedin/ambry/commit/a9e6e0c0f021972f33fb0d9f73c0ed1addc2c1ed", "message": "Address comments", "committedDate": "2020-04-03T07:04:43Z", "type": "commit"}, {"oid": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "url": "https://github.com/linkedin/ambry/commit/664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "message": "Address comments", "committedDate": "2020-04-03T17:19:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403232649", "bodyText": "I raised the same question in the other PR:\nwhy not check storeValidateAuthorization here? assume replication always correct?", "author": "zzmao", "createdAt": "2020-04-03T18:38:06Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTA2MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403269061", "bodyText": "I suppose so. Replication thread would replicating same blob record from different nodes, which means this record is already verified in different nodes.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDM5MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403270391", "bodyText": "I suppose I can verify it here again, there is no harm of doing it again.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\nindex 9a0b48b03..da34eab20 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n\n@@ -475,20 +475,20 @@ public class BlobStore implements Store {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n         }\n+        if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+          if (config.storeValidateAuthorization) {\n+            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                StoreErrorCodes.Authorization_Failure);\n+          } else {\n+            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+            metrics.deleteAuthorizationFailureCount.inc();\n+          }\n+        }\n         if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n           // This is a delete request from frontend\n-          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-            if (config.storeValidateAuthorization) {\n-              throw new StoreException(\n-                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                  StoreErrorCodes.Authorization_Failure);\n-            } else {\n-              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-              metrics.deleteAuthorizationFailureCount.inc();\n-            }\n-          } else if (value.isDelete()) {\n+          if (value.isDelete()) {\n             throw new StoreException(\n                 \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n                 StoreErrorCodes.ID_Deleted);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzMyOA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403233328", "bodyText": "minor: use isTtlUpdate() to make it consistent with other Ttl", "author": "zzmao", "createdAt": "2020-04-03T18:38:53Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java", "diffHunk": "@@ -542,9 +542,11 @@ void addEntry(IndexEntry entry, Offset fileEndOffset) throws StoreException {\n       }\n       if (resetKey == null) {\n         PersistentIndex.IndexEntryType type = PersistentIndex.IndexEntryType.PUT;\n-        if (entry.getValue().isFlagSet(IndexValue.Flags.Delete_Index)) {\n+        if (entry.getValue().isDelete()) {\n           type = PersistentIndex.IndexEntryType.DELETE;\n-        } else if (entry.getValue().isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+        } else if (entry.getValue().isUndelete()) {\n+          type = PersistentIndex.IndexEntryType.UNDELETE;\n+        } else if (entry.getValue().isTTLUpdate()) {", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTE2MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403269161", "bodyText": "I will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\nindex 8923a4d54..7a3514b00 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/IndexSegment.java\n\n@@ -546,7 +546,7 @@ class IndexSegment {\n           type = PersistentIndex.IndexEntryType.DELETE;\n         } else if (entry.getValue().isUndelete()) {\n           type = PersistentIndex.IndexEntryType.UNDELETE;\n-        } else if (entry.getValue().isTTLUpdate()) {\n+        } else if (entry.getValue().isTtlUpdate()) {\n           type = PersistentIndex.IndexEntryType.TTL_UPDATE;\n         }\n         resetKey = new Pair<>(entry.getKey(), type);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODY1MA==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403198650", "bodyText": "nit: (1) StoreKey (2) extra space between LifeVersion and should", "author": "jsjtzyy", "createdAt": "2020-04-03T17:58:06Z", "path": "ambry-api/src/main/java/com/github/ambry/store/Store.java", "diffHunk": "@@ -41,29 +41,37 @@\n   StoreInfo get(List<? extends StoreKey> ids, EnumSet<StoreGetOptions> storeGetOptions) throws StoreException;\n \n   /**\n-   * Puts a set of messages into the store\n+   * Puts a set of messages into the store. When the lifeVersion is {@link MessageInfo#LIFE_VERSION_FROM_FRONTEND}, this\n+   * method is invoked by the responding to the frontend request. Otherwise, it's invoked in the replication thread.\n    * @param messageSetToWrite The message set to write to the store\n+   *                          Only the Storekey, OperationTime, ExpirationTime, LifeVersion  should be used in this method.", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/store/Store.java b/ambry-api/src/main/java/com/github/ambry/store/Store.java\nindex 893bbcd12..0f1f7e1d6 100644\n--- a/ambry-api/src/main/java/com/github/ambry/store/Store.java\n+++ b/ambry-api/src/main/java/com/github/ambry/store/Store.java\n\n@@ -44,7 +44,7 @@ public interface Store {\n    * Puts a set of messages into the store. When the lifeVersion is {@link MessageInfo#LIFE_VERSION_FROM_FRONTEND}, this\n    * method is invoked by the responding to the frontend request. Otherwise, it's invoked in the replication thread.\n    * @param messageSetToWrite The message set to write to the store\n-   *                          Only the Storekey, OperationTime, ExpirationTime, LifeVersion  should be used in this method.\n+   *                          Only the StoreKey, OperationTime, ExpirationTime, LifeVersion should be used in this method.\n    * @throws StoreException\n    */\n   void put(MessageWriteSet messageSetToWrite) throws StoreException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTI5OQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403225299", "bodyText": "When revisiting this piece of code, I find line 518 directly throws exception if it's deleted without checking the version. I feel like it may have edge case there. Could you double check if it needs to be updated?", "author": "jsjtzyy", "createdAt": "2020-04-03T18:29:14Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -470,23 +474,38 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         if (value == null) {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n-        } else if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-          if (config.storeValidateAuthorization) {\n-            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                StoreErrorCodes.Authorization_Failure);\n-          } else {\n-            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-            metrics.deleteAuthorizationFailureCount.inc();\n+        }\n+        if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n+          // This is a delete request from frontend\n+          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+            if (config.storeValidateAuthorization) {\n+              throw new StoreException(\n+                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                  StoreErrorCodes.Authorization_Failure);\n+            } else {\n+              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+              metrics.deleteAuthorizationFailureCount.inc();\n+            }\n+          } else if (value.isDelete()) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.ID_Deleted);\n           }\n-        } else if (value.isDelete()) {\n-          throw new StoreException(\n-              \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n-              StoreErrorCodes.ID_Deleted);\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(value.getLifeVersion());\n+        } else {\n+          // This is a delete request from replication\n+          if ((value.isDelete() && value.getLifeVersion() >= info.getLifeVersion()) || (value.getLifeVersion()\n+              > info.getLifeVersion())) {\n+            throw new StoreException(\n+                \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n+                StoreErrorCodes.Life_Version_Conflict);\n+          }\n+          indexValuesToDelete.add(value);\n+          lifeVersions.add(info.getLifeVersion());\n         }\n-        indexValuesToDelete.add(value);\n-        lifeVersions.add(value.getLifeVersion());\n       }\n       synchronized (storeWriteLock) {\n         Offset currentIndexEndOffset = index.getCurrentEndOffset();", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NzE2Ng==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403277166", "bodyText": "It could potentially be a edge case here, when the frontend deletes a blob and replication for this delete arrive at the same time. I will check the lifeVersion before throwing an exception.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\nindex 9a0b48b03..da34eab20 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/BlobStore.java\n\n@@ -475,20 +475,20 @@ public class BlobStore implements Store {\n           throw new StoreException(\"Cannot delete id \" + info.getStoreKey() + \" since it is not present in the index.\",\n               StoreErrorCodes.ID_Not_Found);\n         }\n+        if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n+          if (config.storeValidateAuthorization) {\n+            throw new StoreException(\"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n+                + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n+                StoreErrorCodes.Authorization_Failure);\n+          } else {\n+            logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+                info.getStoreKey(), value.getAccountId(), value.getContainerId());\n+            metrics.deleteAuthorizationFailureCount.inc();\n+          }\n+        }\n         if (info.getLifeVersion() == MessageInfo.LIFE_VERSION_FROM_FRONTEND) {\n           // This is a delete request from frontend\n-          if (!info.getStoreKey().isAccountContainerMatch(value.getAccountId(), value.getContainerId())) {\n-            if (config.storeValidateAuthorization) {\n-              throw new StoreException(\n-                  \"DELETE authorization failure. Key: \" + info.getStoreKey() + \"Actually accountId: \"\n-                      + value.getAccountId() + \"Actually containerId: \" + value.getContainerId(),\n-                  StoreErrorCodes.Authorization_Failure);\n-            } else {\n-              logger.warn(\"DELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n-                  info.getStoreKey(), value.getAccountId(), value.getContainerId());\n-              metrics.deleteAuthorizationFailureCount.inc();\n-            }\n-          } else if (value.isDelete()) {\n+          if (value.isDelete()) {\n             throw new StoreException(\n                 \"Cannot delete id \" + info.getStoreKey() + \" since it is already deleted in the index.\",\n                 StoreErrorCodes.ID_Deleted);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MjczOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403242739", "bodyText": "minor: line 847 in PersistentIndex, the java doc for lifeVersion should be delete record rather than undelete record", "author": "jsjtzyy", "createdAt": "2020-04-03T18:52:15Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -525,7 +545,8 @@ public void delete(List<MessageInfo> infosToDelete) throws StoreException {\n         int correspondingPutIndex = 0;\n         for (MessageInfo info : updatedInfos) {\n           FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n-          IndexValue deleteIndexValue = index.markAsDeleted(info.getStoreKey(), fileSpan, info.getOperationTimeMs());\n+          IndexValue deleteIndexValue =\n+              index.markAsDeleted(info.getStoreKey(), fileSpan, null, info.getOperationTimeMs(), info.getLifeVersion());", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3ODM3MQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403278371", "bodyText": "will update.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MjczOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTY4Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403249682", "bodyText": "In which case the value could be null ?", "author": "jsjtzyy", "createdAt": "2020-04-03T19:01:55Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3OTgzOQ==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403279839", "bodyText": "Honestly i don't know it was here for a while then.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java b/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\nindex 165a7a11c..9f924a3e0 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\n\n@@ -932,7 +932,7 @@ class PersistentIndex {\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n     if (value != null && value.isDelete()) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n-    } else if (value != null && value.isTTLUpdate()) {\n+    } else if (value != null && value.isTtlUpdate()) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n     } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n       throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTY5Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403251692", "bodyText": "In this PR, hasLifeVersion is always false, right? (because BlobStore.handleTtlUpate passes LIFE_VERSION_FROM_FRONTEND into this method)", "author": "jsjtzyy", "createdAt": "2020-04-03T19:04:40Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -922,18 +921,18 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n-      short lifeVersion) throws StoreException {\n+  IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n+      throws StoreException {\n     validateFileSpan(fileSpan, true);\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n-    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    if (value != null && value.isDelete()) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+    } else if (value != null && value.isTTLUpdate()) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n     } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4MDMyMg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403280322", "bodyText": "that's right, TTL_UPDATE record will always follow a PUT or an UNDELETE.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "chunk": "diff --git a/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java b/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\nindex 165a7a11c..9f924a3e0 100644\n--- a/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java\n\n@@ -932,7 +932,7 @@ class PersistentIndex {\n     short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n     if (value != null && value.isDelete()) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n-    } else if (value != null && value.isTTLUpdate()) {\n+    } else if (value != null && value.isTtlUpdate()) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n     } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n       throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403257597", "bodyText": "Could you explain why we pass info.getLifeVersion() rather than resolved lifeVersion to message info?", "author": "jsjtzyy", "createdAt": "2020-04-03T19:17:01Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStore.java", "diffHunk": "@@ -660,15 +686,16 @@ public short undelete(MessageInfo info) throws StoreException {\n       StoreKey id = info.getStoreKey();\n       Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n       List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n-      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      index.validateSanityForUndelete(id, values, info.getLifeVersion());\n       IndexValue latestValue = values.get(0);\n       short lifeVersion = (short) (latestValue.getLifeVersion() + 1);\n       MessageFormatInputStream stream =\n           new UndeleteMessageFormatInputStream(id, info.getAccountId(), info.getContainerId(),\n               info.getOperationTimeMs(), lifeVersion);\n       // Update info to add stream size;\n       info =\n-          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs());\n+          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs(),\n+              info.getLifeVersion());", "originalCommit": "664afc203b9c63ab3b5a6950e7c0b2db90a7708f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4Mzc3Mg==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403283772", "bodyText": "LifeVersion is used in two different places in undelete method. One is to construct an UndeleteMessageFormatInputStream, and we have to use a resolved lifeVersion, it can't be -1.\nThe other one is to verify the validity of a Undelete IndexEntry in PersistentIndex. when verifying undelete entry in persistent index (in method markAsUndelete), we need to pass lifeVersion as -1 if it's -1 in the message info so the persistentIndex knows it's from frontend.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T19:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3ODQ2Mw==", "url": "https://github.com/linkedin/ambry/pull/1444#discussion_r403378463", "bodyText": "That's true.  I took a look at writeTo(log) method and found life version is not actually used when persisting to log. Then, it should be fine.", "author": "jsjtzyy", "createdAt": "2020-04-03T23:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzU5Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "85d8ac616fb3f7734f9a3e265c583a5298c16365", "url": "https://github.com/linkedin/ambry/commit/85d8ac616fb3f7734f9a3e265c583a5298c16365", "message": "Address comments", "committedDate": "2020-04-03T19:55:24Z", "type": "commit"}]}