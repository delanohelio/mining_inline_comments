{"pr_number": 1687, "pr_title": "[DISK_IO]Prefetch BlobAll for GetChunk request to reduce disk IOs", "pr_createdAt": "2020-11-05T06:39:16Z", "pr_url": "https://github.com/linkedin/ambry/pull/1687", "timeline": [{"oid": "b9e905081b4875b5fc0a4f178c7d79f5bc818ef9", "url": "https://github.com/linkedin/ambry/commit/b9e905081b4875b5fc0a4f178c7d79f5bc818ef9", "message": "Prefetch BlobAll for GetChunk request to reduce disk IOs\n\n1. Prefetch BlobAll for GetChunk request, which only needs BlobData, to reduce disk IOs.\n2. Refacotr CloudMessageReadSet to use ByteBuf as content store.", "committedDate": "2020-11-05T06:38:32Z", "type": "commit"}, {"oid": "929d5fc04988b206ce3a89d407620c56fa62cd6c", "url": "https://github.com/linkedin/ambry/commit/929d5fc04988b206ce3a89d407620c56fa62cd6c", "message": "Fix encrpption key issue.", "committedDate": "2020-11-05T22:53:15Z", "type": "forcePushed"}, {"oid": "0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "url": "https://github.com/linkedin/ambry/commit/0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "message": "Fix encrpption key issue", "committedDate": "2020-11-05T23:25:33Z", "type": "commit"}, {"oid": "0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "url": "https://github.com/linkedin/ambry/commit/0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "message": "Fix encrpption key issue", "committedDate": "2020-11-05T23:25:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1Njc2Mw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r519056763", "bodyText": "Can the flag == Blob case on line 203 be removed now?", "author": "cgtz", "createdAt": "2020-11-06T23:39:38Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java", "diffHunk": "@@ -118,57 +119,49 @@ private void fetchDataFromReadSet() throws MessageFormatException {\n       logger.trace(\"Calculate offsets of messages for one partition, MessageFormatFlag : {} number of messages : {}\",\n           flag, messageCount);\n       for (int i = 0; i < messageCount; i++) {\n-        if (flag == MessageFormatFlags.All) {\n+        if (flag == MessageFormatFlags.All || flag == MessageFormatFlags.Blob) {\n           // just copy over the total size and use relative offset to be 0\n           // We do not have to check any version in this case as we dont\n           // have to read any data to deserialize anything.\n-          sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n-          messageMetadataList.add(i, null);\n-          totalSizeToWrite += readSet.sizeInBytes(i);\n           readSet.doPrefetch(i, 0, readSet.sizeInBytes(i));\n+\n+          if (flag == MessageFormatFlags.All) {\n+            sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n+            messageMetadataList.add(i, null);\n+            totalSizeToWrite += readSet.sizeInBytes(i);\n+          } else if (flag == MessageFormatFlags.Blob) {\n+            ByteBuf blobAll = readSet.getPrefetchedData(i);\n+            InputStream is = new ByteBufInputStream(blobAll);\n+\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+\n+            MessageMetadata messageMetadata = null;\n+            if (headerFormat.hasEncryptionKeyRecord()) {\n+              // If encryption key exists, MessageMetadata with encryption key is needed.\n+              ByteBuf duplicatedByteBuf = blobAll.duplicate();\n+              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n+              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              messageMetadata =\n+                  new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n+            }\n+            messageMetadataList.add(messageMetadata);\n+            sendInfoList.add(i,\n+                new SendInfo(headerFormat.getBlobRecordRelativeOffset(), headerFormat.getBlobRecordSize()));\n+            totalSizeToWrite += headerFormat.getBlobRecordSize();\n+\n+            // Adjust underlying ByteBuf reader and writer index.\n+            blobAll.readerIndex(headerFormat.getBlobRecordRelativeOffset());\n+            blobAll.writerIndex((int) (headerFormat.getBlobRecordRelativeOffset() + headerFormat.getBlobRecordSize()));\n+          }\n         } else {\n-          long startTime = SystemTime.getInstance().milliseconds();\n           BufferedInputStream bufferedInputStream =\n               new BufferedInputStream(new MessageReadSetIndexInputStream(readSet, i, 0),\n                   BUFFERED_INPUT_STREAM_BUFFER_SIZE);\n-          // read and verify header version\n-          byte[] headerVersionBytes = new byte[Version_Field_Size_In_Bytes];\n-          bufferedInputStream.read(headerVersionBytes, 0, Version_Field_Size_In_Bytes);\n-          short version = ByteBuffer.wrap(headerVersionBytes).getShort();\n-          if (!isValidHeaderVersion(version)) {\n-            throw new MessageFormatException(\n-                \"Version not known while reading message - version \" + version + \", StoreKey \" + readSet.getKeyAt(i),\n-                MessageFormatErrorCodes.Unknown_Format_Version);\n-          }\n-          logger.trace(\"Calculate offsets, read and verify header version time: {}\",\n-              SystemTime.getInstance().milliseconds() - startTime);\n-\n-          // read and verify header\n-          startTime = SystemTime.getInstance().milliseconds();\n-          byte[] headerBytes = new byte[getHeaderSizeForVersion(version)];\n-          bufferedInputStream.read(headerBytes, Version_Field_Size_In_Bytes,\n-              headerBytes.length - Version_Field_Size_In_Bytes);\n-\n-          ByteBuffer header = ByteBuffer.wrap(headerBytes);\n-          header.putShort(version);\n-          header.rewind();\n-          MessageHeader_Format headerFormat = getMessageHeader(version, header);\n-          headerFormat.verifyHeader();\n-          logger.trace(\"Calculate offsets, read and verify header time: {}\",\n-              SystemTime.getInstance().milliseconds() - startTime);\n-\n-          // read and verify storeKey\n-          startTime = SystemTime.getInstance().milliseconds();\n-          StoreKey storeKey = storeKeyFactory.getStoreKey(new DataInputStream(bufferedInputStream));\n-          if (storeKey.compareTo(readSet.getKeyAt(i)) != 0) {\n-            throw new MessageFormatException(\n-                \"Id mismatch between metadata and store - metadataId \" + readSet.getKeyAt(i) + \" storeId \" + storeKey,\n-                MessageFormatErrorCodes.Store_Key_Id_MisMatch);\n-          }\n-          logger.trace(\"Calculate offsets, read and verify storeKey time: {}\",\n-              SystemTime.getInstance().milliseconds() - startTime);\n \n-          startTime = SystemTime.getInstance().milliseconds();\n+          MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(bufferedInputStream, i);\n+\n+          long startTime = SystemTime.getInstance().milliseconds();\n           if (flag == MessageFormatFlags.BlobProperties) {\n             sendInfoList.add(i, new SendInfo(headerFormat.getBlobPropertiesRecordRelativeOffset(),\n                 headerFormat.getBlobPropertiesRecordSize()));", "originalCommit": "0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3MzU5Nw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520073597", "bodyText": "removed.", "author": "zzmao", "createdAt": "2020-11-09T19:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1Njc2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\nindex 269811d2c..8b5f2d1df 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n\n@@ -131,17 +131,17 @@ public class MessageFormatSend extends AbstractByteBufHolder<MessageFormatSend>\n             totalSizeToWrite += readSet.sizeInBytes(i);\n           } else if (flag == MessageFormatFlags.Blob) {\n             ByteBuf blobAll = readSet.getPrefetchedData(i);\n-            InputStream is = new ByteBufInputStream(blobAll);\n+            InputStream blobInputStream = new ByteBufInputStream(blobAll);\n \n-            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(blobInputStream, i);\n \n             MessageMetadata messageMetadata = null;\n             if (headerFormat.hasEncryptionKeyRecord()) {\n               // If encryption key exists, MessageMetadata with encryption key is needed.\n               ByteBuf duplicatedByteBuf = blobAll.duplicate();\n-              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n-              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n-                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              duplicatedByteBuf.setIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset(),\n+                  headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                      + headerFormat.getBlobEncryptionKeyRecordSize());\n               messageMetadata =\n                   new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NzU0Ng==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r519057546", "bodyText": "extra println here", "author": "cgtz", "createdAt": "2020-11-06T23:43:03Z", "path": "ambry-server/src/integration-test/java/com/github/ambry/server/ServerTestUtil.java", "diffHunk": "@@ -2066,6 +2066,7 @@ static void endToEndReplicationWithMultiNodeSinglePartitionTest(String routerDat\n       channel3.disconnect();\n     } catch (Exception e) {\n       e.printStackTrace();\n+      System.out.println(e);", "originalCommit": "0949f241d1d2531bcd7fe0042479c9f6a8bcf909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3MzYzOQ==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520073639", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-11-09T19:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NzU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "chunk": "diff --git a/ambry-server/src/integration-test/java/com/github/ambry/server/ServerTestUtil.java b/ambry-server/src/integration-test/java/com/github/ambry/server/ServerTestUtil.java\nindex e848a7fae..85fa78304 100644\n--- a/ambry-server/src/integration-test/java/com/github/ambry/server/ServerTestUtil.java\n+++ b/ambry-server/src/integration-test/java/com/github/ambry/server/ServerTestUtil.java\n\n@@ -2066,7 +2066,6 @@ final class ServerTestUtil {\n       channel3.disconnect();\n     } catch (Exception e) {\n       e.printStackTrace();\n-      System.out.println(e);\n       fail();\n     }\n   }\n"}}, {"oid": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "url": "https://github.com/linkedin/ambry/commit/f1cbe85926b9c32f6bf885798d4560af579bdc9f", "message": "Address comments", "committedDate": "2020-11-09T18:33:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3NjU4MA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520076580", "bodyText": "nit: we can use a more descriptive name than just is, something like 'blobInputStream.", "author": "justinlin-linkedin", "createdAt": "2020-11-09T19:46:41Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java", "diffHunk": "@@ -118,57 +119,49 @@ private void fetchDataFromReadSet() throws MessageFormatException {\n       logger.trace(\"Calculate offsets of messages for one partition, MessageFormatFlag : {} number of messages : {}\",\n           flag, messageCount);\n       for (int i = 0; i < messageCount; i++) {\n-        if (flag == MessageFormatFlags.All) {\n+        if (flag == MessageFormatFlags.All || flag == MessageFormatFlags.Blob) {\n           // just copy over the total size and use relative offset to be 0\n           // We do not have to check any version in this case as we dont\n           // have to read any data to deserialize anything.\n-          sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n-          messageMetadataList.add(i, null);\n-          totalSizeToWrite += readSet.sizeInBytes(i);\n           readSet.doPrefetch(i, 0, readSet.sizeInBytes(i));\n+\n+          if (flag == MessageFormatFlags.All) {\n+            sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n+            messageMetadataList.add(i, null);\n+            totalSizeToWrite += readSet.sizeInBytes(i);\n+          } else if (flag == MessageFormatFlags.Blob) {\n+            ByteBuf blobAll = readSet.getPrefetchedData(i);\n+            InputStream is = new ByteBufInputStream(blobAll);", "originalCommit": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NzI5Mw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520097293", "bodyText": "sure. Changed.", "author": "zzmao", "createdAt": "2020-11-09T20:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3NjU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\nindex b2976b78d..8b5f2d1df 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n\n@@ -131,17 +131,17 @@ public class MessageFormatSend extends AbstractByteBufHolder<MessageFormatSend>\n             totalSizeToWrite += readSet.sizeInBytes(i);\n           } else if (flag == MessageFormatFlags.Blob) {\n             ByteBuf blobAll = readSet.getPrefetchedData(i);\n-            InputStream is = new ByteBufInputStream(blobAll);\n+            InputStream blobInputStream = new ByteBufInputStream(blobAll);\n \n-            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(blobInputStream, i);\n \n             MessageMetadata messageMetadata = null;\n             if (headerFormat.hasEncryptionKeyRecord()) {\n               // If encryption key exists, MessageMetadata with encryption key is needed.\n               ByteBuf duplicatedByteBuf = blobAll.duplicate();\n-              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n-              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n-                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              duplicatedByteBuf.setIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset(),\n+                  headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                      + headerFormat.getBlobEncryptionKeyRecordSize());\n               messageMetadata =\n                   new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3NjkyNg==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520076926", "bodyText": "you can do duplicatedByteBuf.setIndex(readerIndex, writerIndex) in just one statement.", "author": "justinlin-linkedin", "createdAt": "2020-11-09T19:47:16Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java", "diffHunk": "@@ -118,57 +119,49 @@ private void fetchDataFromReadSet() throws MessageFormatException {\n       logger.trace(\"Calculate offsets of messages for one partition, MessageFormatFlag : {} number of messages : {}\",\n           flag, messageCount);\n       for (int i = 0; i < messageCount; i++) {\n-        if (flag == MessageFormatFlags.All) {\n+        if (flag == MessageFormatFlags.All || flag == MessageFormatFlags.Blob) {\n           // just copy over the total size and use relative offset to be 0\n           // We do not have to check any version in this case as we dont\n           // have to read any data to deserialize anything.\n-          sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n-          messageMetadataList.add(i, null);\n-          totalSizeToWrite += readSet.sizeInBytes(i);\n           readSet.doPrefetch(i, 0, readSet.sizeInBytes(i));\n+\n+          if (flag == MessageFormatFlags.All) {\n+            sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n+            messageMetadataList.add(i, null);\n+            totalSizeToWrite += readSet.sizeInBytes(i);\n+          } else if (flag == MessageFormatFlags.Blob) {\n+            ByteBuf blobAll = readSet.getPrefetchedData(i);\n+            InputStream is = new ByteBufInputStream(blobAll);\n+\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+\n+            MessageMetadata messageMetadata = null;\n+            if (headerFormat.hasEncryptionKeyRecord()) {\n+              // If encryption key exists, MessageMetadata with encryption key is needed.\n+              ByteBuf duplicatedByteBuf = blobAll.duplicate();\n+              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n+              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()", "originalCommit": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NzM4NA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520097384", "bodyText": "done.", "author": "zzmao", "createdAt": "2020-11-09T20:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3NjkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\nindex b2976b78d..8b5f2d1df 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n\n@@ -131,17 +131,17 @@ public class MessageFormatSend extends AbstractByteBufHolder<MessageFormatSend>\n             totalSizeToWrite += readSet.sizeInBytes(i);\n           } else if (flag == MessageFormatFlags.Blob) {\n             ByteBuf blobAll = readSet.getPrefetchedData(i);\n-            InputStream is = new ByteBufInputStream(blobAll);\n+            InputStream blobInputStream = new ByteBufInputStream(blobAll);\n \n-            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(blobInputStream, i);\n \n             MessageMetadata messageMetadata = null;\n             if (headerFormat.hasEncryptionKeyRecord()) {\n               // If encryption key exists, MessageMetadata with encryption key is needed.\n               ByteBuf duplicatedByteBuf = blobAll.duplicate();\n-              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n-              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n-                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              duplicatedByteBuf.setIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset(),\n+                  headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                      + headerFormat.getBlobEncryptionKeyRecordSize());\n               messageMetadata =\n                   new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3NzAxNA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520077014", "bodyText": "same above", "author": "justinlin-linkedin", "createdAt": "2020-11-09T19:47:26Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java", "diffHunk": "@@ -118,57 +119,49 @@ private void fetchDataFromReadSet() throws MessageFormatException {\n       logger.trace(\"Calculate offsets of messages for one partition, MessageFormatFlag : {} number of messages : {}\",\n           flag, messageCount);\n       for (int i = 0; i < messageCount; i++) {\n-        if (flag == MessageFormatFlags.All) {\n+        if (flag == MessageFormatFlags.All || flag == MessageFormatFlags.Blob) {\n           // just copy over the total size and use relative offset to be 0\n           // We do not have to check any version in this case as we dont\n           // have to read any data to deserialize anything.\n-          sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n-          messageMetadataList.add(i, null);\n-          totalSizeToWrite += readSet.sizeInBytes(i);\n           readSet.doPrefetch(i, 0, readSet.sizeInBytes(i));\n+\n+          if (flag == MessageFormatFlags.All) {\n+            sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n+            messageMetadataList.add(i, null);\n+            totalSizeToWrite += readSet.sizeInBytes(i);\n+          } else if (flag == MessageFormatFlags.Blob) {\n+            ByteBuf blobAll = readSet.getPrefetchedData(i);\n+            InputStream is = new ByteBufInputStream(blobAll);\n+\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+\n+            MessageMetadata messageMetadata = null;\n+            if (headerFormat.hasEncryptionKeyRecord()) {\n+              // If encryption key exists, MessageMetadata with encryption key is needed.\n+              ByteBuf duplicatedByteBuf = blobAll.duplicate();\n+              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n+              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              messageMetadata =\n+                  new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n+            }\n+            messageMetadataList.add(messageMetadata);\n+            sendInfoList.add(i,\n+                new SendInfo(headerFormat.getBlobRecordRelativeOffset(), headerFormat.getBlobRecordSize()));\n+            totalSizeToWrite += headerFormat.getBlobRecordSize();\n+\n+            // Adjust underlying ByteBuf reader and writer index.\n+            blobAll.readerIndex(headerFormat.getBlobRecordRelativeOffset());\n+            blobAll.writerIndex((int) (headerFormat.getBlobRecordRelativeOffset() + headerFormat.getBlobRecordSize()));", "originalCommit": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\nindex b2976b78d..8b5f2d1df 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n\n@@ -131,17 +131,17 @@ public class MessageFormatSend extends AbstractByteBufHolder<MessageFormatSend>\n             totalSizeToWrite += readSet.sizeInBytes(i);\n           } else if (flag == MessageFormatFlags.Blob) {\n             ByteBuf blobAll = readSet.getPrefetchedData(i);\n-            InputStream is = new ByteBufInputStream(blobAll);\n+            InputStream blobInputStream = new ByteBufInputStream(blobAll);\n \n-            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(blobInputStream, i);\n \n             MessageMetadata messageMetadata = null;\n             if (headerFormat.hasEncryptionKeyRecord()) {\n               // If encryption key exists, MessageMetadata with encryption key is needed.\n               ByteBuf duplicatedByteBuf = blobAll.duplicate();\n-              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n-              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n-                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              duplicatedByteBuf.setIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset(),\n+                  headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                      + headerFormat.getBlobEncryptionKeyRecordSize());\n               messageMetadata =\n                   new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4MjM1MQ==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520082351", "bodyText": "I am a bit worried about the using prefetchedData here, without adding it to the dataFromReadSet list.\nIf there is any exception while parsing the header, this ByteBuf will be leaked. We should probably add the prefetchedData ByteBuf to the dataFromReadSet list before using it to parse the header.", "author": "justinlin-linkedin", "createdAt": "2020-11-09T19:56:33Z", "path": "ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java", "diffHunk": "@@ -118,57 +119,49 @@ private void fetchDataFromReadSet() throws MessageFormatException {\n       logger.trace(\"Calculate offsets of messages for one partition, MessageFormatFlag : {} number of messages : {}\",\n           flag, messageCount);\n       for (int i = 0; i < messageCount; i++) {\n-        if (flag == MessageFormatFlags.All) {\n+        if (flag == MessageFormatFlags.All || flag == MessageFormatFlags.Blob) {\n           // just copy over the total size and use relative offset to be 0\n           // We do not have to check any version in this case as we dont\n           // have to read any data to deserialize anything.\n-          sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n-          messageMetadataList.add(i, null);\n-          totalSizeToWrite += readSet.sizeInBytes(i);\n           readSet.doPrefetch(i, 0, readSet.sizeInBytes(i));\n+\n+          if (flag == MessageFormatFlags.All) {\n+            sendInfoList.add(i, new SendInfo(0, readSet.sizeInBytes(i)));\n+            messageMetadataList.add(i, null);\n+            totalSizeToWrite += readSet.sizeInBytes(i);\n+          } else if (flag == MessageFormatFlags.Blob) {\n+            ByteBuf blobAll = readSet.getPrefetchedData(i);", "originalCommit": "f1cbe85926b9c32f6bf885798d4560af579bdc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5ODQzNw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520098437", "bodyText": "dataFromReadSet.add(readSet.getPrefetchedData(i)); also covers this case. (It's after the if-else for each message). no?", "author": "zzmao", "createdAt": "2020-11-09T20:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4MjM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEzMzI1NA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520133254", "bodyText": "it does, but what if at line 136, parseHeaderAndVerifyStoreKey failed with an exception, then this ByteBuf will not be released.", "author": "justinlin-linkedin", "createdAt": "2020-11-09T21:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4MjM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE1MTU2Mw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520151563", "bodyText": "Got it. changes made.", "author": "zzmao", "createdAt": "2020-11-09T22:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4MjM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "chunk": "diff --git a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\nindex b2976b78d..8b5f2d1df 100644\n--- a/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com/github/ambry/messageformat/MessageFormatSend.java\n\n@@ -131,17 +131,17 @@ public class MessageFormatSend extends AbstractByteBufHolder<MessageFormatSend>\n             totalSizeToWrite += readSet.sizeInBytes(i);\n           } else if (flag == MessageFormatFlags.Blob) {\n             ByteBuf blobAll = readSet.getPrefetchedData(i);\n-            InputStream is = new ByteBufInputStream(blobAll);\n+            InputStream blobInputStream = new ByteBufInputStream(blobAll);\n \n-            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(is, i);\n+            MessageHeader_Format headerFormat = parseHeaderAndVerifyStoreKey(blobInputStream, i);\n \n             MessageMetadata messageMetadata = null;\n             if (headerFormat.hasEncryptionKeyRecord()) {\n               // If encryption key exists, MessageMetadata with encryption key is needed.\n               ByteBuf duplicatedByteBuf = blobAll.duplicate();\n-              duplicatedByteBuf.readerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset());\n-              duplicatedByteBuf.writerIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n-                  + headerFormat.getBlobEncryptionKeyRecordSize());\n+              duplicatedByteBuf.setIndex(headerFormat.getBlobEncryptionKeyRecordRelativeOffset(),\n+                  headerFormat.getBlobEncryptionKeyRecordRelativeOffset()\n+                      + headerFormat.getBlobEncryptionKeyRecordSize());\n               messageMetadata =\n                   new MessageMetadata(deserializeBlobEncryptionKey(new ByteBufInputStream(duplicatedByteBuf)));\n             }\n"}}, {"oid": "73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "url": "https://github.com/linkedin/ambry/commit/73b05e80323c27bc58e5ad746fd77bf64c7e12bd", "message": "address justin comment", "committedDate": "2020-11-09T20:23:06Z", "type": "commit"}, {"oid": "7116d6d0fc1ae4cc2ad720f641d1426353f03ae3", "url": "https://github.com/linkedin/ambry/commit/7116d6d0fc1ae4cc2ad720f641d1426353f03ae3", "message": "address expection caused buf leak issue", "committedDate": "2020-11-09T22:06:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3NjA4NA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520176084", "bodyText": "why go extra step for this, we can just do\n      ByteBuf outputBuf = blobReadInfo.getBlobContent().duplicate();\n      long sizeToRead = Math.min(maxSize, blobReadInfo.getBlobSize() - relativeOffset);\n      outputBuf.setIndex((int) (relativeOffset), (int)(relativeOffset + sizeToRead));\n      written = channel.write(outputBuf.nioBuffer());", "author": "justinlin-linkedin", "createdAt": "2020-11-09T23:01:05Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java", "diffHunk": "@@ -56,14 +54,15 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     try {\n       // TODO: Need to refactor the code to avoid prefetching blobs for BlobInfo request,\n       // or at least to prefetch only the header (requires CloudDestination enhancement)\n-      if (!blobReadInfo.isPrefetched()) {\n-        blobReadInfo.prefetchBlob(blobStore);\n+      if (!blobReadInfo.isBlobDownloaded()) {\n+        blobReadInfo.downloadBlob(blobStore);\n       }\n-      ByteBuffer outputBuffer = blobReadInfo.getPrefetchedBuffer();\n+      ByteBuf outputBuf = blobReadInfo.getBlobContent().duplicate();\n       long sizeToRead = Math.min(maxSize, blobReadInfo.getBlobSize() - relativeOffset);\n-      outputBuffer.limit((int) (relativeOffset + sizeToRead));\n-      outputBuffer.position((int) (relativeOffset));\n-      written = channel.write(outputBuffer);\n+      byte[] array = new byte[(int) sizeToRead];\n+      outputBuf.readerIndex((int) (relativeOffset));\n+      outputBuf.readBytes(array);\n+      written = channel.write(ByteBuffer.wrap(array));", "originalCommit": "7116d6d0fc1ae4cc2ad720f641d1426353f03ae3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "94421398e0b141422d26f0bcd579d9eb97ca8f29", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\nindex 7794a6d4a..b7754da5f 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\n\n@@ -59,10 +59,8 @@ class CloudMessageReadSet implements MessageReadSet {\n       }\n       ByteBuf outputBuf = blobReadInfo.getBlobContent().duplicate();\n       long sizeToRead = Math.min(maxSize, blobReadInfo.getBlobSize() - relativeOffset);\n-      byte[] array = new byte[(int) sizeToRead];\n-      outputBuf.readerIndex((int) (relativeOffset));\n-      outputBuf.readBytes(array);\n-      written = channel.write(ByteBuffer.wrap(array));\n+      outputBuf.setIndex((int) (relativeOffset), (int) (relativeOffset + sizeToRead));\n+      written = channel.write(outputBuf.nioBuffer());\n     } catch (StoreException ex) {\n       throw new IOException(\"Write of cloud blob \" + blobIdStr + \" failed\", ex);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyNTI4NA==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520225284", "bodyText": "nit: byteBuf.setIndex.", "author": "justinlin-linkedin", "createdAt": "2020-11-10T01:20:33Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java", "diffHunk": "@@ -98,10 +97,12 @@ public StoreKey getKeyAt(int index) {\n   public void doPrefetch(int index, long relativeOffset, long size) throws IOException {\n     BlobReadInfo blobReadInfo = blobReadInfoList.get(index);\n     try {\n-      if (!blobReadInfo.isPrefetched()) {\n-        blobReadInfo.prefetchBlob(blobStore);\n+      if (!blobReadInfo.isBlobDownloaded()) {\n+        blobReadInfo.downloadBlob(blobStore);\n       }\n-      blobReadInfo.setPositionAndSize(relativeOffset, size);\n+      ByteBuf byteBuf = blobReadInfoList.get(index).getBlobContent();\n+      byteBuf.readerIndex((int) (relativeOffset));\n+      byteBuf.writerIndex((int) (relativeOffset + size));", "originalCommit": "7116d6d0fc1ae4cc2ad720f641d1426353f03ae3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "94421398e0b141422d26f0bcd579d9eb97ca8f29", "chunk": "diff --git a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\nindex 7794a6d4a..b7754da5f 100644\n--- a/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\n+++ b/ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java\n\n@@ -101,8 +99,7 @@ class CloudMessageReadSet implements MessageReadSet {\n         blobReadInfo.downloadBlob(blobStore);\n       }\n       ByteBuf byteBuf = blobReadInfoList.get(index).getBlobContent();\n-      byteBuf.readerIndex((int) (relativeOffset));\n-      byteBuf.writerIndex((int) (relativeOffset + size));\n+      byteBuf.setIndex((int) (relativeOffset), (int) (relativeOffset + size));\n     } catch (StoreException ex) {\n       throw new IOException(\"Prefetch of cloud blob \" + blobReadInfo.getBlobId().getID() + \" failed\", ex);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyODIwNw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r520228207", "bodyText": "is it safe to use netty ByteBuf in CloudMessageReadSet? @ankagrawal  what is the cloud network implementation? does it use http2? socket server?", "author": "justinlin-linkedin", "createdAt": "2020-11-10T01:29:32Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudMessageReadSet.java", "diffHunk": "@@ -140,81 +131,38 @@ private void validateIndex(int index) {\n   static class BlobReadInfo {\n     private final CloudBlobMetadata blobMetadata;\n     private final BlobId blobId;\n-    private ByteBuffer prefetchedBuffer;\n-    private int position = -1;\n-    private int size = -1;\n-    private boolean isPrefetched;\n+    private ByteBuf blobContent = null;\n \n     public BlobReadInfo(CloudBlobMetadata blobMetadata, BlobId blobId) {\n       this.blobMetadata = blobMetadata;\n       this.blobId = blobId;\n-      this.isPrefetched = false;\n     }\n \n     /**\n-     * Prefetch the {@code blob} from {@code CloudDestination} and put it in {@code prefetchedBuffer}\n+     * Download the {@code blob} from {@code CloudDestination} and put it in {@code blobContent}\n      * @param blobStore {@code CloudBlobStore} implementation representing the cloud from which download will happen.\n      * @throws StoreException if blob cloud not be downloaded\n      */\n-    public void prefetchBlob(CloudBlobStore blobStore) throws StoreException {\n+    public void downloadBlob(CloudBlobStore blobStore) throws StoreException {\n       // Casting blobsize to int, as blobs are chunked in Ambry, and chunk size is 4/8MB.\n       // However, if in future, if very large size of blobs are allowed, then prefetching logic should be changed.\n-      prefetchedBuffer = ByteBuffer.allocate((int) blobMetadata.getSize());\n-      ByteBufferOutputStream outputStream = new ByteBufferOutputStream(prefetchedBuffer);\n-      blobStore.downloadBlob(blobMetadata, blobId, outputStream);\n-      prefetchedBuffer.flip();\n-      isPrefetched = true;\n-    }\n-\n-    /**\n-     * Donwload the blob from the {@code CloudDestination} to the {@code OutputStream}\n-     * @param blobStore {@code CloudBlobStore} implementation representing the cloud from which download will happen.\n-     * @param outputStream OutputStream to download the blob to\n-     * @throws StoreException if blob download fails.\n-     */\n-    public void downloadBlob(CloudBlobStore blobStore, OutputStream outputStream) throws StoreException {\n+      blobContent = PooledByteBufAllocator.DEFAULT.ioBuffer((int) blobMetadata.getSize());", "originalCommit": "7116d6d0fc1ae4cc2ad720f641d1426353f03ae3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3NDM0Ng==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r522374346", "bodyText": "@justinlin-linkedin you are concerning if it's used in socket server, the ByteBuf can't be released?\nstoreMessageSet had the same problem. I guess we should retire socket server soon.", "author": "zzmao", "createdAt": "2020-11-12T19:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4MDQ3Mw==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r524380473", "bodyText": "For vcr the network implementation currently is socket server based. It doesn't use http2.", "author": "ankagrawal", "createdAt": "2020-11-16T16:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM4Njk2OQ==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r524386969", "bodyText": "For now, until we have netty based http2 implementation in cloud, is there an issue with using ByteBuffer.allocate for cloud?", "author": "ankagrawal", "createdAt": "2020-11-16T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyMTIzMQ==", "url": "https://github.com/linkedin/ambry/pull/1687#discussion_r525421231", "bodyText": "Both socket and http network stack can take care of allocated ByteBuf. As long as we have no cloud based network implementation, it's good. (Or release ByteBuf correctly in new implementations)", "author": "zzmao", "createdAt": "2020-11-17T19:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIyODIwNw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "94421398e0b141422d26f0bcd579d9eb97ca8f29", "url": "https://github.com/linkedin/ambry/commit/94421398e0b141422d26f0bcd579d9eb97ca8f29", "message": "address nit comments", "committedDate": "2020-11-17T19:14:41Z", "type": "commit"}]}