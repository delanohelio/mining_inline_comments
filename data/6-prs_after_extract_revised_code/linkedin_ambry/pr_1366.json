{"pr_number": 1366, "pr_title": "Adding undelete record to persistent index", "pr_createdAt": "2020-01-24T18:32:20Z", "pr_url": "https://github.com/linkedin/ambry/pull/1366", "timeline": [{"oid": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "url": "https://github.com/linkedin/ambry/commit/09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "message": "Fix", "committedDate": "2020-01-28T01:17:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwNzgzMw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372207833", "bodyText": "Do we still need ID_Deleted?", "author": "jsjtzyy", "createdAt": "2020-01-29T06:26:45Z", "path": "ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java", "diffHunk": "@@ -35,5 +35,9 @@\n   Already_Updated,\n   Update_Not_Allowed,\n   File_Not_Found,\n-  Channel_Closed\n+  Channel_Closed,\n+  Life_Version_Conflict,\n+  ID_Not_Deleted,\n+  ID_Undeleted,\n+  ID_Deleted_Permanently", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMTM4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372701383", "bodyText": "we still need it, it will be returned when ambry-frontend requests to delete a already deleted blob.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwNzgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java b/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\nindex 4464998bc..61ae97b1b 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\n+++ b/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\n\n@@ -37,7 +37,5 @@ public enum StoreErrorCodes {\n   File_Not_Found,\n   Channel_Closed,\n   Life_Version_Conflict,\n-  ID_Not_Deleted,\n-  ID_Undeleted,\n-  ID_Deleted_Permanently\n+  ID_Not_Deleted\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MDQ4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372640483", "bodyText": "Can you explain a little bit more about difference between life version from frontend and that is not?", "author": "jsjtzyy", "createdAt": "2020-01-29T21:30:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -55,6 +55,8 @@\n \n   final static byte FLAGS_DEFAULT_VALUE = (byte) 0;\n   final static long UNKNOWN_ORIGINAL_MESSAGE_OFFSET = -1;\n+  // The life version when the operation is trigger by the requests from frontend.\n+  final static short LIFE_VERSION_FROM_FRONTEND = -1;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjQ1NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702454", "bodyText": "frontend requests don't carry any lifeVersion information. This just indicates that markAsPermanent, markAsDeleted and markAsUndeleted is called by the requests from ambry frontend. When it's not from frontend, it should be from recovery and replication.\nIn the end, we will remove this variable. In the end, after we start to support lifeVersion, we will have to know lifeVersion for every frontend and replication requests.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MDQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\nindex b90868997..7573aa7f8 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n\n@@ -55,8 +55,6 @@ class IndexValue implements Comparable<IndexValue> {\n \n   final static byte FLAGS_DEFAULT_VALUE = (byte) 0;\n   final static long UNKNOWN_ORIGINAL_MESSAGE_OFFSET = -1;\n-  // The life version when the operation is trigger by the requests from frontend.\n-  final static short LIFE_VERSION_FROM_FRONTEND = -1;\n \n   private final static int BLOB_SIZE_IN_BYTES = 8;\n   private final static int OFFSET_SIZE_IN_BYTES = 8;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MTU1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372641557", "bodyText": "Replace isFlagSet(Flags.Undelete_Index) with isUndelete(). Same for DELETE and TTLUpdate.", "author": "jsjtzyy", "createdAt": "2020-01-29T21:32:57Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -386,11 +429,11 @@ ByteBuffer getBytes() {\n   @Override\n   public String toString() {\n     return \"Offset: \" + offset + \", Size: \" + getSize() + \", Deleted: \" + isFlagSet(Flags.Delete_Index)\n-        + \", TTL Updated: \" + isFlagSet(Flags.Ttl_Update_Index) + \", Undelete: \" + isFlagSet(\n-        Flags.Undelete_Index) + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \"\n-        + getOriginalMessageOffset() + (formatVersion != PersistentIndex.VERSION_0 ? (\", OperationTimeAtSecs \"\n-        + getOperationTimeInMs() + \", AccountId \" + getAccountId() + \", ContainerId \" + getContainerId())\n-        : \"\") + (formatVersion > PersistentIndex.VERSION_2 ? \", Life Version:\" + lifeVersion : \"\");\n+        + \", TTL Updated: \" + isFlagSet(Flags.Ttl_Update_Index) + \", Undelete: \" + isFlagSet(Flags.Undelete_Index)\n+        + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \" + getOriginalMessageOffset() + (", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\nindex b90868997..0726609e0 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n\n@@ -428,12 +428,11 @@ class IndexValue implements Comparable<IndexValue> {\n \n   @Override\n   public String toString() {\n-    return \"Offset: \" + offset + \", Size: \" + getSize() + \", Deleted: \" + isFlagSet(Flags.Delete_Index)\n-        + \", TTL Updated: \" + isFlagSet(Flags.Ttl_Update_Index) + \", Undelete: \" + isFlagSet(Flags.Undelete_Index)\n-        + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \" + getOriginalMessageOffset() + (\n-        formatVersion != PersistentIndex.VERSION_0 ? (\", OperationTimeAtSecs \" + getOperationTimeInMs() + \", AccountId \"\n-            + getAccountId() + \", ContainerId \" + getContainerId()) : \"\") + (formatVersion > PersistentIndex.VERSION_2 ?\n-        \", Life Version:\" + lifeVersion : \"\");\n+    return \"Offset: \" + offset + \", Size: \" + getSize() + \", Deleted: \" + isDelete() + \", TTL Updated: \" + isTTLUpdate()\n+        + \", Undelete: \" + isUndelete() + \", ExpiresAtMs: \" + getExpiresAtMs() + \", Original Message Offset: \"\n+        + getOriginalMessageOffset() + (formatVersion != PersistentIndex.VERSION_0 ? (\", OperationTimeAtSecs \"\n+        + getOperationTimeInMs() + \", AccountId \" + getAccountId() + \", ContainerId \" + getContainerId()) : \"\") + (\n+        formatVersion > PersistentIndex.VERSION_2 ? \", Life Version:\" + lifeVersion : \"\");\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0NjUyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372646525", "bodyText": "If life version is not from frontend, dose it mean that the version comes from replication or compaction?", "author": "jsjtzyy", "createdAt": "2020-01-29T21:42:55Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -279,6 +313,15 @@ short getContainerId() {\n     return containerId;\n   }\n \n+  /**\n+   * True when the life version is not from frontend requests.\n+   * @param lifeVersion the given life version.\n+   * @return true when it's not from frontend requests.\n+   */\n+  static boolean hasLifeVersion(short lifeVersion) {\n+    return lifeVersion > LIFE_VERSION_FROM_FRONTEND;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjgyNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702824", "bodyText": "and recovery also", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0NjUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\nindex b90868997..7573aa7f8 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n\n@@ -313,15 +279,6 @@ class IndexValue implements Comparable<IndexValue> {\n     return containerId;\n   }\n \n-  /**\n-   * True when the life version is not from frontend requests.\n-   * @param lifeVersion the given life version.\n-   * @return true when it's not from frontend requests.\n-   */\n-  static boolean hasLifeVersion(short lifeVersion) {\n-    return lifeVersion > LIFE_VERSION_FROM_FRONTEND;\n-  }\n-\n   /**\n    * @return the lifeVersion of the {@link IndexValue}\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372661466", "bodyText": "Can this be simplified as flags == FLAGS_DEFAULT_VALUE ?", "author": "jsjtzyy", "createdAt": "2020-01-29T22:16:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/IndexValue.java", "diffHunk": "@@ -243,6 +245,38 @@ boolean isFlagSet(Flags flag) {\n     return ((getFlags() & (1 << flag.ordinal())) != 0);\n   }\n \n+  /**\n+   * Helper function for isFlagSet(Flags.Ttl_Update_Index).\n+   * @return true when the Ttl_Update_Index is set.\n+   */\n+  boolean isTTLUpdate() {\n+    return isFlagSet(Flags.Ttl_Update_Index);\n+  }\n+\n+  /**\n+   * Helper function for isFlagSet(Flags.Delete_Index).\n+   * @return true when the Delete_Index is set.\n+   */\n+  boolean isDelete() {\n+    return isFlagSet(Flags.Delete_Index);\n+  }\n+\n+  /**\n+   * Helper function for isFlagSet(Flags.Undelete_Index).\n+   * @return true when the Undelete_Index is set.\n+   */\n+  boolean isUndelete() {\n+    return isFlagSet(Flags.Undelete_Index);\n+  }\n+\n+  /**\n+   * Helper function to decide if this value is a put value or not.\n+   * @return true when it's not a put record.\n+   */\n+  boolean isPut() {\n+    return !(isTTLUpdate() || isDelete() || isUndelete());", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjg3Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372702876", "bodyText": "make sense.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMDY1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372710657", "bodyText": "+1", "author": "zzmao", "createdAt": "2020-01-30T00:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MTQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\nindex b90868997..0726609e0 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/IndexValue.java\n\n@@ -274,7 +274,7 @@ class IndexValue implements Comparable<IndexValue> {\n    * @return true when it's not a put record.\n    */\n   boolean isPut() {\n-    return !(isTTLUpdate() || isDelete() || isUndelete());\n+    return flags == FLAGS_DEFAULT_VALUE;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3Mjc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372672752", "bodyText": "If this is for testing purpose, I suggest removing this and either use mockito or extends PersisentIndex to override getVersion() method.", "author": "jsjtzyy", "createdAt": "2020-01-29T22:44:24Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -69,6 +70,30 @@\n   static final short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n+  // set by the setVersion method from test cases to test IndexValue at next version.\n+  private static Short externalSetVersion = null;", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..bd19ee5b4 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -67,33 +67,9 @@ class PersistentIndex {\n   static final short VERSION_1 = 1;\n   static final short VERSION_2 = 2;\n   static final short VERSION_3 = 3;\n-  static final short CURRENT_VERSION = VERSION_2;\n+  static short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n-  // set by the setVersion method from test cases to test IndexValue at next version.\n-  private static Short externalSetVersion = null;\n-\n-  /**\n-   * Return the version. If {@link #setVersion(Short)} was invoked before, the version provided in the {@link #setVersion(Short)}\n-   * would be returned here.\n-   * @return The version of {@link PersistentIndex}.\n-   */\n-  static short getVersion() {\n-    if (externalSetVersion != null) {\n-      return externalSetVersion;\n-    }\n-    return CURRENT_VERSION;\n-  }\n-\n-  /**\n-   * Set the version for {@link PersistentIndex}. To resume the version to default one, pass a null to this method.\n-   * This method should only be used in the test cases.\n-   * @param external the version to set for {@link PersistentIndex}.\n-   */\n-  static void setVersion(Short external) {\n-    externalSetVersion = external;\n-  }\n-\n   static final FilenameFilter INDEX_SEGMENT_FILE_FILTER = new FilenameFilter() {\n     @Override\n     public boolean accept(File dir, String name) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3MzcwNg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372673706", "bodyText": "same here, we probably could remove this method", "author": "jsjtzyy", "createdAt": "2020-01-29T22:46:49Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -69,6 +70,30 @@\n   static final short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n+  // set by the setVersion method from test cases to test IndexValue at next version.\n+  private static Short externalSetVersion = null;\n+\n+  /**\n+   * Return the version. If {@link #setVersion(Short)} was invoked before, the version provided in the {@link #setVersion(Short)}\n+   * would be returned here.\n+   * @return The version of {@link PersistentIndex}.\n+   */\n+  static short getVersion() {\n+    if (externalSetVersion != null) {\n+      return externalSetVersion;\n+    }\n+    return CURRENT_VERSION;\n+  }\n+\n+  /**\n+   * Set the version for {@link PersistentIndex}. To resume the version to default one, pass a null to this method.\n+   * This method should only be used in the test cases.\n+   * @param external the version to set for {@link PersistentIndex}.\n+   */\n+  static void setVersion(Short external) {\n+    externalSetVersion = external;\n+  }", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..bd19ee5b4 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -67,33 +67,9 @@ class PersistentIndex {\n   static final short VERSION_1 = 1;\n   static final short VERSION_2 = 2;\n   static final short VERSION_3 = 3;\n-  static final short CURRENT_VERSION = VERSION_2;\n+  static short CURRENT_VERSION = VERSION_2;\n   static final String CLEAN_SHUTDOWN_FILENAME = \"cleanshutdown\";\n \n-  // set by the setVersion method from test cases to test IndexValue at next version.\n-  private static Short externalSetVersion = null;\n-\n-  /**\n-   * Return the version. If {@link #setVersion(Short)} was invoked before, the version provided in the {@link #setVersion(Short)}\n-   * would be returned here.\n-   * @return The version of {@link PersistentIndex}.\n-   */\n-  static short getVersion() {\n-    if (externalSetVersion != null) {\n-      return externalSetVersion;\n-    }\n-    return CURRENT_VERSION;\n-  }\n-\n-  /**\n-   * Set the version for {@link PersistentIndex}. To resume the version to default one, pass a null to this method.\n-   * This method should only be used in the test cases.\n-   * @param external the version to set for {@link PersistentIndex}.\n-   */\n-  static void setVersion(Short external) {\n-    externalSetVersion = external;\n-  }\n-\n   static final FilenameFilter INDEX_SEGMENT_FILE_FILTER = new FilenameFilter() {\n     @Override\n     public boolean accept(File dir, String name) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MjU0MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372682541", "bodyText": "The info here comes from recovery.recover() but I don't see BlobStoreRecovery handles UNDELETE case. Are you planning to add that in future PR?", "author": "jsjtzyy", "createdAt": "2020-01-29T23:12:23Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -332,14 +357,24 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzgxOQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372707819", "bodyText": "It does, I have to rebase.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MjU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..b79555961 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -357,24 +333,14 @@ class PersistentIndex {\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n-        } else if (info.isUndeleted()) {\n-          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs(), info.getLifeVersion());\n-          logger.info(\"Index : {} updated message with key {} by inserting undelete update entry of size {} ttl {}\",\n-              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n-          if (value == null) {\n-            // Undelete record indicates that there might be a put and delete record before it.\n-            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),\n-                StoreErrorCodes.Initialization_Error);\n-          }\n         } else if (value != null) {\n           throw new StoreException(\"Illegal message state during recovery. Duplicate PUT record\",\n               StoreErrorCodes.Initialization_Error);\n         } else {\n           // create a new entry in the index\n-          IndexValue newValue = new IndexValue(info.getSize(), runningOffset, IndexValue.FLAGS_DEFAULT_VALUE,\n-              info.getExpirationTimeInMs(), info.getOperationTimeMs(), info.getAccountId(), info.getContainerId(),\n-              info.getLifeVersion());\n+          IndexValue newValue =\n+              new IndexValue(info.getSize(), runningOffset, info.getExpirationTimeInMs(), info.getOperationTimeMs(),\n+                  info.getAccountId(), info.getContainerId());\n           addToIndex(new IndexEntry(info.getStoreKey(), newValue, null), new FileSpan(runningOffset, infoEndOffset));\n           logger.info(\"Index : {} adding new message to index with key {} size {} ttl {} deleted {}\", dataDir,\n               info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.isDeleted());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjA4Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372696082", "bodyText": "why we throw exception here?  If ttlUpdate doesn't have version, it is invalid?", "author": "jsjtzyy", "createdAt": "2020-01-29T23:57:47Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -712,37 +897,106 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of ttlUpdate carries invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNzU4MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372707580", "bodyText": "If it doesn't have lifeVersion, it mean lifeVersion is -1. This will never happen, for 1 when the method is called in recovery or replication, we already the lifeVersion from MessageInfo 2 when the method is called in handling frontend requests, we will have a put record in the persistent index so the value == null will be false.", "author": "justinlin-linkedin", "createdAt": "2020-01-30T00:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NjA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..bd19ee5b4 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -894,6 +871,7 @@ class PersistentIndex {\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5Njc4MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372696780", "bodyText": "update the java doc of this method by adding lifeVersion", "author": "jsjtzyy", "createdAt": "2020-01-30T00:00:08Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -712,37 +897,106 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4630e28a026a0cea4ec501b9002bde97a401073", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..bd19ee5b4 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -894,6 +871,7 @@ class PersistentIndex {\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n"}}, {"oid": "d4630e28a026a0cea4ec501b9002bde97a401073", "url": "https://github.com/linkedin/ambry/commit/d4630e28a026a0cea4ec501b9002bde97a401073", "message": "Address comments", "committedDate": "2020-01-30T01:02:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTQ1Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372711456", "bodyText": "logger.info add info.getLifeVersion()?", "author": "zzmao", "createdAt": "2020-01-30T00:55:02Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,15 +340,15 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n           logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,", "originalCommit": "09d5ddedaea1c3a9a8c465187e556da1c082f5ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTY3OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r372711678", "bodyText": "same for logs below.", "author": "zzmao", "createdAt": "2020-01-30T00:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcxMTQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex b0054b4ea..b79555961 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -338,6 +313,7 @@ class PersistentIndex {\n         logger.trace(\"Index : {} recovering key {} offset {} size {}\", dataDir, info.getStoreKey(), runningOffset,\n             info.getSize());\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n+        //TODO IndexValue findLatest\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n           markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyNjYwNg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373626606", "bodyText": "Minor: Life_Version_Invalid", "author": "zzmao", "createdAt": "2020-01-31T18:41:53Z", "path": "ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java", "diffHunk": "@@ -35,5 +35,9 @@\n   Already_Updated,\n   Update_Not_Allowed,\n   File_Not_Found,\n-  Channel_Closed\n+  Channel_Closed,\n+  Life_Version_Conflict,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NzY4Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373657682", "bodyText": "Feel like conflict is better here, invalid seems to indicate the lifeVersion is not a valid number.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyNjYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java b/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\nindex 4464998bc..61ae97b1b 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\n+++ b/ambry-api/src/main/java/com.github.ambry/store/StoreErrorCodes.java\n\n@@ -37,7 +37,5 @@ public enum StoreErrorCodes {\n   File_Not_Found,\n   Channel_Closed,\n   Life_Version_Conflict,\n-  ID_Not_Deleted,\n-  ID_Undeleted,\n-  ID_Deleted_Permanently\n+  ID_Not_Deleted\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373628472", "bodyText": "Does U/D carry expiration time?", "author": "zzmao", "createdAt": "2020-01-31T18:45:57Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -518,17 +532,18 @@ private boolean needToRollOverIndex(IndexEntry entry) {\n   }\n \n   /**\n-   * Finds a key in the index and returns the blob index value associated with it. If not found,\n-   * returns null\n+   * Finds {@link IndexValue} that represents the latest state of the given {@code key} in the index and return it. If\n+   * not found, returns null.\n    * <br>\n-   * This method only returns PUT or DELETE index entries. It does not return TTL_UPDATE entries but accounts for\n-   * TTL updates by updating the flag and expiry time (if applicable).\n+   * This method returns the final state of the given {@code key}. The final state of a key can be a Put value, a Delete\n+   * value and a Undelete value. Ttl_update isn't considered as final state as it just update the expiration date.\n+   * {@link IndexValue} returned by this method would carry expiration date from Ttl_update if there is one.", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMjY1NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373632654", "bodyText": "Is it possible to embed TTL_UPDATE FLAG in D/U all the time?\nIf we support UNDELETE to DELETE after we release this feature, there won't be backward compatible  issue.", "author": "zzmao", "createdAt": "2020-01-31T18:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzNDg0NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373634844", "bodyText": "Or, can we set it permanent if a blob with TTL is undeleted?  To make TTL_UPDATE easier.", "author": "zzmao", "createdAt": "2020-01-31T19:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1Nzg1OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373657858", "bodyText": "talked offline.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyODQ3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 0aab72700..b79555961 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -532,12 +519,11 @@ class PersistentIndex {\n   }\n \n   /**\n-   * Finds {@link IndexValue} that represents the latest state of the given {@code key} in the index and return it. If\n-   * not found, returns null.\n+   * Finds a key in the index and returns the blob index value associated with it. If not found,\n+   * returns null\n    * <br>\n-   * This method returns the final state of the given {@code key}. The final state of a key can be a Put value, a Delete\n-   * value and a Undelete value. Ttl_update isn't considered as final state as it just update the expiration date.\n-   * {@link IndexValue} returned by this method would carry expiration date from Ttl_update if there is one.\n+   * This method only returns PUT or DELETE index entries. It does not return TTL_UPDATE entries but accounts for\n+   * TTL updates by updating the flag and expiry time (if applicable).\n    * @param key  The key to find in the index\n    * @return The blob index value associated with the key. Null if the key is not found.\n    * @throws StoreException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373629798", "bodyText": "The word reversed is confused.\nBecause the default order in our mind is latest to oldest. How about not use reverse in function name, just add some comments about what the order is.", "author": "zzmao", "createdAt": "2020-01-31T18:48:56Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKeyInReverseOrder(StoreKey key, FileSpan fileSpan,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1ODE0Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373658146", "bodyText": "I can do that. Given that this is the only order we present the index values.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1OTI0OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373659248", "bodyText": "yes.", "author": "zzmao", "createdAt": "2020-01-31T19:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYyOTc5OA=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 0aab72700..b79555961 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -646,165 +633,6 @@ class PersistentIndex {\n     return retCandidate;\n   }\n \n-  /**\n-   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed order.\n-   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n-   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n-   * @param types the types of {@link IndexEntryType} to look for.\n-   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n-   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n-   * @throws StoreException any error.\n-   */\n-  List<IndexValue> findAllIndexValuesForKeyInReverseOrder(StoreKey key, FileSpan fileSpan,\n-      EnumSet<IndexEntryType> types, ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n-    List<IndexValue> result = null;\n-    final Timer.Context context = metrics.findTime.time();\n-    try {\n-      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n-      if (fileSpan == null) {\n-        logger.trace(\"Searching for \" + key + \" in the entire index\");\n-        segmentsMapToSearch = indexSegments.descendingMap();\n-      } else {\n-        logger.trace(\n-            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n-                + fileSpan.getEndOffset());\n-        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n-            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n-        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n-      }\n-      int segmentsSearched = 0;\n-      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n-        segmentsSearched++;\n-        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n-        NavigableSet<IndexValue> values = entry.getValue().find(key);\n-        if (values != null) {\n-          if (result == null) {\n-            result = new LinkedList<>();\n-          }\n-          Iterator<IndexValue> it = values.descendingIterator();\n-          while (it.hasNext()) {\n-            IndexValue value = it.next();\n-            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n-                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n-                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n-              // Add a copy of the value to the result since we return a modifiable list to the caller.\n-              IndexValue newValue =\n-                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n-                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n-                      value.getLifeVersion());\n-              result.add(newValue);\n-            }\n-          }\n-        }\n-      }\n-      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n-    } finally {\n-      context.stop();\n-    }\n-    if (result != null) {\n-      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n-    }\n-    return result;\n-  }\n-\n-  /**\n-   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n-   * <p/>\n-   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n-   * hasn't expired yet.\n-   * @param key the key to be undeleted.\n-   * @param values the previous {@link IndexValue}s in reversed order.\n-   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n-   */\n-  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n-    if (values == null || values.isEmpty()) {\n-      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    }\n-    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n-      validateSanityForUndeleteWithoutLifeVersion(key, values);\n-      return;\n-    }\n-    IndexValue firstValue = values.get(values.size() - 1);\n-    IndexValue lastValue = values.get(0);\n-    if (!firstValue.isPut()) {\n-      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n-          StoreErrorCodes.ID_Deleted_Permanently);\n-    }\n-    if (lastValue.getLifeVersion() >= lifeVersion) {\n-      throw new StoreException(\n-          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + lastValue.getLifeVersion()\n-              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n-    }\n-  }\n-\n-  /**\n-   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key} when there is\n-   * no lifeVersion provided.\n-   * <p/>\n-   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n-   * hasn't expired yet.\n-   * @param key the key to be undeleted.\n-   * @param values the previous {@link IndexValue}s in reversed order.\n-   */\n-  void validateSanityForUndeleteWithoutLifeVersion(StoreKey key, List<IndexValue> values) throws StoreException {\n-    // When it's valid to undelete this key\n-    // P/T + D\n-    // P/T + D + U + D\n-    if (values.size() == 1) {\n-      IndexValue value = values.get(0);\n-      if (value.isDelete() || value.isTTLUpdate()) {\n-        throw new StoreException(\"Id \" + key + \" is compacted in index\" + dataDir,\n-            StoreErrorCodes.ID_Deleted_Permanently);\n-      } else if (value.isPut()) {\n-        throw new StoreException(\"Id \" + key + \" is not deleted yet in index \" + dataDir,\n-            StoreErrorCodes.ID_Not_Deleted);\n-      } else {\n-        throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir,\n-            StoreErrorCodes.ID_Undeleted);\n-      }\n-    }\n-    // First item has to be put and last item has to be a delete.\n-    // PutRecord can't expire and delete record can't be older than the delete retention time.\n-    IndexValue firstValue = values.get(values.size() - 1);\n-    IndexValue lastValue = values.get(0);\n-    if (lastValue.isUndelete()) {\n-      throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir, StoreErrorCodes.ID_Undeleted);\n-    }\n-    if (!firstValue.isPut() || !lastValue.isDelete()) {\n-      throw new StoreException(\n-          \"Id \" + key + \" requires first value to be a put and last value to be a delete in index \" + dataDir,\n-          StoreErrorCodes.ID_Not_Deleted);\n-    }\n-    if (lastValue.getOperationTimeInMs() + TimeUnit.DAYS.toMillis(config.storeDeletedMessageRetentionDays)\n-        < time.milliseconds()) {\n-      throw new StoreException(\"Id \" + key + \" already permanently deleted in index \" + dataDir,\n-          StoreErrorCodes.ID_Deleted_Permanently);\n-    }\n-    maybeChangeExpirationDate(firstValue, values);\n-    if (isExpired(firstValue)) {\n-      throw new StoreException(\"Id \" + key + \" already expired in index \" + dataDir, StoreErrorCodes.TTL_Expired);\n-    }\n-  }\n-\n-  /**\n-   * Change the target's expiration date and set the ttl_update_index to be true if there is a ttl index in given list.\n-   * @param target the {@link IndexValue} to change expiration date.\n-   * @param allValues the given list of {@link IndexValue}s.\n-   */\n-  void maybeChangeExpirationDate(IndexValue target, List<IndexValue> allValues) {\n-    if (target.isTTLUpdate()) {\n-      return;\n-    }\n-    for (IndexValue v : allValues) {\n-      if (v.isTTLUpdate()) {\n-        target.setExpiresAtMs(v.getExpiresAtMs());\n-        target.setFlag(IndexValue.Flags.Ttl_Update_Index);\n-        return;\n-      }\n-    }\n-  }\n-\n   /**\n    * Returns true if the given message was recently seen by this Index.\n    * @param info the {@link MessageInfo} to check.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzI0MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373633240", "bodyText": "Why getDeletedBlobReadOptions is so complicated?", "author": "zzmao", "createdAt": "2020-01-31T18:56:45Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1099,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n+   * @throws StoreException\n+   */\n+  private BlobReadOptions getUndeletedBlobReadOptions(IndexValue value, StoreKey key,", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1ODIxNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373658214", "bodyText": "talked offline.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzI0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 0aab72700..b79555961 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -1099,33 +962,6 @@ class PersistentIndex {\n     return readOptions;\n   }\n \n-  /**\n-   * Gets {@link BlobReadOptions} for a undeleted blob.\n-   * @param value the {@link IndexValue} of the delete index entry for the blob.\n-   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n-   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n-   * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n-   * @throws StoreException\n-   */\n-  private BlobReadOptions getUndeletedBlobReadOptions(IndexValue value, StoreKey key,\n-      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n-    IndexValue putValue =\n-        findKey(key, new FileSpan(getStartOffset(indexSegments), value.getOffset()), EnumSet.of(IndexEntryType.PUT),\n-            indexSegments);\n-    if (putValue != null) {\n-      // use the expiration time from the original value because it may have been updated\n-      // since we are here dealing with undelete blob, we have to return the right life version\n-      return new BlobReadOptions(log, putValue.getOffset(),\n-          new MessageInfo(key, putValue.getSize(), false, value.isFlagSet(IndexValue.Flags.Ttl_Update_Index), true,\n-              value.getExpiresAtMs(), null, putValue.getAccountId(), putValue.getContainerId(),\n-              putValue.getOperationTimeInMs(), value.getLifeVersion()));\n-    } else {\n-      // PUT record no longer available.\n-      throw new StoreException(\"Did not find PUT index entry for key [\" + key + \"] when there is an undelete entry\",\n-          StoreErrorCodes.ID_Not_Found);\n-    }\n-  }\n-\n   boolean isExpired(IndexValue value) {\n     return value.getExpiresAtMs() != Utils.Infinite_Time && time.milliseconds() > value.getExpiresAtMs();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzYzNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373633635", "bodyText": "Why is size changed?", "author": "zzmao", "createdAt": "2020-01-31T18:57:38Z", "path": "ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java", "diffHunk": "@@ -77,7 +77,10 @@\n   // deliberately do not divide the capacities perfectly.\n   static final long PUT_RECORD_SIZE = 53;\n   static final long DELETE_RECORD_SIZE = 29;\n-  static final long TTL_UPDATE_RECORD_SIZE = 37;\n+  static final long TTL_UPDATE_RECORD_SIZE = 29;", "originalCommit": "d52a85b804a74458ad517fcd7c373895a3ce2b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1OTAyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373659025", "bodyText": "That's minor change, size doesn't really matter, it seems like those are just random prime number greater than 24. I added some new records for undelete and the log segment is over flowed. I will change this back and change the log segment size instead.", "author": "justinlin-linkedin", "createdAt": "2020-01-31T19:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzMzYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "chunk": "diff --git a/ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java b/ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java\nindex 8f1e996cd..e4bdf8ad2 100644\n--- a/ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java\n+++ b/ambry-store/src/test/java/com.github.ambry.store/CuratedLogIndexState.java\n\n@@ -77,10 +77,8 @@ class CuratedLogIndexState {\n   // deliberately do not divide the capacities perfectly.\n   static final long PUT_RECORD_SIZE = 53;\n   static final long DELETE_RECORD_SIZE = 29;\n-  static final long TTL_UPDATE_RECORD_SIZE = 29;\n-  static final long UNDELETE_RECORD_SIZE = 29;\n-\n-  static final int deleteRetentionDay = 1;\n+  static final long TTL_UPDATE_RECORD_SIZE = 37;\n+  static final long UNDELETE_RECORD_SIZE = 41;\n \n   static {\n     try {\n"}}, {"oid": "0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "url": "https://github.com/linkedin/ambry/commit/0ed6e5c1a76f0fad0c6fbb244ea78f69f494b13a", "message": "Added behavioral changes for PersistentIndex for Undeletes\n\nAdded behavioral changes for PersistentIndex for Undeletes\n\nfix for IndexTest failure\n\nAdded test for bad undelete, test infra for undelete in CuratedLogIndexState\n\nAdded tests for index undelete\n\nthing to trigger change add\n\nthing to trigger build del\n\nthing to trigger change add\n\nthing to trigger build del\n\nthing to trigger change add\n\nthing to trigger build del\n\nfixed test\n\nadded undelete/lifeVersion awareness to findEntriesSince method", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "eafaf0ad50234f17f6f9464376790697285a89e5", "url": "https://github.com/linkedin/ambry/commit/eafaf0ad50234f17f6f9464376790697285a89e5", "message": "wip", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "eedf9524b48fae96f5d55e7f31d809d035a495f6", "url": "https://github.com/linkedin/ambry/commit/eedf9524b48fae96f5d55e7f31d809d035a495f6", "message": "Fix", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "f02fe7a6961288805c5861b1cdfcd70d900e5632", "url": "https://github.com/linkedin/ambry/commit/f02fe7a6961288805c5861b1cdfcd70d900e5632", "message": "Address comments", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "cf39281166bdcb85c404ba7aa69bd4cff5eadb9a", "url": "https://github.com/linkedin/ambry/commit/cf39281166bdcb85c404ba7aa69bd4cff5eadb9a", "message": "Updates", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "c73c0395656a5d0dfcb643b4e406831693ee995d", "url": "https://github.com/linkedin/ambry/commit/c73c0395656a5d0dfcb643b4e406831693ee995d", "message": "Comments", "committedDate": "2020-01-31T19:25:23Z", "type": "commit"}, {"oid": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "url": "https://github.com/linkedin/ambry/commit/cc0dd0855f4405b60609475b40e1f25f66c3e336", "message": "Comments", "committedDate": "2020-01-31T20:10:08Z", "type": "commit"}, {"oid": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "url": "https://github.com/linkedin/ambry/commit/cc0dd0855f4405b60609475b40e1f25f66c3e336", "message": "Comments", "committedDate": "2020-01-31T20:10:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwOTMzNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373709335", "bodyText": "nit: inserting undelete entry of size ...", "author": "jsjtzyy", "createdAt": "2020-01-31T22:14:54Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,31 +316,44 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting delete entry of size {} ttl {} lifeVersion{}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+              info.getOperationTimeMs(), info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           if (value == null) {\n             // this TTL update was forced even though there was no equivalent PUT record - this means that we MUST see\n             // a DELETE for this key (because the PUT record is gone, compaction must have cleaned it up because a\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete update entry of size {} ttl {} lifeVersion {}\",", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -323,6 +323,17 @@ class PersistentIndex {\n               dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n+          if (value == null) {\n+            // Undelete record indicates that a put and/or a delete record were expected.\n+            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),\n+                StoreErrorCodes.Initialization_Error);\n+          }\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n               info.getOperationTimeMs(), info.getLifeVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373713531", "bodyText": "minor: PUT or DELETE were expected, right?", "author": "jsjtzyy", "createdAt": "2020-01-31T22:28:25Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -315,31 +316,44 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n         Offset infoEndOffset = new Offset(runningOffset.getName(), runningOffset.getOffset() + info.getSize());\n         IndexValue value = findKey(info.getStoreKey());\n         if (info.isDeleted()) {\n-          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting delete entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+          markAsDeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info, info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting delete entry of size {} ttl {} lifeVersion{}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n-              info.getOperationTimeMs());\n-          logger.info(\"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {}\", dataDir,\n-              info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs());\n+              info.getOperationTimeMs(), info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting TTL update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           if (value == null) {\n             // this TTL update was forced even though there was no equivalent PUT record - this means that we MUST see\n             // a DELETE for this key (because the PUT record is gone, compaction must have cleaned it up because a\n             // DELETE must have been present)\n             deleteExpectedKeys.add(info.getStoreKey());\n           }\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete update entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n+          if (value == null) {\n+            // Undelete record indicates that there might be a put and delete record before it.\n+            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxNDc4Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373714786", "bodyText": "After a second thought, is it possible that Put record has been compacted. Just like value == null for TTL update? My point is, it may not need an exception here.", "author": "jsjtzyy", "createdAt": "2020-01-31T22:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzU2NA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807564", "bodyText": "it's not possible, if a put is already compacted, then an undelete operation would be rejected since undelete doesn't do anything.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMzUzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -323,6 +323,17 @@ class PersistentIndex {\n               dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n+        } else if (info.isUndeleted()) {\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n+              info.getLifeVersion());\n+          logger.info(\n+              \"Index : {} updated message with key {} by inserting undelete entry of size {} ttl {} lifeVersion {}\",\n+              dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n+          if (value == null) {\n+            // Undelete record indicates that a put and/or a delete record were expected.\n+            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),\n+                StoreErrorCodes.Initialization_Error);\n+          }\n         } else if (info.isTtlUpdated()) {\n           markAsPermanent(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n               info.getOperationTimeMs(), info.getLifeVersion());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMjg0NQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373722845", "bodyText": "Can you present a case where we do need to check !value.isDelete() && !value.isUndelete()? I know the piece of code comes from previous version, I just don't quite understand why we need such additional check.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:01:36Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -590,15 +605,17 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n             }\n             logger.trace(\"Index : {} found value offset {} size {} ttl {}\", dataDir, value.getOffset(), value.getSize(),\n                 value.getExpiresAtMs());\n-            if (types.contains(IndexEntryType.DELETE) && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+            if (types.contains(IndexEntryType.DELETE) && value.isDelete()) {\n+              retCandidate = value;\n+              break;\n+            } else if (types.contains(IndexEntryType.UNDELETE) && value.isUndelete()) {\n               retCandidate = value;\n               break;\n-            } else if (types.contains(IndexEntryType.TTL_UPDATE) && !value.isFlagSet(IndexValue.Flags.Delete_Index)\n-                && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n+            } else if (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete() && !value.isUndelete()\n+                && value.isTTLUpdate()) {", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzgwNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807804", "bodyText": "A delete or undelete entry will carry TTL_UPDATE_INDEX flag if there is a ttl_update record comes before it. So here if the search types only contain TTL_UPDATE_INDEX and we are seeing a delete record, then we have to make sure it doesn't get returned, therefore, we have to check !value.isDelete() && !value.isUndelete().", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyMjg0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNTQzNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373725434", "bodyText": "can be private", "author": "jsjtzyy", "createdAt": "2020-01-31T23:12:26Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzg1Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807856", "bodyText": "I have to expose this method in package scope, since in later PR, blobstore will call this method to do a precheck before adding undelete record to persistent index.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNTQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjEzMw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726133", "bodyText": "minor: change to Searching all index values for to distinguish from findKey method", "author": "jsjtzyy", "createdAt": "2020-01-31T23:15:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjQxMg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726412", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-01-31T23:16:53Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNjYyMg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373726622", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-01-31T23:17:45Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNzQ0Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373727443", "bodyText": "types.contains(IndexEntryType.TTL_UPDATE logic doesn't consider !value.isUndelete() like that in findKey method. Any specific reason?", "author": "jsjtzyy", "createdAt": "2020-01-31T23:21:33Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzk1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807952", "bodyText": "good catch, it's my bad, will update.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyNzQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODAxNw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728017", "bodyText": "Optional: probably worth adding a constructor for IndexValue that takes in another index value for deep copy purpose. (Pass in many parameters is error-prone)", "author": "jsjtzyy", "createdAt": "2020-01-31T23:24:19Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwNzk5Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373807992", "bodyText": "make sense, will add a new constructor.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODAxNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODI1Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728257", "bodyText": "typo Returning", "author": "jsjtzyy", "createdAt": "2020-01-31T23:25:34Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373728996", "bodyText": "Looks like result may be null. Can you explicitly mention this in java doc?\nAlso, if null means not find index value related to given key. We can make result = new ArrayList<>() at the very beginning and in the end, return result.isEmpty() ? null : result;\nThen we can remove\n if (result == null) {\n            result = new LinkedList<>();\n  }", "author": "jsjtzyy", "createdAt": "2020-01-31T23:28:04Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyOTExMA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373729110", "bodyText": "Or probably we can accept an empty result as a return value.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODM4Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808386", "bodyText": "I think returning a null is find here. I will comment it.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyMTk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373921991", "bodyText": "I see your comment. Also, like I said, we are able to remove\n if (result == null) {\n            result = new LinkedList<>();\n  }\n\nin the for loop.", "author": "jsjtzyy", "createdAt": "2020-02-03T04:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyODk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjQ4OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373732488", "bodyText": "I get you point here but I would suggest reverse values before hand which makes logic easier to understand and more consistent with your java docs of this method.", "author": "jsjtzyy", "createdAt": "2020-01-31T23:46:04Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODQ2MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808460", "bodyText": "I think the order in list is correct, i will change the variable name.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjQ4OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjk1Mg==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373732952", "bodyText": "Why we didn't check last value type and expiration time of PUT in this method?", "author": "jsjtzyy", "createdAt": "2020-01-31T23:48:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (!firstValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (lastValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + lastValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODYzNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808634", "bodyText": "you are right, we should check the the expiration date.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNDMxNw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373734317", "bodyText": "if target is already updated or expiration time = -1, in either case we can skip update", "author": "jsjtzyy", "createdAt": "2020-01-31T23:55:50Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,165 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset() + \" to \"\n+                + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching index with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT) && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              IndexValue newValue =\n+                  new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(),\n+                      value.getOperationTimeInMs(), value.getAccountId(), value.getContainerId(),\n+                      value.getLifeVersion());\n+              result.add(newValue);\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returninng values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (!firstValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (lastValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + lastValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key} when there is\n+   * no lifeVersion provided.\n+   * <p/>\n+   * Undelete should be permitted only when the first record is a Put and last record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   */\n+  void validateSanityForUndeleteWithoutLifeVersion(StoreKey key, List<IndexValue> values) throws StoreException {\n+    // When it's valid to undelete this key\n+    // P/T + D\n+    // P/T + D + U + D\n+    if (values.size() == 1) {\n+      IndexValue value = values.get(0);\n+      if (value.isDelete() || value.isTTLUpdate()) {\n+        throw new StoreException(\"Id \" + key + \" is compacted in index\" + dataDir,\n+            StoreErrorCodes.ID_Deleted_Permanently);\n+      } else if (value.isPut()) {\n+        throw new StoreException(\"Id \" + key + \" is not deleted yet in index \" + dataDir,\n+            StoreErrorCodes.ID_Not_Deleted);\n+      } else {\n+        throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir,\n+            StoreErrorCodes.ID_Undeleted);\n+      }\n+    }\n+    // First item has to be put and last item has to be a delete.\n+    // PutRecord can't expire and delete record can't be older than the delete retention time.\n+    IndexValue firstValue = values.get(values.size() - 1);\n+    IndexValue lastValue = values.get(0);\n+    if (lastValue.isUndelete()) {\n+      throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir, StoreErrorCodes.ID_Undeleted);\n+    }\n+    if (!firstValue.isPut() || !lastValue.isDelete()) {\n+      throw new StoreException(\n+          \"Id \" + key + \" requires first value to be a put and last value to be a delete in index \" + dataDir,\n+          StoreErrorCodes.ID_Not_Deleted);\n+    }\n+    if (lastValue.getOperationTimeInMs() + TimeUnit.DAYS.toMillis(config.storeDeletedMessageRetentionDays)\n+        < time.milliseconds()) {\n+      throw new StoreException(\"Id \" + key + \" already permanently deleted in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    maybeChangeExpirationDate(firstValue, values);\n+    if (isExpired(firstValue)) {\n+      throw new StoreException(\"Id \" + key + \" already expired in index \" + dataDir, StoreErrorCodes.TTL_Expired);\n+    }\n+  }\n+\n+  /**\n+   * Change the target's expiration date and set the ttl_update_index to be true if there is a ttl index in given list.\n+   * @param target the {@link IndexValue} to change expiration date.\n+   * @param allValues the given list of {@link IndexValue}s.\n+   */\n+  void maybeChangeExpirationDate(IndexValue target, List<IndexValue> allValues) {\n+    if (target.isTTLUpdate()) {\n+      return;", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -648,7 +648,8 @@ class PersistentIndex {\n \n   /**\n    * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n-   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order.\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n    * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n    * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n    * @param types the types of {@link IndexEntryType} to look for.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODExOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373748118", "bodyText": "nit: carries", "author": "jsjtzyy", "createdAt": "2020-02-01T01:40:05Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -658,33 +834,55 @@ IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, long deletionTimeMs) th\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n    * @param deletionTimeMs deletion time of the blob. In-case of recovery, deletion time is obtained from {@code info}.\n+   * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the delete record\n    * @throws StoreException\n    */\n-  private IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs)\n+  IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs, short lifeVersion)\n       throws StoreException {\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-      throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+    } else if (value != null) {\n+      if (hasLifeVersion) {\n+        // When this method is invoked in either recovery or replication, delete can follow any index value.\n+        if ((value.isDelete() && value.getLifeVersion() >= lifeVersion) || (value.getLifeVersion() > lifeVersion)) {\n+          throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + value.getLifeVersion()\n+              + \" Delete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+        }\n+      } else {\n+        if (value.isDelete()) {\n+          throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+        }\n+      }\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -863,7 +865,7 @@ class PersistentIndex {\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n       if (!hasLifeVersion) {\n-        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",\n+        throw new StoreException(\"MessageInfo of delete carries invalid lifeVersion\",\n             StoreErrorCodes.Initialization_Error);\n       }\n       newValue =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODkxMA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373748910", "bodyText": "should we clear TTL Update flag as well?", "author": "jsjtzyy", "createdAt": "2020-02-01T01:49:48Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -658,33 +834,55 @@ IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, long deletionTimeMs) th\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n    * @param deletionTimeMs deletion time of the blob. In-case of recovery, deletion time is obtained from {@code info}.\n+   * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the delete record\n    * @throws StoreException\n    */\n-  private IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs)\n+  IndexValue markAsDeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long deletionTimeMs, short lifeVersion)\n       throws StoreException {\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n-      throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+    } else if (value != null) {\n+      if (hasLifeVersion) {\n+        // When this method is invoked in either recovery or replication, delete can follow any index value.\n+        if ((value.isDelete() && value.getLifeVersion() >= lifeVersion) || (value.getLifeVersion() > lifeVersion)) {\n+          throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + value.getLifeVersion()\n+              + \" Delete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+        }\n+      } else {\n+        if (value.isDelete()) {\n+          throw new StoreException(\"Id \" + id + \" already deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n+        }\n+      }\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);\n+      }\n       newValue =\n-          new IndexValue(size, fileSpan.getStartOffset(), info.getExpirationTimeInMs(), info.getOperationTimeMs(),\n-              info.getAccountId(), info.getContainerId());\n+          new IndexValue(size, fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE, info.getExpirationTimeInMs(),\n+              info.getOperationTimeMs(), info.getAccountId(), info.getContainerId(), lifeVersion);\n       newValue.clearOriginalMessageOffset();\n     } else {\n+      lifeVersion = hasLifeVersion ? lifeVersion : value.getLifeVersion();\n       newValue =\n           new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(), deletionTimeMs,\n-              value.getAccountId(), value.getContainerId(), (short) 0);\n+              value.getAccountId(), value.getContainerId(), lifeVersion);\n       newValue.setNewOffset(fileSpan.getStartOffset());\n+      // Only set the original message offset when the value is put\n+      if (!value.isPut()) {\n+        newValue.clearOriginalMessageOffset();\n+      }\n       newValue.setNewSize(size);\n     }\n+    newValue.clearFlag(IndexValue.Flags.Undelete_Index);", "originalCommit": "cc0dd0855f4405b60609475b40e1f25f66c3e336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwODkyNQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373808925", "bodyText": "we don't, a delete or undelete can carry ttl_update_index flag and it's expiration date, since a delete and a undelete should represent the final state of a key. And expiration date is the final state of this key.", "author": "justinlin-linkedin", "createdAt": "2020-02-01T23:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0ODkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 585e6add4..5306accdc 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -863,7 +865,7 @@ class PersistentIndex {\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n       if (!hasLifeVersion) {\n-        throw new StoreException(\"MessageInfo of delete carry invalid lifeVersion\",\n+        throw new StoreException(\"MessageInfo of delete carries invalid lifeVersion\",\n             StoreErrorCodes.Initialization_Error);\n       }\n       newValue =\n"}}, {"oid": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "url": "https://github.com/linkedin/ambry/commit/ea2ba25eebd566b2d94119211b5f549a59fc2da3", "message": "More comments", "committedDate": "2020-02-01T23:45:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjA2MA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373926060", "bodyText": "Looks like firstValue/lastValue ordering is different from that in method validateSanityForUndelete().  I don't see any issue here but could we make them consistent?", "author": "jsjtzyy", "createdAt": "2020-02-03T05:22:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -629,6 +646,167 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n     return retCandidate;\n   }\n \n+  /**\n+   * Finds all the {@link IndexValue}s associated with the given {@code key} that matches any of the provided {@code types}\n+   * if present in the index with the given {@code fileSpan} and return them in reversed chronological order. If there is\n+   * no matched {@link IndexValue}, this method would return null;\n+   * @param key the {@link StoreKey} whose {@link IndexValue} is required.\n+   * @param fileSpan {@link FileSpan} which specifies the range within which search should be made.\n+   * @param types the types of {@link IndexEntryType} to look for.\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return The list of the {@link IndexValue}s for {@code key} conforming to one of the types {@code types}.\n+   * @throws StoreException any error.\n+   */\n+  List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    List<IndexValue> result = null;\n+    final Timer.Context context = metrics.findTime.time();\n+    try {\n+      ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n+      if (fileSpan == null) {\n+        logger.trace(\"Searching all indexes for \" + key + \" in the entire index\");\n+        segmentsMapToSearch = indexSegments.descendingMap();\n+      } else {\n+        logger.trace(\n+            \"Searching all indexes for \" + key + \" in index with filespan ranging from \" + fileSpan.getStartOffset()\n+                + \" to \" + fileSpan.getEndOffset());\n+        segmentsMapToSearch = indexSegments.subMap(indexSegments.floorKey(fileSpan.getStartOffset()), true,\n+            indexSegments.floorKey(fileSpan.getEndOffset()), true).descendingMap();\n+        metrics.segmentSizeForExists.update(segmentsMapToSearch.size());\n+      }\n+      int segmentsSearched = 0;\n+      for (Map.Entry<Offset, IndexSegment> entry : segmentsMapToSearch.entrySet()) {\n+        segmentsSearched++;\n+        logger.trace(\"Index : {} searching all indexes with start offset {}\", dataDir, entry.getKey());\n+        NavigableSet<IndexValue> values = entry.getValue().find(key);\n+        if (values != null) {\n+          if (result == null) {\n+            result = new LinkedList<>();\n+          }\n+          Iterator<IndexValue> it = values.descendingIterator();\n+          while (it.hasNext()) {\n+            IndexValue value = it.next();\n+            if ((types.contains(IndexEntryType.DELETE) && value.isDelete()) || (types.contains(IndexEntryType.UNDELETE)\n+                && value.isUndelete()) || (types.contains(IndexEntryType.TTL_UPDATE) && !value.isDelete()\n+                && !value.isUndelete() && value.isTTLUpdate()) || (types.contains(IndexEntryType.PUT)\n+                && value.isPut())) {\n+              // Add a copy of the value to the result since we return a modifiable list to the caller.\n+              result.add(new IndexValue(value));\n+            }\n+          }\n+        }\n+      }\n+      metrics.segmentsAccessedPerBlobCount.update(segmentsSearched);\n+    } finally {\n+      context.stop();\n+    }\n+    if (result != null) {\n+      logger.trace(\"Index: {} Returning values {}\", dataDir, result);\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key}.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   * @param lifeVersion lifeVersion for the undelete record, it's only valid when in recovery or replication.\n+   */\n+  void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n+    if (values == null || values.isEmpty()) {\n+      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+    }\n+    if (!IndexValue.hasLifeVersion(lifeVersion)) {\n+      validateSanityForUndeleteWithoutLifeVersion(key, values);\n+      return;\n+    }\n+    // This is from recovery or replication, make sure the last value is a put and the first value's lifeVersion is strictly\n+    // less than the given lifeVersion. We don't care about the first value's type, it can be a put, ttl_update or delete, it\n+    // can even be an undelete.\n+    IndexValue lastValue = values.get(values.size() - 1);\n+    IndexValue firstValue = values.get(0);\n+    if (!lastValue.isPut()) {\n+      throw new StoreException(\"Id \" + key + \" requires first value to be a put in index \" + dataDir,\n+          StoreErrorCodes.ID_Deleted_Permanently);\n+    }\n+    if (firstValue.getLifeVersion() >= lifeVersion) {\n+      throw new StoreException(\n+          \"LifeVersion conflict in index. Id \" + key + \" LifeVersion: \" + firstValue.getLifeVersion()\n+              + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n+    }\n+    maybeChangeExpirationDate(lastValue, values);\n+    if (isExpired(lastValue)) {\n+      throw new StoreException(\"Id \" + key + \" already expired in index \" + dataDir, StoreErrorCodes.TTL_Expired);\n+    }\n+  }\n+\n+  /**\n+   * Ensure that the previous {@link IndexValue}s is structured correctly for undeleting the {@code key} when there is\n+   * no lifeVersion provided.\n+   * <p/>\n+   * Undelete should be permitted only when the last value is a Put and first record is a Delete, and the Put record\n+   * hasn't expired yet.\n+   * @param key the key to be undeleted.\n+   * @param values the previous {@link IndexValue}s in reversed order.\n+   */\n+  void validateSanityForUndeleteWithoutLifeVersion(StoreKey key, List<IndexValue> values) throws StoreException {\n+    // When it's valid to undelete this key\n+    // P/T + D\n+    // P/T + D + U + D\n+    if (values.size() == 1) {\n+      IndexValue value = values.get(0);\n+      if (value.isDelete() || value.isTTLUpdate()) {\n+        throw new StoreException(\"Id \" + key + \" is compacted in index\" + dataDir,\n+            StoreErrorCodes.ID_Deleted_Permanently);\n+      } else if (value.isPut()) {\n+        throw new StoreException(\"Id \" + key + \" is not deleted yet in index \" + dataDir,\n+            StoreErrorCodes.ID_Not_Deleted);\n+      } else {\n+        throw new StoreException(\"Id \" + key + \" is already undeleted in index\" + dataDir,\n+            StoreErrorCodes.ID_Undeleted);\n+      }\n+    }\n+    // First item has to be put and last item has to be a delete.\n+    // PutRecord can't expire and delete record can't be older than the delete retention time.\n+    IndexValue firstValue = values.get(0);\n+    IndexValue lastValue = values.get(values.size() - 1);", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0NzQ5Nw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374247497", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-02-03T17:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjA2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 5306accdc..28ea351ff 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -659,7 +659,7 @@ class PersistentIndex {\n    */\n   List<IndexValue> findAllIndexValuesForKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryType> types,\n       ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n-    List<IndexValue> result = null;\n+    List<IndexValue> result = new ArrayList<>();\n     final Timer.Context context = metrics.findTime.time();\n     try {\n       ConcurrentNavigableMap<Offset, IndexSegment> segmentsMapToSearch;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDc1MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373934751", "bodyText": "typo: as undelete", "author": "jsjtzyy", "createdAt": "2020-02-03T06:11:06Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -709,40 +909,100 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of ttlUpdate carries invalid lifeVersion\",\n+            StoreErrorCodes.Initialization_Error);\n+      }\n       newValue =\n-          new IndexValue(size, fileSpan.getStartOffset(), info.getExpirationTimeInMs(), info.getOperationTimeMs(),\n-              info.getAccountId(), info.getContainerId());\n+          new IndexValue(size, fileSpan.getStartOffset(), IndexValue.FLAGS_DEFAULT_VALUE, info.getExpirationTimeInMs(),\n+              info.getOperationTimeMs(), info.getAccountId(), info.getContainerId(), lifeVersion);\n       newValue.clearOriginalMessageOffset();\n     } else {\n+      lifeVersion = hasLifeVersion ? lifeVersion : value.getLifeVersion();\n       newValue =\n           new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), Utils.Infinite_Time, operationTimeMs,\n-              value.getAccountId(), value.getContainerId(), (short) 0);\n+              value.getAccountId(), value.getContainerId(), lifeVersion);\n       newValue.setNewOffset(fileSpan.getStartOffset());\n       newValue.setNewSize(size);\n     }\n+    newValue.clearFlag(IndexValue.Flags.Undelete_Index);\n     newValue.setFlag(IndexValue.Flags.Ttl_Update_Index);\n     addToIndex(new IndexEntry(id, newValue, null), fileSpan);\n     return newValue;\n   }\n \n+  /**\n+   * Marks a blob as permanent", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 5306accdc..28ea351ff 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -959,7 +956,7 @@ class PersistentIndex {\n   }\n \n   /**\n-   * Marks a blob as permanent\n+   * Marks a blob as undeleted\n    * @param id the {@link StoreKey} of the blob\n    * @param fileSpan the file span represented by this entry in the log\n    * @param operationTimeMs the time of the update operation\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNTk3OA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r373935978", "bodyText": "I have same question here, do you have any idea why TTL update is placed even when PUT has been cleaned up?", "author": "jsjtzyy", "createdAt": "2020-02-03T06:16:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -709,40 +909,100 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, long operationTimeMs)\n    * @param operationTimeMs the time of the update operation\n    * @param info this needs to be non-null in the case of recovery. Can be {@code null} otherwise. Used if the PUT\n    *             record could not be found\n+   * @param lifeVersion lifeVersion of this ttlUpdate record.\n    * @return the {@link IndexValue} of the ttl update record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs)\n-      throws StoreException {\n+  private IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs,\n+      short lifeVersion) throws StoreException {\n     validateFileSpan(fileSpan, true);\n+    boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     IndexValue value = findKey(id);\n     if (value == null && info == null) {\n       throw new StoreException(\"Id \" + id + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n-    } else if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n+    }\n+    short retrievedLifeVersion = value == null ? info.getLifeVersion() : value.getLifeVersion();\n+    if (value != null && value.isFlagSet(IndexValue.Flags.Delete_Index)) {\n       throw new StoreException(\"Id \" + id + \" deleted in index \" + dataDir, StoreErrorCodes.ID_Deleted);\n     } else if (value != null && value.isFlagSet(IndexValue.Flags.Ttl_Update_Index)) {\n       throw new StoreException(\"TTL of \" + id + \" already updated in index\" + dataDir, StoreErrorCodes.Already_Updated);\n+    } else if (hasLifeVersion && retrievedLifeVersion > lifeVersion) {\n+      throw new StoreException(\"LifeVersion conflict in index. Id \" + id + \" LifeVersion: \" + retrievedLifeVersion\n+          + \" Undelete LifeVersion: \" + lifeVersion, StoreErrorCodes.Life_Version_Conflict);\n     }\n     long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     IndexValue newValue;\n+\n     if (value == null) {\n       // It is possible that the PUT has been cleaned by compaction\n+      // but the TTL update is going to still be placed?", "originalCommit": "ea2ba25eebd566b2d94119211b5f549a59fc2da3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI1MDQ3Ng==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374250476", "bodyText": "i don't think it's possible. But I will take another look at later PR", "author": "justinlin-linkedin", "createdAt": "2020-02-03T17:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNTk3OA=="}], "type": "inlineReview", "revised_code": {"commit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 5306accdc..28ea351ff 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -959,7 +956,7 @@ class PersistentIndex {\n   }\n \n   /**\n-   * Marks a blob as permanent\n+   * Marks a blob as undeleted\n    * @param id the {@link StoreKey} of the blob\n    * @param fileSpan the file span represented by this entry in the log\n    * @param operationTimeMs the time of the update operation\n"}}, {"oid": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "url": "https://github.com/linkedin/ambry/commit/f65940cac1fe13b1d839c94d2ff81df94299c6fa", "message": "More comments", "committedDate": "2020-02-03T18:08:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2NzM4Mw==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374267383", "bodyText": "please update comment for value and key parameters (change delete to undelete)", "author": "jsjtzyy", "createdAt": "2020-02-03T18:32:44Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1098,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "945473f79bdefb31c05038cd469914786c194241", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 28ea351ff..4ed104517 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -1100,8 +1100,8 @@ class PersistentIndex {\n \n   /**\n    * Gets {@link BlobReadOptions} for a undeleted blob.\n-   * @param value the {@link IndexValue} of the delete index entry for the blob.\n-   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param value the {@link IndexValue} of the undelete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the undelete {@link IndexValue}\n    * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n    * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n    * @throws StoreException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MDg4MQ==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374270881", "bodyText": "nit: value.isTTLUpdate()", "author": "jsjtzyy", "createdAt": "2020-02-03T18:39:28Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -839,6 +1098,33 @@ private BlobReadOptions getDeletedBlobReadOptions(IndexValue value, StoreKey key\n     return readOptions;\n   }\n \n+  /**\n+   * Gets {@link BlobReadOptions} for a undeleted blob.\n+   * @param value the {@link IndexValue} of the delete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n+   * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n+   * @throws StoreException\n+   */\n+  private BlobReadOptions getUndeletedBlobReadOptions(IndexValue value, StoreKey key,\n+      ConcurrentSkipListMap<Offset, IndexSegment> indexSegments) throws StoreException {\n+    IndexValue putValue =\n+        findKey(key, new FileSpan(getStartOffset(indexSegments), value.getOffset()), EnumSet.of(IndexEntryType.PUT),\n+            indexSegments);\n+    if (putValue != null) {\n+      // use the expiration time from the original value because it may have been updated\n+      // since we are here dealing with undelete blob, we have to return the right life version\n+      return new BlobReadOptions(log, putValue.getOffset(),\n+          new MessageInfo(key, putValue.getSize(), false, value.isFlagSet(IndexValue.Flags.Ttl_Update_Index), true,", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "945473f79bdefb31c05038cd469914786c194241", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 28ea351ff..4ed104517 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -1100,8 +1100,8 @@ class PersistentIndex {\n \n   /**\n    * Gets {@link BlobReadOptions} for a undeleted blob.\n-   * @param value the {@link IndexValue} of the delete index entry for the blob.\n-   * @param key the {@link StoreKey} for which {@code value} is the delete {@link IndexValue}\n+   * @param value the {@link IndexValue} of the undelete index entry for the blob.\n+   * @param key the {@link StoreKey} for which {@code value} is the undelete {@link IndexValue}\n    * @param indexSegments the map of index segment start {@link Offset} to {@link IndexSegment} instances\n    * @return the {@link BlobReadOptions} that contains the information for the given {@code id}\n    * @throws StoreException\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MzgxNA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374273814", "bodyText": "why here we filter delete entries again? Is this because messageInfo is updated in updateStateForMessages?", "author": "jsjtzyy", "createdAt": "2020-02-03T18:45:31Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -1555,6 +1839,10 @@ FindInfo findDeletedEntriesSince(FindToken token, long maxTotalSizeOfEntries, lo\n         }\n       }\n     }\n+    // Filter out all the messages that are not \"deleted\", then update state for remaining deleted message.\n+    filterDeleteEntries(messageEntries);\n+    updateStateForMessages(messageEntries);\n+\n     filterDeleteEntries(messageEntries);", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwMDQxOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374300418", "bodyText": "talked offline", "author": "justinlin-linkedin", "createdAt": "2020-02-03T19:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MzgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "945473f79bdefb31c05038cd469914786c194241", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\nindex 28ea351ff..4ed104517 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java\n\n@@ -1840,9 +1841,12 @@ class PersistentIndex {\n       }\n     }\n     // Filter out all the messages that are not \"deleted\", then update state for remaining deleted message.\n+    // First, filter out all the entries that are not delete\n+    // second, update all the remaining delete entries' state since delete might not be the final state of those entries, they can be undeleted.\n+    // third, filter out undelete entries after\n+    // fourth, eliminate duplicate deleted entries. We might have more than one versions of delete entries here.\n     filterDeleteEntries(messageEntries);\n     updateStateForMessages(messageEntries);\n-\n     filterDeleteEntries(messageEntries);\n     eliminateDuplicates(messageEntries);\n     return new FindInfo(messageEntries, newToken);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3NDEzOA==", "url": "https://github.com/linkedin/ambry/pull/1366#discussion_r374274138", "bodyText": "minor: please update java doc for this method.", "author": "jsjtzyy", "createdAt": "2020-02-03T18:46:11Z", "path": "ambry-store/src/main/java/com.github.ambry.store/PersistentIndex.java", "diffHunk": "@@ -1342,17 +1627,16 @@ private void updateStateForMessages(List<MessageInfo> messageEntries) throws Sto\n     ListIterator<MessageInfo> messageEntriesIterator = messageEntries.listIterator();\n     while (messageEntriesIterator.hasNext()) {\n       MessageInfo messageInfo = messageEntriesIterator.next();\n-      if (!messageInfo.isDeleted()) {\n-        // ok to use most recent ref\n-        IndexValue indexValue =\n-            findKey(messageInfo.getStoreKey(), null, EnumSet.of(IndexEntryType.TTL_UPDATE, IndexEntryType.DELETE));\n-        if (indexValue != null) {\n-          messageInfo = new MessageInfo(messageInfo.getStoreKey(), messageInfo.getSize(),\n-              indexValue.isFlagSet(IndexValue.Flags.Delete_Index),\n-              indexValue.isFlagSet(IndexValue.Flags.Ttl_Update_Index), indexValue.getExpiresAtMs(),\n-              indexValue.getAccountId(), indexValue.getContainerId(), indexValue.getOperationTimeInMs());\n-          messageEntriesIterator.set(messageInfo);\n-        }\n+      // for all the message info, we use most recent ref even for delete. since a deleted entry can be undeleted.\n+      // ok to use most recent ref\n+      IndexValue indexValue = findKey(messageInfo.getStoreKey(), null,\n+          EnumSet.of(IndexEntryType.TTL_UPDATE, IndexEntryType.DELETE, IndexEntryType.UNDELETE));\n+      if (indexValue != null) {\n+        messageInfo = new MessageInfo(messageInfo.getStoreKey(), indexValue.getSize(), indexValue.isDelete(),\n+            indexValue.isTTLUpdate(), indexValue.isUndelete(), indexValue.getExpiresAtMs(), null,\n+            indexValue.getAccountId(), indexValue.getContainerId(), indexValue.getOperationTimeInMs(),\n+            indexValue.getLifeVersion());\n+        messageEntriesIterator.set(messageInfo);", "originalCommit": "f65940cac1fe13b1d839c94d2ff81df94299c6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "945473f79bdefb31c05038cd469914786c194241", "url": "https://github.com/linkedin/ambry/commit/945473f79bdefb31c05038cd469914786c194241", "message": "More comments", "committedDate": "2020-02-03T19:39:08Z", "type": "commit"}]}