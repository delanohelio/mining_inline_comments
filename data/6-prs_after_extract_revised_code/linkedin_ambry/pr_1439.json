{"pr_number": 1439, "pr_title": "Support netty bytebuf in PutOperation", "pr_createdAt": "2020-03-25T23:58:48Z", "pr_url": "https://github.com/linkedin/ambry/pull/1439", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNjgyNA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r398816824", "bodyText": "remove?", "author": "zzmao", "createdAt": "2020-03-26T18:55:46Z", "path": "ambry-network/src/main/java/com.github.ambry.network/Selector.java", "diffHunk": "@@ -788,6 +788,7 @@ private NetworkSend write(SelectionKey key, Transmission transmission) {\n     } catch (IOException e) {\n       // We have key information if we log IOException here.\n       handleReadWriteIOException(e, key);\n+      //transmission.networkSend.getPayload().release();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ca1583e6dd81d1097a856553990b84b354114732", "chunk": "diff --git a/ambry-network/src/main/java/com.github.ambry.network/Selector.java b/ambry-network/src/main/java/com/github/ambry/network/Selector.java\nsimilarity index 99%\nrename from ambry-network/src/main/java/com.github.ambry.network/Selector.java\nrename to ambry-network/src/main/java/com/github/ambry/network/Selector.java\nindex fa953c362..ea5117908 100644\n--- a/ambry-network/src/main/java/com.github.ambry.network/Selector.java\n+++ b/ambry-network/src/main/java/com/github/ambry/network/Selector.java\n\n@@ -788,7 +788,7 @@ public class Selector implements Selectable {\n     } catch (IOException e) {\n       // We have key information if we log IOException here.\n       handleReadWriteIOException(e, key);\n-      //transmission.networkSend.getPayload().release();\n+      transmission.networkSend.getPayload().release();\n       return null;\n     } finally {\n       long writeTime = time.milliseconds() - startTimeToWriteInMs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxODE1NQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401018155", "bodyText": "not directly in the scope of this PR, but since you're making changes, could you make this inner class static along with DecryptJobResult.", "author": "cgtz", "createdAt": "2020-03-31T15:43:52Z", "path": "ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java", "diffHunk": "@@ -103,25 +112,31 @@ public void closeJob(GeneralSecurityException gse) {\n    */\n   class EncryptJobResult {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "800d95e84c472219464019dded7a628f5d7ca084", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java b/ambry-router/src/main/java/com/github/ambry/router/EncryptJob.java\nsimilarity index 99%\nrename from ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java\nrename to ambry-router/src/main/java/com/github/ambry/router/EncryptJob.java\nindex e00ff64fb..a94049baa 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/EncryptJob.java\n\n@@ -110,7 +110,7 @@ public class EncryptJob implements CryptoJob {\n   /**\n    * Class representing encrypt job result\n    */\n-  class EncryptJobResult {\n+  static class EncryptJobResult {\n     private final ByteBuffer encryptedKey;\n     private final ByteBuffer encryptedUserMetadata;\n     private final ByteBuf encryptedBlobContent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAyMTc1OA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401021758", "bodyText": "Could this just be buf.readBytes(dest) instead of iterating through the nio buffers?", "author": "cgtz", "createdAt": "2020-03-31T15:48:40Z", "path": "ambry-router/src/test/java/com.github.ambry.router/ChunkFillTest.java", "diffHunk": "@@ -319,20 +319,20 @@ private void fillChunksAndAssertSuccess() throws Exception {\n   private void assertDataIdentity(ClusterMap clusterMap) throws IOException {\n     if (!testEncryption) {\n       ByteBuffer dest = ByteBuffer.allocate(totalSizeWritten);\n-      for (ByteBuffer buf : compositeBuffers) {\n+      for (ByteBuf buf : compositeBuffers) {\n         Assert.assertNotNull(\"All chunks should have come in\", buf);\n-        buf.flip();\n-        dest.put(buf);\n+        for (ByteBuffer buffer: buf.nioBuffers()) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NTM2OA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401965368", "bodyText": "This is easier. dest will read all the ByteBufs in the array of compositeBuffers, so buf.readBytes(dest) would fail. We have to set limit on dest before reading bytes from buf. But in this way, we don't have to.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAyMTc1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTEwNw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401041107", "bodyText": "why was the leak helper disabled for this test case?", "author": "cgtz", "createdAt": "2020-03-31T16:15:41Z", "path": "ambry-router/src/test/java/com.github.ambry.router/NonBlockingRouterTest.java", "diffHunk": "@@ -411,6 +413,7 @@ public void testRouterNoPartitionInLocalDC() throws Exception {\n    */\n   @Test\n   public void testRequestResponseHandlerThreadExitFlow() throws Exception {\n+    nettyByteBufLeakHelper.setDisabled(true);", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NTk2NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401965964", "bodyText": "There are tests in NonBlockingRouterTest that needs creates new ByteBuf by putting a blob to the in memory router but never release it. Those tests are going to break the leak detector helper. That's why I disable the leak detector helper for those tests.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTEwNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0NzI0OQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401047249", "bodyText": "nit: if less then -> is less than, than this -> then this", "author": "cgtz", "createdAt": "2020-03-31T16:24:31Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -562,9 +587,11 @@ void fillChunks() {\n         }\n       }\n       if (chunkFillingCompletedSuccessfully) {\n+        // If the blob size if less then 4MB or the last chunk size is less than 4MB, than this lastChunk will be", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "800d95e84c472219464019dded7a628f5d7ca084", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..8ae40716a 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -587,7 +585,7 @@ class PutOperation {\n         }\n       }\n       if (chunkFillingCompletedSuccessfully) {\n-        // If the blob size if less then 4MB or the last chunk size is less than 4MB, than this lastChunk will be\n+        // If the blob size is less then 4MB or the last chunk size is less than 4MB, than this lastChunk will be\n         // the chunk above.\n         PutChunk lastChunk = getBuildingChunk();\n         if (lastChunk != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMDI1MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401110250", "bodyText": "there is an empty if condition here", "author": "cgtz", "createdAt": "2020-03-31T18:03:43Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -528,10 +551,12 @@ void fillChunks() {\n       PutChunk chunkToFill;\n       while (!isChunkFillingDone()) {\n         // Attempt to fill a chunk\n-        if (channelReadBuffer == null) {\n-          channelReadBuffer = chunkFillerChannel.getNextChunk(0);\n+        if (channelReadBuf == null) {\n+          channelReadBuf = chunkFillerChannel.getNextByteBuf(0);\n+          if (channelReadBuf != null) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -553,8 +553,6 @@ class PutOperation {\n         // Attempt to fill a chunk\n         if (channelReadBuf == null) {\n           channelReadBuf = chunkFillerChannel.getNextByteBuf(0);\n-          if (channelReadBuf != null) {\n-          }\n         }\n         if (channelReadBuf != null) {\n           maybeStopTrackingWaitForChannelDataTime();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyNjA4MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401126081", "bodyText": "Could this be a lower log level? Or moved inside of the if (lastChunk != null) check so it only is printed if there was a chunk still being built?", "author": "cgtz", "createdAt": "2020-03-31T18:30:22Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -575,10 +602,21 @@ void fillChunks() {\n           }\n         }\n       }\n+      if (operationCompleted) {\n+        logger.info(\"Clear unfinished chunk since operation is completed\");", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -603,10 +601,11 @@ class PutOperation {\n         }\n       }\n       if (operationCompleted) {\n-        logger.info(\"Clear unfinished chunk since operation is completed\");\n         PutChunk lastChunk = getBuildingChunk();\n         if (lastChunk != null) {\n-          lastChunk.clear();\n+          logger.info(\"Clear unfinished chunk since operation is completed\");\n+          // call release blob content, not clear, since clear should only be used in the main thread.\n+          lastChunk.releaseBlobContent();\n         }\n       }\n     } catch (Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MTI2MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401161260", "bodyText": "The clear() method does not seem like it was meant to be called from non-main threads. Is it necessary to do all of the cleanup or just call releaseBlobContent here and in fillChunks()?", "author": "cgtz", "createdAt": "2020-03-31T19:29:06Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {\n+                  logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n+                  if (!isMetadataChunk()) {\n+                    releaseBlobContent();\n+                  }\n+                  encryptJobMetricsTracker.onJobResultProcessingStart();\n+                  if (exception == null && !isOperationComplete()) {\n+                    if (!isMetadataChunk()) {\n+                      buf = result.getEncryptedBlobContent();\n+                    }\n+                    encryptedPerBlobKey = result.getEncryptedKey();\n+                    chunkUserMetadata = result.getEncryptedUserMetadata().array();\n+                    logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n+                    prepareForSending();\n+                    chunkReadyAtMs = time.milliseconds();\n+                  } else {\n+                    encryptJobMetricsTracker.incrementOperationError();\n+                    if (!isOperationComplete()) {\n+                      logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n+                      // If we are here, then the result is null. no need to release it.\n+                      setOperationExceptionAndComplete(new RouterException(\n+                          \"Exception thrown on encrypting the content for chunk at index \" + chunkIndex, exception,\n+                          RouterErrorCode.UnexpectedInternalError));\n+                    } else {\n+                      logger.trace(\n+                          \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n+                          chunkIndex, getOperationException(), exception);\n+                      // If we are here, then the operation is completed and the exception could be null, in this case,\n+                      // we have to release the content in the result.\n+                      if (result != null) {\n+                        result.release();\n+                      }\n+                    }\n+                  }\n+                  routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n+                  encryptJobMetricsTracker.onJobResultProcessingComplete();\n+                  routerCallback.onPollReady();\n+                  // double check if the operation is not completed. If so, we have to release the buf here, since in\n+                  // main thread, chunk might already be released.\n+                  if (isOperationComplete()) {\n+                    logger.info(\"Clear put chunk in encryption callback since operation is completed\");\n+                    clear();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjA4MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966081", "bodyText": "make sense", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MTI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1147,62 +1199,14 @@ class PutOperation {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n-                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n-                (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-                  logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-                  if (!isMetadataChunk()) {\n-                    releaseBlobContent();\n-                  }\n-                  encryptJobMetricsTracker.onJobResultProcessingStart();\n-                  if (exception == null && !isOperationComplete()) {\n-                    if (!isMetadataChunk()) {\n-                      buf = result.getEncryptedBlobContent();\n-                    }\n-                    encryptedPerBlobKey = result.getEncryptedKey();\n-                    chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                    logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                    prepareForSending();\n-                    chunkReadyAtMs = time.milliseconds();\n-                  } else {\n-                    encryptJobMetricsTracker.incrementOperationError();\n-                    if (!isOperationComplete()) {\n-                      logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                      // If we are here, then the result is null. no need to release it.\n-                      setOperationExceptionAndComplete(new RouterException(\n-                          \"Exception thrown on encrypting the content for chunk at index \" + chunkIndex, exception,\n-                          RouterErrorCode.UnexpectedInternalError));\n-                    } else {\n-                      logger.trace(\n-                          \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                          chunkIndex, getOperationException(), exception);\n-                      // If we are here, then the operation is completed and the exception could be null, in this case,\n-                      // we have to release the content in the result.\n-                      if (result != null) {\n-                        result.release();\n-                      }\n-                    }\n-                  }\n-                  routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-                  encryptJobMetricsTracker.onJobResultProcessingComplete();\n-                  routerCallback.onPollReady();\n-                  // double check if the operation is not completed. If so, we have to release the buf here, since in\n-                  // main thread, chunk might already be released.\n-                  if (isOperationComplete()) {\n-                    logger.info(\"Clear put chunk in encryption callback since operation is completed\");\n-                    clear();\n-                  }\n-                }));\n+                isMetadataChunk() ? null : buf.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker, this::encryptionCallback));\n       } catch (GeneralSecurityException e) {\n         encryptJobMetricsTracker.incrementOperationError();\n         logger.trace(\"Exception thrown while generating random key for chunk at index {}\", chunkIndex, e);\n         setOperationExceptionAndComplete(new RouterException(\n             \"GeneralSecurityException thrown while generating random key for chunk at index \" + chunkIndex, e,\n             RouterErrorCode.UnexpectedInternalError));\n-      } finally {\n-        if (toEncrypt != null) {\n-          toEncrypt.release();\n-        }\n       }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MzA0Mg==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401163042", "bodyText": "This lambda is quite long. Could you move it to a helper function. e.g. void onEncryptionComplete(EncryptJobResult, Exception)?", "author": "cgtz", "createdAt": "2020-03-31T19:32:25Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1147,62 +1199,14 @@ class PutOperation {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n-                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n-                (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-                  logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-                  if (!isMetadataChunk()) {\n-                    releaseBlobContent();\n-                  }\n-                  encryptJobMetricsTracker.onJobResultProcessingStart();\n-                  if (exception == null && !isOperationComplete()) {\n-                    if (!isMetadataChunk()) {\n-                      buf = result.getEncryptedBlobContent();\n-                    }\n-                    encryptedPerBlobKey = result.getEncryptedKey();\n-                    chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                    logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                    prepareForSending();\n-                    chunkReadyAtMs = time.milliseconds();\n-                  } else {\n-                    encryptJobMetricsTracker.incrementOperationError();\n-                    if (!isOperationComplete()) {\n-                      logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                      // If we are here, then the result is null. no need to release it.\n-                      setOperationExceptionAndComplete(new RouterException(\n-                          \"Exception thrown on encrypting the content for chunk at index \" + chunkIndex, exception,\n-                          RouterErrorCode.UnexpectedInternalError));\n-                    } else {\n-                      logger.trace(\n-                          \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                          chunkIndex, getOperationException(), exception);\n-                      // If we are here, then the operation is completed and the exception could be null, in this case,\n-                      // we have to release the content in the result.\n-                      if (result != null) {\n-                        result.release();\n-                      }\n-                    }\n-                  }\n-                  routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-                  encryptJobMetricsTracker.onJobResultProcessingComplete();\n-                  routerCallback.onPollReady();\n-                  // double check if the operation is not completed. If so, we have to release the buf here, since in\n-                  // main thread, chunk might already be released.\n-                  if (isOperationComplete()) {\n-                    logger.info(\"Clear put chunk in encryption callback since operation is completed\");\n-                    clear();\n-                  }\n-                }));\n+                isMetadataChunk() ? null : buf.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker, this::encryptionCallback));\n       } catch (GeneralSecurityException e) {\n         encryptJobMetricsTracker.incrementOperationError();\n         logger.trace(\"Exception thrown while generating random key for chunk at index {}\", chunkIndex, e);\n         setOperationExceptionAndComplete(new RouterException(\n             \"GeneralSecurityException thrown while generating random key for chunk at index \" + chunkIndex, e,\n             RouterErrorCode.UnexpectedInternalError));\n-      } finally {\n-        if (toEncrypt != null) {\n-          toEncrypt.release();\n-        }\n       }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTEzMw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401165133", "bodyText": "It seems like this buffer is retained and then retained again with toEncrypt.retainedDuplicate() and then released at the end of this method. Could the retain from this line and release on 1204 be removed?", "author": "cgtz", "createdAt": "2020-03-31T19:36:15Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1144,6 +1138,7 @@ private void prepareForSending() {\n      * Submits encrypt job for the given {@link PutChunk} and processes the callback for the same\n      */\n     private void encryptChunk() {\n+      ByteBuf toEncrypt = buf.retain();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjEzNA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966134", "bodyText": "legacy code.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1134,11 +1134,63 @@ class PutOperation {\n       }\n     }\n \n+    /**\n+     * The callback method to handle the result and exception from an encryption job.\n+     * @param result The result of Encryption job.\n+     * @param exception The exception of Encryption job.\n+     */\n+    private void encryptionCallback(EncryptJob.EncryptJobResult result, Exception exception) {\n+      logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n+      if (!isMetadataChunk()) {\n+        // If this is a data blob, then release the content with or without exception.\n+        // When there is no exception, then the encrypted data will be used.\n+        // When there is an exception, then PutOperation will be terminated, and there is no use for this blob anymore.\n+        releaseBlobContent();\n+      }\n+      encryptJobMetricsTracker.onJobResultProcessingStart();\n+      if (exception == null && !isOperationComplete()) {\n+        if (!isMetadataChunk()) {\n+          buf = result.getEncryptedBlobContent();\n+        }\n+        encryptedPerBlobKey = result.getEncryptedKey();\n+        chunkUserMetadata = result.getEncryptedUserMetadata().array();\n+        logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n+        prepareForSending();\n+        chunkReadyAtMs = time.milliseconds();\n+      } else {\n+        encryptJobMetricsTracker.incrementOperationError();\n+        if (!isOperationComplete()) {\n+          logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n+          // If we are here, then the result is null. no need to release it.\n+          setOperationExceptionAndComplete(\n+              new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n+                  exception, RouterErrorCode.UnexpectedInternalError));\n+        } else {\n+          logger.trace(\n+              \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n+              chunkIndex, getOperationException(), exception);\n+          // If we are here, then the operation is completed and the exception could be null, in this case,\n+          // we have to release the content in the result.\n+          if (result != null) {\n+            result.release();\n+          }\n+        }\n+      }\n+      routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n+      encryptJobMetricsTracker.onJobResultProcessingComplete();\n+      routerCallback.onPollReady();\n+      // double check if the operation is not completed. If so, we have to release the buf here, since in\n+      // main thread, chunk might already be released.\n+      if (isOperationComplete()) {\n+        logger.info(\"Release blob content for put chunk in encryption callback since operation is completed\");\n+        releaseBlobContent();\n+      }\n+    }\n+\n     /**\n      * Submits encrypt job for the given {@link PutChunk} and processes the callback for the same\n      */\n     private void encryptChunk() {\n-      ByteBuf toEncrypt = buf.retain();\n       try {\n         logger.trace(\"Chunk at index {} moves to {} state\", chunkIndex, ChunkState.Encrypting);\n         state = ChunkState.Encrypting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODI4NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168284", "bodyText": "for declaringtoWrite and remaininSlice you can remove the assignment part because of each of them are assigned by all the cases afterwards", "author": "cgtz", "createdAt": "2020-03-31T19:42:03Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjIyOA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966228", "bodyText": "updated to new code.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1230,33 +1234,23 @@ class PutOperation {\n      * @return the number of bytes transferred in this operation.\n      */\n     int fillFrom(ByteBuf channelReadBuf) {\n-      int toWrite = 0;\n+      int toWrite;\n       if (buf == null) {\n-        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n-          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n-          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          buf = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n         int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n-        ByteBuf remainingSlice = null;\n-        if (channelReadBuf.readableBytes() > remainingSize) {\n-          toWrite = remainingSize;\n-          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n-        int size = buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n         // buf already has some bytes\n         if (buf instanceof CompositeByteBuf) {\n           // Buf is already a CompositeByteBuf, then just add the slice from\n           ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n         } else {\n-          CompositeByteBuf composite =\n-              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);\n+          int maxComponents = routerConfig.routerMaxPutChunkSizeBytes;\n+          CompositeByteBuf composite = buf.isDirect() ? buf.alloc().compositeDirectBuffer(maxComponents)\n+              : buf.alloc().compositeHeapBuffer(maxComponents);\n           composite.addComponents(true, buf, remainingSlice);\n           buf = composite;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODM4OQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168389", "bodyText": "size unused", "author": "cgtz", "createdAt": "2020-03-31T19:42:16Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1230,33 +1234,23 @@ class PutOperation {\n      * @return the number of bytes transferred in this operation.\n      */\n     int fillFrom(ByteBuf channelReadBuf) {\n-      int toWrite = 0;\n+      int toWrite;\n       if (buf == null) {\n-        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n-          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n-          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          buf = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n         int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n-        ByteBuf remainingSlice = null;\n-        if (channelReadBuf.readableBytes() > remainingSize) {\n-          toWrite = remainingSize;\n-          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n-        int size = buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n         // buf already has some bytes\n         if (buf instanceof CompositeByteBuf) {\n           // Buf is already a CompositeByteBuf, then just add the slice from\n           ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n         } else {\n-          CompositeByteBuf composite =\n-              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);\n+          int maxComponents = routerConfig.routerMaxPutChunkSizeBytes;\n+          CompositeByteBuf composite = buf.isDirect() ? buf.alloc().compositeDirectBuffer(maxComponents)\n+              : buf.alloc().compositeHeapBuffer(maxComponents);\n           composite.addComponents(true, buf, remainingSlice);\n           buf = composite;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MTQzNw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401171437", "bodyText": "The javadocs for CompositeByteBuf recommend using the alloc.compositeBuffer() methods if possible. Probably since the allocators seem to wrap the buffer with extra leak detection stuff (see AbstractByteBufAllocator). Also, the third param is the max number of child components in the buffer, not the max size in bytes. I guess it is still valuable to raise the limit since the default limit seems to be 16 from AbstractByteBufAllocator.\nThis can probably be composite = buf.isDirect()? buf.alloc().compositeDirectBuffer(maxComponents) : buf.alloc().compositeHeapBuffer(maxComponents) instead.", "author": "cgtz", "createdAt": "2020-03-31T19:47:56Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {\n+          // Buf is already a CompositeByteBuf, then just add the slice from\n+          ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n+        } else {\n+          CompositeByteBuf composite =\n+              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjI2Mw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966263", "bodyText": "make sense.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MTQzNw=="}], "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1230,33 +1234,23 @@ class PutOperation {\n      * @return the number of bytes transferred in this operation.\n      */\n     int fillFrom(ByteBuf channelReadBuf) {\n-      int toWrite = 0;\n+      int toWrite;\n       if (buf == null) {\n-        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n-          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n-          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          buf = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n         int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n-        ByteBuf remainingSlice = null;\n-        if (channelReadBuf.readableBytes() > remainingSize) {\n-          toWrite = remainingSize;\n-          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n-        int size = buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n         // buf already has some bytes\n         if (buf instanceof CompositeByteBuf) {\n           // Buf is already a CompositeByteBuf, then just add the slice from\n           ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n         } else {\n-          CompositeByteBuf composite =\n-              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);\n+          int maxComponents = routerConfig.routerMaxPutChunkSizeBytes;\n+          CompositeByteBuf composite = buf.isDirect() ? buf.alloc().compositeDirectBuffer(maxComponents)\n+              : buf.alloc().compositeHeapBuffer(maxComponents);\n           composite.addComponents(true, buf, remainingSlice);\n           buf = composite;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401177103", "bodyText": "What if channelReadBuf was already a CompositeByteBuf? Would it be safer to just initialize the buffer in prepareForBuilding instead of use type checking logic here? The only thing that I think would be lost would be if the buffer came with a non-default allocator and the logic about direct vs not, but I don't think either of these will be used in practice unless the composite buffers capacity is expanded or components are squashed together inside.", "author": "cgtz", "createdAt": "2020-03-31T19:57:58Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjY2Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966667", "bodyText": "I was under the impression that channelReadBuf is passed to PutOperation from HttpContent and shouldn't be composite bytebuf. Is there cases where it will be composite bytebuf?", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTE4MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401971180", "bodyText": "You're probably right that there are no cases in practice with the chunked HttpContents we use. I just wanted to not make too many assumptions about the input in case something changes down the line", "author": "cgtz", "createdAt": "2020-04-01T23:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3ODE1MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403378151", "bodyText": "If we keep this code as it's, then when the channelReadBuf is a CompositeByteBuf, then when we do channelReadBuf.readRetainedSlice, it returns a unpooled ByteBuf. I suppose the code would still operate, but just not with the optimized memory arranagement.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "chunk": "diff --git a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nsimilarity index 94%\nrename from ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\nrename to ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 74a2e0c1f..4ee3e9571 100644\n--- a/ambry-router/src/main/java/com.github.ambry.router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1230,33 +1234,23 @@ class PutOperation {\n      * @return the number of bytes transferred in this operation.\n      */\n     int fillFrom(ByteBuf channelReadBuf) {\n-      int toWrite = 0;\n+      int toWrite;\n       if (buf == null) {\n-        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n-          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n-          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          buf = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n         int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n-        ByteBuf remainingSlice = null;\n-        if (channelReadBuf.readableBytes() > remainingSize) {\n-          toWrite = remainingSize;\n-          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n-        } else {\n-          toWrite = channelReadBuf.readableBytes();\n-          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n-        }\n-        int size = buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n         // buf already has some bytes\n         if (buf instanceof CompositeByteBuf) {\n           // Buf is already a CompositeByteBuf, then just add the slice from\n           ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n         } else {\n-          CompositeByteBuf composite =\n-              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);\n+          int maxComponents = routerConfig.routerMaxPutChunkSizeBytes;\n+          CompositeByteBuf composite = buf.isDirect() ? buf.alloc().compositeDirectBuffer(maxComponents)\n+              : buf.alloc().compositeHeapBuffer(maxComponents);\n           composite.addComponents(true, buf, remainingSlice);\n           buf = composite;\n         }\n"}}, {"oid": "7898d32775be9befbe576ff3fe427a21d04afb26", "url": "https://github.com/linkedin/ambry/commit/7898d32775be9befbe576ff3fe427a21d04afb26", "message": "Rebase", "committedDate": "2020-04-01T20:30:20Z", "type": "forcePushed"}, {"oid": "be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "url": "https://github.com/linkedin/ambry/commit/be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "message": "Comments", "committedDate": "2020-04-01T20:36:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTc0NQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402515745", "bodyText": "any reason to increase it?", "author": "zzmao", "createdAt": "2020-04-02T18:13:24Z", "path": "ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java", "diffHunk": "@@ -71,7 +71,7 @@ public void close() {\n         }\n       }\n       try {\n-        scheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);\n+        scheduler.awaitTermination(10000, TimeUnit.MILLISECONDS);", "originalCommit": "573eefe64025e2a6cc69c95eb02dd89b155b471f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTc0Ng==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379746", "bodyText": "for testing purpose, i will revert.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "cec396a216436b638079bd8c60fee71151eb19c7", "chunk": "diff --git a/ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java b/ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java\nindex 05887ed53..86576be5f 100644\n--- a/ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java\n\n@@ -71,7 +71,7 @@ class CryptoJobHandler implements Closeable {\n         }\n       }\n       try {\n-        scheduler.awaitTermination(10000, TimeUnit.MILLISECONDS);\n+        scheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);\n       } catch (Exception e) {\n         logger.error(\"Unexpected exception while waiting for crypto jobs to terminate\", e);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402523494", "bodyText": "Can you explain a little bit how fillFrom triggered?  I am not familiar with this area.\nFor 1 MB blob put, will it trigger fillFrom multiple times?\nMy concern here is if this will cause many small ByteBufs in buf.", "author": "zzmao", "createdAt": "2020-04-02T18:26:53Z", "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "diffHunk": "@@ -1211,22 +1229,33 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite;\n+      if (buf == null) {\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        // buf already has some bytes", "originalCommit": "573eefe64025e2a6cc69c95eb02dd89b155b471f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTE4Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379187", "bodyText": "It depends on how the http content works. For http put request, frontend would receive a bunch of netty httpContents, each http content carries a netty bytebuf, which is channelReadBuf. PutManager has a running thread that calls fillFrom periodically.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTU3Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379577", "bodyText": "If we have a 1MB blob, if the frontend receives 10 100K bytebuf, then the final buf would have 10 small ByteBuf. But the important thing is this is zero-copy bytebuf. We don't have to move any bytes from one place to another.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "ca1583e6dd81d1097a856553990b84b354114732", "chunk": "diff --git a/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\nindex 1f4a3bb28..05400d2b2 100644\n--- a/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n+++ b/ambry-router/src/main/java/com/github/ambry/router/PutOperation.java\n\n@@ -1234,23 +1230,33 @@ class PutOperation {\n      * @return the number of bytes transferred in this operation.\n      */\n     int fillFrom(ByteBuf channelReadBuf) {\n-      int toWrite;\n+      int toWrite = 0;\n       if (buf == null) {\n-        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n-        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n-        buf = channelReadBuf.readRetainedSlice(toWrite);\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n         int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n-        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n-        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n         // buf already has some bytes\n         if (buf instanceof CompositeByteBuf) {\n           // Buf is already a CompositeByteBuf, then just add the slice from\n           ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n         } else {\n-          int maxComponents = routerConfig.routerMaxPutChunkSizeBytes;\n-          CompositeByteBuf composite = buf.isDirect() ? buf.alloc().compositeDirectBuffer(maxComponents)\n-              : buf.alloc().compositeHeapBuffer(maxComponents);\n+          CompositeByteBuf composite =\n+              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);\n           composite.addComponents(true, buf, remainingSlice);\n           buf = composite;\n         }\n"}}, {"oid": "ca1583e6dd81d1097a856553990b84b354114732", "url": "https://github.com/linkedin/ambry/commit/ca1583e6dd81d1097a856553990b84b354114732", "message": "Using Netty ByteByte in PutOperation", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "3ba16d5908141ec0955d17afbd5617dbab4ab6db", "url": "https://github.com/linkedin/ambry/commit/3ba16d5908141ec0955d17afbd5617dbab4ab6db", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "1436919a5886e64d89587704ca0682c1e4e1a71f", "url": "https://github.com/linkedin/ambry/commit/1436919a5886e64d89587704ca0682c1e4e1a71f", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "url": "https://github.com/linkedin/ambry/commit/1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "message": "Address comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "800d95e84c472219464019dded7a628f5d7ca084", "url": "https://github.com/linkedin/ambry/commit/800d95e84c472219464019dded7a628f5d7ca084", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "8081abee24fdbf49e321a60604957fb09f666b79", "url": "https://github.com/linkedin/ambry/commit/8081abee24fdbf49e321a60604957fb09f666b79", "message": "Another comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "2897ff86eb5d41c300a7c539fd52eef00b0dd429", "url": "https://github.com/linkedin/ambry/commit/2897ff86eb5d41c300a7c539fd52eef00b0dd429", "message": "Fix test failure", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "message": "Address comments", "committedDate": "2020-04-03T23:16:39Z", "type": "commit"}, {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "message": "Address comments", "committedDate": "2020-04-03T23:16:39Z", "type": "forcePushed"}]}