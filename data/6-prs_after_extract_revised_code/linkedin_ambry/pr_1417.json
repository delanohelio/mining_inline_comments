{"pr_number": 1417, "pr_title": "Minor changes in CloudToStoreReplicationManager for move replica", "pr_createdAt": "2020-03-05T20:02:24Z", "pr_url": "https://github.com/linkedin/ambry/pull/1417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4MTM0Ng==", "url": "https://github.com/linkedin/ambry/pull/1417#discussion_r389781346", "bodyText": "that makes sense.", "author": "lightningrob", "createdAt": "2020-03-09T15:49:37Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/CloudReplica.java", "diffHunk": "@@ -62,11 +62,10 @@ public String getReplicaPath() {\n \n   @Override\n   public List<ReplicaId> getPeerReplicaIds() {\n-    List<ReplicaId> replicasOfPartition = partitionId.getReplicaIds()\n+    return partitionId.getReplicaIds()\n         .stream()\n         .filter(replica -> replica.getDataNodeId().compareTo(dataNodeId) != 0)", "originalCommit": "b0ebb43aa0c224f567ea5a63c2b9b17b0ebbe6b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxMDczNw==", "url": "https://github.com/linkedin/ambry/pull/1417#discussion_r389910737", "bodyText": "I don't think we should expose an internal thread pool just for the test to check if an operation succeeded.  Perhaps we can expose a more specific method like hasStoreForDatacenter() in the ReplicationEngine base class?", "author": "lightningrob", "createdAt": "2020-03-09T19:26:01Z", "path": "ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockClusterMap;\n+import com.github.ambry.clustermap.MockClusterSpectator;\n+import com.github.ambry.clustermap.MockDataNodeId;\n+import com.github.ambry.clustermap.MockHelixParticipant;\n+import com.github.ambry.clustermap.MockPartitionId;\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.DiskManagerConfig;\n+import com.github.ambry.config.ReplicationConfig;\n+import com.github.ambry.config.ServerConfig;\n+import com.github.ambry.config.StoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.Port;\n+import com.github.ambry.network.PortType;\n+import com.github.ambry.store.MockStoreKeyConverterFactory;\n+import com.github.ambry.store.StorageManager;\n+import com.github.ambry.store.StoreKey;\n+import com.github.ambry.store.StoreKeyFactory;\n+import com.github.ambry.utils.MockTime;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.json.JSONObject;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import static com.github.ambry.clustermap.ClusterMapUtils.*;\n+import static com.github.ambry.clustermap.TestUtils.*;\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * Tests for {@link CloudToStoreReplicationManager} when adding/removing cloud replica. The tests also cover the case\n+ * where new replica is added due to \"move replica\".\n+ */\n+public class CloudToStoreReplicationManagerTest {\n+  private static final String NEW_PARTITION_NAME = \"12\";\n+  private static final String CLOUD_DC_NAME = \"CloudDc\";\n+  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n+  private final VerifiableProperties verifiableProperties;\n+  private final ScheduledExecutorService mockScheduler;\n+  private final StoreKeyFactory storeKeyFactory;\n+  private final ClusterMapConfig clusterMapConfig;\n+  private final ReplicationConfig replicationConfig;\n+  private final ServerConfig serverConfig;\n+  private final StoreConfig storeConfig;\n+  private final MockStoreKeyConverterFactory storeKeyConverterFactory;\n+  private final MockDataNodeId vcrNode;\n+  private final DataNodeId currentNode;\n+  private final MockHelixParticipant mockHelixParticipant;\n+  private final MockClusterSpectator mockClusterSpectator;\n+  private final MockClusterMap clusterMap;\n+\n+  public CloudToStoreReplicationManagerTest() throws Exception {\n+    List<TestUtils.ZkInfo> zkInfoList = new ArrayList<>();\n+    zkInfoList.add(new TestUtils.ZkInfo(null, \"DC1\", (byte) 0, 2299, false));\n+    JSONObject zkJson = constructZkLayoutJSON(zkInfoList);\n+    storeKeyConverterFactory = new MockStoreKeyConverterFactory(null, null);\n+    storeKeyConverterFactory.setConversionMap(new HashMap<>());\n+    mockScheduler = Mockito.mock(ScheduledExecutorService.class);\n+    storeKeyFactory = new StoreKeyFactory() {\n+      @Override\n+      public StoreKey getStoreKey(DataInputStream stream) throws IOException {\n+        return null;\n+      }\n+\n+      @Override\n+      public StoreKey getStoreKey(String input) throws IOException {\n+        return null;\n+      }\n+    };\n+    // create vcr node\n+    List<Port> vcrPortList = Arrays.asList(new Port(12310, PortType.PLAINTEXT), new Port(12410, PortType.SSL));\n+    vcrNode = new MockDataNodeId(\"localhost\", vcrPortList, Collections.singletonList(VCR_MOUNT_PATH), CLOUD_DC_NAME);\n+    clusterMap = new MockClusterMap();\n+    currentNode = clusterMap.getDataNodeIds().get(0);\n+    mockClusterSpectator = new MockClusterSpectator(Collections.singletonList(vcrNode));\n+    long replicaCapacity = clusterMap.getAllPartitionIds(null).get(0).getReplicaIds().get(0).getCapacityInBytes();\n+    Properties properties = new Properties();\n+    properties.setProperty(\"store.segment.size.in.bytes\", Long.toString(replicaCapacity / 2L));\n+    properties.setProperty(\"clustermap.cluster.name\", \"test\");\n+    properties.setProperty(\"clustermap.datacenter.name\", \"DC1\");\n+    properties.setProperty(\"clustermap.vcr.datacenter.name\", \"DC1\");\n+    properties.setProperty(\"clustermap.host.name\", \"localhost\");\n+    properties.setProperty(\"clustermap.dcs.zk.connect.strings\", zkJson.toString(2));\n+    properties.setProperty(\"replication.cloud.token.factory\", \"com.github.ambry.replication.MockFindTokenFactory\");\n+    properties.setProperty(\"disk.manager.enable.segment.pooling\", \"true\");\n+    verifiableProperties = new VerifiableProperties(properties);\n+    storeConfig = new StoreConfig(verifiableProperties);\n+    clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n+    replicationConfig = new ReplicationConfig(verifiableProperties);\n+    serverConfig = new ServerConfig(verifiableProperties);\n+    mockHelixParticipant = new MockHelixParticipant(clusterMapConfig);\n+  }\n+\n+  /**\n+   * Test both success and failure cases when adding cloud replica\n+   * @throws Exception\n+   */\n+  @Test\n+  public void cloudReplicaAdditionTest() throws Exception {\n+    StorageManager storageManager =\n+        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n+            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n+            null);\n+    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n+        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n+            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n+            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n+            mockHelixParticipant);\n+    storageManager.start();\n+    cloudToStoreReplicationManager.start();\n+    mockClusterSpectator.spectate();\n+    // 1. test adding cloud replica that is not present locally\n+    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n+    assertNull(\"Thread pool for DC1 should be null\",\n+        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));", "originalCommit": "b0ebb43aa0c224f567ea5a63c2b9b17b0ebbe6b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "25662360f32401ca08591b2e302625322675fe7a", "chunk": "diff --git a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java b/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\ndeleted file mode 100644\nindex 858e75957..000000000\n--- a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-/**\n- * Copyright 2020 LinkedIn Corp. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- */\n-package com.github.ambry.replication;\n-\n-import com.github.ambry.clustermap.DataNodeId;\n-import com.github.ambry.clustermap.MockClusterMap;\n-import com.github.ambry.clustermap.MockClusterSpectator;\n-import com.github.ambry.clustermap.MockDataNodeId;\n-import com.github.ambry.clustermap.MockHelixParticipant;\n-import com.github.ambry.clustermap.MockPartitionId;\n-import com.github.ambry.clustermap.PartitionId;\n-import com.github.ambry.clustermap.ReplicaId;\n-import com.github.ambry.config.ClusterMapConfig;\n-import com.github.ambry.config.DiskManagerConfig;\n-import com.github.ambry.config.ReplicationConfig;\n-import com.github.ambry.config.ServerConfig;\n-import com.github.ambry.config.StoreConfig;\n-import com.github.ambry.config.VerifiableProperties;\n-import com.github.ambry.network.Port;\n-import com.github.ambry.network.PortType;\n-import com.github.ambry.store.MockStoreKeyConverterFactory;\n-import com.github.ambry.store.StorageManager;\n-import com.github.ambry.store.StoreKey;\n-import com.github.ambry.store.StoreKeyFactory;\n-import com.github.ambry.utils.MockTime;\n-import com.github.ambry.utils.TestUtils;\n-import com.github.ambry.utils.Utils;\n-import java.io.DataInputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.concurrent.ScheduledExecutorService;\n-import org.json.JSONObject;\n-import org.junit.Test;\n-import org.mockito.Mockito;\n-\n-import static com.github.ambry.clustermap.ClusterMapUtils.*;\n-import static com.github.ambry.clustermap.TestUtils.*;\n-import static org.junit.Assert.*;\n-\n-\n-/**\n- * Tests for {@link CloudToStoreReplicationManager} when adding/removing cloud replica. The tests also cover the case\n- * where new replica is added due to \"move replica\".\n- */\n-public class CloudToStoreReplicationManagerTest {\n-  private static final String NEW_PARTITION_NAME = \"12\";\n-  private static final String CLOUD_DC_NAME = \"CloudDc\";\n-  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n-  private final VerifiableProperties verifiableProperties;\n-  private final ScheduledExecutorService mockScheduler;\n-  private final StoreKeyFactory storeKeyFactory;\n-  private final ClusterMapConfig clusterMapConfig;\n-  private final ReplicationConfig replicationConfig;\n-  private final ServerConfig serverConfig;\n-  private final StoreConfig storeConfig;\n-  private final MockStoreKeyConverterFactory storeKeyConverterFactory;\n-  private final MockDataNodeId vcrNode;\n-  private final DataNodeId currentNode;\n-  private final MockHelixParticipant mockHelixParticipant;\n-  private final MockClusterSpectator mockClusterSpectator;\n-  private final MockClusterMap clusterMap;\n-\n-  public CloudToStoreReplicationManagerTest() throws Exception {\n-    List<TestUtils.ZkInfo> zkInfoList = new ArrayList<>();\n-    zkInfoList.add(new TestUtils.ZkInfo(null, \"DC1\", (byte) 0, 2299, false));\n-    JSONObject zkJson = constructZkLayoutJSON(zkInfoList);\n-    storeKeyConverterFactory = new MockStoreKeyConverterFactory(null, null);\n-    storeKeyConverterFactory.setConversionMap(new HashMap<>());\n-    mockScheduler = Mockito.mock(ScheduledExecutorService.class);\n-    storeKeyFactory = new StoreKeyFactory() {\n-      @Override\n-      public StoreKey getStoreKey(DataInputStream stream) throws IOException {\n-        return null;\n-      }\n-\n-      @Override\n-      public StoreKey getStoreKey(String input) throws IOException {\n-        return null;\n-      }\n-    };\n-    // create vcr node\n-    List<Port> vcrPortList = Arrays.asList(new Port(12310, PortType.PLAINTEXT), new Port(12410, PortType.SSL));\n-    vcrNode = new MockDataNodeId(\"localhost\", vcrPortList, Collections.singletonList(VCR_MOUNT_PATH), CLOUD_DC_NAME);\n-    clusterMap = new MockClusterMap();\n-    currentNode = clusterMap.getDataNodeIds().get(0);\n-    mockClusterSpectator = new MockClusterSpectator(Collections.singletonList(vcrNode));\n-    long replicaCapacity = clusterMap.getAllPartitionIds(null).get(0).getReplicaIds().get(0).getCapacityInBytes();\n-    Properties properties = new Properties();\n-    properties.setProperty(\"store.segment.size.in.bytes\", Long.toString(replicaCapacity / 2L));\n-    properties.setProperty(\"clustermap.cluster.name\", \"test\");\n-    properties.setProperty(\"clustermap.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.vcr.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.host.name\", \"localhost\");\n-    properties.setProperty(\"clustermap.dcs.zk.connect.strings\", zkJson.toString(2));\n-    properties.setProperty(\"replication.cloud.token.factory\", \"com.github.ambry.replication.MockFindTokenFactory\");\n-    properties.setProperty(\"disk.manager.enable.segment.pooling\", \"true\");\n-    verifiableProperties = new VerifiableProperties(properties);\n-    storeConfig = new StoreConfig(verifiableProperties);\n-    clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n-    replicationConfig = new ReplicationConfig(verifiableProperties);\n-    serverConfig = new ServerConfig(verifiableProperties);\n-    mockHelixParticipant = new MockHelixParticipant(clusterMapConfig);\n-  }\n-\n-  /**\n-   * Test both success and failure cases when adding cloud replica\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaAdditionTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    // 1. test adding cloud replica that is not present locally\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Thread pool for DC1 should be null\",\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    // create a new partition and add corresponding store in storage manager\n-    PartitionId newPartition =\n-        new MockPartitionId(Long.parseLong(NEW_PARTITION_NAME), MockClusterMap.DEFAULT_PARTITION_CLASS,\n-            clusterMap.getDataNodes(), 0);\n-    ReplicaId replicaToAdd = newPartition.getReplicaIds().get(0);\n-    assertTrue(\"Adding new store should succeed\", storageManager.addBlobStore(replicaToAdd));\n-    // 2. we deliberately shut down the store to induce failure when adding cloud replica\n-    storageManager.shutdownBlobStore(newPartition);\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Thread pool for DC1 should be null\",\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    storageManager.startBlobStore(newPartition);\n-    // 3. mock success case\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNotNull(\"There should be a thread for DC1\",\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-\n-  /**\n-   * Test both success and failure cases when removing cloud replica.\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaRemovalTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    PartitionId localPartition = storageManager.getLocalPartitions().iterator().next();\n-    // 1. add cloud replica first for subsequent removal test\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(localPartition.toPathString());\n-    assertNotNull(\"Thread pool should not be null for DC1 \",\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    ReplicaThread replicaThread = cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\").get(0);\n-    Map<DataNodeId, List<RemoteReplicaInfo>> nodeToRemoteReplicaInfos = replicaThread.getRemoteReplicaInfos();\n-    assertEquals(\"There should be only one remote replica info in replica thread\", 1, nodeToRemoteReplicaInfos.size());\n-    Map.Entry<DataNodeId, List<RemoteReplicaInfo>> entry = nodeToRemoteReplicaInfos.entrySet().iterator().next();\n-    DataNodeId remoteNode = entry.getKey();\n-    assertEquals(\"Mismatch in InstanceName\", getInstanceName(vcrNode.getHostname(), vcrNode.getPort()),\n-        getInstanceName(remoteNode.getHostname(), remoteNode.getPort()));\n-\n-    // 2. before removing cloud replica of local partition let's remove a non-existent partition first\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(NEW_PARTITION_NAME);\n-    // ensure there is no change in replica thread\n-    assertEquals(\"There should be only one thread\", 1,\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\").size());\n-    assertEquals(\"Remote replica info should stay unchanged\", 1,\n-        replicaThread.getRemoteReplicaInfos().entrySet().iterator().next().getValue().size());\n-    // 3. remove the cloud replica by calling Leader-To-Standby transition on local partition\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(localPartition.toPathString());\n-    // ensure that the remote replica info has been successfully removed from replica thread\n-    assertEquals(\"Remote replica info should be removed\", 0,\n-        replicaThread.getRemoteReplicaInfos().entrySet().iterator().next().getValue().size());\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjY5Mw==", "url": "https://github.com/linkedin/ambry/pull/1417#discussion_r391962693", "bodyText": "I was wondering where this hardcoded constant was coming from and found this horrible line of code in ReplicationEngine.createThreadPool():\nString threadIdentity =  (startThread ? \"Vcr\" : \"\") + \"ReplicaThread-\" + ...\nI'm adding a TODO for myself to fix that and this constant as well.  It's okay for now.", "author": "lightningrob", "createdAt": "2020-03-12T23:49:07Z", "path": "ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.replication;\n+\n+import com.github.ambry.clustermap.DataNodeId;\n+import com.github.ambry.clustermap.MockClusterMap;\n+import com.github.ambry.clustermap.MockClusterSpectator;\n+import com.github.ambry.clustermap.MockDataNodeId;\n+import com.github.ambry.clustermap.MockHelixParticipant;\n+import com.github.ambry.clustermap.MockPartitionId;\n+import com.github.ambry.clustermap.PartitionId;\n+import com.github.ambry.clustermap.ReplicaId;\n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.config.DiskManagerConfig;\n+import com.github.ambry.config.ReplicationConfig;\n+import com.github.ambry.config.ServerConfig;\n+import com.github.ambry.config.StoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.Port;\n+import com.github.ambry.network.PortType;\n+import com.github.ambry.store.MockStoreKeyConverterFactory;\n+import com.github.ambry.store.StorageManager;\n+import com.github.ambry.store.StoreKey;\n+import com.github.ambry.store.StoreKeyFactory;\n+import com.github.ambry.utils.MockTime;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.json.JSONObject;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import static com.github.ambry.clustermap.CloudReplica.*;\n+import static com.github.ambry.clustermap.TestUtils.*;\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * Tests for {@link CloudToStoreReplicationManager} when adding/removing cloud replica. The tests also cover the case\n+ * where new replica is added due to \"move replica\".\n+ */\n+public class CloudToStoreReplicationManagerTest {\n+  private static final String NEW_PARTITION_NAME = \"12\";\n+  private static final String CLOUD_DC_NAME = \"CloudDc\";\n+  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n+  private static final String VCR_REPLICA_THREAD_PREFIX = \"VcrReplicaThread-\";", "originalCommit": "20584d25745a3341cc4dc638080d2dbef51ee883", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MjYzOQ==", "url": "https://github.com/linkedin/ambry/pull/1417#discussion_r391972639", "bodyText": "yeah, we probably need to fix it in ReplicationEngine as well.", "author": "jsjtzyy", "createdAt": "2020-03-13T00:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "25662360f32401ca08591b2e302625322675fe7a", "chunk": "diff --git a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java b/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\ndeleted file mode 100644\nindex b05350a6f..000000000\n--- a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\n+++ /dev/null\n\n@@ -1,207 +0,0 @@\n-/**\n- * Copyright 2020 LinkedIn Corp. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- */\n-package com.github.ambry.replication;\n-\n-import com.github.ambry.clustermap.DataNodeId;\n-import com.github.ambry.clustermap.MockClusterMap;\n-import com.github.ambry.clustermap.MockClusterSpectator;\n-import com.github.ambry.clustermap.MockDataNodeId;\n-import com.github.ambry.clustermap.MockHelixParticipant;\n-import com.github.ambry.clustermap.MockPartitionId;\n-import com.github.ambry.clustermap.PartitionId;\n-import com.github.ambry.clustermap.ReplicaId;\n-import com.github.ambry.config.ClusterMapConfig;\n-import com.github.ambry.config.DiskManagerConfig;\n-import com.github.ambry.config.ReplicationConfig;\n-import com.github.ambry.config.ServerConfig;\n-import com.github.ambry.config.StoreConfig;\n-import com.github.ambry.config.VerifiableProperties;\n-import com.github.ambry.network.Port;\n-import com.github.ambry.network.PortType;\n-import com.github.ambry.store.MockStoreKeyConverterFactory;\n-import com.github.ambry.store.StorageManager;\n-import com.github.ambry.store.StoreKey;\n-import com.github.ambry.store.StoreKeyFactory;\n-import com.github.ambry.utils.MockTime;\n-import com.github.ambry.utils.TestUtils;\n-import com.github.ambry.utils.Utils;\n-import java.io.DataInputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Properties;\n-import java.util.concurrent.ScheduledExecutorService;\n-import org.json.JSONObject;\n-import org.junit.Test;\n-import org.mockito.Mockito;\n-\n-import static com.github.ambry.clustermap.CloudReplica.*;\n-import static com.github.ambry.clustermap.TestUtils.*;\n-import static org.junit.Assert.*;\n-\n-\n-/**\n- * Tests for {@link CloudToStoreReplicationManager} when adding/removing cloud replica. The tests also cover the case\n- * where new replica is added due to \"move replica\".\n- */\n-public class CloudToStoreReplicationManagerTest {\n-  private static final String NEW_PARTITION_NAME = \"12\";\n-  private static final String CLOUD_DC_NAME = \"CloudDc\";\n-  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n-  private static final String VCR_REPLICA_THREAD_PREFIX = \"VcrReplicaThread-\";\n-  private final VerifiableProperties verifiableProperties;\n-  private final ScheduledExecutorService mockScheduler;\n-  private final StoreKeyFactory storeKeyFactory;\n-  private final ClusterMapConfig clusterMapConfig;\n-  private final ReplicationConfig replicationConfig;\n-  private final ServerConfig serverConfig;\n-  private final StoreConfig storeConfig;\n-  private final MockStoreKeyConverterFactory storeKeyConverterFactory;\n-  private final MockDataNodeId vcrNode;\n-  private final DataNodeId currentNode;\n-  private final MockHelixParticipant mockHelixParticipant;\n-  private final MockClusterSpectator mockClusterSpectator;\n-  private final MockClusterMap clusterMap;\n-\n-  public CloudToStoreReplicationManagerTest() throws Exception {\n-    List<TestUtils.ZkInfo> zkInfoList = new ArrayList<>();\n-    zkInfoList.add(new TestUtils.ZkInfo(null, \"DC1\", (byte) 0, 2299, false));\n-    JSONObject zkJson = constructZkLayoutJSON(zkInfoList);\n-    storeKeyConverterFactory = new MockStoreKeyConverterFactory(null, null);\n-    storeKeyConverterFactory.setConversionMap(new HashMap<>());\n-    mockScheduler = Mockito.mock(ScheduledExecutorService.class);\n-    storeKeyFactory = new StoreKeyFactory() {\n-      @Override\n-      public StoreKey getStoreKey(DataInputStream stream) throws IOException {\n-        return null;\n-      }\n-\n-      @Override\n-      public StoreKey getStoreKey(String input) throws IOException {\n-        return null;\n-      }\n-    };\n-    // create vcr node\n-    List<Port> vcrPortList = Arrays.asList(new Port(12310, PortType.PLAINTEXT), new Port(12410, PortType.SSL));\n-    vcrNode = new MockDataNodeId(\"localhost\", vcrPortList, Collections.singletonList(VCR_MOUNT_PATH), CLOUD_DC_NAME);\n-    clusterMap = new MockClusterMap();\n-    currentNode = clusterMap.getDataNodeIds().get(0);\n-    mockClusterSpectator = new MockClusterSpectator(Collections.singletonList(vcrNode));\n-    long replicaCapacity = clusterMap.getAllPartitionIds(null).get(0).getReplicaIds().get(0).getCapacityInBytes();\n-    Properties properties = new Properties();\n-    properties.setProperty(\"store.segment.size.in.bytes\", Long.toString(replicaCapacity / 2L));\n-    properties.setProperty(\"clustermap.cluster.name\", \"test\");\n-    properties.setProperty(\"clustermap.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.vcr.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.host.name\", \"localhost\");\n-    properties.setProperty(\"clustermap.dcs.zk.connect.strings\", zkJson.toString(2));\n-    properties.setProperty(\"replication.cloud.token.factory\", \"com.github.ambry.replication.MockFindTokenFactory\");\n-    properties.setProperty(\"disk.manager.enable.segment.pooling\", \"true\");\n-    verifiableProperties = new VerifiableProperties(properties);\n-    storeConfig = new StoreConfig(verifiableProperties);\n-    clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n-    replicationConfig = new ReplicationConfig(verifiableProperties);\n-    serverConfig = new ServerConfig(verifiableProperties);\n-    mockHelixParticipant = new MockHelixParticipant(clusterMapConfig);\n-  }\n-\n-  /**\n-   * Test both success and failure cases when adding cloud replica\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaAdditionTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    // 1. test adding cloud replica that is not present locally\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Cloud replica thread should not be created\", TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    //assertNull(\"Thread pool for DC1 should be null\",\n-    //cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    // create a new partition and add corresponding store in storage manager\n-    PartitionId newPartition =\n-        new MockPartitionId(Long.parseLong(NEW_PARTITION_NAME), MockClusterMap.DEFAULT_PARTITION_CLASS,\n-            clusterMap.getDataNodes(), 0);\n-    ReplicaId replicaToAdd = newPartition.getReplicaIds().get(0);\n-    assertTrue(\"Adding new store should succeed\", storageManager.addBlobStore(replicaToAdd));\n-    // 2. we deliberately shut down the store to induce failure when adding cloud replica\n-    storageManager.shutdownBlobStore(newPartition);\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Cloud replica thread should not be created\", TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    storageManager.startBlobStore(newPartition);\n-    // 3. mock success case\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNotNull(\"Cloud replica thread should be created for DC1\",\n-        TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-\n-  /**\n-   * Test both success and failure cases when removing cloud replica.\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaRemovalTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    PartitionId localPartition = storageManager.getLocalPartitions().iterator().next();\n-    // 1. add cloud replica first for subsequent removal test\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(localPartition.toPathString());\n-    String replicaPath = Cloud_Replica_Keyword + File.separator + localPartition.toPathString() + File.separator\n-        + localPartition.toPathString();\n-    RemoteReplicaInfo remoteReplicaInfo =\n-        cloudToStoreReplicationManager.getRemoteReplicaInfo(localPartition, vcrNode.getHostname(), replicaPath);\n-    assertNotNull(\"Remote replica info should not be null\", remoteReplicaInfo);\n-    assertEquals(\"There should be only one cloud replica thread created\", 1,\n-        TestUtils.getAllThreadsByThisName(VCR_REPLICA_THREAD_PREFIX).size());\n-\n-    // 2. before removing cloud replica of local partition let's remove a non-existent partition first\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(NEW_PARTITION_NAME);\n-    // ensure there is no change in replica thread\n-    assertEquals(\"There should be only one cloud replica thread created\", 1,\n-        TestUtils.getAllThreadsByThisName(VCR_REPLICA_THREAD_PREFIX).size());\n-\n-    // 3. remove the cloud replica by calling Leader-To-Standby transition on local partition\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(localPartition.toPathString());\n-    // ensure that the remote replica info has been successfully removed from replica thread\n-    assertNull(\"Cloud replica should be removed and no thread is assigned to it\", remoteReplicaInfo.getReplicaThread());\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2Mjg3MA==", "url": "https://github.com/linkedin/ambry/pull/1417#discussion_r391962870", "bodyText": "Remove these lines?", "author": "lightningrob", "createdAt": "2020-03-12T23:49:55Z", "path": "ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java", "diffHunk": "@@ -139,8 +140,9 @@ public void cloudReplicaAdditionTest() throws Exception {\n     mockClusterSpectator.spectate();\n     // 1. test adding cloud replica that is not present locally\n     mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Thread pool for DC1 should be null\",\n-        cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n+    assertNull(\"Cloud replica thread should not be created\", TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n+    //assertNull(\"Thread pool for DC1 should be null\",\n+    //cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));", "originalCommit": "20584d25745a3341cc4dc638080d2dbef51ee883", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "25662360f32401ca08591b2e302625322675fe7a", "chunk": "diff --git a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java b/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\ndeleted file mode 100644\nindex b05350a6f..000000000\n--- a/ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java\n+++ /dev/null\n\n@@ -1,207 +0,0 @@\n-/**\n- * Copyright 2020 LinkedIn Corp. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- */\n-package com.github.ambry.replication;\n-\n-import com.github.ambry.clustermap.DataNodeId;\n-import com.github.ambry.clustermap.MockClusterMap;\n-import com.github.ambry.clustermap.MockClusterSpectator;\n-import com.github.ambry.clustermap.MockDataNodeId;\n-import com.github.ambry.clustermap.MockHelixParticipant;\n-import com.github.ambry.clustermap.MockPartitionId;\n-import com.github.ambry.clustermap.PartitionId;\n-import com.github.ambry.clustermap.ReplicaId;\n-import com.github.ambry.config.ClusterMapConfig;\n-import com.github.ambry.config.DiskManagerConfig;\n-import com.github.ambry.config.ReplicationConfig;\n-import com.github.ambry.config.ServerConfig;\n-import com.github.ambry.config.StoreConfig;\n-import com.github.ambry.config.VerifiableProperties;\n-import com.github.ambry.network.Port;\n-import com.github.ambry.network.PortType;\n-import com.github.ambry.store.MockStoreKeyConverterFactory;\n-import com.github.ambry.store.StorageManager;\n-import com.github.ambry.store.StoreKey;\n-import com.github.ambry.store.StoreKeyFactory;\n-import com.github.ambry.utils.MockTime;\n-import com.github.ambry.utils.TestUtils;\n-import com.github.ambry.utils.Utils;\n-import java.io.DataInputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Properties;\n-import java.util.concurrent.ScheduledExecutorService;\n-import org.json.JSONObject;\n-import org.junit.Test;\n-import org.mockito.Mockito;\n-\n-import static com.github.ambry.clustermap.CloudReplica.*;\n-import static com.github.ambry.clustermap.TestUtils.*;\n-import static org.junit.Assert.*;\n-\n-\n-/**\n- * Tests for {@link CloudToStoreReplicationManager} when adding/removing cloud replica. The tests also cover the case\n- * where new replica is added due to \"move replica\".\n- */\n-public class CloudToStoreReplicationManagerTest {\n-  private static final String NEW_PARTITION_NAME = \"12\";\n-  private static final String CLOUD_DC_NAME = \"CloudDc\";\n-  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n-  private static final String VCR_REPLICA_THREAD_PREFIX = \"VcrReplicaThread-\";\n-  private final VerifiableProperties verifiableProperties;\n-  private final ScheduledExecutorService mockScheduler;\n-  private final StoreKeyFactory storeKeyFactory;\n-  private final ClusterMapConfig clusterMapConfig;\n-  private final ReplicationConfig replicationConfig;\n-  private final ServerConfig serverConfig;\n-  private final StoreConfig storeConfig;\n-  private final MockStoreKeyConverterFactory storeKeyConverterFactory;\n-  private final MockDataNodeId vcrNode;\n-  private final DataNodeId currentNode;\n-  private final MockHelixParticipant mockHelixParticipant;\n-  private final MockClusterSpectator mockClusterSpectator;\n-  private final MockClusterMap clusterMap;\n-\n-  public CloudToStoreReplicationManagerTest() throws Exception {\n-    List<TestUtils.ZkInfo> zkInfoList = new ArrayList<>();\n-    zkInfoList.add(new TestUtils.ZkInfo(null, \"DC1\", (byte) 0, 2299, false));\n-    JSONObject zkJson = constructZkLayoutJSON(zkInfoList);\n-    storeKeyConverterFactory = new MockStoreKeyConverterFactory(null, null);\n-    storeKeyConverterFactory.setConversionMap(new HashMap<>());\n-    mockScheduler = Mockito.mock(ScheduledExecutorService.class);\n-    storeKeyFactory = new StoreKeyFactory() {\n-      @Override\n-      public StoreKey getStoreKey(DataInputStream stream) throws IOException {\n-        return null;\n-      }\n-\n-      @Override\n-      public StoreKey getStoreKey(String input) throws IOException {\n-        return null;\n-      }\n-    };\n-    // create vcr node\n-    List<Port> vcrPortList = Arrays.asList(new Port(12310, PortType.PLAINTEXT), new Port(12410, PortType.SSL));\n-    vcrNode = new MockDataNodeId(\"localhost\", vcrPortList, Collections.singletonList(VCR_MOUNT_PATH), CLOUD_DC_NAME);\n-    clusterMap = new MockClusterMap();\n-    currentNode = clusterMap.getDataNodeIds().get(0);\n-    mockClusterSpectator = new MockClusterSpectator(Collections.singletonList(vcrNode));\n-    long replicaCapacity = clusterMap.getAllPartitionIds(null).get(0).getReplicaIds().get(0).getCapacityInBytes();\n-    Properties properties = new Properties();\n-    properties.setProperty(\"store.segment.size.in.bytes\", Long.toString(replicaCapacity / 2L));\n-    properties.setProperty(\"clustermap.cluster.name\", \"test\");\n-    properties.setProperty(\"clustermap.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.vcr.datacenter.name\", \"DC1\");\n-    properties.setProperty(\"clustermap.host.name\", \"localhost\");\n-    properties.setProperty(\"clustermap.dcs.zk.connect.strings\", zkJson.toString(2));\n-    properties.setProperty(\"replication.cloud.token.factory\", \"com.github.ambry.replication.MockFindTokenFactory\");\n-    properties.setProperty(\"disk.manager.enable.segment.pooling\", \"true\");\n-    verifiableProperties = new VerifiableProperties(properties);\n-    storeConfig = new StoreConfig(verifiableProperties);\n-    clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n-    replicationConfig = new ReplicationConfig(verifiableProperties);\n-    serverConfig = new ServerConfig(verifiableProperties);\n-    mockHelixParticipant = new MockHelixParticipant(clusterMapConfig);\n-  }\n-\n-  /**\n-   * Test both success and failure cases when adding cloud replica\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaAdditionTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    // 1. test adding cloud replica that is not present locally\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Cloud replica thread should not be created\", TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    //assertNull(\"Thread pool for DC1 should be null\",\n-    //cloudToStoreReplicationManager.getReplicaThreadPoolByDc().get(\"DC1\"));\n-    // create a new partition and add corresponding store in storage manager\n-    PartitionId newPartition =\n-        new MockPartitionId(Long.parseLong(NEW_PARTITION_NAME), MockClusterMap.DEFAULT_PARTITION_CLASS,\n-            clusterMap.getDataNodes(), 0);\n-    ReplicaId replicaToAdd = newPartition.getReplicaIds().get(0);\n-    assertTrue(\"Adding new store should succeed\", storageManager.addBlobStore(replicaToAdd));\n-    // 2. we deliberately shut down the store to induce failure when adding cloud replica\n-    storageManager.shutdownBlobStore(newPartition);\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNull(\"Cloud replica thread should not be created\", TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    storageManager.startBlobStore(newPartition);\n-    // 3. mock success case\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(NEW_PARTITION_NAME);\n-    assertNotNull(\"Cloud replica thread should be created for DC1\",\n-        TestUtils.getThreadByThisName(VCR_REPLICA_THREAD_PREFIX));\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-\n-  /**\n-   * Test both success and failure cases when removing cloud replica.\n-   * @throws Exception\n-   */\n-  @Test\n-  public void cloudReplicaRemovalTest() throws Exception {\n-    StorageManager storageManager =\n-        new StorageManager(storeConfig, new DiskManagerConfig(verifiableProperties), Utils.newScheduler(1, true),\n-            clusterMap.getMetricRegistry(), null, clusterMap, currentNode, null, mockHelixParticipant, new MockTime(),\n-            null);\n-    CloudToStoreReplicationManager cloudToStoreReplicationManager =\n-        new CloudToStoreReplicationManager(replicationConfig, clusterMapConfig, storeConfig, storageManager,\n-            storeKeyFactory, clusterMap, mockScheduler, currentNode, null, clusterMap.getMetricRegistry(), null,\n-            storeKeyConverterFactory, serverConfig.serverMessageTransformer, mockClusterSpectator,\n-            mockHelixParticipant);\n-    storageManager.start();\n-    cloudToStoreReplicationManager.start();\n-    mockClusterSpectator.spectate();\n-    PartitionId localPartition = storageManager.getLocalPartitions().iterator().next();\n-    // 1. add cloud replica first for subsequent removal test\n-    mockHelixParticipant.onPartitionBecomeLeaderFromStandby(localPartition.toPathString());\n-    String replicaPath = Cloud_Replica_Keyword + File.separator + localPartition.toPathString() + File.separator\n-        + localPartition.toPathString();\n-    RemoteReplicaInfo remoteReplicaInfo =\n-        cloudToStoreReplicationManager.getRemoteReplicaInfo(localPartition, vcrNode.getHostname(), replicaPath);\n-    assertNotNull(\"Remote replica info should not be null\", remoteReplicaInfo);\n-    assertEquals(\"There should be only one cloud replica thread created\", 1,\n-        TestUtils.getAllThreadsByThisName(VCR_REPLICA_THREAD_PREFIX).size());\n-\n-    // 2. before removing cloud replica of local partition let's remove a non-existent partition first\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(NEW_PARTITION_NAME);\n-    // ensure there is no change in replica thread\n-    assertEquals(\"There should be only one cloud replica thread created\", 1,\n-        TestUtils.getAllThreadsByThisName(VCR_REPLICA_THREAD_PREFIX).size());\n-\n-    // 3. remove the cloud replica by calling Leader-To-Standby transition on local partition\n-    mockHelixParticipant.onPartitionBecomeStandbyFromLeader(localPartition.toPathString());\n-    // ensure that the remote replica info has been successfully removed from replica thread\n-    assertNull(\"Cloud replica should be removed and no thread is assigned to it\", remoteReplicaInfo.getReplicaThread());\n-    cloudToStoreReplicationManager.shutdown();\n-    storageManager.shutdown();\n-  }\n-}\n"}}, {"oid": "25662360f32401ca08591b2e302625322675fe7a", "url": "https://github.com/linkedin/ambry/commit/25662360f32401ca08591b2e302625322675fe7a", "message": "Minor changes in CloudToStoreReplicationManager for move replica\n\nCloudToStoreReplicationManager is not really affected by \"move replica\"\nfeature except for the local partition map. This PR removes local\npartition map and makes it fetch local partition from storage manager\nwhich maintains an up-to-date list of current local partitions.", "committedDate": "2020-03-13T00:16:40Z", "type": "commit"}, {"oid": "bc214125b9d8730a723061d830590c6153f60150", "url": "https://github.com/linkedin/ambry/commit/bc214125b9d8730a723061d830590c6153f60150", "message": "added unit tests", "committedDate": "2020-03-13T00:16:40Z", "type": "commit"}, {"oid": "f657e6921b449ab02032904e905ada4150788f82", "url": "https://github.com/linkedin/ambry/commit/f657e6921b449ab02032904e905ada4150788f82", "message": "address Rob's comments", "committedDate": "2020-03-13T00:16:40Z", "type": "commit"}, {"oid": "6c644e291879a8fbabec365e34b7ed1aa7fe14ee", "url": "https://github.com/linkedin/ambry/commit/6c644e291879a8fbabec365e34b7ed1aa7fe14ee", "message": "rebase and address comments", "committedDate": "2020-03-13T05:04:36Z", "type": "commit"}, {"oid": "6c644e291879a8fbabec365e34b7ed1aa7fe14ee", "url": "https://github.com/linkedin/ambry/commit/6c644e291879a8fbabec365e34b7ed1aa7fe14ee", "message": "rebase and address comments", "committedDate": "2020-03-13T05:04:36Z", "type": "forcePushed"}]}