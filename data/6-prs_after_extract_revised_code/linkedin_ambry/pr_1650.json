{"pr_number": 1650, "pr_title": "[StorageQuota] Adding StorageQuotaEnforcer and StorageQuotaService", "pr_createdAt": "2020-10-07T22:04:59Z", "pr_url": "https://github.com/linkedin/ambry/pull/1650", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzNTAxNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503435015", "bodyText": "Minor: since this is not in specific class, the name is too broad. Can we call it QuotaMode?", "author": "jsjtzyy", "createdAt": "2020-10-12T17:25:51Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Mode.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Quota service mode. If mode is tracking, it will not throttle traffics even if the quota is exceeded.\n+ */\n+public enum Mode {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/Mode.java b/ambry-api/src/main/java/com/github/ambry/quota/QuotaMode.java\nsimilarity index 96%\nrename from ambry-api/src/main/java/com/github/ambry/quota/Mode.java\nrename to ambry-api/src/main/java/com/github/ambry/quota/QuotaMode.java\nindex 33dfda02f..7d441079e 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/Mode.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/QuotaMode.java\n\n@@ -16,6 +16,6 @@ package com.github.ambry.quota;\n /**\n  * Quota service mode. If mode is tracking, it will not throttle traffics even if the quota is exceeded.\n  */\n-public enum Mode {\n+public enum QuotaMode {\n   Tracking, Throttling\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzODU1Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503438553", "bodyText": "same here, maybe call it QuotaOperation?", "author": "jsjtzyy", "createdAt": "2020-10-12T17:33:18Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Operation.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Operations for quota service.\n+ */\n+public enum Operation {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/Operation.java b/ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\nsimilarity index 91%\nrename from ambry-api/src/main/java/com/github/ambry/quota/Operation.java\nrename to ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\nindex 35f701e42..270ffffed 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/Operation.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\n\n@@ -16,6 +16,6 @@ package com.github.ambry.quota;\n /**\n  * Operations for quota service.\n  */\n-public enum Operation {\n-  Upload, Delete, TtlUpdate\n+public enum QuotaOperation {\n+  Post, Delete, TtlUpdate\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQzOTA3Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503439076", "bodyText": "Why we use Upload instead of Post? I think latter one is consistent with what we use in code base.", "author": "jsjtzyy", "createdAt": "2020-10-12T17:34:23Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/Operation.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * Operations for quota service.\n+ */\n+public enum Operation {\n+  Upload, Delete, TtlUpdate", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/Operation.java b/ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\nsimilarity index 91%\nrename from ambry-api/src/main/java/com/github/ambry/quota/Operation.java\nrename to ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\nindex 35f701e42..270ffffed 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/Operation.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/QuotaOperation.java\n\n@@ -16,6 +16,6 @@ package com.github.ambry.quota;\n /**\n  * Operations for quota service.\n  */\n-public enum Operation {\n-  Upload, Delete, TtlUpdate\n+public enum QuotaOperation {\n+  Post, Delete, TtlUpdate\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1ODc1OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503558759", "bodyText": "typo: ZooKeeper", "author": "jsjtzyy", "createdAt": "2020-10-12T22:08:45Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -18,13 +18,21 @@\n  */\n public class StorageQuotaConfig {\n   public static final String STORAGE_QUOTA_PREFIX = \"storage.quota.\";\n+  public static final String HELIX_PROPERTY_ROOT_PATH = STORAGE_QUOTA_PREFIX + \"helix.property.root.path\";\n   public static final String ZK_CLIENT_CONNECT_ADDRESS = STORAGE_QUOTA_PREFIX + \"zk.client.connect.address\";\n   public static final String REFRESHER_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"refresher.polling.interval.ms\";\n   public static final String CONTAINER_STORAGE_QUOTA_IN_JSON = STORAGE_QUOTA_PREFIX + \"container.storage.quota.in.json\";\n   public static final String SOURCE_POLLING_INTERVAL_MS = STORAGE_QUOTA_PREFIX + \"source.polling.interval.ms\";\n \n   //////////////// Config for HelixStorageUsageRefresher ///////////////\n \n+  /**\n+   * The root path of helix property store in ZooKeepr for HelixStorageUsageRefresher. Must start with {@code /}, and", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java b/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\nindex fbdafec8e..51d2839a0 100644\n--- a/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\n+++ b/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\n\n@@ -27,7 +27,7 @@ public class StorageQuotaConfig {\n   //////////////// Config for HelixStorageUsageRefresher ///////////////\n \n   /**\n-   * The root path of helix property store in ZooKeepr for HelixStorageUsageRefresher. Must start with {@code /}, and\n+   * The root path of helix property store in ZooKeeper for HelixStorageUsageRefresher. Must start with {@code /}, and\n    * must not end with {@code /}. The root path should be {@code /{clustername}/PROPERTYSTORE}\n    */\n   @Config(HELIX_PROPERTY_ROOT_PATH)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTU4Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503559586", "bodyText": "Minor: Use getIntInRange for sourcePollingIntervalMs as well.", "author": "jsjtzyy", "createdAt": "2020-10-12T22:11:02Z", "path": "ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java", "diffHunk": "@@ -73,6 +81,7 @@\n    * @param verifiableProperties The {@link VerifiableProperties} that contains all the properties.\n    */\n   public StorageQuotaConfig(VerifiableProperties verifiableProperties) {\n+    helixPropertyRootPath = verifiableProperties.getString(HELIX_PROPERTY_ROOT_PATH);\n     zkClientConnectAddress = verifiableProperties.getString(ZK_CLIENT_CONNECT_ADDRESS);\n     refresherPollingIntervalMs =", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java b/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\nindex fbdafec8e..51d2839a0 100644\n--- a/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\n+++ b/ambry-api/src/main/java/com/github/ambry/config/StorageQuotaConfig.java\n\n@@ -86,6 +86,7 @@ public class StorageQuotaConfig {\n     refresherPollingIntervalMs =\n         verifiableProperties.getIntInRange(REFRESHER_POLLING_INTERVAL_MS, 30 * 60 * 1000, 0, Integer.MAX_VALUE);\n     containerStorageQuotaInJson = verifiableProperties.getString(CONTAINER_STORAGE_QUOTA_IN_JSON, \"\");\n-    sourcePollingIntervalMs = verifiableProperties.getInt(SOURCE_POLLING_INTERVAL_MS, 30 * 60 * 1000);\n+    sourcePollingIntervalMs =\n+        verifiableProperties.getIntInRange(SOURCE_POLLING_INTERVAL_MS, 30 * 60 * 1000, 0, Integer.MAX_VALUE);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTg3OA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503559878", "bodyText": "typo: usage", "author": "jsjtzyy", "createdAt": "2020-10-12T22:11:54Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex 7d1cbafbf..c2a5ba195 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -21,7 +21,7 @@ import java.util.Map;\n  *\n  * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n  * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n- * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n  * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n  *\n  * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503570859", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-10-12T22:46:19Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTQ5Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503571496", "bodyText": "btw, the quota change comes from Nuage, right?", "author": "jsjtzyy", "createdAt": "2020-10-12T22:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NDYyNw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503684627", "bodyText": "yes, it comes from nuage, but it's stored in a different service, called QuotaIn.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T05:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex 7d1cbafbf..c2a5ba195 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -21,7 +21,7 @@ import java.util.Map;\n  *\n  * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n  * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n- * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n  * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n  *\n  * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTMwNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503571305", "bodyText": "if {@link StorageQuotaEnforcer} doesn't want to listen on the changes. does this mean there is no listener in StorageQuotaEnforcer?  (If so, can you tweak the comment?)", "author": "jsjtzyy", "createdAt": "2020-10-12T22:47:32Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NDA0NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505654045", "bodyText": "Why would getUsageRefresherListener() be called for an object that doesn't want to listen? When enforcer has to listen to the changes, it would just say StorageUsafeRefresher.addListener() or StorageQuotaRefresher.addListener(). If it doesn't want to listen, then it should not call addListener.", "author": "ankagrawal", "createdAt": "2020-10-15T15:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MTMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex 7d1cbafbf..c2a5ba195 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -21,7 +21,7 @@ import java.util.Map;\n  *\n  * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n  * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n- * {@link StorageQuotaSource} and current storage uasage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n  * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n  *\n  * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NTM1NA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503575354", "bodyText": "nit : @code -> @link", "author": "jsjtzyy", "createdAt": "2020-10-12T22:59:07Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+/**\n+ * {@code StorageQuotaServiceFactory} is a factory to generate all the supporting cast required to instantiate an", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java\nindex 1902bf78b..182518f96 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaServiceFactory.java\n\n@@ -14,7 +14,7 @@\n package com.github.ambry.quota;\n \n /**\n- * {@code StorageQuotaServiceFactory} is a factory to generate all the supporting cast required to instantiate an\n+ * {@link StorageQuotaServiceFactory} is a factory to generate all the supporting cast required to instantiate an\n  * {@link StorageQuotaService}. Usually called with the canonical class name and as such might have to support appropriate\n  * (multiple) constructors.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3NzA3OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503577079", "bodyText": "typo in comment: The container usage map's key is the container id in string format", "author": "jsjtzyy", "createdAt": "2020-10-12T23:04:57Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java", "diffHunk": "@@ -29,4 +29,20 @@\n    * @return The storage quota for each container.\n    */\n   Map<String, Map<String, Long>> getContainerQuota();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java\nindex cafa38043..c88377bf4 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaSource.java\n\n@@ -24,7 +24,7 @@ public interface StorageQuotaSource {\n    * Return the storage quota of each container. The returned map should be structured as such:\n    * The key of the map is the account id in string format and the value of the map is the storage quota of each\n    * container under this account.\n-   * The container usage map's key is the container is in string format, and the value is storage quota in bytes of\n+   * The container usage map's key is the container id in string format, and the value is storage quota in bytes of\n    * this container.\n    * @return The storage quota for each container.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDE1Nw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503580157", "bodyText": "Looks like the intellij complains about casting and unboxing. Try changing it following way:\n    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);", "author": "jsjtzyy", "createdAt": "2020-10-12T23:15:57Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MTQ5MA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503581490", "bodyText": "Looks like unboxing is not necessary. So v.longValue() -> v", "author": "jsjtzyy", "createdAt": "2020-10-12T23:20:59Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MjQ1NA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503582454", "bodyText": "return mode == Mode.Throttling ? exceedQuota.get() : false;", "author": "jsjtzyy", "createdAt": "2020-10-12T23:24:31Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDQ5MQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503584491", "bodyText": "Every time we call getUsageRefresherListener(), it instantiates a new StorageUsageRefresher.Listener, is this intended?", "author": "jsjtzyy", "createdAt": "2020-10-12T23:32:03Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjM5NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503686395", "bodyText": "we will only call it once.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDU5Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503584593", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-10-12T23:32:27Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NjQ3NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503686475", "bodyText": "we will only call it once.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NDU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTk3NQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503585975", "bodyText": "Maybe out of scope but we should consider precluding deleted container in both storageUsage and storageQuota maps.", "author": "jsjtzyy", "createdAt": "2020-10-12T23:37:35Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link Operation#Upload}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile Mode mode = Mode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, Operation op, long size) {\n+    if (op != Operation.Upload) {\n+      return false;\n+    }\n+    long quota =\n+        ((Map<String, Long>) storageQuota.getOrDefault(String.valueOf(accountId), Collections.EMPTY_MAP)).getOrDefault(\n+            String.valueOf(containerId), Long.MAX_VALUE).longValue();\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v.longValue() + size < quota) {\n+            return v.longValue() + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v.longValue();\n+          }\n+        });\n+    if (mode == Mode.Throttling) {\n+      return exceedQuota.get();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void setMode(Mode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {\n+      @Override\n+      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n+        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+        initMap(containerStorageQuota, newQuota, false);\n+        storageQuota = newQuota;\n+      }\n+    };\n+  }\n+\n+  private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,\n+      boolean concurrentMap) {\n+    for (Map.Entry<String, Map<String, Long>> mapEntry : mapWithValue.entrySet()) {\n+      Map<String, Long> innerMap = mapToInit.computeIfAbsent(mapEntry.getKey(),\n+          k -> concurrentMap ? new ConcurrentHashMap<>() : new HashMap<>());\n+      for (Map.Entry<String, Long> innerMapEntry : mapEntry.getValue().entrySet()) {\n+        // Replace the value in the map anyway.\n+        innerMap.put(innerMapEntry.getKey(), innerMapEntry.getValue());", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NzAxMg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503687012", "bodyText": "hmm, this would be complicated since storage has to know about the deleted container. I would have to expose another  method in StorageQuotaService for that. Will do this later. Thanks for bring this up, will do this later, by adding a TODO .", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex 94e7f3776..c20b9cc4d 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -13,7 +13,6 @@\n  */\n package com.github.ambry.quota;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NjU5Mg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503586592", "bodyText": "typo: storageQuotaEnforcer", "author": "jsjtzyy", "createdAt": "2020-10-12T23:40:03Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.utils.Utils;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * An implementation for {@link StorageQuotaService}.\n+ */\n+public class AmbryStorageQuotaService implements StorageQuotaService {\n+\n+  private final StorageUsageRefresher storageUsageRefresher;\n+  private final StorageQuotaSource storageQuotaSource;\n+  private final StorageQuotaEnforcer storageQuotaEnforer;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\nindex 6c96615f0..cb39267c2 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\n\n@@ -27,7 +27,7 @@ public class AmbryStorageQuotaService implements StorageQuotaService {\n \n   private final StorageUsageRefresher storageUsageRefresher;\n   private final StorageQuotaSource storageQuotaSource;\n-  private final StorageQuotaEnforcer storageQuotaEnforer;\n+  private final StorageQuotaEnforcer storageQuotaEnforcer;\n   private final ScheduledExecutorService scheduler;\n   private final StorageQuotaConfig config;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503592056", "bodyText": "The scheduler will be used in future PR?", "author": "jsjtzyy", "createdAt": "2020-10-12T23:52:27Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.utils.Utils;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * An implementation for {@link StorageQuotaService}.\n+ */\n+public class AmbryStorageQuotaService implements StorageQuotaService {\n+\n+  private final StorageUsageRefresher storageUsageRefresher;\n+  private final StorageQuotaSource storageQuotaSource;\n+  private final StorageQuotaEnforcer storageQuotaEnforer;\n+  private final ScheduledExecutorService scheduler;\n+  private final StorageQuotaConfig config;\n+\n+  public AmbryStorageQuotaService(StorageUsageRefresher storageUsageRefresher, StorageQuotaSource storageQuotaSource,\n+      StorageQuotaEnforcer storageQuotaEnforcer, ScheduledExecutorService scheduler, StorageQuotaConfig config) {\n+    this.storageUsageRefresher = Objects.requireNonNull(storageUsageRefresher, \"StorageUsageRefresher empty\");\n+    this.storageQuotaSource = Objects.requireNonNull(storageQuotaSource, \"StorageQuotaSource empty\");\n+    this.storageQuotaEnforer = Objects.requireNonNull(storageQuotaEnforcer, \"StorageQuotaEnforcer empty\");\n+    this.config = Objects.requireNonNull(config, \"StorageQuotaConfig empty\");\n+    this.scheduler = scheduler;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4ODExNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503688116", "bodyText": "it's already used in helixStorageUsageRefresher, passing it to storagequotaservice is to close it when shutting the service down.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNjkwNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r506706906", "bodyText": "I understand that. I guess I didn't make it clear previously. The comment is together with the comment in AmbryStorageQuotaServiceFactory class where I suggested moving scheduler, quotaSource etc into  AmbryStorageQuotaService ctor.  That comment was resolved but I didn't see the change. Did I miss anything?", "author": "jsjtzyy", "createdAt": "2020-10-16T20:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MjA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\nindex 6c96615f0..cb39267c2 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaService.java\n\n@@ -27,7 +27,7 @@ public class AmbryStorageQuotaService implements StorageQuotaService {\n \n   private final StorageUsageRefresher storageUsageRefresher;\n   private final StorageQuotaSource storageQuotaSource;\n-  private final StorageQuotaEnforcer storageQuotaEnforer;\n+  private final StorageQuotaEnforcer storageQuotaEnforcer;\n   private final ScheduledExecutorService scheduler;\n   private final StorageQuotaConfig config;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5MzE0OA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503593148", "bodyText": "unused import", "author": "jsjtzyy", "createdAt": "2020-10-12T23:53:43Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\nindex 011d34cc0..7ff4fae60 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n\n@@ -15,9 +15,7 @@ package com.github.ambry.quota;\n \n import com.codahale.metrics.MetricRegistry;\n import com.github.ambry.commons.CommonUtils;\n-import com.github.ambry.config.HelixPropertyStoreConfig;\n import com.github.ambry.config.StorageQuotaConfig;\n-import com.github.ambry.config.VerifiableProperties;\n import com.github.ambry.utils.Utils;\n import java.util.concurrent.ScheduledExecutorService;\n import org.apache.helix.store.HelixPropertyStore;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5Mzk3OQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503593979", "bodyText": "I guess you wanted to pass metrics into AmbryStorageQuotaService", "author": "jsjtzyy", "createdAt": "2020-10-12T23:55:12Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+\n+/**\n+ * An factory implementation for {@link StorageQuotaService}. It uses {@link HelixStorageUsageRefresher}, {@link JSONStringStorageQuotaSource}\n+ * and {@link AmbryStorageQuotaEnforcer}.\n+ */\n+public class AmbryStorageQuotaServiceFactory implements StorageQuotaServiceFactory {\n+  private static final String STORAGE_QUOTA_SERVICE_PREFIX = \"storage-quota-service\";\n+  private final StorageQuotaService storageQuotaService;\n+\n+  public AmbryStorageQuotaServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry)", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4ODczNQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503688735", "bodyText": "oh, yes, i haven't figured out what metric to add, but just put metric registry here.", "author": "justinlin-linkedin", "createdAt": "2020-10-13T06:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5Mzk3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\nindex 011d34cc0..7ff4fae60 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n\n@@ -15,9 +15,7 @@ package com.github.ambry.quota;\n \n import com.codahale.metrics.MetricRegistry;\n import com.github.ambry.commons.CommonUtils;\n-import com.github.ambry.config.HelixPropertyStoreConfig;\n import com.github.ambry.config.StorageQuotaConfig;\n-import com.github.ambry.config.VerifiableProperties;\n import com.github.ambry.utils.Utils;\n import java.util.concurrent.ScheduledExecutorService;\n import org.apache.helix.store.HelixPropertyStore;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTIyMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503595221", "bodyText": "I think all of this can be instantiated in AmbryStorageQuotaService class. Hence, the constructor of AmbryStorageQuotaService can be simplified to:\npublic AmbryStorageQuotaService(StorageQuotaConfig config, StorageQuotaMetrics metrics)", "author": "jsjtzyy", "createdAt": "2020-10-13T00:00:06Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.StorageQuotaConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.Utils;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+\n+\n+/**\n+ * An factory implementation for {@link StorageQuotaService}. It uses {@link HelixStorageUsageRefresher}, {@link JSONStringStorageQuotaSource}\n+ * and {@link AmbryStorageQuotaEnforcer}.\n+ */\n+public class AmbryStorageQuotaServiceFactory implements StorageQuotaServiceFactory {\n+  private static final String STORAGE_QUOTA_SERVICE_PREFIX = \"storage-quota-service\";\n+  private final StorageQuotaService storageQuotaService;\n+\n+  public AmbryStorageQuotaServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry)\n+      throws Exception {\n+    StorageQuotaConfig storageQuotaConfig = new StorageQuotaConfig(verifiableProperties);\n+\n+    HelixPropertyStore<ZNRecord> helixStore =\n+        CommonUtils.createHelixPropertyStore(storageQuotaConfig.zkClientConnectAddress,\n+            storageQuotaConfig.helixPropertyRootPath, null);\n+    ScheduledExecutorService scheduler = Utils.newScheduler(1, STORAGE_QUOTA_SERVICE_PREFIX, false);\n+    HelixStorageUsageRefresher storageUsageRefresher =\n+        new HelixStorageUsageRefresher(helixStore, scheduler, storageQuotaConfig);\n+    JSONStringStorageQuotaSource storageQuotaSource = new JSONStringStorageQuotaSource(storageQuotaConfig);\n+    AmbryStorageQuotaEnforcer storageQuotaEnforcer = new AmbryStorageQuotaEnforcer();", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\nindex 011d34cc0..7ff4fae60 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaServiceFactory.java\n\n@@ -15,9 +15,7 @@ package com.github.ambry.quota;\n \n import com.codahale.metrics.MetricRegistry;\n import com.github.ambry.commons.CommonUtils;\n-import com.github.ambry.config.HelixPropertyStoreConfig;\n import com.github.ambry.config.StorageQuotaConfig;\n-import com.github.ambry.config.VerifiableProperties;\n import com.github.ambry.utils.Utils;\n import java.util.concurrent.ScheduledExecutorService;\n import org.apache.helix.store.HelixPropertyStore;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTMzNA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r503595334", "bodyText": "Remove this.", "author": "jsjtzyy", "createdAt": "2020-10-13T00:00:32Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java", "diffHunk": "@@ -140,6 +140,7 @@ public void registerListener(Listener cb) {\n   private void refreshOnUpdate(String path) {\n     try {\n       Map<String, Map<String, Long>> storageUsage = fetchContainerStorageUsageFromPath(path);\n+      System.out.println(\"Getting this from update: \" + storageUsage);", "originalCommit": "5985526a67adc8b5f68c70f88e4c73c768dfea32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java b/ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java\nindex e92631030..b824fd5d5 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/HelixStorageUsageRefresher.java\n\n@@ -140,7 +140,6 @@ public class HelixStorageUsageRefresher implements StorageUsageRefresher {\n   private void refreshOnUpdate(String path) {\n     try {\n       Map<String, Map<String, Long>> storageUsage = fetchContainerStorageUsageFromPath(path);\n-      System.out.println(\"Getting this from update: \" + storageUsage);\n       containerStorageUsageRef.set(storageUsage);\n       if (callback.get() != null) {\n         callback.get().onNewContainerStorageUsage(Collections.unmodifiableMap(storageUsage));\n"}}, {"oid": "84a9064a2f1b62e3a5a6980ade79871ad903442f", "url": "https://github.com/linkedin/ambry/commit/84a9064a2f1b62e3a5a6980ade79871ad903442f", "message": "Address comments", "committedDate": "2020-10-13T06:20:22Z", "type": "forcePushed"}, {"oid": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "url": "https://github.com/linkedin/ambry/commit/ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "message": "More typos", "committedDate": "2020-10-13T17:54:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDYyMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505640621", "bodyText": "The comments here are awesome. Thanks for adding detailed comments.", "author": "ankagrawal", "createdAt": "2020-10-15T15:33:57Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex c2a5ba195..2ea896fc5 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -42,13 +42,6 @@ public interface StorageQuotaEnforcer {\n    */\n   void initStorageUsage(Map<String, Map<String, Long>> usage);\n \n-  /**\n-   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n-   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n-   * @return The {@link StorageUsageRefresher.Listener}.\n-   */\n-  StorageUsageRefresher.Listener getUsageRefresherListener();\n-\n   /**\n    * Initialize the storage quota in {@link StorageQuotaSource}.\n    * @param quota The initial quota from {@link StorageQuotaSource}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTMyOA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505655328", "bodyText": "See comments for getUsageRefresherListener", "author": "ankagrawal", "createdAt": "2020-10-15T15:54:17Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMjE0MQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505922141", "bodyText": "Updated, added a registerListeners method in StorageQuotaEnforcer.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex c2a5ba195..2ea896fc5 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -42,13 +42,6 @@ public interface StorageQuotaEnforcer {\n    */\n   void initStorageUsage(Map<String, Map<String, Long>> usage);\n \n-  /**\n-   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n-   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n-   * @return The {@link StorageUsageRefresher.Listener}.\n-   */\n-  StorageUsageRefresher.Listener getUsageRefresherListener();\n-\n   /**\n    * Initialize the storage quota in {@link StorageQuotaSource}.\n    * @param quota The initial quota from {@link StorageQuotaSource}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1NTY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505655683", "bodyText": "typo: \"if\" the  given ....", "author": "ankagrawal", "createdAt": "2020-10-15T15:54:48Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();\n+\n+  /**\n+   * Return true if the given {@link QuotaOperation} should be throttled.\n+   * @param accountId The accountId of this operation.\n+   * @param containerId The containerId of this operation.\n+   * @param op The {@link QuotaOperation}.\n+   * @param size The size of this operation. eg, if the op is {@link QuotaOperation#Post}, size if the size of the content.\n+   * @return True is the given {@link QuotaOperation} should be throttled.", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex c2a5ba195..2ea896fc5 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -42,13 +42,6 @@ public interface StorageQuotaEnforcer {\n    */\n   void initStorageUsage(Map<String, Map<String, Long>> usage);\n \n-  /**\n-   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n-   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n-   * @return The {@link StorageUsageRefresher.Listener}.\n-   */\n-  StorageUsageRefresher.Listener getUsageRefresherListener();\n-\n   /**\n    * Initialize the storage quota in {@link StorageQuotaSource}.\n    * @param quota The initial quota from {@link StorageQuotaSource}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505658629", "bodyText": "Is StorageQuotaEnforcer going to be per container or for all containers. If it is going to be for all the containers, then is there a possibility that different containers might have different QuotaModes? If it is per container, then maybe we should remove containerId and accountId arguments from shouldThrottle.", "author": "ankagrawal", "createdAt": "2020-10-15T15:58:46Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * {@link StorageQuotaEnforcer} enforces the traffic throttling based on the storage quota and the current storage usage.\n+ *\n+ * Each traffic that changes storage usage is targeted at a specific account and container. Enforcer enforces storage\n+ * quota on each container. Before evaluating any traffic, enforcer has to retrieve storage quota of each container from\n+ * {@link StorageQuotaSource} and current storage usage of each container from {@link StorageUsageRefresher}, by calling\n+ * {@link #initStorageQuota} and {@link #initStorageUsage} respectively.\n+ *\n+ * Container storage quota can be dynamic, it can be updated to increase or decrease the quota for specific containers.\n+ * To listen on these changes, Enforcer would return a {@link StorageQuotaSource.Listener}.\n+ *\n+ * Container storage usage is changing all the the time because of expired blobs and compacted deleted blobs. That's the\n+ * reason why relying on the incoming traffic won't give you a correct answer about the current storage usage. For instance,\n+ * if 1GB blob is uploaded to containerA and the TTL for this blob is one day. Then one day later, without any traffic\n+ * from client, the storage usage for containerA becomes 0. Since the storage usage from {@link StorageUsageRefresher} is\n+ * the source of the truth, enforcer has to listen on the changes for storage usage and replace the value in memory with\n+ * the value from {@link StorageUsageRefresher}.\n+ */\n+public interface StorageQuotaEnforcer {\n+\n+  /**\n+   * Initialize the storage usage in {@link StorageQuotaEnforcer}.\n+   * @param usage The initial storage usage from {@link StorageUsageRefresher}.\n+   */\n+  void initStorageUsage(Map<String, Map<String, Long>> usage);\n+\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener();\n+\n+  /**\n+   * Initialize the storage quota in {@link StorageQuotaSource}.\n+   * @param quota The initial quota from {@link StorageQuotaSource}.\n+   */\n+  void initStorageQuota(Map<String, Map<String, Long>> quota);\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener} to listen on the change of storage quota.\n+   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n+   * @return The {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener();\n+\n+  /**\n+   * Return true if the given {@link QuotaOperation} should be throttled.\n+   * @param accountId The accountId of this operation.\n+   * @param containerId The containerId of this operation.\n+   * @param op The {@link QuotaOperation}.\n+   * @param size The size of this operation. eg, if the op is {@link QuotaOperation#Post}, size if the size of the content.\n+   * @return True is the given {@link QuotaOperation} should be throttled.\n+   */\n+  boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size);\n+\n+  /**\n+   * Change the {@link StorageQuotaEnforcer}'s mode to the given value. If the mode is {@link QuotaMode#Tracking}, then {@link StorageQuotaEnforcer}\n+   * should never return true in {@link #shouldThrottle} method.\n+   * @param mode The new value for {@link QuotaMode}.\n+   */\n+  void setQuotaMode(QuotaMode mode);", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMzQxMg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505923412", "bodyText": "the quota is enforced per container. Different containers would have different quota, thus will be throttled at different time. QuotaMode now is a global setting. If we want to stop throttling per container. Then the current interface would have to be changed. I probably would have to revisit the interface when I start implementing for the closed source ambry.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg0MDEwNA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r507840104", "bodyText": "Nit: maybe name it setGlobalQuotaMode to make it explicit.", "author": "ankagrawal", "createdAt": "2020-10-19T15:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY1ODYyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\nindex c2a5ba195..2ea896fc5 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaEnforcer.java\n\n@@ -42,13 +42,6 @@ public interface StorageQuotaEnforcer {\n    */\n   void initStorageUsage(Map<String, Map<String, Long>> usage);\n \n-  /**\n-   * Return a {@link StorageUsageRefresher.Listener} to listen on the change of current storage usage.\n-   * Return null if {@link StorageQuotaEnforcer} doesn't want to listen on the changes.\n-   * @return The {@link StorageUsageRefresher.Listener}.\n-   */\n-  StorageUsageRefresher.Listener getUsageRefresherListener();\n-\n   /**\n    * Initialize the storage quota in {@link StorageQuotaSource}.\n    * @param quota The initial quota from {@link StorageQuotaSource}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2NDAxNg==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505664016", "bodyText": "Its not clear to me whats the difference between StorageQuotaService and StorageQuotaEnforcer. This interface seems to have same methods as StorageQuotaEnforcer.", "author": "ankagrawal", "createdAt": "2020-10-15T16:06:23Z", "path": "ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.Container;\n+\n+\n+/**", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyNDcwOA==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505924708", "bodyText": "StorageQuotaService is more like a wrapper, it's responsibility is to 1) choose different implementation of StorageQuotaSource StorageUsageRefresher and StorageQuotaEnforcer 2) glue them together and make it work.\nBut mainly the reason why I have StorageQuotaService and StorageQuotaServiceFactory is to use different implementations of those components. In closed source ambry, I would create a QuotaInStorageQuotaSource, which will get the quota from QuotaIn service, a HelixBasedDataPlanStorageUsageRefresher, which will get the monthly storage usage instead of total usage from helix. And probably a different storage quota enforcer.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2NDAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "0a4fb4b31058ade6baad5da88e787d9f8ab69651", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java\nindex 21a9640e7..db93d0a80 100644\n--- a/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java\n+++ b/ambry-api/src/main/java/com/github/ambry/quota/StorageQuotaService.java\n\n@@ -13,45 +13,13 @@\n  */\n package com.github.ambry.quota;\n \n-import com.github.ambry.account.Account;\n-import com.github.ambry.account.Container;\n-\n-\n-/**\n- * {@link StorageQuotaService} is the component to handles storage quota for different {@link Account} and {@link Container}.\n- * It keeps track of the storage usage of different {@link Container}s and decides to throttle the Frontend operations\n- * based on the quota and the {@link QuotaMode}.\n- * If you just want to keep track of the the usage without throttling the traffic, you can call {@link #setQuotaMode} to change\n- * {@link QuotaMode} from {@link QuotaMode#Throttling} to {@link QuotaMode#Tracking}.\n- * TODO: add a new method to deal with deleted containers.\n- */\n public interface StorageQuotaService {\n \n-  /**\n-   * Start the {@link StorageQuotaService} with all the initialization logic.\n-   * @throws Exception\n-   */\n   void start() throws Exception;\n \n-  /**\n-   * Shutdown the {@link StorageQuotaService}.\n-   */\n   void shutdown();\n \n-  /**\n-   * Return true if the given {@link QuotaOperation} should be throttled.\n-   * @param accountId The accountId of this operation.\n-   * @param containerId The containerId of this operation.\n-   * @param op The {@link QuotaOperation}.\n-   * @param size The size of this operation. eg, if the op is Upload, size if the size of the content.\n-   * @return True is the given {@link QuotaOperation} should be throttled.\n-   */\n-  boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size);\n+  boolean shouldThrottle(short accountId, short containerId, Operation op, long size);\n \n-  /**\n-   * Change the {@link StorageQuotaService}'s quotaMode to the given value. If the quotaMode is {@link QuotaMode#Tracking}, then {@link StorageQuotaService}\n-   * should never return true in {@link #shouldThrottle} method.\n-   * @param quotaMode The new value for {@link QuotaMode}.\n-   */\n-  void setQuotaMode(QuotaMode quotaMode);\n+  void setMode(Mode mode);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MTgxMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505671811", "bodyText": "It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.", "author": "ankagrawal", "createdAt": "2020-10-15T16:18:00Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link QuotaOperation#Post}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile QuotaMode mode = QuotaMode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size) {\n+    if (op != QuotaOperation.Post) {\n+      return false;\n+    }\n+    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n+        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v + size < quota) {\n+            return v + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v;\n+          }\n+        });\n+    return mode == QuotaMode.Throttling ? exceedQuota.get() : false;\n+  }\n+\n+  @Override\n+  public void setQuotaMode(QuotaMode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMjY5Mw==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505922693", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-10-15T23:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MTgxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex c20b9cc4d..7cb08c200 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -75,27 +75,40 @@ public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n   }\n \n   @Override\n-  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n-    return new StorageUsageRefresher.Listener() {\n-      @Override\n-      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n-        initMap(containerStorageUsage, storageUsage, true);\n-      }\n+  public void registerListeners(StorageQuotaSource storageQuotaSource, StorageUsageRefresher storageUsageRefresher) {\n+    storageQuotaSource.registerListener(getQuotaSourceListener());\n+    storageUsageRefresher.registerListener(getUsageRefresherListener());\n+  }\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener}, only used in test.\n+   * @return {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return containerStorageQuota -> {\n+      Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+      initMap(containerStorageQuota, newQuota, false);\n+      storageQuota = newQuota;\n     };\n   }\n \n-  @Override\n-  public StorageQuotaSource.Listener getQuotaSourceListener() {\n-    return new StorageQuotaSource.Listener() {\n-      @Override\n-      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n-        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n-        initMap(containerStorageQuota, newQuota, false);\n-        storageQuota = newQuota;\n-      }\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener}, only used in test.\n+   * @return {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return containerStorageUsage -> {\n+      initMap(containerStorageUsage, storageUsage, true);\n     };\n   }\n \n+  /**\n+   * Initialize the map with another given map and replace the value in the map with the value from given map.\n+   * @param mapWithValue The given map used to initialize a different map.\n+   * @param mapToInit The map to be initialized.\n+   * @param concurrentMap If true, then create a concurent hashmap for the inner map when it doesn't exist in the map\n+   *                      to be initialized.\n+   */\n   private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,\n       boolean concurrentMap) {\n     for (Map.Entry<String, Map<String, Long>> mapEntry : mapWithValue.entrySet()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3MzExMQ==", "url": "https://github.com/linkedin/ambry/pull/1650#discussion_r505673111", "bodyText": "javadocs?", "author": "ankagrawal", "createdAt": "2020-10-15T16:20:09Z", "path": "ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.quota;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link StorageQuotaEnforcer} implementation. It keeps an in-memory map for storage quota and listens on the quota change\n+ * to update this in-memory map. It also keeps another in-memory map for storage usage of each container and listens on usage\n+ * change from {@link StorageUsageRefresher}.\n+ *\n+ * This implementation checks whether to throttle the operation only if the operation is {@link QuotaOperation#Post}. And when the\n+ * targeted account and container doesn't have a quota specified, it doesn't throttle the operation at all. Any legitimate\n+ * uploads would also increase the storage usage in the in-memory map.\n+ */\n+public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n+  private volatile QuotaMode mode = QuotaMode.Tracking;\n+  private volatile Map<String, Map<String, Long>> storageQuota;\n+  private volatile Map<String, Map<String, Long>> storageUsage;\n+\n+  @Override\n+  public boolean shouldThrottle(short accountId, short containerId, QuotaOperation op, long size) {\n+    if (op != QuotaOperation.Post) {\n+      return false;\n+    }\n+    long quota = storageQuota.getOrDefault(String.valueOf(accountId), new HashMap<>())\n+        .getOrDefault(String.valueOf(containerId), Long.MAX_VALUE);\n+\n+    AtomicBoolean exceedQuota = new AtomicBoolean(false);\n+    storageUsage.computeIfAbsent(String.valueOf(accountId), k -> new ConcurrentHashMap<>())\n+        .compute(String.valueOf(containerId), (k, v) -> {\n+          if (v == null) {\n+            return size;\n+          }\n+          if (v + size < quota) {\n+            return v + size;\n+          } else {\n+            exceedQuota.set(true);\n+            return v;\n+          }\n+        });\n+    return mode == QuotaMode.Throttling ? exceedQuota.get() : false;\n+  }\n+\n+  @Override\n+  public void setQuotaMode(QuotaMode mode) {\n+    this.mode = mode;\n+  }\n+\n+  @Override\n+  public void initStorageUsage(Map<String, Map<String, Long>> usage) {\n+    storageUsage = new ConcurrentHashMap<>();\n+    initMap(usage, storageUsage, true);\n+  }\n+\n+  @Override\n+  public void initStorageQuota(Map<String, Map<String, Long>> quota) {\n+    storageQuota = new HashMap<>();\n+    initMap(quota, storageQuota, false);\n+  }\n+\n+  @Override\n+  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return new StorageUsageRefresher.Listener() {\n+      @Override\n+      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n+        initMap(containerStorageUsage, storageUsage, true);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return new StorageQuotaSource.Listener() {\n+      @Override\n+      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n+        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+        initMap(containerStorageQuota, newQuota, false);\n+        storageQuota = newQuota;\n+      }\n+    };\n+  }\n+\n+  private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,", "originalCommit": "ffeddd7f28a122f0ed53b3602e33aa9c7e424367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "chunk": "diff --git a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\nindex c20b9cc4d..7cb08c200 100644\n--- a/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n+++ b/ambry-quota/src/main/java/com/github/ambry/quota/AmbryStorageQuotaEnforcer.java\n\n@@ -75,27 +75,40 @@ public class AmbryStorageQuotaEnforcer implements StorageQuotaEnforcer {\n   }\n \n   @Override\n-  public StorageUsageRefresher.Listener getUsageRefresherListener() {\n-    return new StorageUsageRefresher.Listener() {\n-      @Override\n-      public void onNewContainerStorageUsage(Map<String, Map<String, Long>> containerStorageUsage) {\n-        initMap(containerStorageUsage, storageUsage, true);\n-      }\n+  public void registerListeners(StorageQuotaSource storageQuotaSource, StorageUsageRefresher storageUsageRefresher) {\n+    storageQuotaSource.registerListener(getQuotaSourceListener());\n+    storageUsageRefresher.registerListener(getUsageRefresherListener());\n+  }\n+\n+  /**\n+   * Return a {@link StorageQuotaSource.Listener}, only used in test.\n+   * @return {@link StorageQuotaSource.Listener}.\n+   */\n+  StorageQuotaSource.Listener getQuotaSourceListener() {\n+    return containerStorageQuota -> {\n+      Map<String, Map<String, Long>> newQuota = new HashMap<>();\n+      initMap(containerStorageQuota, newQuota, false);\n+      storageQuota = newQuota;\n     };\n   }\n \n-  @Override\n-  public StorageQuotaSource.Listener getQuotaSourceListener() {\n-    return new StorageQuotaSource.Listener() {\n-      @Override\n-      public void onNewContainerStorageQuota(Map<String, Map<String, Long>> containerStorageQuota) {\n-        Map<String, Map<String, Long>> newQuota = new HashMap<>();\n-        initMap(containerStorageQuota, newQuota, false);\n-        storageQuota = newQuota;\n-      }\n+  /**\n+   * Return a {@link StorageUsageRefresher.Listener}, only used in test.\n+   * @return {@link StorageUsageRefresher.Listener}.\n+   */\n+  StorageUsageRefresher.Listener getUsageRefresherListener() {\n+    return containerStorageUsage -> {\n+      initMap(containerStorageUsage, storageUsage, true);\n     };\n   }\n \n+  /**\n+   * Initialize the map with another given map and replace the value in the map with the value from given map.\n+   * @param mapWithValue The given map used to initialize a different map.\n+   * @param mapToInit The map to be initialized.\n+   * @param concurrentMap If true, then create a concurent hashmap for the inner map when it doesn't exist in the map\n+   *                      to be initialized.\n+   */\n   private void initMap(Map<String, Map<String, Long>> mapWithValue, Map<String, Map<String, Long>> mapToInit,\n       boolean concurrentMap) {\n     for (Map.Entry<String, Map<String, Long>> mapEntry : mapWithValue.entrySet()) {\n"}}, {"oid": "d1e212e204f2db17b34154b168c1cf7a99d5a80f", "url": "https://github.com/linkedin/ambry/commit/d1e212e204f2db17b34154b168c1cf7a99d5a80f", "message": "Address comments", "committedDate": "2020-10-16T00:06:45Z", "type": "forcePushed"}, {"oid": "0a4fb4b31058ade6baad5da88e787d9f8ab69651", "url": "https://github.com/linkedin/ambry/commit/0a4fb4b31058ade6baad5da88e787d9f8ab69651", "message": "[StorageQuota] Adding StorageQuotaEnforcer and StorageQuotaService", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "58d694fd1c2a4b20f3e957a1b87c350d11b903c1", "url": "https://github.com/linkedin/ambry/commit/58d694fd1c2a4b20f3e957a1b87c350d11b903c1", "message": "Add comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "d4e52b30001a2d5d62583ad7f71abdfad5235a11", "url": "https://github.com/linkedin/ambry/commit/d4e52b30001a2d5d62583ad7f71abdfad5235a11", "message": "Add more tests", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "d5ab3cc47c033047279c19bfe02347371b3a08d9", "url": "https://github.com/linkedin/ambry/commit/d5ab3cc47c033047279c19bfe02347371b3a08d9", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "4cb78731cef19d328befa284b4819d1560f9c7a5", "url": "https://github.com/linkedin/ambry/commit/4cb78731cef19d328befa284b4819d1560f9c7a5", "message": "Fix typos", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "19ed3281d3b75cd1e54e14732d7386e911ba0e09", "url": "https://github.com/linkedin/ambry/commit/19ed3281d3b75cd1e54e14732d7386e911ba0e09", "message": "More typos", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "url": "https://github.com/linkedin/ambry/commit/daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "commit"}, {"oid": "daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "url": "https://github.com/linkedin/ambry/commit/daa6c658fedb5cbc9eea4c67b493d7d65c4597f1", "message": "Address comments", "committedDate": "2020-10-19T23:05:30Z", "type": "forcePushed"}, {"oid": "25c6496f806b941b80e40a7ff9e53edbcac07d21", "url": "https://github.com/linkedin/ambry/commit/25c6496f806b941b80e40a7ff9e53edbcac07d21", "message": "Address commments", "committedDate": "2020-10-20T21:19:50Z", "type": "commit"}]}