{"pr_number": 1669, "pr_title": "Changes to notify account updates in MySqlAccountService to consumers", "pr_createdAt": "2020-10-22T22:33:11Z", "pr_url": "https://github.com/linkedin/ambry/pull/1669", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1NDMyOQ==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512354329", "bodyText": "You need to include updatedAccountsInDB, no?", "author": "lightningrob", "createdAt": "2020-10-27T00:57:57Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -159,7 +158,13 @@ synchronized void fetchAndUpdateCache() {\n         // At this point we can safely say cache is refreshed\n         needRefresh = false;\n \n-        // Persist account metadata in cache to back up file on disk.\n+        // Notify updated accounts to consumers\n+        Collection<Account> updatedAccounts = updatedContainersInDB.stream()\n+            .map(container -> accountInfoMapRef.get().getAccountById(container.getParentAccountId()))\n+            .collect(Collectors.toSet());\n+        notifyAccountUpdateConsumers(updatedAccounts, false);", "originalCommit": "3b6c759bb0ab58dfd8b9e2db08003e5a287fb1d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwMjQzOA==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512402438", "bodyText": "+1, although request from Nuage doesn't purely update the account (for now only account owner and description can be modified), it's still better to include the account if we update account's attributes without touching any container in the future.", "author": "jsjtzyy", "createdAt": "2020-10-27T03:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1NDMyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "47d232dd77836117d38990de52258872e9c2f543", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\nindex 52f70664f..aae33b3c5 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n\n@@ -159,9 +160,11 @@ public class MySqlAccountService extends AbstractAccountService {\n         needRefresh = false;\n \n         // Notify updated accounts to consumers\n-        Collection<Account> updatedAccounts = updatedContainersInDB.stream()\n-            .map(container -> accountInfoMapRef.get().getAccountById(container.getParentAccountId()))\n-            .collect(Collectors.toSet());\n+        Set<Account> updatedAccounts = new HashSet<>();\n+        updatedAccountsInDB.forEach(\n+            account -> updatedAccounts.add(accountInfoMapRef.get().getAccountById(account.getId())));\n+        updatedContainersInDB.forEach(\n+            container -> updatedAccounts.add(accountInfoMapRef.get().getAccountById(container.getParentAccountId())));\n         notifyAccountUpdateConsumers(updatedAccounts, false);\n \n         // Persist all account metadata to back up file on disk.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1ODQzMQ==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512358431", "bodyText": "This seems like the wrong metric (or maybe needs name change).", "author": "lightningrob", "createdAt": "2020-10-27T01:13:45Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -220,5 +218,57 @@ protected void notifyAccountUpdateConsumers(AccountInfoMap newAccountInfoMap, Ac\n       logger.debug(\"HelixAccountService is updated with 0 updated account\");\n     }\n   }\n+\n+  /**\n+   * Selects {@link Container}s to be marked as INACTIVE and marked in underlying account store.\n+   */\n+  public void selectInactiveContainersAndMarkInStore(StatsSnapshot statsSnapshot) {\n+    Set<Container> inactiveContainerCandidateSet = AccountUtils.selectInactiveContainerCandidates(statsSnapshot,\n+        getContainersByStatus(Container.ContainerStatus.DELETE_IN_PROGRESS));\n+    try {\n+      markContainersInactive(inactiveContainerCandidateSet);\n+    } catch (InterruptedException e) {\n+      logger.error(\"Mark inactive container in zookeeper is interrupted\", e);\n+    }\n+  }\n+\n+  /**\n+   * Mark the given {@link Container}s status to INACTIVE in account store.\n+   * @param inactiveContainerCandidateSet DELETE_IN_PROGRESS {@link Container} set which has been deleted successfully during compaction.\n+   */\n+  void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n+    if (inactiveContainerCandidateSet != null) {\n+      boolean success = false;\n+      Exception updateException = null;\n+      int retry = 0;\n+      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n+        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+        inactiveContainerCandidateSet.forEach(container -> {\n+          // start by getting account, and then get container from account to make sure that we are editing the most\n+          // recent snapshot\n+          short accountId = container.getParentAccountId();\n+          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+          Container editedContainer =\n+              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+          accountToUpdateMap.put(accountId,\n+              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+        });\n+        try {\n+          updateAccounts(accountToUpdateMap.values());\n+          success = true;\n+        } catch (AccountServiceException ase) {\n+          updateException = ase;\n+          retry++;\n+          Thread.sleep(config.retryDelayMs);\n+        }\n+      }\n+      if (updateException != null) {\n+        logger.error(\"Failed to mark containers INACTIVE in set : {}  after {} retries\", inactiveContainerCandidateSet,\n+            config.maxRetryCountOnUpdateFailure, updateException);\n+        accountServiceMetrics.accountUpdatesToZkErrorCount.inc();", "originalCommit": "3b6c759bb0ab58dfd8b9e2db08003e5a287fb1d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47d232dd77836117d38990de52258872e9c2f543", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\nindex b949b4ad3..51cd5084c 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n\n@@ -266,7 +267,7 @@ abstract class AbstractAccountService implements AccountService {\n       if (updateException != null) {\n         logger.error(\"Failed to mark containers INACTIVE in set : {}  after {} retries\", inactiveContainerCandidateSet,\n             config.maxRetryCountOnUpdateFailure, updateException);\n-        accountServiceMetrics.accountUpdatesToZkErrorCount.inc();\n+        accountServiceMetrics.accountUpdatesToStoreErrorCount.inc();\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1OTA5Ng==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512359096", "bodyText": "Minor: add @return line.", "author": "lightningrob", "createdAt": "2020-10-27T01:15:57Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +74,51 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Selects {@link Container}s to be marked as INACTIVE. Check the valid data size of each DELETE_IN_PROGRESS container\n+   * from {@link StatsSnapshot} and select the ones with zero data size to be marked as INACTIVE.\n+   */", "originalCommit": "3b6c759bb0ab58dfd8b9e2db08003e5a287fb1d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47d232dd77836117d38990de52258872e9c2f543", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java b/ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java\nindex 8dd3cc23e..95d02862c 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java\n\n@@ -75,9 +76,100 @@ public class AccountUtils {\n     return deprecatedContainers;\n   }\n \n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)\n+        .collect(Collectors.toSet());\n+\n+    Set<Account> accountsDifferentInSecondary = new HashSet<>(accountsInPrimary);\n+    accountsDifferentInSecondary.removeAll(accountsInSecondary);\n+    accountsDifferentInSecondary.removeAll(accountsMissingInSecondary);\n+\n+    if (!accountsMissingInSecondary.isEmpty() || !accountsDifferentInSecondary.isEmpty()) {\n+      isSame = false;\n+\n+      StringBuilder accountsInfo = new StringBuilder();\n+\n+      if (!accountsMissingInSecondary.isEmpty()) {\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsMissingInSecondary) {\n+          accountsInfo.append(AccountCollectionSerde.accountToJsonNoContainers(account).toString()).append(\",\");\n+        }\n+        accountsInfo.append(\"]\");\n+        logger.warn(\"Accounts found in primary and absent in secondary = {}\", accountsInfo.toString());\n+      }\n+\n+      if (!accountsDifferentInSecondary.isEmpty()) {\n+        accountsInfo.setLength(0);\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsDifferentInSecondary) {\n+          accountsInfo.append(\"{Account = \")\n+              .append(account.toString())\n+              .append(\", primary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(account).toString())\n+              .append(\", secondary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(secondaryAccountMap.get(account.getId()))\n+                  .toString());\n+\n+          Set<Container> containersMissingInSecondary = account.getAllContainers()\n+              .stream()\n+              .filter(\n+                  container -> secondaryAccountMap.get(account.getId()).getContainerByName(container.getName()) == null)\n+              .collect(Collectors.toSet());\n+\n+          Set<Container> containersDifferentInSecondary = new HashSet<>(account.getAllContainers());\n+          containersDifferentInSecondary.removeAll(secondaryAccountMap.get(account.getId()).getAllContainers());\n+          containersDifferentInSecondary.removeAll(containersMissingInSecondary);\n+\n+          if (!containersMissingInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers missing in secondary: [\");\n+            for (Container container : containersMissingInSecondary) {\n+              accountsInfo.append(container.toJson().toString()).append(\",\");\n+            }\n+            accountsInfo.append(\"]\");\n+          }\n+\n+          if (!containersDifferentInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers different in secondary: [\");\n+            for (Container container : containersDifferentInSecondary) {\n+              accountsInfo.append(\"{container = \")\n+                  .append(container.toString())\n+                  .append(\", primary = \")\n+                  .append(container.toJson().toString())\n+                  .append(\", secondary = \")\n+                  .append(secondaryAccountMap.get(account.getId())\n+                      .getContainerByName(container.getName())\n+                      .toJson()\n+                      .toString())\n+                  .append(\"},\");\n+            }\n+            accountsInfo.append(\"]\");\n+          }\n+          accountsInfo.append(\"}\");\n+        }\n+        accountsInfo.append(\"]\");\n+\n+        logger.warn(\"Accounts mismatch in primary and secondary = {}\", accountsInfo.toString());\n+      }\n+    }\n+    return isSame;\n+  }\n+\n   /**\n    * Selects {@link Container}s to be marked as INACTIVE. Check the valid data size of each DELETE_IN_PROGRESS container\n    * from {@link StatsSnapshot} and select the ones with zero data size to be marked as INACTIVE.\n+   * @return {@link Set} of inactive {@link Container} candidates.\n    */\n   public static Set<Container> selectInactiveContainerCandidates(StatsSnapshot statsSnapshot,\n       Set<Container> deleteInProgressContainerSet) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM5Mjg2Mw==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512392863", "bodyText": "Does this updatedAccounts hold whole account info? If yes, we may end up printing thousands of containers here. We can either print account id (as previous code did) or change this to DEBUG level.", "author": "jsjtzyy", "createdAt": "2020-10-27T03:19:09Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -184,30 +191,21 @@ public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> account\n \n   /**\n    * Logs and notifies account update {@link Consumer}s about any new account changes/creations.\n-   * @param newAccountInfoMap the new {@link AccountInfoMap} that has been set.\n-   * @param oldAccountInfoMap the {@link AccountInfoMap} that was cached before this change.\n+   * @param updatedAccounts collection of updated accounts\n    * @param isCalledFromListener {@code true} if the caller is the account update listener, {@code false} otherwise.\n    */\n-  protected void notifyAccountUpdateConsumers(AccountInfoMap newAccountInfoMap, AccountInfoMap oldAccountInfoMap,\n-      boolean isCalledFromListener) {\n-    Map<Short, Account> idToUpdatedAccounts = new HashMap<>();\n-    for (Account newAccount : newAccountInfoMap.getAccounts()) {\n-      if (!newAccount.equals(oldAccountInfoMap.getAccountById(newAccount.getId()))) {\n-        idToUpdatedAccounts.put(newAccount.getId(), newAccount);\n-      }\n-    }\n-    if (idToUpdatedAccounts.size() > 0) {\n-      logger.info(\"Received updates for {} accounts. Received from listener={}. Account IDs={}\",\n-          idToUpdatedAccounts.size(), isCalledFromListener, idToUpdatedAccounts.keySet());\n+  protected void notifyAccountUpdateConsumers(Collection<Account> updatedAccounts, boolean isCalledFromListener) {\n+    if (updatedAccounts.size() > 0) {\n+      logger.info(\"Received updates for {} accounts. Received from listener={}. Accounts={}\", updatedAccounts.size(),\n+          isCalledFromListener, updatedAccounts);", "originalCommit": "754bf6bedbc514ee05f811fea429377a1dba4ece", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47d232dd77836117d38990de52258872e9c2f543", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\nindex ae22d9866..51cd5084c 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n\n@@ -196,8 +197,8 @@ abstract class AbstractAccountService implements AccountService {\n    */\n   protected void notifyAccountUpdateConsumers(Collection<Account> updatedAccounts, boolean isCalledFromListener) {\n     if (updatedAccounts.size() > 0) {\n-      logger.info(\"Received updates for {} accounts. Received from listener={}. Accounts={}\", updatedAccounts.size(),\n-          isCalledFromListener, updatedAccounts);\n+      logger.info(\"Received updates for {} accounts. Received from listener={}. Account IDs={}\", updatedAccounts.size(),\n+          isCalledFromListener, updatedAccounts.stream().map(Account::getId).collect(Collectors.toList()));\n       // @todo In long run, this metric is not necessary.\n       if (isCalledFromListener) {\n         accountServiceMetrics.accountUpdatesCapturedByScheduledUpdaterCount.inc();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDc1Ng==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512404756", "bodyText": "Is there a unit test for this?", "author": "jsjtzyy", "createdAt": "2020-10-27T04:07:09Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java", "diffHunk": "@@ -200,16 +199,21 @@ boolean hasConflictingAccount(Collection<Account> accountsToSet) {\n    */\n   boolean hasConflictingContainer(Collection<Container> containersToSet, short parentAccountId) {\n     for (Container container : containersToSet) {\n-\n-      // TODO: Once we have versioning, check that version for existing container (being updated) matches.\n+      // if the container already exists, check that the snapshot version matches the expected value.\n+      Container containerInMap = getContainerByNameForAccount(container.getParentAccountId(), container.getName());\n+      if (containerInMap != null && container.getSnapshotVersion() != containerInMap.getSnapshotVersion()) {\n+        logger.error(\n+            \"Container to update in AccountId {} (containerId={} containerName={}) has an unexpected snapshot version in store (expected={}, encountered={})\",\n+            parentAccountId, container.getId(), container.getName(), container.getSnapshotVersion(),\n+            containerInMap.getSnapshotVersion());\n+        return true;", "originalCommit": "754bf6bedbc514ee05f811fea429377a1dba4ece", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNTAyOA==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r512405028", "bodyText": "Same here, do we have unit test to verify the updated version?", "author": "jsjtzyy", "createdAt": "2020-10-27T04:08:29Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -401,11 +392,14 @@ private void updateContainersWithMySqlStore(short accountId, Collection<Containe\n       Container containerInCache =\n           accountInfoMap.getContainerByIdForAccount(containerToUpdate.getParentAccountId(), containerToUpdate.getId());\n       if (containerInCache == null) {\n-        // new container added (insert into container table)\n+        // new container added. Insert record into container table.\n         mySqlAccountStore.addContainer(containerToUpdate);\n       } else {\n         if (!containerInCache.equals(containerToUpdate)) {\n-          // existing container modified (update container table)\n+          // Existing container modified. Increase the version of container and update container record\n+          containerToUpdate =\n+              new ContainerBuilder(containerToUpdate).setSnapshotVersion(containerToUpdate.getSnapshotVersion() + 1)\n+                  .build();", "originalCommit": "754bf6bedbc514ee05f811fea429377a1dba4ece", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MzIxNw==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513053217", "bodyText": "At some point we should use jackson library for json serialization.", "author": "justinlin-linkedin", "createdAt": "2020-10-27T21:48:49Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -75,6 +75,7 @@\n   static final String CONTENT_TYPE_WHITELIST_FOR_FILENAMES_ON_DOWNLOAD = \"contentTypeWhitelistForFilenamesOnDownload\";\n   static final String PARENT_ACCOUNT_ID_KEY = \"parentAccountId\";\n   static final String LAST_MODIFIED_TIME_KEY = \"lastModifiedTime\";\n+  static final String SNAPSHOT_VERSION_KEY = \"snapshotVersion\";", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MzY0NQ==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513053645", "bodyText": "nitpicking: can you move this method before toString method so the getter methods can stay together.", "author": "justinlin-linkedin", "createdAt": "2020-10-27T21:49:38Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -764,6 +773,16 @@ private void checkPreconditions(String name, ContainerStatus status, boolean enc\n     }\n   }\n \n+  /**\n+   * The snapshot version is generally the number of modifications to the container that were expected to have occurred\n+   * before the current time. This is used to validate that there were no unexpected container modifications that could be\n+   * inadvertently overwritten by an container update.\n+   * @return the expected version for the container record.\n+   */\n+  public int getSnapshotVersion() {", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26a6bc4925e0202f2237d6f0813130023d675b77", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/account/Container.java b/ambry-api/src/main/java/com/github/ambry/account/Container.java\nindex c88763ff2..d8080ae7d 100644\n--- a/ambry-api/src/main/java/com/github/ambry/account/Container.java\n+++ b/ambry-api/src/main/java/com/github/ambry/account/Container.java\n\n@@ -773,16 +784,6 @@ public class Container {\n     }\n   }\n \n-  /**\n-   * The snapshot version is generally the number of modifications to the container that were expected to have occurred\n-   * before the current time. This is used to validate that there were no unexpected container modifications that could be\n-   * inadvertently overwritten by an container update.\n-   * @return the expected version for the container record.\n-   */\n-  public int getSnapshotVersion() {\n-    return snapshotVersion;\n-  }\n-\n   /**\n    * Status of the container. {@code ACTIVE} means this container is in operational state, {@code INACTIVE} means\n    * the container has been deactivated, and {@code DELETE_IN_PROGRESS} means blobs in this container are being\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Njc2OQ==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513056769", "bodyText": "Don't forget to update equals method in this class. And BTW, what is the difference between isSameContainer and equals methods?", "author": "justinlin-linkedin", "createdAt": "2020-10-27T21:56:12Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -459,7 +464,8 @@ private Container(JSONObject metadata, short parentAccountId) throws JSONExcepti\n   Container(short id, String name, ContainerStatus status, String description, boolean encrypted,\n       boolean previouslyEncrypted, boolean cacheable, boolean mediaScanDisabled, String replicationPolicy,\n       boolean ttlRequired, boolean securePathRequired, Set<String> contentTypeWhitelistForFilenamesOnDownload,\n-      boolean backupEnabled, short parentAccountId, long deleteTriggerTime, long lastModifiedTime) {\n+      boolean backupEnabled, short parentAccountId, long deleteTriggerTime, long lastModifiedTime,\n+      int snapshotVersion) {", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyMTUzNw==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513121537", "bodyText": "I think Yingyi added isSameContainer() recently to only compare user editable fields in Container. @jsjtzyy", "author": "Arun-LinkedIn", "createdAt": "2020-10-28T01:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Njc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNTYwNA==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513605604", "bodyText": "Please add snapshotVersion in equals method.", "author": "justinlin-linkedin", "createdAt": "2020-10-28T16:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Njc2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3MzM1Nw==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513073357", "bodyText": "Just wondering if we already solve the issue when a container has data in more than one cluster? @SophieGuo410", "author": "justinlin-linkedin", "createdAt": "2020-10-27T22:35:19Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -220,5 +219,57 @@ protected void notifyAccountUpdateConsumers(AccountInfoMap newAccountInfoMap, Ac\n       logger.debug(\"HelixAccountService is updated with 0 updated account\");\n     }\n   }\n+\n+  /**\n+   * Selects {@link Container}s to be marked as INACTIVE and marked in underlying account store.\n+   */\n+  public void selectInactiveContainersAndMarkInStore(StatsSnapshot statsSnapshot) {", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTI1Nw==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513609257", "bodyText": "@justinlin-linkedin , I'm still working on the orca job implementation(it's in a different MP ambry-ecl-tools). Currently it's working on my local. But still need to tested on EI and Prod. I'll remove the legacy code once I've done with the orca job implementation.", "author": "SophieGuo410", "createdAt": "2020-10-28T16:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3MzM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "26a6bc4925e0202f2237d6f0813130023d675b77", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\nindex 51cd5084c..8b870e5ce 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n\n@@ -239,31 +239,30 @@ abstract class AbstractAccountService implements AccountService {\n    */\n   void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n     if (inactiveContainerCandidateSet != null) {\n-      boolean success = false;\n       Exception updateException = null;\n       int retry = 0;\n-      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n-        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n-        inactiveContainerCandidateSet.forEach(container -> {\n-          // start by getting account, and then get container from account to make sure that we are editing the most\n-          // recent snapshot\n-          short accountId = container.getParentAccountId();\n-          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n-          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n-          Container editedContainer =\n-              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n-          accountToUpdateMap.put(accountId,\n-              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n-        });\n+      Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+      inactiveContainerCandidateSet.forEach(container -> {\n+        // start by getting account, and then get container from account to make sure that we are editing the most\n+        // recent snapshot\n+        short accountId = container.getParentAccountId();\n+        Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+        Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+        Container editedContainer =\n+            new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+        accountToUpdateMap.put(accountId,\n+            new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+      });\n+      do {\n         try {\n           updateAccounts(accountToUpdateMap.values());\n-          success = true;\n+          updateException = null;\n         } catch (AccountServiceException ase) {\n           updateException = ase;\n           retry++;\n           Thread.sleep(config.retryDelayMs);\n         }\n-      }\n+      } while (updateException != null && retry < config.maxRetryCountOnUpdateFailure);\n       if (updateException != null) {\n         logger.error(\"Failed to mark containers INACTIVE in set : {}  after {} retries\", inactiveContainerCandidateSet,\n             config.maxRetryCountOnUpdateFailure, updateException);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NDM4MA==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513074380", "bodyText": "nit: we can move this block outside of while loop.", "author": "justinlin-linkedin", "createdAt": "2020-10-27T22:38:09Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -220,5 +219,57 @@ protected void notifyAccountUpdateConsumers(AccountInfoMap newAccountInfoMap, Ac\n       logger.debug(\"HelixAccountService is updated with 0 updated account\");\n     }\n   }\n+\n+  /**\n+   * Selects {@link Container}s to be marked as INACTIVE and marked in underlying account store.\n+   */\n+  public void selectInactiveContainersAndMarkInStore(StatsSnapshot statsSnapshot) {\n+    Set<Container> inactiveContainerCandidateSet = AccountUtils.selectInactiveContainerCandidates(statsSnapshot,\n+        getContainersByStatus(Container.ContainerStatus.DELETE_IN_PROGRESS));\n+    try {\n+      markContainersInactive(inactiveContainerCandidateSet);\n+    } catch (InterruptedException e) {\n+      logger.error(\"Mark inactive container in zookeeper is interrupted\", e);\n+    }\n+  }\n+\n+  /**\n+   * Mark the given {@link Container}s status to INACTIVE in account store.\n+   * @param inactiveContainerCandidateSet DELETE_IN_PROGRESS {@link Container} set which has been deleted successfully during compaction.\n+   */\n+  void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n+    if (inactiveContainerCandidateSet != null) {\n+      boolean success = false;\n+      Exception updateException = null;\n+      int retry = 0;\n+      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n+        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+        inactiveContainerCandidateSet.forEach(container -> {\n+          // start by getting account, and then get container from account to make sure that we are editing the most\n+          // recent snapshot\n+          short accountId = container.getParentAccountId();\n+          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+          Container editedContainer =\n+              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+          accountToUpdateMap.put(accountId,\n+              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+        });", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26a6bc4925e0202f2237d6f0813130023d675b77", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\nindex 51cd5084c..8b870e5ce 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n\n@@ -239,31 +239,30 @@ abstract class AbstractAccountService implements AccountService {\n    */\n   void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n     if (inactiveContainerCandidateSet != null) {\n-      boolean success = false;\n       Exception updateException = null;\n       int retry = 0;\n-      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n-        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n-        inactiveContainerCandidateSet.forEach(container -> {\n-          // start by getting account, and then get container from account to make sure that we are editing the most\n-          // recent snapshot\n-          short accountId = container.getParentAccountId();\n-          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n-          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n-          Container editedContainer =\n-              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n-          accountToUpdateMap.put(accountId,\n-              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n-        });\n+      Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+      inactiveContainerCandidateSet.forEach(container -> {\n+        // start by getting account, and then get container from account to make sure that we are editing the most\n+        // recent snapshot\n+        short accountId = container.getParentAccountId();\n+        Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+        Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+        Container editedContainer =\n+            new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+        accountToUpdateMap.put(accountId,\n+            new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+      });\n+      do {\n         try {\n           updateAccounts(accountToUpdateMap.values());\n-          success = true;\n+          updateException = null;\n         } catch (AccountServiceException ase) {\n           updateException = ase;\n           retry++;\n           Thread.sleep(config.retryDelayMs);\n         }\n-      }\n+      } while (updateException != null && retry < config.maxRetryCountOnUpdateFailure);\n       if (updateException != null) {\n         logger.error(\"Failed to mark containers INACTIVE in set : {}  after {} retries\", inactiveContainerCandidateSet,\n             config.maxRetryCountOnUpdateFailure, updateException);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NDc5Ng==", "url": "https://github.com/linkedin/ambry/pull/1669#discussion_r513074796", "bodyText": "should nullify updateException for a fresh start.", "author": "justinlin-linkedin", "createdAt": "2020-10-27T22:39:19Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java", "diffHunk": "@@ -220,5 +219,57 @@ protected void notifyAccountUpdateConsumers(AccountInfoMap newAccountInfoMap, Ac\n       logger.debug(\"HelixAccountService is updated with 0 updated account\");\n     }\n   }\n+\n+  /**\n+   * Selects {@link Container}s to be marked as INACTIVE and marked in underlying account store.\n+   */\n+  public void selectInactiveContainersAndMarkInStore(StatsSnapshot statsSnapshot) {\n+    Set<Container> inactiveContainerCandidateSet = AccountUtils.selectInactiveContainerCandidates(statsSnapshot,\n+        getContainersByStatus(Container.ContainerStatus.DELETE_IN_PROGRESS));\n+    try {\n+      markContainersInactive(inactiveContainerCandidateSet);\n+    } catch (InterruptedException e) {\n+      logger.error(\"Mark inactive container in zookeeper is interrupted\", e);\n+    }\n+  }\n+\n+  /**\n+   * Mark the given {@link Container}s status to INACTIVE in account store.\n+   * @param inactiveContainerCandidateSet DELETE_IN_PROGRESS {@link Container} set which has been deleted successfully during compaction.\n+   */\n+  void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n+    if (inactiveContainerCandidateSet != null) {\n+      boolean success = false;\n+      Exception updateException = null;\n+      int retry = 0;\n+      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n+        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+        inactiveContainerCandidateSet.forEach(container -> {\n+          // start by getting account, and then get container from account to make sure that we are editing the most\n+          // recent snapshot\n+          short accountId = container.getParentAccountId();\n+          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+          Container editedContainer =\n+              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+          accountToUpdateMap.put(accountId,\n+              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+        });\n+        try {\n+          updateAccounts(accountToUpdateMap.values());", "originalCommit": "75725313a720bd3d1ae7e0aaeae6604dae1627f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26a6bc4925e0202f2237d6f0813130023d675b77", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\nindex 51cd5084c..8b870e5ce 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AbstractAccountService.java\n\n@@ -239,31 +239,30 @@ abstract class AbstractAccountService implements AccountService {\n    */\n   void markContainersInactive(Set<Container> inactiveContainerCandidateSet) throws InterruptedException {\n     if (inactiveContainerCandidateSet != null) {\n-      boolean success = false;\n       Exception updateException = null;\n       int retry = 0;\n-      while (!success && retry < config.maxRetryCountOnUpdateFailure) {\n-        Map<Short, Account> accountToUpdateMap = new HashMap<>();\n-        inactiveContainerCandidateSet.forEach(container -> {\n-          // start by getting account, and then get container from account to make sure that we are editing the most\n-          // recent snapshot\n-          short accountId = container.getParentAccountId();\n-          Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n-          Container containerToEdit = accountToEdit.getContainerById(container.getId());\n-          Container editedContainer =\n-              new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n-          accountToUpdateMap.put(accountId,\n-              new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n-        });\n+      Map<Short, Account> accountToUpdateMap = new HashMap<>();\n+      inactiveContainerCandidateSet.forEach(container -> {\n+        // start by getting account, and then get container from account to make sure that we are editing the most\n+        // recent snapshot\n+        short accountId = container.getParentAccountId();\n+        Account accountToEdit = accountToUpdateMap.computeIfAbsent(accountId, this::getAccountById);\n+        Container containerToEdit = accountToEdit.getContainerById(container.getId());\n+        Container editedContainer =\n+            new ContainerBuilder(containerToEdit).setStatus(Container.ContainerStatus.INACTIVE).build();\n+        accountToUpdateMap.put(accountId,\n+            new AccountBuilder(accountToEdit).addOrUpdateContainer(editedContainer).build());\n+      });\n+      do {\n         try {\n           updateAccounts(accountToUpdateMap.values());\n-          success = true;\n+          updateException = null;\n         } catch (AccountServiceException ase) {\n           updateException = ase;\n           retry++;\n           Thread.sleep(config.retryDelayMs);\n         }\n-      }\n+      } while (updateException != null && retry < config.maxRetryCountOnUpdateFailure);\n       if (updateException != null) {\n         logger.error(\"Failed to mark containers INACTIVE in set : {}  after {} retries\", inactiveContainerCandidateSet,\n             config.maxRetryCountOnUpdateFailure, updateException);\n"}}, {"oid": "47d232dd77836117d38990de52258872e9c2f543", "url": "https://github.com/linkedin/ambry/commit/47d232dd77836117d38990de52258872e9c2f543", "message": "Changes to:\n1. Notify account updates in MySqlAccountService to consumers\n2. Add version field in Container\n3. Move selectInactiveContainersAndMarkInZk method from HelixAccountService to AbstractAccountService.", "committedDate": "2020-10-28T00:13:52Z", "type": "commit"}, {"oid": "47d232dd77836117d38990de52258872e9c2f543", "url": "https://github.com/linkedin/ambry/commit/47d232dd77836117d38990de52258872e9c2f543", "message": "Changes to:\n1. Notify account updates in MySqlAccountService to consumers\n2. Add version field in Container\n3. Move selectInactiveContainersAndMarkInZk method from HelixAccountService to AbstractAccountService.", "committedDate": "2020-10-28T00:13:52Z", "type": "forcePushed"}, {"oid": "26a6bc4925e0202f2237d6f0813130023d675b77", "url": "https://github.com/linkedin/ambry/commit/26a6bc4925e0202f2237d6f0813130023d675b77", "message": "Address Justin's comments", "committedDate": "2020-10-28T01:02:29Z", "type": "commit"}, {"oid": "57d3e394f165fd02147b076e23be9a7985153d54", "url": "https://github.com/linkedin/ambry/commit/57d3e394f165fd02147b076e23be9a7985153d54", "message": "Update snapshotVersion field in Account and Container when fetching from db", "committedDate": "2020-10-28T05:50:01Z", "type": "commit"}, {"oid": "d2c1e46ae851b203d5b4b21ac9263d64e5e274a5", "url": "https://github.com/linkedin/ambry/commit/d2c1e46ae851b203d5b4b21ac9263d64e5e274a5", "message": "Add version field in SELECT queries of Accounts and Containers", "committedDate": "2020-10-28T17:23:31Z", "type": "commit"}]}