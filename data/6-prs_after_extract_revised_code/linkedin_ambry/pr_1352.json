{"pr_number": 1352, "pr_title": "Add Netty Based HTTP2 implementation for storage server.", "pr_createdAt": "2020-01-06T21:12:50Z", "pr_url": "https://github.com/linkedin/ambry/pull/1352", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NTg4Nw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r363485887", "bodyText": "The test is temporarily disabled, will fix it soon in this PR.", "author": "zzmao", "createdAt": "2020-01-06T21:14:12Z", "path": "ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java", "diffHunk": "@@ -71,7 +71,6 @@ public void getAsyncRequestResponseHandlerTest() throws InstantiationException,\n   /**\n    * Tests instantiation of {@link AsyncRequestResponseHandlerFactory} with bad input.\n    */\n-  @Test", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2Mjc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369162752", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-01-21T18:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NTg4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java b/ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java\nindex 606d46475..39155a5c7 100644\n--- a/ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java\n+++ b/ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java\n\n@@ -71,24 +66,23 @@ public class AsyncRequestResponseHandlerFactoryTest {\n   /**\n    * Tests instantiation of {@link AsyncRequestResponseHandlerFactory} with bad input.\n    */\n+  @Test\n   public void getFactoryTestWithBadInputTest() throws IOException {\n     VerifiableProperties verifiableProperties = new VerifiableProperties(new Properties());\n     Router router = new InMemoryRouter(verifiableProperties, new MockClusterMap());\n-    MockRestRequestResponseHandler restRequestResponseHandler = new MockRestRequestResponseHandler();\n-    RestRequestService restRequestService =\n-        new MockRestRequestService(verifiableProperties, restRequestResponseHandler, router);\n+    RestRequestService restRequestService = new MockRestRequestService(verifiableProperties, router);\n \n     // RestResponseHandlerFactory constructor.\n     // handlerCount = 0\n     try {\n-      new AsyncRequestResponseHandlerFactory(0, METRIC_REGISTRY);\n+      new AsyncRequestResponseHandlerFactory(0, new MetricRegistry(), restRequestService);\n       fail(\"Instantiation should have failed because response handler count is 0\");\n     } catch (IllegalArgumentException e) {\n       // expected. Nothing to do.\n     }\n     // handlerCount < 0\n     try {\n-      new AsyncRequestResponseHandlerFactory(-1, METRIC_REGISTRY);\n+      new AsyncRequestResponseHandlerFactory(-1, new MetricRegistry(), restRequestService);\n       fail(\"Instantiation should have failed because response handler count is less than 0\");\n     } catch (IllegalArgumentException e) {\n       // expected. Nothing to do.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NjE1MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r363486150", "bodyText": "Temporarily commented. Will fix it soon in this PR.", "author": "zzmao", "createdAt": "2020-01-06T21:14:52Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java", "diffHunk": "@@ -109,10 +109,10 @@ private static void buildInstance(MetricRegistry metricRegistry) {\n         instance = new AsyncRequestResponseHandler(requestResponseHandlerMetrics);\n       }\n       // check if same instance of MetricRegistry - otherwise it is a problem.\n-      if (AsyncRequestResponseHandlerFactory.requestResponseHandlerMetrics.metricRegistry != metricRegistry) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MjgwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369162804", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-01-21T18:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NjE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java b/ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java\nindex 749c85ed8..dbe27eb30 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java\n\n@@ -71,51 +49,26 @@ public class AsyncRequestResponseHandlerFactory implements RestRequestHandlerFac\n     } else if (handlerCount <= 0) {\n       throw new IllegalArgumentException(\"Request handler scaling unit count has to be > 0. Is \" + handlerCount);\n     } else {\n-      buildInstance(metricRegistry);\n-      instance.setupRequestHandling(handlerCount, restRequestService);\n+      handler = new AsyncRequestResponseHandler(new RequestResponseHandlerMetrics(metricRegistry), handlerCount,\n+          restRequestService);\n     }\n     logger.trace(\"Instantiated AsyncRequestResponseHandlerFactory as RestRequestHandler\");\n   }\n \n   /**\n-   * Returns an instance of {@link AsyncRequestResponseHandler}.\n-   * @return an instance of {@link AsyncRequestResponseHandler}.\n+   * @return {@link AsyncRequestResponseHandler}.\n    */\n   @Override\n   public RestRequestHandler getRestRequestHandler() {\n-    return instance;\n+    return handler;\n   }\n \n   /**\n-   * Returns an instance of {@link AsyncRequestResponseHandler}.\n-   * @return an instance of {@link AsyncRequestResponseHandler}.\n+   * @return {@link AsyncRequestResponseHandler}.\n    */\n   @Override\n   public RestResponseHandler getRestResponseHandler() {\n-    return instance;\n-  }\n-\n-  /**\n-   * Returns the singleton {@link AsyncRequestResponseHandler} instance being maintained. Creates it if it hasn't been\n-   * created already.\n-   * @param metricRegistry the {@link MetricRegistry} instance that should be used for metrics.\n-   */\n-  private static void buildInstance(MetricRegistry metricRegistry) {\n-    lock.lock();\n-    try {\n-      if (instance == null) {\n-        AsyncRequestResponseHandlerFactory.requestResponseHandlerMetrics =\n-            new RequestResponseHandlerMetrics(metricRegistry);\n-        instance = new AsyncRequestResponseHandler(requestResponseHandlerMetrics);\n-      }\n-      // check if same instance of MetricRegistry - otherwise it is a problem.\n-//      if (AsyncRequestResponseHandlerFactory.requestResponseHandlerMetrics.metricRegistry != metricRegistry) {\n-//        throw new IllegalStateException(\"MetricRegistry instance provided during construction of \"\n-//            + \"AsyncRequestResponseHandler differs from the one currently received\");\n-//      }\n-    } finally {\n-      lock.unlock();\n-    }\n+    return handler;\n   }\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r364042586", "bodyText": "we should only call callback method once for the entire list since the callback passed to writeTo should be invoked only when the write is completed or failed.", "author": "justinlin-linkedin", "createdAt": "2020-01-08T02:38:35Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -48,6 +50,13 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    for (Send send : compositSendList) {\n+      send.writeTo(channel, callback);\n+    }\n+  }\n+", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzkyMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365483920", "bodyText": "Yes, perhaps each child send should have its own callback and then when either all of those callbacks succeed or an error has occured, the passed-in callback is notified, like in the default impl of AsyncWritableChannel.write(ByteBuf src, Callback<Long> callback)", "author": "cgtz", "createdAt": "2020-01-11T00:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3MDIwMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369170203", "bodyText": "Yes, this should be changed.\nI will make another PR to address this issue. For this PR, I will set callback to null in child send.", "author": "zzmao", "createdAt": "2020-01-21T18:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\nindex e4012af4e..87e8c9569 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n\n@@ -41,9 +41,9 @@ public class CompositeSend implements Send {\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjgwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r364042804", "bodyText": "same here, callback should only be invoked once.", "author": "justinlin-linkedin", "createdAt": "2020-01-08T02:39:53Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java", "diffHunk": "@@ -131,6 +133,26 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    if (bufferToSend == null) {\n+      bufferToSend = ByteBuffer.allocate(\n+          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n+      writeHeader();\n+      if (partitionResponseInfoList != null) {\n+        bufferToSend.putInt(partitionResponseInfoList.size());\n+        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n+          partitionResponseInfo.writeTo(bufferToSend);\n+        }\n+      }\n+      bufferToSend.flip();\n+    }\n+    channel.write(bufferToSend, callback);\n+    if (toSend != null) {\n+      toSend.writeTo(channel, callback);\n+    }", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3MDMzNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369170334", "bodyText": "Will make another PR to address this issue. For this PR, I will set callback to null in child send.", "author": "zzmao", "createdAt": "2020-01-21T18:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\nindex 9d15eaf94..04e79f9a1 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\n\n@@ -135,18 +139,7 @@ public class GetResponse extends Response {\n \n   @Override\n   public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n-          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n-      writeHeader();\n-      if (partitionResponseInfoList != null) {\n-        bufferToSend.putInt(partitionResponseInfoList.size());\n-        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n-          partitionResponseInfo.writeTo(bufferToSend);\n-        }\n-      }\n-      bufferToSend.flip();\n-    }\n+    prepareBufferToSend();\n     channel.write(bufferToSend, callback);\n     if (toSend != null) {\n       toSend.writeTo(channel, callback);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365481814", "bodyText": "Add asynchronously to the docs to indicate that this method returns immediately after the write is initiated?", "author": "cgtz", "createdAt": "2020-01-11T00:37:48Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,14 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * Write all messages in this set to the give {@link AsyncWritableChannel}", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYwOQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365556609", "bodyText": "Oh nvm, upon reading the other code I see that this is at least calls write() for all data available. Could you explain how this method is intended to behave. For example, is the supplied callback to be called when the entire batch of writes succeeds or fails? Also, are implementations of this method allowed to block waiting for i.o. (e.g. disk access), or are they supposed to have their messages ready and materialized in memory?", "author": "cgtz", "createdAt": "2020-01-12T04:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3Njc0Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369176746", "bodyText": "Added in comment:\n   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n   * called when the entire batch of writes succeeds or fails.", "author": "zzmao", "createdAt": "2020-01-21T18:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\nindex 80f7edbed..71e26f0bf 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n+++ b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n\n@@ -38,12 +38,14 @@ public interface MessageReadSet {\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Write all messages in this set to the give {@link AsyncWritableChannel}\n+   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n+   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n+   * called when the entire batch of writes succeeds or fails.\n    * @param channel the channel into which the data needs to be written to\n    * @param callback The callback when data is fully wrote to the channel.\n-   * @throws IOException\n+   * @throws IOException If prefetch is not used.\n    */\n-  void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException;\n+  void writeTo(AsyncWritableChannel channel, Callback<Void> callback) throws IOException;\n \n   /**\n    * @return The total number of messages in this set\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTkwMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365481901", "bodyText": "Callback<Void>?", "author": "cgtz", "createdAt": "2020-01-11T00:38:40Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,14 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * Write all messages in this set to the give {@link AsyncWritableChannel}\n+   * @param channel the channel into which the data needs to be written to\n+   * @param callback The callback when data is fully wrote to the channel.\n+   * @throws IOException\n+   */\n+  void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException;", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\nindex 80f7edbed..71e26f0bf 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n+++ b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n\n@@ -38,12 +38,14 @@ public interface MessageReadSet {\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Write all messages in this set to the give {@link AsyncWritableChannel}\n+   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n+   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n+   * called when the entire batch of writes succeeds or fails.\n    * @param channel the channel into which the data needs to be written to\n    * @param callback The callback when data is fully wrote to the channel.\n-   * @throws IOException\n+   * @throws IOException If prefetch is not used.\n    */\n-  void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException;\n+  void writeTo(AsyncWritableChannel channel, Callback<Void> callback) throws IOException;\n \n   /**\n    * @return The total number of messages in this set\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzU4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365483588", "bodyText": "composit -> composite", "author": "cgtz", "createdAt": "2020-01-11T00:50:24Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -48,6 +50,13 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    for (Send send : compositSendList) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\nindex e4012af4e..87e8c9569 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n\n@@ -41,9 +41,9 @@ public class CompositeSend implements Send {\n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDE4NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365484184", "bodyText": "This is done inside of the selector, reading the size of the payload is implemented in BoundedReceive", "author": "cgtz", "createdAt": "2020-01-11T00:54:38Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,13 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // TODO: Where is this done in socket channel?", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\nindex 26b5a76a6..c2788f2ff 100644\n--- a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n+++ b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n\n@@ -35,7 +35,8 @@ public class NettyServerRequestResponseChannel implements RequestResponseChannel\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n     DataInputStream stream = new DataInputStream(request.getInputStream());\n     try {\n-      // TODO: Where is this done in socket channel?\n+      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}\n+      // Here we just need to consume it.\n       stream.readLong();\n     } catch (IOException e) {\n       throw new InterruptedException(\"stream read error.\" + e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUzOTU5MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365539590", "bodyText": "if the first port is not optional, make it an int instead of a wrapper object.", "author": "cgtz", "createdAt": "2020-01-11T20:07:45Z", "path": "ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java", "diffHunk": "@@ -234,16 +238,15 @@ public static MockClusterMap createOneNodeRecoveryClusterMap(MockDataNodeId reco\n     return new MockClusterMap(recoveryNode, vcrNode, dcName);\n   }\n \n-  protected ArrayList<Port> getListOfPorts(int port) {\n-    ArrayList<Port> ports = new ArrayList<>();\n-    ports.add(new Port(port, PortType.PLAINTEXT));\n-    return ports;\n-  }\n-\n-  protected ArrayList<Port> getListOfPorts(int port, int sslPort) {\n+  protected ArrayList<Port> getListOfPorts(Integer port, Integer sslPort, Integer http2Port) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java b/ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java\nindex 8dc6014a9..c6af94b21 100644\n--- a/ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java\n+++ b/ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java\n\n@@ -238,7 +238,7 @@ public class MockClusterMap implements ClusterMap {\n     return new MockClusterMap(recoveryNode, vcrNode, dcName);\n   }\n \n-  protected ArrayList<Port> getListOfPorts(Integer port, Integer sslPort, Integer http2Port) {\n+  protected ArrayList<Port> getListOfPorts(int port, Integer sslPort, Integer http2Port) {\n     ArrayList<Port> ports = new ArrayList<Port>();\n     ports.add(new Port(port, PortType.PLAINTEXT));\n     if (sslPort != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYzNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365556636", "bodyText": "Can you make this shared code block into a helper function?", "author": "cgtz", "createdAt": "2020-01-12T04:13:15Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java", "diffHunk": "@@ -131,6 +133,26 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    if (bufferToSend == null) {\n+      bufferToSend = ByteBuffer.allocate(\n+          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n+      writeHeader();\n+      if (partitionResponseInfoList != null) {\n+        bufferToSend.putInt(partitionResponseInfoList.size());\n+        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n+          partitionResponseInfo.writeTo(bufferToSend);\n+        }\n+      }\n+      bufferToSend.flip();\n+    }", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3OTU3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368179573", "bodyText": "yes, I should do this.", "author": "zzmao", "createdAt": "2020-01-17T23:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\nindex 9d15eaf94..04e79f9a1 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java\n\n@@ -135,18 +139,7 @@ public class GetResponse extends Response {\n \n   @Override\n   public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n-          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n-      writeHeader();\n-      if (partitionResponseInfoList != null) {\n-        bufferToSend.putInt(partitionResponseInfoList.size());\n-        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n-          partitionResponseInfo.writeTo(bufferToSend);\n-        }\n-      }\n-      bufferToSend.flip();\n-    }\n+    prepareBufferToSend();\n     channel.write(bufferToSend, callback);\n     if (toSend != null) {\n       toSend.writeTo(channel, callback);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MTc0MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365971740", "bodyText": "I thought this was combined into RestRequestResponseHandlerFactory", "author": "cgtz", "createdAt": "2020-01-13T18:58:56Z", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java", "diffHunk": "@@ -201,6 +215,37 @@ public void startup() throws InstantiationException {\n           networkServer.getRequestResponseChannel(), requests);\n       networkServer.start();\n \n+      // start netty http2 server\n+      if (nodeId.hasHttp2Port()) {\n+        RestServerConfig restServerConfig = new RestServerConfig(properties);\n+        SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);\n+        RestServerState restServerState = new RestServerState(restServerConfig.restServerHealthCheckUri);\n+        NettyServerRequestResponseChannel requestResponseChannel = new NettyServerRequestResponseChannel(1);\n+        RestRequestService restRequestService = new StorageRestRequestService(requestResponseChannel);\n+\n+        AmbryServerRequests ambryServerRequestsForHttp2 =\n+            new AmbryServerRequests(storageManager, requestResponseChannel, clusterMap, nodeId, registry, serverMetrics,\n+                findTokenHelper, notificationSystem, replicationManager, storeKeyFactory, serverConfig,\n+                storeKeyConverterFactory, statsManager);\n+        RequestHandlerPool requestHandlerPoolForHttp2 =\n+            new RequestHandlerPool(serverConfig.serverRequestHandlerNumOfThreads, requestResponseChannel,\n+                ambryServerRequestsForHttp2);\n+\n+        RestRequestHandlerFactory restRequestHandlerFactory =", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java b/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\nindex 33c6e4cf6..7da66a40d 100644\n--- a/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\n+++ b/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\n\n@@ -215,7 +215,7 @@ public class AmbryServer {\n           networkServer.getRequestResponseChannel(), requests);\n       networkServer.start();\n \n-      // start netty http2 server\n+      // Start netty http2 server\n       if (nodeId.hasHttp2Port()) {\n         RestServerConfig restServerConfig = new RestServerConfig(properties);\n         SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MjkyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365972921", "bodyText": "It does not look like this factory has the override behavior, so you can modify this javadoc and change the arg name to just sslFactory", "author": "cgtz", "createdAt": "2020-01-13T19:01:45Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\nindex 64c785afe..2467af0c9 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n\n@@ -21,7 +21,6 @@ import com.github.ambry.config.VerifiableProperties;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.socket.SocketChannel;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MzAxMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365973011", "bodyText": "sslfactory is required", "author": "cgtz", "createdAt": "2020-01-13T19:01:56Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\nindex 64c785afe..2467af0c9 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n\n@@ -21,7 +21,6 @@ import com.github.ambry.config.VerifiableProperties;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.socket.SocketChannel;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTI4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975288", "bodyText": "It may be worth looking into what to do about public access logging on storage servers. They already have public access logging facilities inside of AmbryRequests. We would either want to disable these logs or make sure that they are redirected to the right log files.", "author": "cgtz", "createdAt": "2020-01-13T19:06:55Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {\n+      throw new IllegalArgumentException(\"Null arg(s) received during instantiation of StorageServerNettyFactory\");\n+    }\n+    nettyConfig = new NettyConfig(verifiableProperties);\n+    performanceConfig = new PerformanceConfig(verifiableProperties);\n+    nettyMetrics = new NettyMetrics(metricRegistry);\n+    ConnectionStatsHandler connectionStatsHandler = new ConnectionStatsHandler(nettyMetrics);\n+\n+    Map<Integer, ChannelInitializer<SocketChannel>> initializers = new HashMap<>();\n+\n+    initializers.put(http2Port,\n+        new StorageServerNettyChannelInitializer(nettyConfig, performanceConfig, nettyMetrics, connectionStatsHandler,\n+            requestHandler, publicAccessLogger, restServerState, defaultSslFactory, metricRegistry));", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3NzU3Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368177572", "bodyText": "removed.", "author": "zzmao", "createdAt": "2020-01-17T23:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\nindex 64c785afe..2467af0c9 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n\n@@ -21,7 +21,6 @@ import com.github.ambry.config.VerifiableProperties;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.socket.SocketChannel;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTY2NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975665", "bodyText": "you can just use Collections.singletonMap here.", "author": "cgtz", "createdAt": "2020-01-13T19:07:38Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {\n+      throw new IllegalArgumentException(\"Null arg(s) received during instantiation of StorageServerNettyFactory\");\n+    }\n+    nettyConfig = new NettyConfig(verifiableProperties);\n+    performanceConfig = new PerformanceConfig(verifiableProperties);\n+    nettyMetrics = new NettyMetrics(metricRegistry);\n+    ConnectionStatsHandler connectionStatsHandler = new ConnectionStatsHandler(nettyMetrics);\n+\n+    Map<Integer, ChannelInitializer<SocketChannel>> initializers = new HashMap<>();", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3OTUwNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368179505", "bodyText": "cool.", "author": "zzmao", "createdAt": "2020-01-17T23:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\nindex 64c785afe..2467af0c9 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java\n\n@@ -21,7 +21,6 @@ import com.github.ambry.config.VerifiableProperties;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.socket.SocketChannel;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTkyNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975927", "bodyText": "commented out ^", "author": "cgtz", "createdAt": "2020-01-13T19:08:14Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final PublicAccessLogger publicAccessLogger;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} to use.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      PublicAccessLogger publicAccessLogger, RestServerState restServerState, SSLFactory sslFactory,\n+      MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.publicAccessLogger = publicAccessLogger;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {\n+      InetSocketAddress peerAddress = ch.remoteAddress();\n+      String peerHost = peerAddress.getHostName();\n+      int peerPort = peerAddress.getPort();\n+      SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(peerHost, peerPort, SSLFactory.Mode.SERVER));\n+      pipeline.addLast(\"SslHandler\", sslHandler);\n+    }\n+    // TODO: add PublicAccessLogger and ConnectionStatsHandler\n+    pipeline.addLast(Http2FrameCodecBuilder.forServer().build())\n+        // .addLast(\"healthCheckHandler\", new HealthCheckHandler(restServerState, nettyMetrics))", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3ODQyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368178421", "bodyText": "removed.", "author": "zzmao", "createdAt": "2020-01-17T23:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\nindex de61a60f9..d625fd130 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n\n@@ -38,7 +38,6 @@ public class StorageServerNettyChannelInitializer extends ChannelInitializer<Soc\n   private final NettyMetrics nettyMetrics;\n   private final ConnectionStatsHandler connectionStatsHandler;\n   private final RestRequestHandler requestHandler;\n-  private final PublicAccessLogger publicAccessLogger;\n   private final RestServerState restServerState;\n   private final SSLFactory sslFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365977172", "bodyText": "Do the utility handlers like HealthCheckHandler, and PublicAccessLogHandler belong here?", "author": "cgtz", "createdAt": "2020-01-13T19:11:05Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http2.Http2StreamFrameToHttpObjectCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+\n+\n+/*\n+ * HTTP2 stream handler for each stream.\n+ */\n+@ChannelHandler.Sharable\n+public class Http2StreamHandler extends ChannelInboundHandlerAdapter {\n+\n+  private NettyMetrics nettyMetrics;\n+  private NettyConfig nettyConfig;\n+  private PerformanceConfig performanceConfig;\n+  private RestRequestHandler requestHandler;\n+\n+  public Http2StreamHandler(NettyMetrics nettyMetrics, NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      RestRequestHandler requestHandler) {\n+    this.nettyMetrics = nettyMetrics;\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+    ctx.pipeline().addLast(new Http2StreamFrameToHttpObjectCodec(true));\n+    // NettyMessageProcessor depends on ChunkedWriteHandler.", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3ODkxOA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368178918", "bodyText": "Existing server logging is good. We don't need PublicAccessLogHandler.\nHealthCheckHandler  is needed. Let me if I can add it in this PR.", "author": "zzmao", "createdAt": "2020-01-17T23:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MjI3MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371562270", "bodyText": "who is sending this health check request? is the send compatible with http2?", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e0c86d8b6d6198be231e8d2133942c659d780a24", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java b/ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java\nindex 15f233ff1..013c7f72e 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java\n\n@@ -45,6 +45,7 @@ public class Http2StreamHandler extends ChannelInboundHandlerAdapter {\n   public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n     ctx.pipeline().addLast(new Http2StreamFrameToHttpObjectCodec(true));\n     // NettyMessageProcessor depends on ChunkedWriteHandler.\n+    // TODO: add health check handler.\n     ctx.pipeline().addLast(new ChunkedWriteHandler());\n     ctx.pipeline().addLast(new NettyMessageProcessor(nettyMetrics, nettyConfig, performanceConfig, requestHandler));\n   }\n"}}, {"oid": "e0c86d8b6d6198be231e8d2133942c659d780a24", "url": "https://github.com/linkedin/ambry/commit/e0c86d8b6d6198be231e8d2133942c659d780a24", "message": "http2 stroage", "committedDate": "2020-01-21T18:47:31Z", "type": "forcePushed"}, {"oid": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "url": "https://github.com/linkedin/ambry/commit/dd6d62a2823ece52260f0ca64e8fc77cb108f555", "message": "simplify http2 blocking channel", "committedDate": "2020-01-22T22:48:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MzIwNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371543205", "bodyText": "should increment i after each write.", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:38:35Z", "path": "ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java", "diffHunk": "@@ -208,6 +210,25 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = readOptions.size() - 1;\n+    int i = 0;\n+    for (BlobReadOptions options : readOptions) {\n+      ByteBuffer buf = options.getPrefetchedData();\n+      if (buf == null) {\n+        throw new IOException(\"Data should be prefetched.\");\n+      }\n+      buf.position(0);\n+      if (i == lastIndex) {", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODE1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372008152", "bodyText": "good catch.", "author": "zzmao", "createdAt": "2020-01-28T19:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MzIwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java b/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\nindex 02e9934f9..e2f9ee151 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\n\n@@ -224,8 +224,10 @@ class StoreMessageReadSet implements MessageReadSet {\n         // only the last one needs callback.\n         channel.write(buf, callback);\n       } else {\n+        // TODO: Stop writing to the channel whenever there is an exception and stop the for loop.\n         channel.write(buf, null);\n       }\n+      i++;\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NDkzNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371544937", "bodyText": "We can stop writing to the channel whenever there is an exception here and stop the for loop. This would require changing the callback implementation.", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:44:48Z", "path": "ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java", "diffHunk": "@@ -208,6 +210,25 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = readOptions.size() - 1;\n+    int i = 0;\n+    for (BlobReadOptions options : readOptions) {\n+      ByteBuffer buf = options.getPrefetchedData();\n+      if (buf == null) {\n+        throw new IOException(\"Data should be prefetched.\");\n+      }\n+      buf.position(0);\n+      if (i == lastIndex) {\n+        // only the last one needs callback.\n+        channel.write(buf, callback);\n+      } else {\n+        channel.write(buf, null);\n+      }", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODc1OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372008759", "bodyText": "Yes. A good callback implementation is needed. Will add todo here and implement in follow up PR.", "author": "zzmao", "createdAt": "2020-01-28T19:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NDkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java b/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\nindex 02e9934f9..e2f9ee151 100644\n--- a/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\n+++ b/ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java\n\n@@ -224,8 +224,10 @@ class StoreMessageReadSet implements MessageReadSet {\n         // only the last one needs callback.\n         channel.write(buf, callback);\n       } else {\n+        // TODO: Stop writing to the channel whenever there is an exception and stop the for loop.\n         channel.write(buf, null);\n       }\n+      i++;\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0ODQ3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371548473", "bodyText": "nit: private volatile", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:57:08Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -55,14 +56,14 @@\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n-  private final Http2ResponseHandler http2ResponseHandler;\n   private final String hostName;\n   private final int port;\n   private EventLoopGroup workerGroup;\n   private Channel channel;\n+  private ChannelPromise channelPromise;\n+  private ByteBuf responseByteBuf;", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\nindex aeaec5f08..bff7b0c59 100644\n--- a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n+++ b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n\n@@ -61,7 +64,8 @@ public class Http2BlockingChannel implements ConnectedChannel {\n   private EventLoopGroup workerGroup;\n   private Channel channel;\n   private ChannelPromise channelPromise;\n-  private ByteBuf responseByteBuf;\n+  private volatile ByteBuf responseByteBuf;\n+  private Http2StreamChannelBootstrap http2StreamChannelBootstrap;\n \n   public Http2BlockingChannel(String hostName, int port) {\n     this.hostName = hostName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371550821", "bodyText": "this is going to run out of sync with the callback in the send method. If the awaitUninterruptedly returns false, dataInputStream would reuse the responseByteBuf set by last send.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:05:25Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -103,24 +104,31 @@ public void send(Send request) throws IOException {\n     byteBufferChannel.getBuffer().position(0);\n     ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n+    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(new Http2ResponseHandler());\n     Http2StreamChannel childChannel =\n         new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n     Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    http2Headers.set(RestUtils.Headers.HTTP2_FRONTEND_REQUEST, \"true\");\n+    channelPromise = childChannel.newPromise();\n+    childChannel.attr(Http2ResponseHandler.RESPONSE_CALLBACK).set(new Callback<ByteBuf>() {\n+      @Override\n+      public void onCompletion(ByteBuf result, Exception exception) {\n+        responseByteBuf = result;\n+        channelPromise.setSuccess();\n+      }\n+    });\n \n     DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n     DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n-    ChannelPromise childChannelPromise = childChannel.newPromise();\n     childChannel.write(headersFrame);\n-    ChannelFuture channelFuture = childChannel.write(dataFrame);\n+    childChannel.write(dataFrame);\n     childChannel.flush();\n-    http2ResponseHandler.put(channelFuture, childChannelPromise);\n   }\n \n   @Override\n   public ChannelOutput receive() throws IOException {\n-    Http2ResponseHandler.StreamResult streamResult = http2ResponseHandler.awaitResponses(5, TimeUnit.SECONDS);\n-    DataInputStream dataInputStream = new NettyByteBufDataInputStream(streamResult.getByteBuf());\n+    channelPromise.awaitUninterruptibly(3, TimeUnit.SECONDS);\n+    DataInputStream dataInputStream = new NettyByteBufDataInputStream(responseByteBuf);", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxMjE2MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372012160", "bodyText": "Adding a check if return value T or F.", "author": "zzmao", "createdAt": "2020-01-28T19:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\nindex aeaec5f08..bff7b0c59 100644\n--- a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n+++ b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n\n@@ -97,6 +103,7 @@ public class Http2BlockingChannel implements ConnectedChannel {\n \n   @Override\n   public void send(Send request) throws IOException {\n+    System.out.println(\"send\");\n     ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n     while (!request.isSendComplete()) {\n       request.writeTo(byteBufferChannel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MzYwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371553604", "bodyText": "we should create a variable in the object to reference requestHandlePoolForHttp2 so we can stop it in the shutdown method.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:16:15Z", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java", "diffHunk": "@@ -201,6 +214,36 @@ public void startup() throws InstantiationException {\n           networkServer.getRequestResponseChannel(), requests);\n       networkServer.start();\n \n+      // Start netty http2 server\n+      if (nodeId.hasHttp2Port()) {\n+        RestServerConfig restServerConfig = new RestServerConfig(properties);\n+        SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);\n+        RestServerState restServerState = new RestServerState(restServerConfig.restServerHealthCheckUri);\n+        NettyServerRequestResponseChannel requestResponseChannel = new NettyServerRequestResponseChannel(1);\n+        RestRequestService restRequestService = new StorageRestRequestService(requestResponseChannel);\n+\n+        AmbryServerRequests ambryServerRequestsForHttp2 =\n+            new AmbryServerRequests(storageManager, requestResponseChannel, clusterMap, nodeId, registry, serverMetrics,\n+                findTokenHelper, notificationSystem, replicationManager, storeKeyFactory, serverConfig,\n+                storeKeyConverterFactory, statsManager);\n+        RequestHandlerPool requestHandlerPoolForHttp2 =", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTA1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372015052", "bodyText": "fixed. Also renamed some variables name with http2 keyword.", "author": "zzmao", "createdAt": "2020-01-28T19:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MzYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java b/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\nindex 61d7bb14e..e12250c1c 100644\n--- a/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\n+++ b/ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java\n\n@@ -226,21 +227,21 @@ public class AmbryServer {\n             new AmbryServerRequests(storageManager, requestResponseChannel, clusterMap, nodeId, registry, serverMetrics,\n                 findTokenHelper, notificationSystem, replicationManager, storeKeyFactory, serverConfig,\n                 storeKeyConverterFactory, statsManager);\n-        RequestHandlerPool requestHandlerPoolForHttp2 =\n+        requestHandlerPoolForHttp2 =\n             new RequestHandlerPool(serverConfig.serverRequestHandlerNumOfThreads, requestResponseChannel,\n                 ambryServerRequestsForHttp2);\n \n         RestRequestResponseHandlerFactory restRequestHandlerFactory =\n             Utils.getObj(restServerConfig.restServerRequestResponseHandlerFactory,\n                 restServerConfig.restServerRequestHandlerScalingUnitCount, registry, restRequestService);\n-        restRequestHandler = restRequestHandlerFactory.getRestRequestHandler();\n-        restRequestHandler.start();\n+        restRequestHandlerForHttp2 = restRequestHandlerFactory.getRestRequestHandler();\n+        restRequestHandlerForHttp2.start();\n \n         NioServerFactory nioServerFactory =\n-            new StorageServerNettyFactory(nodeId.getHttp2Port(), properties, registry, restRequestHandler,\n+            new StorageServerNettyFactory(nodeId.getHttp2Port(), properties, registry, restRequestHandlerForHttp2,\n                 restServerState, sslFactory);\n-        nioServer = nioServerFactory.getNioServer();\n-        nioServer.start();\n+        nettyHttp2Server = nioServerFactory.getNioServer();\n+        nettyHttp2Server.start();\n       }\n \n       // Other code\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371555980", "bodyText": "I don't get this one.\nThis method will be called in the StorageRestRequestService, which is a service to handle http2 request. That means the NetworkRequest would only contains the bytes from http2 client, why the BoundedReceive is involved here? I don't see a reason to read 8 bytes from enqueuing this request.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:25:13Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,14 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}\n+      // Here we just need to consume it.\n+      stream.readLong();", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMTMxNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372031314", "bodyText": "Talk offline.", "author": "zzmao", "createdAt": "2020-01-28T20:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNTU1Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373925556", "bodyText": "To make this more symmetrical with SocketServer, which handles the size header before adding the request to the queue, it may be better to read the size header in StorageRestRequestService.", "author": "cgtz", "createdAt": "2020-02-03T05:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\nindex c2788f2ff..d4f488f36 100644\n--- a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n+++ b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n\n@@ -39,7 +40,7 @@ public class NettyServerRequestResponseChannel implements RequestResponseChannel\n       // Here we just need to consume it.\n       stream.readLong();\n     } catch (IOException e) {\n-      throw new InterruptedException(\"stream read error.\" + e);\n+      throw new IllegalStateException(\"stream read error.\" + e);\n     }\n     requestQueue.put(request);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NjYzMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371556630", "bodyText": "nit: please add javadoc.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:27:39Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java", "diffHunk": "@@ -59,15 +61,25 @@ public static AdminResponse readFrom(DataInputStream stream) throws IOException\n     return new AdminResponse(correlationId, clientId, error);\n   }\n \n-  @Override\n-  public long writeTo(WritableByteChannel channel) throws IOException {\n+  private void prepareBufferToSend() {", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxOTA4Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372019082", "bodyText": "added. Also changed in GetResponse.", "author": "zzmao", "createdAt": "2020-01-28T19:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NjYzMA=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java\nindex 4333fe5ff..2504b6784 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java\n\n@@ -61,6 +61,11 @@ public class AdminResponse extends Response {\n     return new AdminResponse(correlationId, clientId, error);\n   }\n \n+  /**\n+   * A private method shared by {@link AdminResponse#writeTo(WritableByteChannel)} and\n+   * {@link AdminResponse#writeTo(AsyncWritableChannel, Callback)}.\n+   * This method allocate bufferToSend and write headers to it if bufferToSend is null.\n+   */\n   private void prepareBufferToSend() {\n     if (bufferToSend == null) {\n       serializeIntoBuffer();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371561011", "bodyText": "We can stop the for loop whenever there is a failure in the writeTo method.\nThe benefit of doing so is that every Send is a StoreMessageReadSet here and calling writeTo on StoreMessageReadSet would trigger one disk io operation. Stoping for loop whenever there is a failure would save some disk io.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:44:36Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,48 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = compositeSendList.size() - 1;\n+    int i = 0;\n+    for (Send send : compositeSendList) {\n+      if (i == lastIndex) {\n+        // only the last one pass in callback\n+        send.writeTo(channel, callback);\n+      } else {\n+        send.writeTo(channel, null);\n+      }\n+      i++;\n+    }", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxOTQ2Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372019462", "bodyText": "What's your suggestion on how to stop it?", "author": "zzmao", "createdAt": "2020-01-28T19:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0MTg5MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373641890", "bodyText": "Had offline chat. Looks like there is no immediate way to stop the loop, because exception happens in callback.  But will enhance callback logic in next PR.", "author": "zzmao", "createdAt": "2020-01-31T19:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\nindex 87e8c9569..4cde62074 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n\n@@ -59,6 +59,7 @@ public class CompositeSend implements Send {\n         // only the last one pass in callback\n         send.writeTo(channel, callback);\n       } else {\n+        //TODO: stop writing to the channel whenever there is an exception here and stop the for loop.\n         send.writeTo(channel, null);\n       }\n       i++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371566293", "bodyText": "I think we should probably add another handler between IdleStateHandler and Http2MultiplexHandler to deal with IdleStateEvent.\nHttp2MulitiplexHandler doesn't seem like it will handle IdleStateEvent, so we would probably see all the children channels would be triggered by this event.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T01:05:56Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {\n+      InetSocketAddress peerAddress = ch.remoteAddress();\n+      String peerHost = peerAddress.getHostName();\n+      int peerPort = peerAddress.getPort();\n+      SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(peerHost, peerPort, SSLFactory.Mode.SERVER));\n+      pipeline.addLast(\"SslHandler\", sslHandler);\n+    }\n+    pipeline.addLast(Http2FrameCodecBuilder.forServer().build())\n+        .addLast(\"IdleStateHandler\", new IdleStateHandler(0, 0, nettyConfig.nettyServerIdleTimeSeconds))\n+        .addLast(\"Http2MultiplexHandler\", new Http2MultiplexHandler(\n+            new Http2StreamHandler(nettyMetrics, nettyConfig, performanceConfig, requestHandler)));", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyOTEyMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372029120", "bodyText": "Got you. Let me think about this.", "author": "zzmao", "createdAt": "2020-01-28T20:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NDkyNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373644925", "bodyText": "OK to remove IdleStateHandler as discussed offline.", "author": "zzmao", "createdAt": "2020-01-31T19:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\nindex d625fd130..332065ae9 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n\n@@ -23,6 +23,7 @@ import io.netty.channel.ChannelPipeline;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n import io.netty.handler.timeout.IdleStateHandler;\n import java.net.InetSocketAddress;\n"}}, {"oid": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "url": "https://github.com/linkedin/ambry/commit/ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "message": "address comments and fix conflict", "committedDate": "2020-01-31T19:36:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMDE0NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372020145", "bodyText": "waif -> wait", "author": "cgtz", "createdAt": "2020-01-28T19:49:17Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java", "diffHunk": "@@ -308,14 +308,16 @@ private boolean handleRequest(HttpRequest httpRequest) throws RestServiceExcepti\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n-          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n+          // be streamed in.\n+          // In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n+          // For HTTP2 from frontend, waif for all contents to be received.", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java b/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\nindex 8fc39ba81..aa87c827b 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\n\n@@ -308,16 +308,14 @@ public class NettyMessageProcessor extends SimpleChannelInboundHandler<HttpObjec\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n-          // be streamed in.\n-          // In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n+          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n-          // For HTTP2 from frontend, waif for all contents to be received.\n           if ((request.getRestMethod().equals(RestMethod.POST) || request.getRestMethod().equals(RestMethod.PUT))\n-              && !HttpPostRequestDecoder.isMultipart(httpRequest) && !request.isHttp2RequestFromFrontend()) {\n+              && !HttpPostRequestDecoder.isMultipart(httpRequest)) {\n             requestHandler.handleRequest(request, responseChannel);\n           }\n         } catch (RestServiceException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjYwMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372022603", "bodyText": "Should this header be set for server -> server replication requests made for replication? If so, could we rename it to \"x-ambry-internal-protocol-request\" or similar?", "author": "cgtz", "createdAt": "2020-01-28T19:54:11Z", "path": "ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java", "diffHunk": "@@ -216,6 +216,11 @@\n      * Response header indicating the reason a request is non compliant.\n      */\n     public final static String NON_COMPLIANCE_WARNING = \"x-ambry-non-compliance-warning\";\n+    \n+    /**\n+     * Request header indicating a HTTP2 request from frontend to server.\n+     */\n+    public final static String HTTP2_FRONTEND_REQUEST = \"x-ambry-http2-frontend-request\";", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjQ4NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374412484", "bodyText": "how about x-ambry-internal-http2-request?", "author": "zzmao", "createdAt": "2020-02-04T00:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java b/ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java\nindex 2a3818c17..56cca9f2b 100644\n--- a/ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java\n+++ b/ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java\n\n@@ -216,11 +216,7 @@ public class RestUtils {\n      * Response header indicating the reason a request is non compliant.\n      */\n     public final static String NON_COMPLIANCE_WARNING = \"x-ambry-non-compliance-warning\";\n-    \n-    /**\n-     * Request header indicating a HTTP2 request from frontend to server.\n-     */\n-    public final static String HTTP2_FRONTEND_REQUEST = \"x-ambry-http2-frontend-request\";\n+\n   }\n \n   public static final class TrackingHeaders {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTQ2NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889464", "bodyText": "can you leave a todo here since we will probably have to go back and implement this. Also, this should take Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T00:38:03Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java", "diffHunk": "@@ -66,6 +68,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java b/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\nindex 1c79f4a03..17c45f2d8 100644\n--- a/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\n+++ b/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\n\n@@ -69,8 +70,9 @@ class CloudMessageReadSet implements MessageReadSet {\n   }\n \n   @Override\n-  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n-\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n+    // TODO: read from cloud based store and write to AsyncWritableChannel is needed in the future.\n+    throw new NotImplementedException();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTQ5NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889495", "bodyText": "Callback<Long>", "author": "cgtz", "createdAt": "2020-02-03T00:38:18Z", "path": "ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java", "diffHunk": "@@ -266,6 +268,11 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java b/ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java\nindex a34180a39..3ec0cbbe6 100644\n--- a/ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java\n+++ b/ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java\n\n@@ -269,7 +269,7 @@ public class MessageFormatSend implements Send {\n   }\n \n   @Override\n-  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n       readSet.writeTo(channel, callback);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTUzMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889533", "bodyText": "Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T00:38:55Z", "path": "ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java", "diffHunk": "@@ -86,6 +88,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n       return written;\n     }\n \n+    @Override\n+    public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java b/ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java\nindex d6eb0d039..af3fa188a 100644\n--- a/ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java\n+++ b/ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java\n\n@@ -89,7 +89,7 @@ public class MessageFormatSendTest {\n     }\n \n     @Override\n-    public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n \n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTcxNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889717", "bodyText": "nit: this isn't exactly a result of an interrupt, so I think throwing a RuntimeException like IllegalStateException would be a better fit here.", "author": "cgtz", "createdAt": "2020-02-03T00:41:26Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,14 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}\n+      // Here we just need to consume it.\n+      stream.readLong();\n+    } catch (IOException e) {\n+      throw new InterruptedException(\"stream read error.\" + e);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzODU5NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r375438595", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-02-05T18:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\nindex c2788f2ff..d4f488f36 100644\n--- a/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n+++ b/ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java\n\n@@ -39,7 +40,7 @@ public class NettyServerRequestResponseChannel implements RequestResponseChannel\n       // Here we just need to consume it.\n       stream.readLong();\n     } catch (IOException e) {\n-      throw new InterruptedException(\"stream read error.\" + e);\n+      throw new IllegalStateException(\"stream read error.\" + e);\n     }\n     requestQueue.put(request);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDU0OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373890548", "bodyText": "Callback<Long> here and in any similar places. Generally try to specify the type parameter in the implementation when the interface explicitly specifies one. This will compile but it limits the compiler's ability to type check, e.g. on line 60.", "author": "cgtz", "createdAt": "2020-02-03T00:51:34Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,49 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxNDUyOA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374414528", "bodyText": "addressing all callback issue.", "author": "zzmao", "createdAt": "2020-02-04T00:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\nindex 4cde62074..87e8c9569 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n\n@@ -59,7 +59,6 @@ public class CompositeSend implements Send {\n         // only the last one pass in callback\n         send.writeTo(channel, callback);\n       } else {\n-        //TODO: stop writing to the channel whenever there is an exception here and stop the for loop.\n         send.writeTo(channel, null);\n       }\n       i++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjY3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373926673", "bodyText": "Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T05:26:14Z", "path": "ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java", "diffHunk": "@@ -286,6 +288,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n         return channel.write(ByteBuffer.wrap(toReturn));\n       }\n \n+      @Override\n+      public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java b/ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java\nindex 017b7de28..8674134e4 100644\n--- a/ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java\n+++ b/ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java\n\n@@ -289,7 +289,7 @@ public class BlobStoreHardDeleteTest {\n       }\n \n       @Override\n-      public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+      public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n \n       }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzIzNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373927235", "bodyText": "Sorry, I think I suggested Callback<Void> in a previous comment. To align with Send and AsyncWritableChannel it may be better to have a Callback<Long> where the result is the total number of bytes written.", "author": "cgtz", "createdAt": "2020-02-03T05:29:47Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,16 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n+   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n+   * called when the entire batch of writes succeeds or fails.\n+   * @param channel the channel into which the data needs to be written to\n+   * @param callback The callback when data is fully wrote to the channel.\n+   * @throws IOException If prefetch is not used.\n+   */\n+  void writeTo(AsyncWritableChannel channel, Callback<Void> callback) throws IOException;", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\nindex 71e26f0bf..abb4f1697 100644\n--- a/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n+++ b/ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java\n\n@@ -43,9 +43,8 @@ public interface MessageReadSet {\n    * called when the entire batch of writes succeeds or fails.\n    * @param channel the channel into which the data needs to be written to\n    * @param callback The callback when data is fully wrote to the channel.\n-   * @throws IOException If prefetch is not used.\n    */\n-  void writeTo(AsyncWritableChannel channel, Callback<Void> callback) throws IOException;\n+  void writeTo(AsyncWritableChannel channel, Callback<Long> callback);\n \n   /**\n    * @return The total number of messages in this set\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzU4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373927585", "bodyText": "This callback technically won't be set to the correct value since it will only reflect the size of the last send, not all sends in the batch. This may not currently be a problem but is something to look out for.", "author": "cgtz", "createdAt": "2020-02-03T05:31:41Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,49 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = compositeSendList.size() - 1;\n+    int i = 0;\n+    for (Send send : compositeSendList) {\n+      if (i == lastIndex) {\n+        // only the last one pass in callback\n+        send.writeTo(channel, callback);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzOTUxNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r375439516", "bodyText": "added a comment", "author": "zzmao", "createdAt": "2020-02-05T18:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\nindex 4cde62074..87e8c9569 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java\n\n@@ -59,7 +59,6 @@ public class CompositeSend implements Send {\n         // only the last one pass in callback\n         send.writeTo(channel, callback);\n       } else {\n-        //TODO: stop writing to the channel whenever there is an exception here and stop the for loop.\n         send.writeTo(channel, null);\n       }\n       i++;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyODQ0MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373928440", "bodyText": "I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.", "author": "cgtz", "createdAt": "2020-02-03T05:36:58Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java", "diffHunk": "@@ -42,16 +44,26 @@ protected void writeHeader() {\n     bufferToSend.putShort((short) error.ordinal());\n   }\n \n-  @Override\n-  public long writeTo(WritableByteChannel channel) throws IOException {\n+  private void prepareBuffer() {\n     if (bufferToSend == null) {\n       bufferToSend = ByteBuffer.allocate((int) sizeInBytes());\n       writeHeader();\n       bufferToSend.flip();\n     }\n+  }\n+\n+  @Override\n+  public long writeTo(WritableByteChannel channel) throws IOException {\n+    prepareBuffer();\n     return bufferToSend.remaining() > 0 ? channel.write(bufferToSend) : 0;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNDUyNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374424524", "bodyText": "This is a good suggestion. IOException is not needed.", "author": "zzmao", "createdAt": "2020-02-04T00:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyODQ0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java b/ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java\nindex 9ddf2853d..8d38b9370 100644\n--- a/ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java\n+++ b/ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java\n\n@@ -59,7 +59,7 @@ public abstract class Response extends RequestOrResponse {\n   }\n \n   @Override\n-  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) throws IOException {\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n     prepareBuffer();\n     channel.write(bufferToSend, callback);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyOTEyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373929121", "bodyText": "final", "author": "cgtz", "createdAt": "2020-02-03T05:40:47Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AttributeKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java b/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java\ndeleted file mode 100644\nindex d76c5622d..000000000\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java\n+++ /dev/null\n\n@@ -1,48 +0,0 @@\n-/*\n- * Copyright 2014 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at:\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package com.github.ambry.rest;\n-\n-import com.github.ambry.router.Callback;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.SimpleChannelInboundHandler;\n-import io.netty.handler.codec.http.FullHttpResponse;\n-import io.netty.handler.codec.http2.HttpConversionUtil;\n-import io.netty.util.AttributeKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n- */\n-@ChannelHandler.Sharable\n-public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n-  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");\n-  protected final Logger logger = LoggerFactory.getLogger(getClass());\n-\n-  @Override\n-  protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-    Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-    if (streamId == null) {\n-      logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-      return;\n-    }\n-    logger.trace(\"Stream response received.\");\n-    Callback<ByteBuf> callback = ctx.channel().attr(RESPONSE_CALLBACK).getAndSet(null);\n-    callback.onCompletion(msg.content().retainedDuplicate(), null);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyOTI4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373929285", "bodyText": "why is this protected? couldn't it be static and private?", "author": "cgtz", "createdAt": "2020-02-03T05:41:52Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AttributeKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java b/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java\ndeleted file mode 100644\nindex d76c5622d..000000000\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java\n+++ /dev/null\n\n@@ -1,48 +0,0 @@\n-/*\n- * Copyright 2014 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n- * copy of the License at:\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package com.github.ambry.rest;\n-\n-import com.github.ambry.router.Callback;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.SimpleChannelInboundHandler;\n-import io.netty.handler.codec.http.FullHttpResponse;\n-import io.netty.handler.codec.http2.HttpConversionUtil;\n-import io.netty.util.AttributeKey;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n- */\n-@ChannelHandler.Sharable\n-public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n-  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");\n-  protected final Logger logger = LoggerFactory.getLogger(getClass());\n-\n-  @Override\n-  protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n-    Integer streamId = msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());\n-    if (streamId == null) {\n-      logger.error(\"Http2ResponseHandler unexpected message received: \" + msg);\n-      return;\n-    }\n-    logger.trace(\"Stream response received.\");\n-    Callback<ByteBuf> callback = ctx.channel().attr(RESPONSE_CALLBACK).getAndSet(null);\n-    callback.onCompletion(msg.content().retainedDuplicate(), null);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMDc5Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373930792", "bodyText": "why does all content need to be received before calling handleRequest for HTTP2? Are there cases that CopyingAsyncWritableChannel will not handle correctly?", "author": "cgtz", "createdAt": "2020-02-03T05:50:39Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java", "diffHunk": "@@ -308,14 +308,16 @@ private boolean handleRequest(HttpRequest httpRequest) throws RestServiceExcepti\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n-          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n+          // be streamed in.\n+          // In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n+          // For HTTP2 from frontend, waif for all contents to be received.\n           if ((request.getRestMethod().equals(RestMethod.POST) || request.getRestMethod().equals(RestMethod.PUT))\n-              && !HttpPostRequestDecoder.isMultipart(httpRequest)) {\n+              && !HttpPostRequestDecoder.isMultipart(httpRequest) && !request.isHttp2RequestFromFrontend()) {\n             requestHandler.handleRequest(request, responseChannel);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java b/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\nindex 8fc39ba81..aa87c827b 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java\n\n@@ -308,16 +308,14 @@ public class NettyMessageProcessor extends SimpleChannelInboundHandler<HttpObjec\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n-          // be streamed in.\n-          // In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n+          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n-          // For HTTP2 from frontend, waif for all contents to be received.\n           if ((request.getRestMethod().equals(RestMethod.POST) || request.getRestMethod().equals(RestMethod.PUT))\n-              && !HttpPostRequestDecoder.isMultipart(httpRequest) && !request.isHttp2RequestFromFrontend()) {\n+              && !HttpPostRequestDecoder.isMultipart(httpRequest)) {\n             requestHandler.handleRequest(request, responseChannel);\n           }\n         } catch (RestServiceException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTA0NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931044", "bodyText": "why remove this comment?", "author": "cgtz", "createdAt": "2020-02-03T05:51:58Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java", "diffHunk": "@@ -39,7 +39,6 @@\n \n /**\n  * An HTTP/2 specific implementation of {@link SSLFactory} that uses Netty's SSL libraries for HTTP2.", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjA4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374426088", "bodyText": "added back.", "author": "zzmao", "createdAt": "2020-02-04T01:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0a217d67d244b88d6b1075951d723aa540213094", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java b/ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java\nindex 8b865e001..99fba27eb 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java\n\n@@ -39,6 +39,7 @@ import static com.github.ambry.rest.NettySslFactory.*;\n \n /**\n  * An HTTP/2 specific implementation of {@link SSLFactory} that uses Netty's SSL libraries for HTTP2.\n+ * The main differences between this factory and {@link NettySslFactory} are getServerSslContext and getServerClientContext.\n  * This factory provides HTTP2 specific sslContext: HTTP2 Ciphers and ALPN.\n  *\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTQ2MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931460", "bodyText": "For http2 is it even an option to not set up SSL? You could use Objects.requireNonNull in the constructor", "author": "cgtz", "createdAt": "2020-02-03T05:54:18Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjgxOQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374426819", "bodyText": "added.", "author": "zzmao", "createdAt": "2020-02-04T01:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\nindex 332065ae9..d625fd130 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n\n@@ -23,7 +23,6 @@ import io.netty.channel.ChannelPipeline;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n import io.netty.handler.timeout.IdleStateHandler;\n import java.net.InetSocketAddress;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTgyNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931826", "bodyText": "Was there an issue with adding ConnectionStatsHandler?", "author": "cgtz", "createdAt": "2020-02-03T05:56:18Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzQ2NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374427465", "bodyText": "added.", "author": "zzmao", "createdAt": "2020-02-04T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTgyNg=="}], "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\nindex 332065ae9..d625fd130 100644\n--- a/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n+++ b/ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java\n\n@@ -23,7 +23,6 @@ import io.netty.channel.ChannelPipeline;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n-import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n import io.netty.handler.timeout.IdleStateHandler;\n import java.net.InetSocketAddress;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMjY2Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373932662", "bodyText": "call TestSSLUtils.addHttp2Properties here?", "author": "cgtz", "createdAt": "2020-02-03T06:00:39Z", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java", "diffHunk": "@@ -74,7 +74,13 @@ public RouterServerPlaintextTest(boolean testEncryption) {\n   @BeforeClass\n   public static void initializeTests() throws Exception {\n     Properties properties = getRouterProperties(\"DC1\");\n-    plaintextCluster = new MockCluster(new Properties(), false, SystemTime.getInstance());\n+\n+    Properties serverProperties = new Properties();\n+    serverProperties.setProperty(\"rest.server.rest.request.service.factory\",", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374427683", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-02-04T01:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMjY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java b/ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java\nindex d10d06675..d64723c97 100644\n--- a/ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java\n+++ b/ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java\n\n@@ -74,13 +74,7 @@ public class RouterServerPlaintextTest {\n   @BeforeClass\n   public static void initializeTests() throws Exception {\n     Properties properties = getRouterProperties(\"DC1\");\n-\n-    Properties serverProperties = new Properties();\n-    serverProperties.setProperty(\"rest.server.rest.request.service.factory\",\n-        \"com.github.ambry.server.StorageRestRequestService\");\n-    serverProperties.setProperty(\"rest.server.nio.server.factory\", \"com.github.ambry.rest.StorageServerNettyFactory\");\n-    serverProperties.setProperty(\"ssl.client.authentication\", \"none\");\n-    plaintextCluster = new MockCluster(serverProperties, false, SystemTime.getInstance());\n+    plaintextCluster = new MockCluster(new Properties(), false, SystemTime.getInstance());\n     MockNotificationSystem notificationSystem = new MockNotificationSystem(plaintextCluster.getClusterMap());\n     plaintextCluster.initializeServers(notificationSystem);\n     plaintextCluster.startServers();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMzQ3OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373933479", "bodyText": "remove println", "author": "cgtz", "createdAt": "2020-02-03T06:05:10Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -96,31 +103,39 @@ public void disconnect() throws IOException {\n \n   @Override\n   public void send(Send request) throws IOException {\n+    System.out.println(\"send\");", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\nindex bff7b0c59..cd4e56b46 100644\n--- a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n+++ b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n\n@@ -103,7 +97,6 @@ public class Http2BlockingChannel implements ConnectedChannel {\n \n   @Override\n   public void send(Send request) throws IOException {\n-    System.out.println(\"send\");\n     ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n     while (!request.isSendComplete()) {\n       request.writeTo(byteBufferChannel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDY4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373934685", "bodyText": "Instead of combining ambry callbacks and netty promises here, how about setting the attribute to a CompletableFuture or ambry's FutureResult? Then you can wait on the future without requiring lines 135-137", "author": "cgtz", "createdAt": "2020-02-03T06:10:45Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -96,31 +103,39 @@ public void disconnect() throws IOException {\n \n   @Override\n   public void send(Send request) throws IOException {\n+    System.out.println(\"send\");\n     ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n     while (!request.isSendComplete()) {\n       request.writeTo(byteBufferChannel);\n     }\n     byteBufferChannel.getBuffer().position(0);\n     ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n-    Http2StreamChannel childChannel =\n-        new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n+    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n     Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    http2Headers.set(RestUtils.Headers.HTTP2_FRONTEND_REQUEST, \"true\");\n+    channelPromise = childChannel.newPromise();", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\nindex bff7b0c59..cd4e56b46 100644\n--- a/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n+++ b/ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java\n\n@@ -103,7 +97,6 @@ public class Http2BlockingChannel implements ConnectedChannel {\n \n   @Override\n   public void send(Send request) throws IOException {\n-    System.out.println(\"send\");\n     ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n     while (!request.isSendComplete()) {\n       request.writeTo(byteBufferChannel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5ODg1OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r376098859", "bodyText": "nit: UnsupportedOperationException, since NotImplementedException is reflection-specific", "author": "cgtz", "createdAt": "2020-02-06T21:44:08Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java", "diffHunk": "@@ -66,6 +69,12 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n+    // TODO: read from cloud based store and write to AsyncWritableChannel is needed in the future.\n+    throw new NotImplementedException();", "originalCommit": "db91456b30ce68b73eb96880e81b057e5992ff65", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "chunk": "diff --git a/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java b/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\nindex 17c45f2d8..1c79f4a03 100644\n--- a/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\n+++ b/ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java\n\n@@ -70,9 +69,8 @@ class CloudMessageReadSet implements MessageReadSet {\n   }\n \n   @Override\n-  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n-    // TODO: read from cloud based store and write to AsyncWritableChannel is needed in the future.\n-    throw new NotImplementedException();\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+\n   }\n \n   @Override\n"}}, {"oid": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "url": "https://github.com/linkedin/ambry/commit/c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "message": "http2 stroage", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "d19013abc408f99434c8f4589406ff04ea42e778", "url": "https://github.com/linkedin/ambry/commit/d19013abc408f99434c8f4589406ff04ea42e778", "message": "fix properties issue", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "8835a8f73640ba4ade7103d2339d40d5231e8795", "url": "https://github.com/linkedin/ambry/commit/8835a8f73640ba4ade7103d2339d40d5231e8795", "message": "properties issue", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "6c05ac67c6ba99b10981cd9acaf44c35abea1d7d", "url": "https://github.com/linkedin/ambry/commit/6c05ac67c6ba99b10981cd9acaf44c35abea1d7d", "message": "simplify http2 blocking channel", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "fc99a58e1210f3125fcf9149b770813f56d9148f", "url": "https://github.com/linkedin/ambry/commit/fc99a58e1210f3125fcf9149b770813f56d9148f", "message": "working", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "68a59ed4c2f47bccb249c1b0f38efdce623c9a49", "url": "https://github.com/linkedin/ambry/commit/68a59ed4c2f47bccb249c1b0f38efdce623c9a49", "message": "address comments and fix conflict", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "a702ee8b657c198e181bee7fbd0728a41a5d5940", "url": "https://github.com/linkedin/ambry/commit/a702ee8b657c198e181bee7fbd0728a41a5d5940", "message": "remove ambry-router/src/main/java/com.github.ambry.router/Http2NetworkClient.java", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "0a217d67d244b88d6b1075951d723aa540213094", "url": "https://github.com/linkedin/ambry/commit/0a217d67d244b88d6b1075951d723aa540213094", "message": "address cgetz comments", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "url": "https://github.com/linkedin/ambry/commit/bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "message": "address last comments.", "committedDate": "2020-02-10T21:47:38Z", "type": "commit"}, {"oid": "bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "url": "https://github.com/linkedin/ambry/commit/bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "message": "address last comments.", "committedDate": "2020-02-10T21:47:38Z", "type": "forcePushed"}, {"oid": "e61ab80edfe913c143ad8045f86c3de829dfc322", "url": "https://github.com/linkedin/ambry/commit/e61ab80edfe913c143ad8045f86c3de829dfc322", "message": "getListOfPorts() fix", "committedDate": "2020-02-10T22:13:46Z", "type": "commit"}, {"oid": "e61ab80edfe913c143ad8045f86c3de829dfc322", "url": "https://github.com/linkedin/ambry/commit/e61ab80edfe913c143ad8045f86c3de829dfc322", "message": "getListOfPorts() fix", "committedDate": "2020-02-10T22:13:46Z", "type": "forcePushed"}]}