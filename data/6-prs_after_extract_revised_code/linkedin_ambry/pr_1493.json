{"pr_number": 1493, "pr_title": "Prevent inactive child clients from slowing down sendAndPoll", "pr_createdAt": "2020-04-29T04:46:27Z", "pr_url": "https://github.com/linkedin/ambry/pull/1493", "timeline": [{"oid": "992c6ea35dcc39cdc2e155f9998bee3a133394a9", "url": "https://github.com/linkedin/ambry/commit/992c6ea35dcc39cdc2e155f9998bee3a133394a9", "message": "CompositeNetworkClient: Prevent inactive child clients from slowing down sendAndPoll\n\nPreviously, CompositeNetworkClient.sendAndPoll iterates over each child\nNetworkClient and calls sendAndPoll on each of them. This is alright if\nboth child clients are active and with many requests/responses to handle.\nHowever, if one of the clients is less active, it may wait for up to the\nconfigured poll timeout. Since this iteration is done from a single loop,\nwaiting for the inactive client prevents responses produced by the other\nchild client from being handled.\n\nTo fix this, this change introduces background threads so that each\nsendAndPoll can run in parallel (similar to parallelism in Selector).\nWhichever child client finishes its sendAndPoll first will call wakeup\non the other child clients to indicate that they should return from\nsendAndPoll immediately.\n\nFixes #1492", "committedDate": "2020-04-29T04:47:24Z", "type": "commit"}, {"oid": "992c6ea35dcc39cdc2e155f9998bee3a133394a9", "url": "https://github.com/linkedin/ambry/commit/992c6ea35dcc39cdc2e155f9998bee3a133394a9", "message": "CompositeNetworkClient: Prevent inactive child clients from slowing down sendAndPoll\n\nPreviously, CompositeNetworkClient.sendAndPoll iterates over each child\nNetworkClient and calls sendAndPoll on each of them. This is alright if\nboth child clients are active and with many requests/responses to handle.\nHowever, if one of the clients is less active, it may wait for up to the\nconfigured poll timeout. Since this iteration is done from a single loop,\nwaiting for the inactive client prevents responses produced by the other\nchild client from being handled.\n\nTo fix this, this change introduces background threads so that each\nsendAndPoll can run in parallel (similar to parallelism in Selector).\nWhichever child client finishes its sendAndPoll first will call wakeup\non the other child clients to indicate that they should return from\nsendAndPoll immediately.\n\nFixes #1492", "committedDate": "2020-04-29T04:47:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MzY1Ng==", "url": "https://github.com/linkedin/ambry/pull/1493#discussion_r417693656", "bodyText": "If we eat this exception, what will happen to the response consumers, will they just time out?", "author": "lightningrob", "createdAt": "2020-04-30T00:44:48Z", "path": "ambry-network/src/main/java/com/github/ambry/network/CompositeNetworkClient.java", "diffHunk": "@@ -71,23 +81,46 @@\n         requestsToDropByType.get(replicaType).add(correlationId);\n       }\n     }\n-    List<ResponseInfo> responses = new ArrayList<>();\n+\n+    // send requests using child clients from background threads so that inactive clients do not block the other client\n+    // from making progress.\n+    AtomicBoolean wakeupCalled = new AtomicBoolean(false);\n+    ArrayList<Future<List<ResponseInfo>>> sendAndPollFutures = new ArrayList<>(childNetworkClients.size());\n     childNetworkClients.forEach((replicaType, client) -> {\n       List<RequestInfo> requestsToSend = requestsToSendByType.get(replicaType);\n       Set<Integer> requestsToDrop = requestsToDropByType.get(replicaType);\n       if (!requestsToSend.isEmpty() || !requestsToDrop.isEmpty()) {\n         logger.trace(\"replicaType={}, requestsToSend={}, requestsToDrop={}\", replicaType, requestsToSend,\n             requestsToDrop);\n       }\n-      List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n-      childClientResponses.forEach(responseInfo -> {\n-        // clean up correlation ids for completed requests\n-        if (responseInfo.getRequestInfo() != null) {\n-          correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+      sendAndPollFutures.add(executor.submit(() -> {\n+        List<ResponseInfo> childClientResponses = client.sendAndPoll(requestsToSend, requestsToDrop, pollTimeoutMs);\n+        if (wakeupCalled.compareAndSet(false, true)) {\n+          // the client that gets a response first can wake up the other clients so that they do not waste time waiting\n+          // for the poll timeout to expire. This helps when one child client is very active and the others have very\n+          // little activity.\n+          childNetworkClients.values().stream().filter(c -> c != client).forEach(NetworkClient::wakeup);\n         }\n-        responses.add(responseInfo);\n-      });\n+        return childClientResponses;\n+      }));\n     });\n+\n+    // process responses returned by each child client\n+    List<ResponseInfo> responses = new ArrayList<>();\n+    for (Future<List<ResponseInfo>> future : sendAndPollFutures) {\n+      try {\n+        List<ResponseInfo> responseInfoList = future.get();\n+        for (ResponseInfo responseInfo : responseInfoList) {\n+          // clean up correlation ids for completed requests\n+          if (responseInfo.getRequestInfo() != null) {\n+            correlationIdToReplicaType.remove(responseInfo.getRequestInfo().getRequest().getCorrelationId());\n+          }\n+          responses.add(responseInfo);\n+        }\n+      } catch (InterruptedException | ExecutionException e) {\n+        logger.error(\"Hit unexpected exception on parallel sendAndPoll.\", e);", "originalCommit": "992c6ea35dcc39cdc2e155f9998bee3a133394a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5NjQ2Ng==", "url": "https://github.com/linkedin/ambry/pull/1493#discussion_r417696466", "bodyText": "Yep, they will just time out in the router after the configured routerRequestTimeout and a request will be sent to another replica.\nThis isn't the greatest, but i noticed that if we rethrow the exception (or encounter any other RuntimeException in sendAndPoll), the router will be closed: https://github.com/linkedin/ambry/blob/master/ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java#L1012\nI think swallowing the error is better than doing this. However, one could also argue that such errors are truly unexpected and require the frontend to be restarted.", "author": "cgtz", "createdAt": "2020-04-30T00:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MzY1Ng=="}], "type": "inlineReview", "revised_code": null}]}