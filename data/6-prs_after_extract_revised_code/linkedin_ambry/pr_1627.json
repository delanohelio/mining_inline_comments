{"pr_number": 1627, "pr_title": "[Container scalability] Implementation of backup file logic for MySqlAccountService and addition of LMT field to Accounts/Containers", "pr_createdAt": "2020-09-22T05:39:40Z", "pr_url": "https://github.com/linkedin/ambry/pull/1627", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MDAzMA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493040030", "bodyText": "MySqlBackupFileManager.  Also, this class is big enough to be in its own file.\nIt is also a generic backup manager, nothing specific to Mysql.  You don't need to pass the entire  MySqlAccountServiceConfig just for the backupDir.", "author": "lightningrob", "createdAt": "2020-09-22T21:19:28Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -307,4 +342,126 @@ private void updateContainersWithMySqlStore(short accountId, Collection<Containe\n       }\n     }\n   }\n+\n+  public static class MySqlBackupFileManager {\n+    private static final Logger logger = LoggerFactory.getLogger(BackupFileManager.class);", "originalCommit": "599024c74d021275fbb9bd262050c45abe365cc8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be61c19f220ef297890af1d80b5419ab5895c815", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\nindex b96169abb..4fbe91a78 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n\n@@ -342,126 +354,4 @@ public class MySqlAccountService implements AccountService {\n       }\n     }\n   }\n-\n-  public static class MySqlBackupFileManager {\n-    private static final Logger logger = LoggerFactory.getLogger(BackupFileManager.class);\n-    private static final String BACKUP_FILE_NAME = \"MySqlAccountMetadataCopy\";\n-    private final AccountServiceMetrics accountServiceMetrics;\n-    static final String TEMP_FILE_SUFFIX = \"tmp\";\n-    static final String SEP = \".\";\n-    static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss\");\n-    static final ZoneOffset zoneOffset = ZoneId.systemDefault().getRules().getOffset(LocalDateTime.now());\n-    static final Pattern filenamePattern = Pattern.compile(BACKUP_FILE_NAME + \"\\\\.(\\\\d{8}T\\\\d{6})$\");\n-    private final Path backupDirPath;\n-\n-    public MySqlBackupFileManager(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config)\n-        throws IOException {\n-      this.accountServiceMetrics = accountServiceMetrics;\n-      backupDirPath = config.backupDir.isEmpty() ? null : Files.createDirectories(Paths.get(config.backupDir));\n-      cleanupBackupFiles();\n-    }\n-\n-    /**\n-     * Persist {@link Account}s (each in the form of JSON string) to local file on disk.\n-     * @param accounts in the form of JSON string\n-     */\n-    void persistAccounts(Collection<String> accounts) {\n-      if (backupDirPath == null) {\n-        return;\n-      }\n-\n-      // Delete existing backup copy after persisting new copy\n-      File backupDir = backupDirPath.toFile();\n-      File[] oldFiles = backupDir.listFiles();\n-\n-      String fileName = getBackupFilename();\n-      String tempFileName = fileName + SEP + TEMP_FILE_SUFFIX;\n-      Path filePath = backupDirPath.resolve(fileName);\n-      Path tempFilePath = backupDirPath.resolve(tempFileName);\n-\n-      long startTimeInMs = System.currentTimeMillis();\n-      try {\n-        writeAccountsToFile(tempFilePath, accounts);\n-        Files.move(tempFilePath, filePath, REPLACE_EXISTING);\n-\n-        if (oldFiles != null) {\n-          for (File file : oldFiles) {\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      } catch (IOException e) {\n-        logger.error(\"Failed to persist state to file: {}\", fileName, e);\n-        accountServiceMetrics.backupErrorCount.inc();\n-        return;\n-      }\n-      accountServiceMetrics.backupWriteTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-    }\n-\n-    /**\n-     * Return the {@link Account}s persisted in the backup file in the form of a string-to-string map, where the key\n-     * is the string form of an {@link Account}'s id and the value is the string form of the {@link Account}'s JSON string.\n-     * @return Map of {@link Account}s.\n-     */\n-    Map<String, String> getAccountMap() {\n-      if (backupDirPath == null) {\n-        return null;\n-      }\n-      Path filepath = backupDirPath.resolve(BACKUP_FILE_NAME);\n-\n-      try {\n-        long startTimeInMs = System.currentTimeMillis();\n-        Map<String, String> accountMapFromFile = readAccountMapFromFile(filepath);\n-        accountServiceMetrics.backupReadTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-        return accountMapFromFile;\n-      } catch (IOException e) {\n-        accountServiceMetrics.backupErrorCount.inc();\n-        logger.error(\"Failed to read all bytes out from file {} {}\", filepath, e.getMessage());\n-        return null;\n-      }\n-    }\n-\n-    /**\n-     * Generate the backup filename by appending timestamp. The filename is of format \"MySqlAccountMetadataCopy.yyyyMMdd'T'HHmmss\".\n-     * @return The filename.\n-     */\n-    private String getBackupFilename() {\n-      String timestamp =\n-          LocalDateTime.ofEpochSecond(SystemTime.getInstance().seconds(), 0, zoneOffset).format(TIMESTAMP_FORMATTER);\n-      return BACKUP_FILE_NAME + SEP + timestamp;\n-    }\n-\n-    /**\n-     * Cleans old back up files\n-     */\n-    private void cleanupBackupFiles() {\n-\n-      File backupDir = backupDirPath.toFile();\n-\n-      // Remove any files with temp file suffix\n-      FileFilter tempFileFilter = (File pathname) -> pathname.getName().endsWith(SEP + TEMP_FILE_SUFFIX);\n-      File[] files = backupDir.listFiles(tempFileFilter);\n-      if (files != null) {\n-        for (File file : files) {\n-          logger.trace(\"Delete temp file {}\", file.getName());\n-          deleteFile(file.toPath());\n-        }\n-      }\n-\n-      // Remove back up files if they are more than a month old\n-      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();\n-      files = backupDir.listFiles(versionFileFilter);\n-      long aMonthAgo = SystemTime.getInstance().seconds() - TimeUnit.DAYS.toSeconds(30);\n-      if (files != null) {\n-        for (File file : files) {\n-          Matcher m = filenamePattern.matcher(file.getName());\n-          m.find();\n-          long modifiedTimeInSecond = LocalDateTime.parse(m.group(1), TIMESTAMP_FORMATTER).toEpochSecond(zoneOffset);\n-          if (modifiedTimeInSecond < aMonthAgo) {\n-            logger.trace(\"Delete old backup file {}\", file.getName());\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      }\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MjYzNA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493192634", "bodyText": "you might want to also add a begin anchor of \"^\" for your pattern. Something like\n\"^\" + BACKUP_FILE_NAME + \"......\"", "author": "justinlin-linkedin", "createdAt": "2020-09-23T04:39:26Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -307,4 +359,134 @@ private void updateContainersWithMySqlStore(short accountId, Collection<Containe\n       }\n     }\n   }\n+\n+  public static class MySqlBackupFileManager {\n+    private static final Logger logger = LoggerFactory.getLogger(BackupFileManager.class);\n+    private static final String BACKUP_FILE_NAME = \"MySqlAccountMetadataCopy\";\n+    private final AccountServiceMetrics accountServiceMetrics;\n+    static final String TEMP_FILE_SUFFIX = \"tmp\";\n+    static final String SEP = \".\";\n+    static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss\");\n+    static final ZoneOffset zoneOffset = ZoneId.systemDefault().getRules().getOffset(LocalDateTime.now());\n+    static final Pattern filenamePattern = Pattern.compile(BACKUP_FILE_NAME + \"\\\\.(\\\\d{8}T\\\\d{6})$\");", "originalCommit": "6e1a269f1b7d30faf5e4ac9b040556ece19e13d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be61c19f220ef297890af1d80b5419ab5895c815", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\nindex f441b77ab..4fbe91a78 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n\n@@ -359,134 +354,4 @@ public class MySqlAccountService implements AccountService {\n       }\n     }\n   }\n-\n-  public static class MySqlBackupFileManager {\n-    private static final Logger logger = LoggerFactory.getLogger(BackupFileManager.class);\n-    private static final String BACKUP_FILE_NAME = \"MySqlAccountMetadataCopy\";\n-    private final AccountServiceMetrics accountServiceMetrics;\n-    static final String TEMP_FILE_SUFFIX = \"tmp\";\n-    static final String SEP = \".\";\n-    static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss\");\n-    static final ZoneOffset zoneOffset = ZoneId.systemDefault().getRules().getOffset(LocalDateTime.now());\n-    static final Pattern filenamePattern = Pattern.compile(BACKUP_FILE_NAME + \"\\\\.(\\\\d{8}T\\\\d{6})$\");\n-    private final Path backupDirPath;\n-\n-    public MySqlBackupFileManager(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config)\n-        throws IOException {\n-      this.accountServiceMetrics = accountServiceMetrics;\n-      backupDirPath = config.backupDir.isEmpty() ? null : Files.createDirectories(Paths.get(config.backupDir));\n-      cleanupBackupFiles();\n-    }\n-\n-    /**\n-     * Persist {@link Account}s (each in the form of JSON string) to local file on disk.\n-     * @param accounts in the form of JSON string\n-     */\n-    void persistAccounts(Collection<String> accounts) {\n-      if (backupDirPath == null) {\n-        return;\n-      }\n-\n-      // Delete existing backup copy after persisting new copy\n-      File backupDir = backupDirPath.toFile();\n-      File[] oldFiles = backupDir.listFiles();\n-\n-      String fileName = getBackupFilename();\n-      String tempFileName = fileName + SEP + TEMP_FILE_SUFFIX;\n-      Path filePath = backupDirPath.resolve(fileName);\n-      Path tempFilePath = backupDirPath.resolve(tempFileName);\n-\n-      long startTimeInMs = System.currentTimeMillis();\n-      try {\n-        writeAccountsToFile(tempFilePath, accounts);\n-        Files.move(tempFilePath, filePath, REPLACE_EXISTING);\n-\n-        if (oldFiles != null) {\n-          for (File file : oldFiles) {\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      } catch (IOException e) {\n-        logger.error(\"Failed to persist state to file: {}\", fileName, e);\n-        accountServiceMetrics.backupErrorCount.inc();\n-        return;\n-      }\n-      accountServiceMetrics.backupWriteTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-    }\n-\n-    /**\n-     * Return the {@link Account}s persisted in the backup file in the form of a string-to-string map, where the key\n-     * is the string form of an {@link Account}'s id and the value is the string form of the {@link Account}'s JSON string.\n-     * @return Map of {@link Account}s.\n-     */\n-    Map<String, String> getAccountMap() {\n-      if (backupDirPath == null) {\n-        return null;\n-      }\n-\n-      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();\n-      File[] files = backupDirPath.toFile().listFiles(versionFileFilter);\n-      if (files == null) {\n-        return null;\n-      }\n-\n-      try {\n-        long startTimeInMs = System.currentTimeMillis();\n-        Map<String, String> accountMapFromFile = readAccountMapFromFile(files[0].toPath());\n-        accountServiceMetrics.backupReadTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-        return accountMapFromFile;\n-      } catch (IOException e) {\n-        accountServiceMetrics.backupErrorCount.inc();\n-        logger.error(\"Failed to read all bytes out from file {} {}\", files[0].toPath(), e.getMessage());\n-        return null;\n-      }\n-    }\n-\n-    /**\n-     * Generate the backup filename by appending timestamp. The filename is of format \"MySqlAccountMetadataCopy.yyyyMMdd'T'HHmmss\".\n-     * @return The filename.\n-     */\n-    private String getBackupFilename() {\n-      String timestamp =\n-          LocalDateTime.ofEpochSecond(SystemTime.getInstance().seconds(), 0, zoneOffset).format(TIMESTAMP_FORMATTER);\n-      return BACKUP_FILE_NAME + SEP + timestamp;\n-    }\n-\n-    /**\n-     * Cleans old back up files\n-     */\n-    private void cleanupBackupFiles() {\n-      if (backupDirPath == null) {\n-        return;\n-      }\n-\n-      File backupDir = backupDirPath.toFile();\n-\n-      // Remove any files with temp file suffix\n-      FileFilter tempFileFilter = (File pathname) -> pathname.getName().endsWith(SEP + TEMP_FILE_SUFFIX);\n-      File[] files = backupDir.listFiles(tempFileFilter);\n-      if (files != null) {\n-        for (File file : files) {\n-          logger.trace(\"Delete temp file {}\", file.getName());\n-          deleteFile(file.toPath());\n-        }\n-      }\n-\n-      // Remove back up files if they are more than a month old\n-      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();\n-      files = backupDir.listFiles(versionFileFilter);\n-      long aMonthAgo = SystemTime.getInstance().seconds() - TimeUnit.DAYS.toSeconds(30);\n-      if (files != null) {\n-        for (File file : files) {\n-          Matcher m = filenamePattern.matcher(file.getName());\n-          m.find();\n-          long modifiedTimeInSecond = LocalDateTime.parse(m.group(1), TIMESTAMP_FORMATTER).toEpochSecond(zoneOffset);\n-          if (modifiedTimeInSecond < aMonthAgo) {\n-            logger.trace(\"Delete old backup file {}\", file.getName());\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      }\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3NDg1NQ==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493774855", "bodyText": "Minor: I think this can just be \"pathname -> ...\"", "author": "lightningrob", "createdAt": "2020-09-23T17:43:40Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -406,16 +423,21 @@ void persistAccounts(Collection<String> accounts) {\n       if (backupDirPath == null) {\n         return null;\n       }\n-      Path filepath = backupDirPath.resolve(BACKUP_FILE_NAME);\n+\n+      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();", "originalCommit": "6e1a269f1b7d30faf5e4ac9b040556ece19e13d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be61c19f220ef297890af1d80b5419ab5895c815", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\nindex f441b77ab..4fbe91a78 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n\n@@ -359,134 +354,4 @@ public class MySqlAccountService implements AccountService {\n       }\n     }\n   }\n-\n-  public static class MySqlBackupFileManager {\n-    private static final Logger logger = LoggerFactory.getLogger(BackupFileManager.class);\n-    private static final String BACKUP_FILE_NAME = \"MySqlAccountMetadataCopy\";\n-    private final AccountServiceMetrics accountServiceMetrics;\n-    static final String TEMP_FILE_SUFFIX = \"tmp\";\n-    static final String SEP = \".\";\n-    static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss\");\n-    static final ZoneOffset zoneOffset = ZoneId.systemDefault().getRules().getOffset(LocalDateTime.now());\n-    static final Pattern filenamePattern = Pattern.compile(BACKUP_FILE_NAME + \"\\\\.(\\\\d{8}T\\\\d{6})$\");\n-    private final Path backupDirPath;\n-\n-    public MySqlBackupFileManager(AccountServiceMetrics accountServiceMetrics, MySqlAccountServiceConfig config)\n-        throws IOException {\n-      this.accountServiceMetrics = accountServiceMetrics;\n-      backupDirPath = config.backupDir.isEmpty() ? null : Files.createDirectories(Paths.get(config.backupDir));\n-      cleanupBackupFiles();\n-    }\n-\n-    /**\n-     * Persist {@link Account}s (each in the form of JSON string) to local file on disk.\n-     * @param accounts in the form of JSON string\n-     */\n-    void persistAccounts(Collection<String> accounts) {\n-      if (backupDirPath == null) {\n-        return;\n-      }\n-\n-      // Delete existing backup copy after persisting new copy\n-      File backupDir = backupDirPath.toFile();\n-      File[] oldFiles = backupDir.listFiles();\n-\n-      String fileName = getBackupFilename();\n-      String tempFileName = fileName + SEP + TEMP_FILE_SUFFIX;\n-      Path filePath = backupDirPath.resolve(fileName);\n-      Path tempFilePath = backupDirPath.resolve(tempFileName);\n-\n-      long startTimeInMs = System.currentTimeMillis();\n-      try {\n-        writeAccountsToFile(tempFilePath, accounts);\n-        Files.move(tempFilePath, filePath, REPLACE_EXISTING);\n-\n-        if (oldFiles != null) {\n-          for (File file : oldFiles) {\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      } catch (IOException e) {\n-        logger.error(\"Failed to persist state to file: {}\", fileName, e);\n-        accountServiceMetrics.backupErrorCount.inc();\n-        return;\n-      }\n-      accountServiceMetrics.backupWriteTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-    }\n-\n-    /**\n-     * Return the {@link Account}s persisted in the backup file in the form of a string-to-string map, where the key\n-     * is the string form of an {@link Account}'s id and the value is the string form of the {@link Account}'s JSON string.\n-     * @return Map of {@link Account}s.\n-     */\n-    Map<String, String> getAccountMap() {\n-      if (backupDirPath == null) {\n-        return null;\n-      }\n-\n-      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();\n-      File[] files = backupDirPath.toFile().listFiles(versionFileFilter);\n-      if (files == null) {\n-        return null;\n-      }\n-\n-      try {\n-        long startTimeInMs = System.currentTimeMillis();\n-        Map<String, String> accountMapFromFile = readAccountMapFromFile(files[0].toPath());\n-        accountServiceMetrics.backupReadTimeInMs.update(System.currentTimeMillis() - startTimeInMs);\n-        return accountMapFromFile;\n-      } catch (IOException e) {\n-        accountServiceMetrics.backupErrorCount.inc();\n-        logger.error(\"Failed to read all bytes out from file {} {}\", files[0].toPath(), e.getMessage());\n-        return null;\n-      }\n-    }\n-\n-    /**\n-     * Generate the backup filename by appending timestamp. The filename is of format \"MySqlAccountMetadataCopy.yyyyMMdd'T'HHmmss\".\n-     * @return The filename.\n-     */\n-    private String getBackupFilename() {\n-      String timestamp =\n-          LocalDateTime.ofEpochSecond(SystemTime.getInstance().seconds(), 0, zoneOffset).format(TIMESTAMP_FORMATTER);\n-      return BACKUP_FILE_NAME + SEP + timestamp;\n-    }\n-\n-    /**\n-     * Cleans old back up files\n-     */\n-    private void cleanupBackupFiles() {\n-      if (backupDirPath == null) {\n-        return;\n-      }\n-\n-      File backupDir = backupDirPath.toFile();\n-\n-      // Remove any files with temp file suffix\n-      FileFilter tempFileFilter = (File pathname) -> pathname.getName().endsWith(SEP + TEMP_FILE_SUFFIX);\n-      File[] files = backupDir.listFiles(tempFileFilter);\n-      if (files != null) {\n-        for (File file : files) {\n-          logger.trace(\"Delete temp file {}\", file.getName());\n-          deleteFile(file.toPath());\n-        }\n-      }\n-\n-      // Remove back up files if they are more than a month old\n-      FileFilter versionFileFilter = (File pathname) -> filenamePattern.matcher(pathname.getName()).find();\n-      files = backupDir.listFiles(versionFileFilter);\n-      long aMonthAgo = SystemTime.getInstance().seconds() - TimeUnit.DAYS.toSeconds(30);\n-      if (files != null) {\n-        for (File file : files) {\n-          Matcher m = filenamePattern.matcher(file.getName());\n-          m.find();\n-          long modifiedTimeInSecond = LocalDateTime.parse(m.group(1), TIMESTAMP_FORMATTER).toEpochSecond(zoneOffset);\n-          if (modifiedTimeInSecond < aMonthAgo) {\n-            logger.trace(\"Delete old backup file {}\", file.getName());\n-            deleteFile(file.toPath());\n-          }\n-        }\n-      }\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3ODEwOQ==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493778109", "bodyText": "Why change from switch to if/else?", "author": "lightningrob", "createdAt": "2020-09-23T17:49:07Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Account.java", "diffHunk": "@@ -122,26 +125,24 @@ private Account(JSONObject metadata) throws JSONException {\n       throw new IllegalArgumentException(\"metadata cannot be null.\");\n     }\n     short metadataVersion = (short) metadata.getInt(JSON_VERSION_KEY);\n-    switch (metadataVersion) {", "originalCommit": "6e1a269f1b7d30faf5e4ac9b040556ece19e13d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be61c19f220ef297890af1d80b5419ab5895c815", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/account/Account.java b/ambry-api/src/main/java/com/github/ambry/account/Account.java\nindex 7978cd0e4..ab6de9e33 100644\n--- a/ambry-api/src/main/java/com/github/ambry/account/Account.java\n+++ b/ambry-api/src/main/java/com/github/ambry/account/Account.java\n\n@@ -125,24 +127,26 @@ public class Account {\n       throw new IllegalArgumentException(\"metadata cannot be null.\");\n     }\n     short metadataVersion = (short) metadata.getInt(JSON_VERSION_KEY);\n-    if (metadataVersion == JSON_VERSION_1) {\n-      id = (short) metadata.getInt(ACCOUNT_ID_KEY);\n-      name = metadata.getString(ACCOUNT_NAME_KEY);\n-      status = AccountStatus.valueOf(metadata.getString(STATUS_KEY));\n-      snapshotVersion = metadata.optInt(SNAPSHOT_VERSION_KEY, SNAPSHOT_VERSION_DEFAULT_VALUE);\n-      lastModifiedTime = metadata.optLong(LAST_MODIFIED_TIME_KEY, LAST_MODIFIED_TIME_DEFAULT_VALUE);\n-      checkRequiredFieldsForBuild();\n-      JSONArray containerArray = metadata.optJSONArray(CONTAINERS_KEY);\n-      if (containerArray != null) {\n-        for (int index = 0; index < containerArray.length(); index++) {\n-          Container container = Container.fromJson(containerArray.getJSONObject(index), id);\n-          checkParentAccountIdInContainers(container);\n-          checkDuplicateContainerNameOrId(container);\n-          updateContainerMap(container);\n+    switch (metadataVersion) {\n+      case JSON_VERSION_1:\n+        id = (short) metadata.getInt(ACCOUNT_ID_KEY);\n+        name = metadata.getString(ACCOUNT_NAME_KEY);\n+        status = AccountStatus.valueOf(metadata.getString(STATUS_KEY));\n+        snapshotVersion = metadata.optInt(SNAPSHOT_VERSION_KEY, SNAPSHOT_VERSION_DEFAULT_VALUE);\n+        lastModifiedTime = metadata.optLong(LAST_MODIFIED_TIME_KEY, LAST_MODIFIED_TIME_DEFAULT_VALUE);\n+        checkRequiredFieldsForBuild();\n+        JSONArray containerArray = metadata.optJSONArray(CONTAINERS_KEY);\n+        if (containerArray != null) {\n+          List<Container> containers = new ArrayList<>();\n+          for (int index = 0; index < containerArray.length(); index++) {\n+            containers.add(Container.fromJson(containerArray.getJSONObject(index), id));\n+          }\n+          updateContainerMap(containers);\n         }\n-      }\n-    } else {\n-      throw new IllegalStateException(\"Unsupported account json version=\" + metadataVersion);\n+        break;\n+\n+      default:\n+        throw new IllegalStateException(\"Unsupported account json version=\" + metadataVersion);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MjA2OA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493782068", "bodyText": "I think it's useful to cache the calculated value, so the whole map doesn't need to be scanned on every refresh.", "author": "lightningrob", "createdAt": "2020-09-23T17:55:32Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java", "diffHunk": "@@ -40,8 +40,6 @@\n   private final static Logger logger = LoggerFactory.getLogger(AccountInfoMap.class);\n   private final Map<String, Account> nameToAccountMap;\n   private final Map<Short, Account> idToAccountMap;\n-  // used to track last modified time of the accounts and containers in this cache\n-  private long lastModifiedTime = 0;", "originalCommit": "6e1a269f1b7d30faf5e4ac9b040556ece19e13d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d412ea4b226895fc622f05e627648166c9e591", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java b/ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java\nindex 1535ed8f5..3aedc5ddc 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/AccountInfoMap.java\n\n@@ -40,6 +39,8 @@ class AccountInfoMap {\n   private final static Logger logger = LoggerFactory.getLogger(AccountInfoMap.class);\n   private final Map<String, Account> nameToAccountMap;\n   private final Map<Short, Account> idToAccountMap;\n+  // used to track last modified time of the accounts and containers in this cache\n+  private long lastModifiedTime = 0;\n \n   /**\n    * Constructor for an empty {@code AccountInfoMap}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MjYwNQ==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r493782605", "bodyText": "This will change infrequently.  Perhaps can use cached value?", "author": "lightningrob", "createdAt": "2020-09-23T17:56:19Z", "path": "ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java", "diffHunk": "@@ -127,8 +128,20 @@ private void fetchAndUpdateCache() {\n       // Retry connection to mysql if we couldn't set up previously\n       createMySqlAccountStore();\n \n-      // TODO: Find max LMT of Accounts and containers in cache.\n+      // Find max LMT of Accounts and containers in cache.", "originalCommit": "6e1a269f1b7d30faf5e4ac9b040556ece19e13d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be61c19f220ef297890af1d80b5419ab5895c815", "chunk": "diff --git a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\nindex f441b77ab..4fbe91a78 100644\n--- a/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n+++ b/ambry-account/src/main/java/com/github/ambry/account/MySqlAccountService.java\n\n@@ -120,8 +113,8 @@ public class MySqlAccountService implements AccountService {\n   }\n \n   /**\n-   * Fetches all the accounts and containers that have been created or modified since the last sync time and loads into\n-   * cache.\n+   * Fetches all the accounts and containers that have been created or modified in the mysql database since the\n+   * last modified/sync time and loads into in-memory {@link AccountInfoMap}.\n    */\n   private void fetchAndUpdateCache() {\n     try {\n"}}, {"oid": "be61c19f220ef297890af1d80b5419ab5895c815", "url": "https://github.com/linkedin/ambry/commit/be61c19f220ef297890af1d80b5419ab5895c815", "message": "Changes to:\n1. Use BackupFileManager in MySqlAccountService to persist and get account metadata from backup files locally.\n2. Add 'lastModifiedTime' field to Account and Container classes and use it to sync added/modified records from db.", "committedDate": "2020-09-24T22:23:47Z", "type": "commit"}, {"oid": "be61c19f220ef297890af1d80b5419ab5895c815", "url": "https://github.com/linkedin/ambry/commit/be61c19f220ef297890af1d80b5419ab5895c815", "message": "Changes to:\n1. Use BackupFileManager in MySqlAccountService to persist and get account metadata from backup files locally.\n2. Add 'lastModifiedTime' field to Account and Container classes and use it to sync added/modified records from db.", "committedDate": "2020-09-24T22:23:47Z", "type": "forcePushed"}, {"oid": "5a51298f6be5835ad2e36a7ac18713a9969e0bfe", "url": "https://github.com/linkedin/ambry/commit/5a51298f6be5835ad2e36a7ac18713a9969e0bfe", "message": "Fix unintended changes in BackupFileManager logger trace messages", "committedDate": "2020-09-25T00:01:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNjg1MQ==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r494726851", "bodyText": "minor: I guess you wanted to set 10 here.", "author": "jsjtzyy", "createdAt": "2020-09-25T03:29:09Z", "path": "ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java", "diffHunk": "@@ -73,6 +74,14 @@\n   @Default(\"\")\n   public final String backupDir;\n \n+  /**\n+   * The maximum number of local backup files kept in disk. When account service exceeds this count, every time it creates\n+   * a new backup file, it will remove the oldest one.\n+   */\n+  @Config(MAX_BACKUP_FILE_COUNT)\n+  @Default(\"100\")", "originalCommit": "5a51298f6be5835ad2e36a7ac18713a9969e0bfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d412ea4b226895fc622f05e627648166c9e591", "chunk": "diff --git a/ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java b/ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java\nindex c3fdde31d..3b1234d0e 100644\n--- a/ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java\n+++ b/ambry-api/src/main/java/com/github/ambry/config/MySqlAccountServiceConfig.java\n\n@@ -79,7 +79,7 @@ public class MySqlAccountServiceConfig {\n    * a new backup file, it will remove the oldest one.\n    */\n   @Config(MAX_BACKUP_FILE_COUNT)\n-  @Default(\"100\")\n+  @Default(\"10\")\n   public final int maxBackupFileCount;\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyODU5NA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r494728594", "bodyText": "This import can be removed.", "author": "jsjtzyy", "createdAt": "2020-09-25T03:36:11Z", "path": "ambry-account/src/test/java/com/github/ambry/account/BackupFileManagerTest.java", "diffHunk": "@@ -16,6 +16,7 @@\n import com.codahale.metrics.MetricRegistry;\n import com.github.ambry.config.HelixAccountServiceConfig;\n import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.SystemTime;", "originalCommit": "5a51298f6be5835ad2e36a7ac18713a9969e0bfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d412ea4b226895fc622f05e627648166c9e591", "chunk": "diff --git a/ambry-account/src/test/java/com/github/ambry/account/BackupFileManagerTest.java b/ambry-account/src/test/java/com/github/ambry/account/BackupFileManagerTest.java\nindex eaf4a7415..3e52d5b01 100644\n--- a/ambry-account/src/test/java/com/github/ambry/account/BackupFileManagerTest.java\n+++ b/ambry-account/src/test/java/com/github/ambry/account/BackupFileManagerTest.java\n\n@@ -16,7 +16,6 @@ package com.github.ambry.account;\n import com.codahale.metrics.MetricRegistry;\n import com.github.ambry.config.HelixAccountServiceConfig;\n import com.github.ambry.config.VerifiableProperties;\n-import com.github.ambry.utils.SystemTime;\n import com.github.ambry.utils.TestUtils;\n import com.github.ambry.utils.Utils;\n import java.io.File;\n"}}, {"oid": "15d412ea4b226895fc622f05e627648166c9e591", "url": "https://github.com/linkedin/ambry/commit/15d412ea4b226895fc622f05e627648166c9e591", "message": "Changes to add unit tests and address review comments", "committedDate": "2020-09-25T04:16:18Z", "type": "commit"}, {"oid": "faf246b8083cf622f25a9392155cc7ee382471e8", "url": "https://github.com/linkedin/ambry/commit/faf246b8083cf622f25a9392155cc7ee382471e8", "message": "Fix unit test failures in AccountsDaoTest and ContainerDaoTest", "committedDate": "2020-09-25T04:41:40Z", "type": "commit"}, {"oid": "d78c7f1c78d012c8df25f6cf0ac79503c2631e6d", "url": "https://github.com/linkedin/ambry/commit/d78c7f1c78d012c8df25f6cf0ac79503c2631e6d", "message": "Fix AccountContainerTest by adding lastModifiedTime field to reference json objects", "committedDate": "2020-09-25T17:32:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEzODM0OA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r495138348", "bodyText": "Is this needed in the old version?", "author": "lightningrob", "createdAt": "2020-09-25T17:41:02Z", "path": "ambry-api/src/test/java/com/github/ambry/account/AccountContainerTest.java", "diffHunk": "@@ -1041,6 +1044,7 @@ private JSONObject buildContainerJson(Container container) throws JSONException\n         containerJson.put(DESCRIPTION_KEY, container.getDescription());\n         containerJson.put(IS_PRIVATE_KEY, !container.isCacheable());\n         containerJson.put(PARENT_ACCOUNT_ID_KEY, container.getParentAccountId());\n+        containerJson.put(LAST_MODIFIED_TIME_KEY, container.getLastModifiedTime());", "originalCommit": "d78c7f1c78d012c8df25f6cf0ac79503c2631e6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEzOTEzOA==", "url": "https://github.com/linkedin/ambry/pull/1627#discussion_r495139138", "bodyText": "Not sure this was really needed.  Could have referenced it by class.", "author": "lightningrob", "createdAt": "2020-09-25T17:42:39Z", "path": "ambry-api/src/test/java/com/github/ambry/account/AccountContainerTest.java", "diffHunk": "@@ -34,6 +35,7 @@\n \n import static com.github.ambry.account.Account.*;\n import static com.github.ambry.account.Container.*;\n+import static com.github.ambry.account.Container.LAST_MODIFIED_TIME_KEY;", "originalCommit": "d78c7f1c78d012c8df25f6cf0ac79503c2631e6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}