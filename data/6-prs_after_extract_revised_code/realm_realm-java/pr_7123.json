{"pr_number": 7123, "pr_title": "Add \"allowWritesOnUiThread\" and \"allowReadsOnUiThread\" to RealmConfiguration", "pr_createdAt": "2020-09-23T10:33:08Z", "pr_url": "https://github.com/realm/realm-java/pull/7123", "timeline": [{"oid": "5bc164249976aaaf2ebb07fe6b7c58f733f58869", "url": "https://github.com/realm/realm-java/commit/5bc164249976aaaf2ebb07fe6b7c58f733f58869", "message": "Added allowWritesOnUiThread to RealmConfig which allows opting in for async writes launched from the UI thread. The default setting is set to disallow these writes as it cannot guarantee consistency in results.", "committedDate": "2020-09-23T10:27:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzNDQyMA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r493434420", "bodyText": "There is some misunderstanding here. Async transactions don't run on the UI thread, they are only started there, but actually run in a background thread, so this test and implementation is wrong. The only thing that should be disallowed is executeTransaction() (which runs on the same thread).", "author": "cmelchior", "createdAt": "2020-09-23T10:40:25Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,76 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransactionAsync_mainThreadQueriesAllowed() {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransactionAsync(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+                countDownLatch.countDown();\n+            }\n+        });\n+\n+        TestHelper.awaitOrFail(countDownLatch);\n+\n+        // Avoid stale data\n+        realm.refresh();\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransactionAsync_throwsWhenRunningOnMainThread() {", "originalCommit": "5bc164249976aaaf2ebb07fe6b7c58f733f58869", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "495411a5728797eae9bde20d54359af092a16fb2", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex 7a9dc8d91..f7ea77797 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1417,27 +1417,19 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransactionAsync_mainThreadQueriesAllowed() {\n-        CountDownLatch countDownLatch = new CountDownLatch(1);\n-\n+    public void executeTransaction_mainThreadWritesAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n                 .allowWritesOnUiThread()\n                 .build();\n \n         Realm realm = Realm.getInstance(configuration);\n-        realm.executeTransactionAsync(new Realm.Transaction() {\n+        realm.executeTransaction(new Realm.Transaction() {\n             @Override\n             public void execute(Realm realm) {\n                 realm.insert(new Dog(\"Snuffles\"));\n-                countDownLatch.countDown();\n             }\n         });\n \n-        TestHelper.awaitOrFail(countDownLatch);\n-\n-        // Avoid stale data\n-        realm.refresh();\n-\n         RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n         assertEquals(1, results.size());\n         assertNotNull(results.first());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQzNTA5Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r493435092", "bodyText": "Shouldn't this be named executeTransaction_mainThreadWritesAllowed()?", "author": "cmelchior", "createdAt": "2020-09-23T10:41:10Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,76 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransactionAsync_mainThreadQueriesAllowed() {", "originalCommit": "5bc164249976aaaf2ebb07fe6b7c58f733f58869", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "495411a5728797eae9bde20d54359af092a16fb2", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex 7a9dc8d91..f7ea77797 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1417,27 +1417,19 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransactionAsync_mainThreadQueriesAllowed() {\n-        CountDownLatch countDownLatch = new CountDownLatch(1);\n-\n+    public void executeTransaction_mainThreadWritesAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n                 .allowWritesOnUiThread()\n                 .build();\n \n         Realm realm = Realm.getInstance(configuration);\n-        realm.executeTransactionAsync(new Realm.Transaction() {\n+        realm.executeTransaction(new Realm.Transaction() {\n             @Override\n             public void execute(Realm realm) {\n                 realm.insert(new Dog(\"Snuffles\"));\n-                countDownLatch.countDown();\n             }\n         });\n \n-        TestHelper.awaitOrFail(countDownLatch);\n-\n-        // Avoid stale data\n-        realm.refresh();\n-\n         RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n         assertEquals(1, results.size());\n         assertNotNull(results.first());\n"}}, {"oid": "495411a5728797eae9bde20d54359af092a16fb2", "url": "https://github.com/realm/realm-java/commit/495411a5728797eae9bde20d54359af092a16fb2", "message": "Fixed silly misunderstanding with async method.", "committedDate": "2020-09-23T13:52:56Z", "type": "commit"}, {"oid": "08659f122e758bbb0c086ec570ecd369cd66459a", "url": "https://github.com/realm/realm-java/commit/08659f122e758bbb0c086ec570ecd369cd66459a", "message": "Added allowQueriesOnUiThread to the API", "committedDate": "2020-09-23T14:34:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3ODQwNQ==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494778405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n          \n          \n            \n                            throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");", "author": "edualonso", "createdAt": "2020-09-25T06:39:58Z", "path": "realm/realm-library/src/main/java/io/realm/RealmQuery.java", "diffHunk": "@@ -82,6 +84,15 @@\n      * to run it.\n      */\n     static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {\n+        // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n+        if (realm.getSharedRealm().capabilities.isMainThread()) {\n+            if (realm.getConfiguration().isAllowQueriesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run queries on the UI thread as it may lead to a drop of frames or ANRs. Please consider doing so from another thread instead.\");\n+            } else {\n+                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in using 'RealmConfiguration.allowQueriesOnUiThread'.\");", "originalCommit": "08659f122e758bbb0c086ec570ecd369cd66459a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\nindex 80db63dad..adea62203 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n\n@@ -89,7 +89,7 @@ public class RealmQuery<E> {\n             if (realm.getConfiguration().isAllowQueriesOnUiThread()) {\n                 RealmLog.warn(\"It is not recommended to run queries on the UI thread as it may lead to a drop of frames or ANRs. Please consider doing so from another thread instead.\");\n             } else {\n-                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n+                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3ODUxOA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494778518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in using 'RealmConfiguration.allowWritesOnUiThread'.\");\n          \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread'.\");", "author": "edualonso", "createdAt": "2020-09-25T06:40:13Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1525,6 +1525,15 @@ public void executeTransaction(Transaction transaction) {\n             throw new IllegalArgumentException(\"Transaction should not be null\");\n         }\n \n+        // Warn on transaction being executed on UI thread if allowWritesOnUiThread is set to true, throw otherwise\n+        if (sharedRealm.capabilities.isMainThread()) {\n+            if (getConfiguration().isAllowWritesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run transactions on the UI thread as it may lead to a drop of frames or ANRs. Please consider using 'executeTransactionAsync' instead.\");\n+            } else {\n+                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in using 'RealmConfiguration.allowWritesOnUiThread'.\");", "originalCommit": "08659f122e758bbb0c086ec570ecd369cd66459a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 58cbb2ba3..7e026c74c 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1530,7 +1530,7 @@ public class Realm extends BaseRealm {\n             if (getConfiguration().isAllowWritesOnUiThread()) {\n                 RealmLog.warn(\"It is not recommended to run transactions on the UI thread as it may lead to a drop of frames or ANRs. Please consider using 'executeTransactionAsync' instead.\");\n             } else {\n-                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in using 'RealmConfiguration.allowWritesOnUiThread'.\");\n+                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread'.\");\n             }\n         }\n \n"}}, {"oid": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "url": "https://github.com/realm/realm-java/commit/d3a7ba5b1d6398da1326323bc93cc2a432565122", "message": "Apply suggestions from code review\r\n\r\nFixed typos", "committedDate": "2020-09-25T06:41:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc4OTU1NQ==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494789555", "bodyText": "This is not documented in @throws. The documentation could also point to executeTransactionAsync to guide users around this.", "author": "rorbech", "createdAt": "2020-09-25T07:06:44Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1525,6 +1525,15 @@ public void executeTransaction(Transaction transaction) {\n             throw new IllegalArgumentException(\"Transaction should not be null\");\n         }\n \n+        // Warn on transaction being executed on UI thread if allowWritesOnUiThread is set to true, throw otherwise\n+        if (sharedRealm.capabilities.isMainThread()) {\n+            if (getConfiguration().isAllowWritesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run transactions on the UI thread as it may lead to a drop of frames or ANRs. Please consider using 'executeTransactionAsync' instead.\");\n+            } else {\n+                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread'.\");", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 7e026c74c..903ff8729 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1514,10 +1514,16 @@ public class Realm extends BaseRealm {\n      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n+     * <p>\n+     *\n+     * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n+     * or even ANRs. We recommend calling this method from a non-UI thread or using\n+     * {@link #executeTransactionAsync(Transaction)} instead.\n      *\n      * @param transaction the {@link io.realm.Realm.Transaction} to execute.\n      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.\n      * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.\n+     * @throws RealmException if called from the UI thread, unless an explicit opt-in has been declared in the configuration.\n      */\n     public void executeTransaction(Transaction transaction) {\n         //noinspection ConstantConditions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc5MTY4MA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494791680", "bodyText": "I guess we don't explicitly document throwing RealmExceptions from all the queries, but maybe some class level documentation about this pointing to the async variants?", "author": "rorbech", "createdAt": "2020-09-25T07:11:37Z", "path": "realm/realm-library/src/main/java/io/realm/RealmQuery.java", "diffHunk": "@@ -82,6 +84,15 @@\n      * to run it.\n      */\n     static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {\n+        // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n+        if (realm.getSharedRealm().capabilities.isMainThread()) {\n+            if (realm.getConfiguration().isAllowQueriesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run queries on the UI thread as it may lead to a drop of frames or ANRs. Please consider doing so from another thread instead.\");\n+            } else {\n+                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\nindex adea62203..9b26b8e3a 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n\n@@ -84,15 +90,6 @@ public class RealmQuery<E> {\n      * to run it.\n      */\n     static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {\n-        // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n-        if (realm.getSharedRealm().capabilities.isMainThread()) {\n-            if (realm.getConfiguration().isAllowQueriesOnUiThread()) {\n-                RealmLog.warn(\"It is not recommended to run queries on the UI thread as it may lead to a drop of frames or ANRs. Please consider doing so from another thread instead.\");\n-            } else {\n-                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n-            }\n-        }\n-\n         return new RealmQuery<>(realm, clazz);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc5MzQ2Ng==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494793466", "bodyText": "Regardless of setting? Maybe set it explicitly to false and verify that it does not break and test default values in configuration tests.", "author": "rorbech", "createdAt": "2020-09-25T07:15:40Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,101 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThreadRegardlessOfSetting() {", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex e64ad027a..36c851fd1 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1440,8 +1440,9 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n                 .build();\n \n         // Try-with-resources\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc5Mzk2OQ==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494793969", "bodyText": "Again, maybe add explicit .allowQueriesOnUiThread(true) and add configuration tests verifying default values.", "author": "rorbech", "createdAt": "2020-09-25T07:16:48Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,101 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThreadRegardlessOfSetting() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                // no-op\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex e64ad027a..36c851fd1 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1440,8 +1440,9 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n                 .build();\n \n         // Try-with-resources\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg2OTU2NA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494869564", "bodyText": "You are only testing one setting in this test. Shouldn't you manually create two different configurations? One with allowWritesOnUiThread(true) and one with allowWritesOnUiThread(false)?", "author": "cmelchior", "createdAt": "2020-09-25T09:37:00Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,101 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThreadRegardlessOfSetting() {", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex e64ad027a..36c851fd1 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1440,8 +1440,9 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n                 .build();\n \n         // Try-with-resources\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MDY0Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494870642", "bodyText": "Shouldn't this be query_runOnNonUiThreadAllowed()?", "author": "cmelchior", "createdAt": "2020-09-25T09:38:51Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,101 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThreadRegardlessOfSetting() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                // no-op\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.where(Dog.class).findAll();\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadThrows() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowQueriesOnUiThread(false)\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.where(Dog.class).findAll();\n+            fail(\"This test specifies queries are not allowed to run on the UI thread, so something went awry.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowQueriesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void query_runOnAnyThreadAllowed() {", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex e64ad027a..36c851fd1 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1440,8 +1440,9 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n                 .build();\n \n         // Try-with-resources\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MTk5OA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494871998", "bodyText": "With this setting, you also need to check and throw if Realm.refresh() is being called, because that will convert async queries to sync queries which would violate this restriction.", "author": "cmelchior", "createdAt": "2020-09-25T09:41:07Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,101 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThreadRegardlessOfSetting() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                // no-op\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.where(Dog.class).findAll();\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadThrows() {", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkxOTIwMg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494919202", "bodyText": "Yes, we discussed that yesterday. I'm still working on it \ud83d\udc4d", "author": "edualonso", "createdAt": "2020-09-25T11:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MTk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex e64ad027a..36c851fd1 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1440,8 +1440,9 @@ public class RealmAsyncQueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void executeTransaction_throwsWhenRunningOnMainThread() {\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n                 .build();\n \n         // Try-with-resources\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MzEwNA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494873104", "bodyText": "Not sure we should log this as a warning if enabled. It is only enabled if you manually opt into it, so hopefully, people are already aware of the tradeoff and the warn level will most likely become visible to users since that is the default setting.", "author": "cmelchior", "createdAt": "2020-09-25T09:42:55Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1525,6 +1525,15 @@ public void executeTransaction(Transaction transaction) {\n             throw new IllegalArgumentException(\"Transaction should not be null\");\n         }\n \n+        // Warn on transaction being executed on UI thread if allowWritesOnUiThread is set to true, throw otherwise\n+        if (sharedRealm.capabilities.isMainThread()) {\n+            if (getConfiguration().isAllowWritesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run transactions on the UI thread as it may lead to a drop of frames or ANRs. Please consider using 'executeTransactionAsync' instead.\");", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkxOTE4OA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494919188", "bodyText": "What should we do then? User RealmLog.info instead?", "author": "edualonso", "createdAt": "2020-09-25T11:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MzEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3ODQ2NA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494978464", "bodyText": "I would probably just remove it completely", "author": "cmelchior", "createdAt": "2020-09-25T13:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MzEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 7e026c74c..903ff8729 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1514,10 +1514,16 @@ public class Realm extends BaseRealm {\n      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n+     * <p>\n+     *\n+     * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n+     * or even ANRs. We recommend calling this method from a non-UI thread or using\n+     * {@link #executeTransactionAsync(Transaction)} instead.\n      *\n      * @param transaction the {@link io.realm.Realm.Transaction} to execute.\n      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.\n      * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.\n+     * @throws RealmException if called from the UI thread, unless an explicit opt-in has been declared in the configuration.\n      */\n     public void executeTransaction(Transaction transaction) {\n         //noinspection ConstantConditions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3NDQ5NA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494874494", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread'.\");\n          \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread are disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread', or avoid it by using 'Realm.executeTransactionAsync()'.\");", "author": "cmelchior", "createdAt": "2020-09-25T09:45:12Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1525,6 +1525,15 @@ public void executeTransaction(Transaction transaction) {\n             throw new IllegalArgumentException(\"Transaction should not be null\");\n         }\n \n+        // Warn on transaction being executed on UI thread if allowWritesOnUiThread is set to true, throw otherwise\n+        if (sharedRealm.capabilities.isMainThread()) {\n+            if (getConfiguration().isAllowWritesOnUiThread()) {\n+                RealmLog.warn(\"It is not recommended to run transactions on the UI thread as it may lead to a drop of frames or ANRs. Please consider using 'executeTransactionAsync' instead.\");\n+            } else {\n+                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread'.\");", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 7e026c74c..903ff8729 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1514,10 +1514,16 @@ public class Realm extends BaseRealm {\n      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n+     * <p>\n+     *\n+     * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n+     * or even ANRs. We recommend calling this method from a non-UI thread or using\n+     * {@link #executeTransactionAsync(Transaction)} instead.\n      *\n      * @param transaction the {@link io.realm.Realm.Transaction} to execute.\n      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.\n      * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.\n+     * @throws RealmException if called from the UI thread, unless an explicit opt-in has been declared in the configuration.\n      */\n     public void executeTransaction(Transaction transaction) {\n         //noinspection ConstantConditions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3NjIzMw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494876233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n          \n          \n            \n                     * Sets whether or not you are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.", "author": "cmelchior", "createdAt": "2020-09-25T09:48:11Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -797,6 +829,28 @@ final Builder schema(Class<? extends RealmModel> firstClass, Class<? extends Rea\n             return this;\n         }\n \n+        /**\n+         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\nindex 1ef7f6425..90dc3f4f6 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n\n@@ -830,10 +830,11 @@ public class RealmConfiguration {\n         }\n \n         /**\n-         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * Sets whether or not calls to {@link Realm#executeTransaction} are allowed from the UI thread.\n          * <p>\n-         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n-         * with this method.</b>\n+         * <b>WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b> We recommend diverting calls to {@code executeTransaction} to non-UI threads or, alternatively,\n+         * using {@link Realm#executeTransactionAsync}.\n          */\n         public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n             this.allowWritesOnUiThread = allowWritesOnUiThread;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3Njc2Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494876762", "bodyText": "The comment you had here is actually pretty great at describing the issue and work-around. I would add that description to this doc as well: https://github.com/realm/realm-java/pull/7123/files#diff-b77f99deee1ca52ca3dc3e47554e4e50R1531", "author": "cmelchior", "createdAt": "2020-09-25T09:49:09Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -797,6 +829,28 @@ final Builder schema(Class<? extends RealmModel> firstClass, Class<? extends Rea\n             return this;\n         }\n \n+        /**\n+         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * <p>", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\nindex 1ef7f6425..90dc3f4f6 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n\n@@ -830,10 +830,11 @@ public class RealmConfiguration {\n         }\n \n         /**\n-         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * Sets whether or not calls to {@link Realm#executeTransaction} are allowed from the UI thread.\n          * <p>\n-         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n-         * with this method.</b>\n+         * <b>WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b> We recommend diverting calls to {@code executeTransaction} to non-UI threads or, alternatively,\n+         * using {@link Realm#executeTransactionAsync}.\n          */\n         public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n             this.allowWritesOnUiThread = allowWritesOnUiThread;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3NzEwOQ==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494877109", "bodyText": "I would also add a line about being cautious about doing this and using REalmQuery.findAllAsync() is the preferred approach.", "author": "cmelchior", "createdAt": "2020-09-25T09:49:46Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -797,6 +829,28 @@ final Builder schema(Class<? extends RealmModel> firstClass, Class<? extends Rea\n             return this;\n         }\n \n+        /**\n+         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * <p>\n+         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b>\n+         */\n+        public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n+            this.allowWritesOnUiThread = allowWritesOnUiThread;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether or not RealmQueries are allowed from the UI thread.\n+         * <p>", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\nindex 1ef7f6425..90dc3f4f6 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n\n@@ -830,10 +830,11 @@ public class RealmConfiguration {\n         }\n \n         /**\n-         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * Sets whether or not calls to {@link Realm#executeTransaction} are allowed from the UI thread.\n          * <p>\n-         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n-         * with this method.</b>\n+         * <b>WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b> We recommend diverting calls to {@code executeTransaction} to non-UI threads or, alternatively,\n+         * using {@link Realm#executeTransactionAsync}.\n          */\n         public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n             this.allowWritesOnUiThread = allowWritesOnUiThread;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3NzU2Mw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494877563", "bodyText": "Any changes to the Javadoc in RealmConfiguration.Builder() should be reflected here.", "author": "cmelchior", "createdAt": "2020-09-25T09:50:26Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -1012,6 +1019,28 @@ public Builder maxNumberOfActiveVersions(long number) {\n             return this;\n         }\n \n+        /**\n+         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * <p>", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\nindex 0aede63fb..8c947aff2 100644\n--- a/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\n+++ b/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\n\n@@ -1020,10 +1021,11 @@ public class SyncConfiguration extends RealmConfiguration {\n         }\n \n         /**\n-         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * Sets whether or not calls to {@link Realm#executeTransaction} are allowed from the UI thread.\n          * <p>\n-         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n-         * with this method.</b>\n+         * <b>WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b> We recommend diverting calls to {@code executeTransaction} to non-UI threads or, alternatively,\n+         * using {@link Realm#executeTransactionAsync}.\n          */\n         public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n             this.allowWritesOnUiThread = allowWritesOnUiThread;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3NzU5Nw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494877597", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-09-25T09:50:30Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java", "diffHunk": "@@ -1012,6 +1019,28 @@ public Builder maxNumberOfActiveVersions(long number) {\n             return this;\n         }\n \n+        /**\n+         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * <p>\n+         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b>\n+         */\n+        public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n+            this.allowWritesOnUiThread = allowWritesOnUiThread;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets whether or not RealmQueries are allowed from the UI thread.\n+         * <p>", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\nindex 0aede63fb..8c947aff2 100644\n--- a/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\n+++ b/realm/realm-library/src/objectServer/java/io/realm/mongodb/sync/SyncConfiguration.java\n\n@@ -1020,10 +1021,11 @@ public class SyncConfiguration extends RealmConfiguration {\n         }\n \n         /**\n-         * Sets whether or not users are allowed to perform calls to {@link Realm#executeTransaction} from the UI thread.\n+         * Sets whether or not calls to {@link Realm#executeTransaction} are allowed from the UI thread.\n          * <p>\n-         * <b>Note: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n-         * with this method.</b>\n+         * <b>WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in\n+         * with this method.</b> We recommend diverting calls to {@code executeTransaction} to non-UI threads or, alternatively,\n+         * using {@link Realm#executeTransactionAsync}.\n          */\n         public Builder allowWritesOnUiThread(boolean allowWritesOnUiThread) {\n             this.allowWritesOnUiThread = allowWritesOnUiThread;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3ODQxMw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r494878413", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns whether {@code RealmQueries} are allowed from the UI thread.\n          \n          \n            \n                 * Returns whether {@link RealmQuery} are allowed from the UI thread.", "author": "cmelchior", "createdAt": "2020-09-25T09:51:52Z", "path": "realm/realm-library/src/main/java/io/realm/RealmConfiguration.java", "diffHunk": "@@ -288,6 +292,30 @@ public long getMaxNumberOfActiveVersions() {\n         return maxNumberOfActiveVersions;\n     }\n \n+    /**\n+     * Returns whether calls to {@link Realm#executeTransaction} can be done on the UI thread.\n+     * <p>\n+     * <b>Note: Realm does not allow blocking transactions to be run on the main thread unless users explicitly opt in with\n+     * {@link Builder#allowWritesOnUiThread(boolean)} or its Realm Sync builder counterpart.</b>\n+     *\n+     * @return whether or not write operations are allowed to be run from the UI thread.\n+     */\n+    public boolean isAllowWritesOnUiThread() {\n+        return allowWritesOnUiThread;\n+    }\n+\n+    /**\n+     * Returns whether {@code RealmQueries} are allowed from the UI thread.", "originalCommit": "d3a7ba5b1d6398da1326323bc93cc2a432565122", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\nindex 1ef7f6425..90dc3f4f6 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java\n\n@@ -305,7 +305,7 @@ public class RealmConfiguration {\n     }\n \n     /**\n-     * Returns whether {@code RealmQueries} are allowed from the UI thread.\n+     * Returns whether a {@link RealmQuery} is allowed to be launched from the UI thread.\n      * <p>\n      * By default Realm allows queries on the main thread. To disallow this users have to explicitly opt in with\n      * {@link Builder#allowQueriesOnUiThread(boolean)} or its Realm Sync builder counterpart.\n"}}, {"oid": "f4348d69f2870d7e4711a1c54819f5f8134aff51", "url": "https://github.com/realm/realm-java/commit/f4348d69f2870d7e4711a1c54819f5f8134aff51", "message": "Improved tests and documentation plus moved checks to BaseRealm", "committedDate": "2020-09-25T18:48:11Z", "type": "commit"}, {"oid": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "url": "https://github.com/realm/realm-java/commit/0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "message": "Updated changelog", "committedDate": "2020-09-25T19:04:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNzY5Ng==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495737696", "bodyText": "We should also test count/min/max/average", "author": "cmelchior", "createdAt": "2020-09-28T07:24:59Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -1411,6 +1415,121 @@ public void onChange(RealmResults<AllTypes> results) {\n         });\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                realm.insert(new Dog(\"Snuffles\"));\n+            }\n+        });\n+\n+        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n+        assertEquals(1, results.size());\n+        assertNotNull(results.first());\n+        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void executeTransaction_mainThreadWritesNotAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.executeTransaction(new Realm.Transaction() {\n+                @Override\n+                public void execute(Realm realm) {\n+                    // no-op\n+                }\n+            });\n+            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n+        } catch (RealmException e) {\n+            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n+        }\n+    }\n+\n+    @Test\n+    public void executeTransaction_runsOnNonUiThread() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowWritesOnUiThread(false)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.executeTransaction(new Realm.Transaction() {\n+            @Override\n+            public void execute(Realm realm) {\n+                // no-op\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowQueriesOnUiThread(true)\n+                .build();\n+\n+        Realm realm = Realm.getInstance(configuration);\n+        realm.where(Dog.class).findAll();\n+        realm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void query_runOnMainThreadThrows() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowQueriesOnUiThread(false)\n+                .build();\n+\n+        // Try-with-resources\n+        try (Realm realm = Realm.getInstance(configuration)) {\n+            realm.where(Dog.class).findAll();", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex 36c851fd1..f6f5b3f87 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -1415,121 +1412,6 @@ public class RealmAsyncQueryTests {\n         });\n     }\n \n-    @Test\n-    @UiThreadTest\n-    public void executeTransaction_mainThreadWritesAllowed() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowWritesOnUiThread(true)\n-                .build();\n-\n-        Realm realm = Realm.getInstance(configuration);\n-        realm.executeTransaction(new Realm.Transaction() {\n-            @Override\n-            public void execute(Realm realm) {\n-                realm.insert(new Dog(\"Snuffles\"));\n-            }\n-        });\n-\n-        RealmResults<Dog> results = realm.where(Dog.class).equalTo(\"name\", \"Snuffles\").findAll();\n-        assertEquals(1, results.size());\n-        assertNotNull(results.first());\n-        assertEquals(\"Snuffles\", Objects.requireNonNull(results.first()).getName());\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void executeTransaction_mainThreadWritesNotAllowed() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowWritesOnUiThread(false)\n-                .build();\n-\n-        // Try-with-resources\n-        try (Realm realm = Realm.getInstance(configuration)) {\n-            realm.executeTransaction(new Realm.Transaction() {\n-                @Override\n-                public void execute(Realm realm) {\n-                    // no-op\n-                }\n-            });\n-            fail(\"It is not allowed to run blocking transactions on the UI thread by default.\");\n-        } catch (RealmException e) {\n-            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowWritesOnUiThread\"));\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransaction_runsOnNonUiThread() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowWritesOnUiThread(false)\n-                .build();\n-\n-        Realm realm = Realm.getInstance(configuration);\n-        realm.executeTransaction(new Realm.Transaction() {\n-            @Override\n-            public void execute(Realm realm) {\n-                // no-op\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void query_runOnMainThreadAllowed() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowQueriesOnUiThread(true)\n-                .build();\n-\n-        Realm realm = Realm.getInstance(configuration);\n-        realm.where(Dog.class).findAll();\n-        realm.close();\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void query_runOnMainThreadThrows() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowQueriesOnUiThread(false)\n-                .build();\n-\n-        // Try-with-resources\n-        try (Realm realm = Realm.getInstance(configuration)) {\n-            realm.where(Dog.class).findAll();\n-            fail(\"This test specifies queries are not allowed to run on the UI thread, so something went awry.\");\n-        } catch (RealmException e) {\n-            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowQueriesOnUiThread\"));\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void asyncQuery_throwsWhenCallingRefresh() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .allowQueriesOnUiThread(false)\n-                .build();\n-\n-        // Try-with-resources\n-        try (Realm realm = Realm.getInstance(configuration)) {\n-            realm.refresh();\n-\n-            fail(\"This test specifies queries are not allowed to run on the UI thread, so something went awry.\");\n-        } catch (RealmException e) {\n-            assertTrue(Objects.requireNonNull(e.getMessage()).contains(\"allowQueriesOnUiThread\"));\n-        }\n-    }\n-\n-    @Test\n-    public void query_runOnNonUiThreadAllowed() {\n-        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n-                .build();\n-\n-        Realm realm = Realm.getInstance(configuration);\n-        RealmResults<Dog> results = realm.where(Dog.class).findAll();\n-        assertEquals(0, results.size());\n-        realm.close();\n-    }\n-\n     // *** Helper methods ***\n \n     private void populateTestRealm(final Realm testRealm, int objects) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczODQyMg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495738422", "bodyText": "We should add the RealmException here as well.", "author": "cmelchior", "createdAt": "2020-09-28T07:26:30Z", "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -177,13 +177,17 @@ public boolean isAutoRefresh() {\n      * It also calls any listeners associated with the Realm if needed.\n      * <p>\n      * WARNING: Calling this on a thread with async queries will turn those queries into synchronous queries.\n-     * In most cases it is better to use {@link RealmChangeListener}s to be notified about changes to the\n-     * Realm on a given thread than it is to use this method.\n+     * This means this method will throw a {@link RealmException} if\n+     * {@link RealmConfiguration.Builder#allowQueriesOnUiThread(boolean)} was used with {@code true} to\n+     * obtain a Realm instance. In most cases it is better to use {@link RealmChangeListener}s to be notified\n+     * about changes to the Realm on a given thread than it is to use this method.\n      *\n      * @throws IllegalStateException if attempting to refresh from within a transaction.", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\nindex f45c85b10..b16f6ccd0 100644\n--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n\n@@ -183,6 +183,7 @@ abstract class BaseRealm implements Closeable {\n      * about changes to the Realm on a given thread than it is to use this method.\n      *\n      * @throws IllegalStateException if attempting to refresh from within a transaction.\n+     * @throws RealmException if called from the UI thread after opting out via {@link RealmConfiguration.Builder#allowQueriesOnUiThread(boolean)}.\n      */\n     public void refresh() {\n         checkIfValid();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDU1NA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495740554", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n          \n          \n            \n                            throw new RealmException(\"Queries on the UI thread have been disabled. They can be enabled by setting 'RealmConfiguration.Builder.allowQueriesOnUiThread(true)'.\");", "author": "cmelchior", "createdAt": "2020-09-28T07:30:43Z", "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -493,6 +497,30 @@ protected void checkIfValid() {\n         }\n     }\n \n+    /**\n+     * Checks whether queries are allowed from the UI thread in the current RealmConfiguration.\n+     */\n+    protected void checkAllowQueriesOnUiThread() {\n+        // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n+        if (getSharedRealm().capabilities.isMainThread()) {\n+            if (!getConfiguration().isAllowQueriesOnUiThread()) {\n+                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\nindex f45c85b10..b16f6ccd0 100644\n--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n\n@@ -504,7 +505,7 @@ abstract class BaseRealm implements Closeable {\n         // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n         if (getSharedRealm().capabilities.isMainThread()) {\n             if (!getConfiguration().isAllowQueriesOnUiThread()) {\n-                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n+                throw new RealmException(\"Queries on the UI thread have been disabled. They can be enabled by setting 'RealmConfiguration.Builder.allowQueriesOnUiThread(true)'.\");\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDk1Mw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495740953", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread' or avoid it by using 'Realm.executeTransactionAsync'.\");\n          \n          \n            \n                            throw new RealmException(\"Running transactions on the UI thread have been disabled. They can be enabled by setting 'RealmConfiguration.Builder.allowQueriesOnUiThread(true)'.\");", "author": "cmelchior", "createdAt": "2020-09-28T07:31:34Z", "path": "realm/realm-library/src/main/java/io/realm/BaseRealm.java", "diffHunk": "@@ -493,6 +497,30 @@ protected void checkIfValid() {\n         }\n     }\n \n+    /**\n+     * Checks whether queries are allowed from the UI thread in the current RealmConfiguration.\n+     */\n+    protected void checkAllowQueriesOnUiThread() {\n+        // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n+        if (getSharedRealm().capabilities.isMainThread()) {\n+            if (!getConfiguration().isAllowQueriesOnUiThread()) {\n+                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks whether writes are allowed from the UI thread in the current RealmConfiguration.\n+     */\n+    protected void checkAllowWritesOnUiThread() {\n+        // Warn on transaction being executed on UI thread if allowWritesOnUiThread is set to true, throw otherwise\n+        if (getSharedRealm().capabilities.isMainThread()) {\n+            if (!getConfiguration().isAllowWritesOnUiThread()) {\n+                throw new RealmException(\"Running transactions on the UI thread is disabled by default. You can opt in by using 'RealmConfiguration.allowWritesOnUiThread' or avoid it by using 'Realm.executeTransactionAsync'.\");", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\nindex f45c85b10..b16f6ccd0 100644\n--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java\n\n@@ -504,7 +505,7 @@ abstract class BaseRealm implements Closeable {\n         // Warn on query being executed on UI thread if isAllowQueriesOnUiThread is set to true, throw otherwise\n         if (getSharedRealm().capabilities.isMainThread()) {\n             if (!getConfiguration().isAllowQueriesOnUiThread()) {\n-                throw new RealmException(\"There exists an opt-out for running queries on the UI thread. By default Realm allows queries from the UI thread. You can alternatively opt in by using 'RealmConfiguration.allowQueriesOnUiThread'.\");\n+                throw new RealmException(\"Queries on the UI thread have been disabled. They can be enabled by setting 'RealmConfiguration.Builder.allowQueriesOnUiThread(true)'.\");\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MTEyMg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495741122", "bodyText": "Maybe link to the option?", "author": "cmelchior", "createdAt": "2020-09-28T07:31:53Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1514,17 +1514,25 @@ public void removeAllChangeListeners() {\n      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n+     * <p>\n+     *\n+     * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n+     * or even ANRs. We recommend calling this method from a non-UI thread or using\n+     * {@link #executeTransactionAsync(Transaction)} instead.\n      *\n      * @param transaction the {@link io.realm.Realm.Transaction} to execute.\n      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.\n      * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.\n+     * @throws RealmException if called from the UI thread, unless an explicit opt-in has been declared in the configuration.", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 903ff8729..e4574b1c6 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1515,7 +1515,6 @@ public class Realm extends BaseRealm {\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n      * <p>\n-     *\n      * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n      * or even ANRs. We recommend calling this method from a non-UI thread or using\n      * {@link #executeTransactionAsync(Transaction)} instead.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MTIwNw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495741207", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "cmelchior", "createdAt": "2020-09-28T07:32:05Z", "path": "realm/realm-library/src/main/java/io/realm/Realm.java", "diffHunk": "@@ -1514,17 +1514,25 @@ public void removeAllChangeListeners() {\n      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n+     * <p>\n+     *", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java\nindex 903ff8729..e4574b1c6 100644\n--- a/realm/realm-library/src/main/java/io/realm/Realm.java\n+++ b/realm/realm-library/src/main/java/io/realm/Realm.java\n\n@@ -1515,7 +1515,6 @@ public class Realm extends BaseRealm {\n      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be\n      * called instead of {@link #commitTransaction()}.\n      * <p>\n-     *\n      * Calling this method from the UI thread will throw a {@link RealmException}. Doing so may result in a drop of frames\n      * or even ANRs. We recommend calling this method from a non-UI thread or using\n      * {@link #executeTransactionAsync(Transaction)} instead.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MTg0OA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495741848", "bodyText": "This is not true, you can only launch the query from the Thread holding the Realm instance. Same for the other descriptions", "author": "cmelchior", "createdAt": "2020-09-28T07:33:29Z", "path": "realm/realm-library/src/main/java/io/realm/RealmQuery.java", "diffHunk": "@@ -51,6 +52,13 @@\n  * is required.\n  * <p>\n  * A RealmQuery cannot be passed between different threads.\n+ * <p>\n+ * Queries can be launched from any thread and results are obtained fairly quickly most of the times. However, launching", "originalCommit": "0f80f1f82d843a5c7976e2e9fa10006c69c2a05e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NTkyOA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r495755928", "bodyText": "Yeah, it was a broad generalisation. I will change it.", "author": "edualonso", "createdAt": "2020-09-28T08:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MTg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\nindex 9b26b8e3a..8529a6e75 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n\n@@ -53,12 +53,11 @@ import io.realm.internal.fields.FieldDescriptor;\n  * <p>\n  * A RealmQuery cannot be passed between different threads.\n  * <p>\n- * Queries can be launched from any thread and results are obtained fairly quickly most of the times. However, launching\n- * heavy queries from the UI thread may result in a drop of frames or even ANRs. If you want to prevent these behaviors,\n- * you can instantiate a Realm using a {@link RealmConfiguration} that explicitly sets\n- * {@link RealmConfiguration.Builder#allowQueriesOnUiThread(boolean)} to {@code false}. This way you will be forced to\n- * launch your queries from a non-UI thread. Alternatively, you can also use {@link #findAllAsync()} or\n- * {@link #findFirstAsync()}.\n+ * Results are obtained fairly quickly most of the times. However, launching heavy queries from the UI thread may result\n+ * in a drop of frames or even ANRs. If you want to prevent these behaviors, you can instantiate a Realm using a\n+ * {@link RealmConfiguration} that explicitly sets {@link RealmConfiguration.Builder#allowQueriesOnUiThread(boolean)} to\n+ * {@code false}. This way queries will be forced to be launched from a non-UI thread. Alternatively, you can also use\n+ * {@link #findAllAsync()} or {@link #findFirstAsync()}.\n  *\n  * @param <E> the class of the objects to be queried.\n  * @see <a href=\"http://en.wikipedia.org/wiki/Builder_pattern\">Builder pattern</a>\n"}}, {"oid": "f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "url": "https://github.com/realm/realm-java/commit/f6c34d17d7887cf7602e463ae8b33c120e7a97ec", "message": "Added missing tests for query ops, improved docs. Still missing tests for dynamic realms", "committedDate": "2020-09-28T09:59:48Z", "type": "commit"}, {"oid": "f6bd7a2c7f83ab9253a47730cd13163cbf0ffda1", "url": "https://github.com/realm/realm-java/commit/f6bd7a2c7f83ab9253a47730cd13163cbf0ffda1", "message": "Added dynamic realm tests for executeTransaction", "committedDate": "2020-09-28T13:10:36Z", "type": "commit"}, {"oid": "57a7aec51a02ea4ef891ba9f9a39a9b92bb20af1", "url": "https://github.com/realm/realm-java/commit/57a7aec51a02ea4ef891ba9f9a39a9b92bb20af1", "message": "Added missing tests for DynamicRealm.executeTransactionAsync", "committedDate": "2020-09-28T15:39:52Z", "type": "commit"}, {"oid": "e47d101ca6180eba209fbf3cb931c106bb29039b", "url": "https://github.com/realm/realm-java/commit/e47d101ca6180eba209fbf3cb931c106bb29039b", "message": "Updated changelog", "committedDate": "2020-09-28T15:45:58Z", "type": "commit"}, {"oid": "f4587e2b41844d4fb2d6dcd6263603a122d0d3ff", "url": "https://github.com/realm/realm-java/commit/f4587e2b41844d4fb2d6dcd6263603a122d0d3ff", "message": "Added missing reference to refresh in changelog", "committedDate": "2020-09-29T07:06:12Z", "type": "commit"}, {"oid": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "url": "https://github.com/realm/realm-java/commit/d7cbc0981b0e51cb07118401b86b6fda6858f746", "message": "Merge branch 'v10' into el/realmconfig-allowwritesonui\n\n# Conflicts:\n#\tCHANGELOG.md", "committedDate": "2020-09-29T09:33:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwMjA3Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496602072", "bodyText": "We should not create configs like this but always go either the ConfigurationFactory or for a default Realm use looperThread.getConfiguration() ... The primary reason is that these Realms will get a specialized location that shouldn't interact with other tests.", "author": "cmelchior", "createdAt": "2020-09-29T10:14:00Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwMjg3Mw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496602873", "bodyText": "If you use looperThread.addClosable(realm). You don't need this as the LooperThread rule will guarantee it being closed even in case of test failures.\nSame for the other tests.", "author": "cmelchior", "createdAt": "2020-09-29T10:15:29Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();\n+\n+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n+        Realm.getInstance(config).close();\n+    }\n+\n+    // ****************************\n+    // ****  Async transaction  ***\n+    // ****************************\n+\n+    // Starts asynchronously a transaction to insert one element.\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwMzAxNw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496603017", "bodyText": "No need to do this if you use the specialized configuration.\nSame for the other tests.", "author": "cmelchior", "createdAt": "2020-09-29T10:15:45Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();\n+\n+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n+        Realm.getInstance(config).close();\n+    }\n+\n+    // ****************************\n+    // ****  Async transaction  ***\n+    // ****************************\n+\n+    // Starts asynchronously a transaction to insert one element.\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNDM0Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496604342", "bodyText": "How is this test different from the above?", "author": "cmelchior", "createdAt": "2020-09-29T10:18:11Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();\n+\n+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n+        Realm.getInstance(config).close();\n+    }\n+\n+    // ****************************\n+    // ****  Async transaction  ***\n+    // ****************************\n+\n+    // Starts asynchronously a transaction to insert one element.\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        }, new DynamicRealm.Transaction.OnError() {\n+            @Override\n+            public void onError(Throwable error) {\n+                fail(error.getMessage());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onSuccess() {", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNTA5Mw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496605093", "bodyText": "Not 100% sure what this is testing?\nIdeally, closing the Realm should also prevent the async write from triggering, but that is a race condition.", "author": "cmelchior", "createdAt": "2020-09-29T10:19:27Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();\n+\n+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n+        Realm.getInstance(config).close();\n+    }\n+\n+    // ****************************\n+    // ****  Async transaction  ***\n+    // ****************************\n+\n+    // Starts asynchronously a transaction to insert one element.\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        }, new DynamicRealm.Transaction.OnError() {\n+            @Override\n+            public void onError(Throwable error) {\n+                fail(error.getMessage());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onSuccess() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onSuccessCallerRealmClosed() {", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNTI5OA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496605298", "bodyText": "Same, not sure what this is testing?", "author": "cmelchior", "createdAt": "2020-09-29T10:19:48Z", "path": "realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.realm.entities.AllTypes;\n+import io.realm.entities.Owner;\n+import io.realm.internal.async.RealmThreadPoolExecutor;\n+import io.realm.log.LogLevel;\n+import io.realm.log.RealmLog;\n+import io.realm.rule.RunInLooperThread;\n+import io.realm.rule.RunTestInLooperThread;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class DynamicRealmAsyncQueryTests {\n+\n+    @Rule\n+    public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n+    @Rule\n+    public final ExpectedException thrown = ExpectedException.none();\n+\n+    private RealmConfiguration config;\n+\n+    @Before\n+    public void setUp() {\n+        config = new RealmConfiguration.Builder().build();\n+\n+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n+        Realm.getInstance(config).close();\n+    }\n+\n+    // ****************************\n+    // ****  Async transaction  ***\n+    // ****************************\n+\n+    // Starts asynchronously a transaction to insert one element.\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        }, new DynamicRealm.Transaction.OnError() {\n+            @Override\n+            public void onError(Throwable error) {\n+                fail(error.getMessage());\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onSuccess() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n+                owner.setString(Owner.FIELD_NAME, \"Owner\");\n+            }\n+        }, new DynamicRealm.Transaction.OnSuccess() {\n+            @Override\n+            public void onSuccess() {\n+                assertTrue(realm.isClosed());\n+                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n+                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n+                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n+\n+                newRealm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        });\n+\n+        realm.close();\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onError() {\n+        final DynamicRealm realm = DynamicRealm.getInstance(config);\n+        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+\n+        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n+            @Override\n+            public void execute(DynamicRealm realm) {\n+                throw runtimeException;\n+            }\n+        }, new DynamicRealm.Transaction.OnError() {\n+            @Override\n+            public void onError(Throwable error) {\n+                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n+                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n+                assertEquals(runtimeException, error);\n+\n+                realm.close();\n+                Realm.deleteRealm(config);\n+\n+                looperThread.testComplete();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @RunTestInLooperThread\n+    public void executeTransactionAsync_onErrorCallerRealmClosed() {", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\ndeleted file mode 100644\nindex b8987bdb8..000000000\n--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmAsyncQueryTests.java\n+++ /dev/null\n\n@@ -1,503 +0,0 @@\n-/*\n- * Copyright 2020 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n-\n-import org.junit.Before;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import io.realm.entities.AllTypes;\n-import io.realm.entities.Owner;\n-import io.realm.internal.async.RealmThreadPoolExecutor;\n-import io.realm.log.LogLevel;\n-import io.realm.log.RealmLog;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class DynamicRealmAsyncQueryTests {\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-    @Rule\n-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();\n-    @Rule\n-    public final ExpectedException thrown = ExpectedException.none();\n-\n-    private RealmConfiguration config;\n-\n-    @Before\n-    public void setUp() {\n-        config = new RealmConfiguration.Builder().build();\n-\n-        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.\n-        Realm.getInstance(config).close();\n-    }\n-\n-    // ****************************\n-    // ****  Async transaction  ***\n-    // ****************************\n-\n-    // Starts asynchronously a transaction to insert one element.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail(error.getMessage());\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccess() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onSuccessCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(1, newRealm.where(Owner.CLASS_NAME).count());\n-                assertEquals(\"Owner\", newRealm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onError() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-                assertNull(realm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_onErrorCallerRealmClosed() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RuntimeException runtimeException = new RuntimeException(\"Oh! What a Terrible Failure\");\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw runtimeException;\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                assertTrue(realm.isClosed());\n-                DynamicRealm newRealm = DynamicRealm.getInstance(config);\n-                assertEquals(0, newRealm.where(Owner.CLASS_NAME).count());\n-                assertNull(newRealm.where(Owner.CLASS_NAME).findFirst());\n-                assertEquals(runtimeException, error);\n-\n-                newRealm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-        realm.close();\n-    }\n-\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_NoCallbacks() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-            }\n-        });\n-        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {\n-            @Override\n-            public void onChange(DynamicRealm otherRealm) {\n-                assertEquals(\"Owner\", realm.where(Owner.CLASS_NAME).findFirst().getString(Owner.FIELD_NAME));\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests that an async transaction that throws when call cancelTransaction manually.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_cancelTransactionInside() {\n-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);\n-        RealmLog.add(testLogger);\n-\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-\n-        assertEquals(0, realm.where(Owner.CLASS_NAME).count());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);\n-                owner.setString(Owner.FIELD_NAME, \"Owner\");\n-                realm.cancelTransaction();\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                fail(\"Should not reach success if runtime exception is thrown in callback.\");\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                // Ensure we are giving developers quality messages in the logs.\n-                assertTrue(testLogger.message.contains(\n-                        \"Exception has been thrown: Can't commit a non-existing write transaction\"));\n-                assertTrue(error instanceof IllegalStateException);\n-                RealmLog.remove(testLogger);\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-    }\n-\n-    // Tests if the background Realm is closed when transaction success returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_realmClosedOnSuccess() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnSuccess transactionCallback = new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        // no-op\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                // no-op\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Tests if the background Realm is closed when transaction error returned.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransaction_async_realmClosedOnError() {\n-        final AtomicInteger counter = new AtomicInteger(100);\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {\n-            @Override\n-            public void onResult(int count) {\n-                assertEquals(1, count);\n-                if (counter.decrementAndGet() == 0) {\n-                    realm.close();\n-                    Realm.deleteRealm(config);\n-\n-                    looperThread.testComplete();\n-                }\n-            }\n-        };\n-        final DynamicRealm.Transaction.OnError transactionCallback = new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);\n-                if (counter.get() == 0) {\n-                    // Finishes testing.\n-                    return;\n-                }\n-                realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                    @Override\n-                    public void execute(DynamicRealm realm) {\n-                        throw new RuntimeException(\"Dummy exception\");\n-                    }\n-                }, this);\n-            }\n-        };\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                throw new RuntimeException(\"Dummy exception\");\n-            }\n-        }, transactionCallback);\n-    }\n-\n-    // Test case for https://github.com/realm/realm-java/issues/1893\n-    // Ensures that onSuccess is called with the correct Realm version for async transaction.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_asyncQuery() {\n-        final DynamicRealm realm = DynamicRealm.getInstance(config);\n-        final RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAllAsync();\n-        assertEquals(0, results.size());\n-\n-        realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());\n-                // We cannot guarantee the async results get delivered from OS.\n-                if (results.isLoaded()) {\n-                    assertEquals(1, results.size());\n-                } else {\n-                    assertEquals(0, results.size());\n-                }\n-\n-                realm.close();\n-                Realm.deleteRealm(config);\n-\n-                looperThread.testComplete();\n-            }\n-        }, new DynamicRealm.Transaction.OnError() {\n-            @Override\n-            public void onError(Throwable error) {\n-                fail();\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnSuccess() {\n-                @Override\n-                public void onSuccess() {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    @Test\n-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {\n-        try (DynamicRealm realm = DynamicRealm.getInstance(config)) {\n-            thrown.expect(IllegalStateException.class);\n-            realm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-                @Override\n-                public void execute(DynamicRealm realm) {\n-                    // no-op\n-                }\n-            }, new DynamicRealm.Transaction.OnError() {\n-                @Override\n-                public void onError(Throwable error) {\n-                    // no-op\n-                }\n-            });\n-        } finally {\n-            Realm.deleteRealm(config);\n-        }\n-    }\n-\n-    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411\n-    // onSuccess might commit another transaction which will call didChange. So before calling async transaction\n-    // callbacks, the callback should be cleared.\n-    @Test\n-    @RunTestInLooperThread\n-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()\n-            throws NoSuchFieldException, IllegalAccessException {\n-        final AtomicInteger callbackCounter = new AtomicInteger(0);\n-        final DynamicRealm foregroundRealm = DynamicRealm.getInstance(config);\n-\n-        // Use single thread executor\n-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());\n-\n-        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.\n-        // We just disable the auto refresh here then the did_change won't be called.\n-        foregroundRealm.setAutoRefresh(false);\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called first and only once\n-                assertEquals(0, callbackCounter.getAndIncrement());\n-\n-                // This transaction should never trigger the onSuccess.\n-                foregroundRealm.beginTransaction();\n-                foregroundRealm.createObject(AllTypes.CLASS_NAME);\n-                foregroundRealm.commitTransaction();\n-            }\n-        });\n-\n-        foregroundRealm.executeTransactionAsync(new DynamicRealm.Transaction() {\n-            @Override\n-            public void execute(DynamicRealm realm) {\n-                realm.createObject(AllTypes.CLASS_NAME);\n-            }\n-        }, new DynamicRealm.Transaction.OnSuccess() {\n-            @Override\n-            public void onSuccess() {\n-                // This will be called 2nd and only once\n-                assertEquals(1, callbackCounter.getAndIncrement());\n-\n-                foregroundRealm.close();\n-\n-                looperThread.testComplete();\n-            }\n-        });\n-\n-        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.\n-        TestHelper.resetRealmThreadExecutor();\n-        looperThread.postRunnable(new Runnable() {\n-            @Override\n-            public void run() {\n-                // Manually call refresh, so the did_change will be triggered.\n-                foregroundRealm.sharedRealm.refresh();\n-            }\n-        });\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNDI4Ng==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496614286", "bodyText": "Doesn't seem to be used?", "author": "cmelchior", "createdAt": "2020-09-29T10:35:54Z", "path": "realm/realm-library/src/androidTest/java/io/realm/QueryTests.java", "diffHunk": "@@ -45,6 +47,8 @@\n     public final ExpectedException thrown = ExpectedException.none();\n     @Rule\n     public final RunInLooperThread looperThread = new RunInLooperThread();\n+    @Rule\n+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MjY4MA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496662680", "bodyText": "Not in this class, but in a child class for the @UiThreadTest annotation. Perhaps it's better to add it in that one instead?", "author": "edualonso", "createdAt": "2020-09-29T12:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNDI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2NTgwOA==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496665808", "bodyText": "I remember now. This class has also some rules, so I thought it might as well be used like the \"rule entry point\".", "author": "edualonso", "createdAt": "2020-09-29T12:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNDI4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNDM1Nw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496614357", "bodyText": "Doesn't seem to be used?", "author": "cmelchior", "createdAt": "2020-09-29T10:36:04Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java", "diffHunk": "@@ -17,8 +17,9 @@\n package io.realm;\n \n import android.os.SystemClock;\n-import androidx.test.rule.UiThreadTestRule;\n+\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import androidx.test.rule.UiThreadTestRule;", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ce9b19c69ffd6e4cdec12d35ad276f88c17cb51", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\nindex f6f5b3f87..900c6fab6 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java\n\n@@ -19,7 +19,6 @@ package io.realm;\n import android.os.SystemClock;\n \n import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import androidx.test.rule.UiThreadTestRule;\n \n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNTI4Mg==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496615282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void finalAll_runOnMainThreadAllowed() {\n          \n          \n            \n                public void findAll_runOnMainThreadAllowed() {", "author": "cmelchior", "createdAt": "2020-09-29T10:37:49Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -3739,6 +3742,210 @@ public void limit_invalidValuesThrows() {\n         }\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void finalAll_runOnMainThreadAllowed() {", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\nindex 0f9dec1e2..945cc30d8 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\n\n@@ -3744,7 +3744,7 @@ public class RealmQueryTests extends QueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void finalAll_runOnMainThreadAllowed() {\n+    public void findAll_runOnMainThreadAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n                 .allowQueriesOnUiThread(true)\n                 .name(\"ui_realm\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxNTM3Mw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496615373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void finalFirst_runOnMainThreadAllowed() {\n          \n          \n            \n                public void findFirst_runOnMainThreadAllowed() {", "author": "cmelchior", "createdAt": "2020-09-29T10:37:59Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -3739,6 +3742,210 @@ public void limit_invalidValuesThrows() {\n         }\n     }\n \n+    @Test\n+    @UiThreadTest\n+    public void finalAll_runOnMainThreadAllowed() {\n+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n+                .allowQueriesOnUiThread(true)\n+                .name(\"ui_realm\")\n+                .build();\n+\n+        Realm uiRealm = Realm.getInstance(configuration);\n+        uiRealm.where(Dog.class).findAll();\n+        uiRealm.close();\n+    }\n+\n+    @Test\n+    @UiThreadTest\n+    public void finalFirst_runOnMainThreadAllowed() {", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\nindex 0f9dec1e2..945cc30d8 100644\n--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\n+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java\n\n@@ -3744,7 +3744,7 @@ public class RealmQueryTests extends QueryTests {\n \n     @Test\n     @UiThreadTest\n-    public void finalAll_runOnMainThreadAllowed() {\n+    public void findAll_runOnMainThreadAllowed() {\n         RealmConfiguration configuration = configFactory.createConfigurationBuilder()\n                 .allowQueriesOnUiThread(true)\n                 .name(\"ui_realm\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMjUyNw==", "url": "https://github.com/realm/realm-java/pull/7123#discussion_r496632527", "bodyText": "Maybe it is just me but the term \"fairly quickly\" feels like a cop out. Either just say \"Quickly\" or remove the line completely IMO", "author": "cmelchior", "createdAt": "2020-09-29T11:10:08Z", "path": "realm/realm-library/src/main/java/io/realm/RealmQuery.java", "diffHunk": "@@ -51,6 +52,12 @@\n  * is required.\n  * <p>\n  * A RealmQuery cannot be passed between different threads.\n+ * <p>\n+ * Results are obtained fairly quickly most of the times. However, launching heavy queries from the UI thread may result", "originalCommit": "d7cbc0981b0e51cb07118401b86b6fda6858f746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d532407325368cc0f40aac614a2c35170e0a2e3", "chunk": "diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\nindex 8529a6e75..494b541ef 100644\n--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java\n\n@@ -53,7 +53,7 @@ import io.realm.internal.fields.FieldDescriptor;\n  * <p>\n  * A RealmQuery cannot be passed between different threads.\n  * <p>\n- * Results are obtained fairly quickly most of the times. However, launching heavy queries from the UI thread may result\n+ * Results are obtained quickly most of the times. However, launching heavy queries from the UI thread may result\n  * in a drop of frames or even ANRs. If you want to prevent these behaviors, you can instantiate a Realm using a\n  * {@link RealmConfiguration} that explicitly sets {@link RealmConfiguration.Builder#allowQueriesOnUiThread(boolean)} to\n  * {@code false}. This way queries will be forced to be launched from a non-UI thread. Alternatively, you can also use\n"}}, {"oid": "c55bbb9baf3bbb4c5d548ddce75a1d232afc4ad9", "url": "https://github.com/realm/realm-java/commit/c55bbb9baf3bbb4c5d548ddce75a1d232afc4ad9", "message": "Merge branch 'v10' into el/realmconfig-allowwritesonui", "committedDate": "2020-09-29T11:24:43Z", "type": "commit"}, {"oid": "82a3112f69cfee098902f87c2dbc432e9079656e", "url": "https://github.com/realm/realm-java/commit/82a3112f69cfee098902f87c2dbc432e9079656e", "message": "wip", "committedDate": "2020-09-29T11:48:26Z", "type": "commit"}, {"oid": "1d532407325368cc0f40aac614a2c35170e0a2e3", "url": "https://github.com/realm/realm-java/commit/1d532407325368cc0f40aac614a2c35170e0a2e3", "message": "Improved documentation and translated dynamic realm async tests to kotlin so that we can use BlockingLooperThread instead of the old java rule", "committedDate": "2020-09-29T13:26:56Z", "type": "commit"}, {"oid": "0ce9b19c69ffd6e4cdec12d35ad276f88c17cb51", "url": "https://github.com/realm/realm-java/commit/0ce9b19c69ffd6e4cdec12d35ad276f88c17cb51", "message": "Removed unused import and rule", "committedDate": "2020-09-30T08:53:07Z", "type": "commit"}, {"oid": "2a164e3851a22a99b4bc9288e54223cc48dcfa00", "url": "https://github.com/realm/realm-java/commit/2a164e3851a22a99b4bc9288e54223cc48dcfa00", "message": "Last bits of cleanup", "committedDate": "2020-10-01T08:58:11Z", "type": "commit"}, {"oid": "2dbbc85f3acae1c5c53d5ca0bc17108133ff7821", "url": "https://github.com/realm/realm-java/commit/2dbbc85f3acae1c5c53d5ca0bc17108133ff7821", "message": "Merge branch 'v10' into el/realmconfig-allowwritesonui", "committedDate": "2020-10-02T11:33:07Z", "type": "commit"}, {"oid": "f99a153938f107ed4fc00c83398cdaa4287c78c8", "url": "https://github.com/realm/realm-java/commit/f99a153938f107ed4fc00c83398cdaa4287c78c8", "message": "Allow running transactions on UI thread by default for tests", "committedDate": "2020-10-02T13:18:25Z", "type": "commit"}]}