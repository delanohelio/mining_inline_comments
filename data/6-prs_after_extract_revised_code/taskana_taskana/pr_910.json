{"pr_number": 910, "pr_title": "Tsk1031: Update to Spring Boot 2.2.4 and Spring 5.2.3", "pr_createdAt": "2020-02-07T19:57:06Z", "pr_url": "https://github.com/Taskana/taskana/pull/910", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTc3Ng==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376801776", "bodyText": "Why is the diff so big?", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:50:17Z", "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/jobs/WorkbasketCleanupJob.java", "diffHunk": "@@ -1,149 +1,146 @@\n-package pro.taskana.common.internal.jobs;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTc4NQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376801785", "bodyText": "Please reformat.", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/common/internal/jobs/WorkbasketCleanupJob.java b/lib/taskana-core/src/main/java/pro/taskana/common/internal/jobs/WorkbasketCleanupJob.java\nindex 54df71841..4633cb126 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/common/internal/jobs/WorkbasketCleanupJob.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/common/internal/jobs/WorkbasketCleanupJob.java\n\n@@ -1,146 +1,146 @@\n-package pro.taskana.common.internal.jobs;\n-\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.List;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import pro.taskana.common.api.BaseQuery;\n-import pro.taskana.common.api.BulkOperationResults;\n-import pro.taskana.common.api.ScheduledJob;\n-import pro.taskana.common.api.TaskanaEngine;\n-import pro.taskana.common.api.exceptions.InvalidArgumentException;\n-import pro.taskana.common.api.exceptions.NotAuthorizedException;\n-import pro.taskana.common.api.exceptions.TaskanaException;\n-import pro.taskana.common.internal.transaction.TaskanaTransactionProvider;\n-import pro.taskana.workbasket.api.WorkbasketQueryColumnName;\n-\n-/**\n- * Job to cleanup completed workbaskets after a period of time if there are no pending tasks\n- * associated to the workbasket.\n- */\n-public class WorkbasketCleanupJob extends AbstractTaskanaJob {\n-\n-  private static final Logger LOGGER = LoggerFactory.getLogger(WorkbasketCleanupJob.class);\n-\n-  // Parameter\n-  private Instant firstRun;\n-  private Duration runEvery;\n-  private int batchSize;\n-\n-  public WorkbasketCleanupJob(\n-      TaskanaEngine taskanaEngine,\n-      TaskanaTransactionProvider<Object> txProvider,\n-      ScheduledJob job) {\n-    super(taskanaEngine, txProvider, job);\n-    firstRun = taskanaEngine.getConfiguration().getCleanupJobFirstRun();\n-    runEvery = taskanaEngine.getConfiguration().getCleanupJobRunEvery();\n-    batchSize = taskanaEngine.getConfiguration().getMaxNumberOfUpdatesPerTransaction();\n-  }\n-\n-  @Override\n-  public void run() throws TaskanaException {\n-    LOGGER.info(\"Running job to delete all workbaskets marked for deletion\");\n-    try {\n-      List<String> workbasketsMarkedForDeletion = getWorkbasketsMarkedForDeletion();\n-      int totalNumberOfWorkbasketDeleted = 0;\n-      while (workbasketsMarkedForDeletion.size() > 0) {\n-        int upperLimit = batchSize;\n-        if (upperLimit > workbasketsMarkedForDeletion.size()) {\n-          upperLimit = workbasketsMarkedForDeletion.size();\n-        }\n-        totalNumberOfWorkbasketDeleted +=\n-            deleteWorkbasketsTransactionally(workbasketsMarkedForDeletion.subList(0, upperLimit));\n-        workbasketsMarkedForDeletion.subList(0, upperLimit).clear();\n-      }\n-      LOGGER.info(\n-          \"Job ended successfully. {} workbaskets deleted.\", totalNumberOfWorkbasketDeleted);\n-    } catch (Exception e) {\n-      throw new TaskanaException(\"Error while processing WorkbasketCleanupJob.\", e);\n-    } finally {\n-      scheduleNextCleanupJob();\n-    }\n-  }\n-\n-  /**\n-   * Initializes the WorkbasketCleanupJob schedule. <br>\n-   * All scheduled cleanup jobs are cancelled/deleted and a new one is scheduled.\n-   *\n-   * @param taskanaEngine the taskana engine\n-   */\n-  public static void initializeSchedule(TaskanaEngine taskanaEngine) {\n-    WorkbasketCleanupJob job = new WorkbasketCleanupJob(taskanaEngine, null, null);\n-    job.scheduleNextCleanupJob();\n-  }\n-\n-  private List<String> getWorkbasketsMarkedForDeletion() {\n-    List<String> workbasketList =\n-        taskanaEngineImpl\n-            .getWorkbasketService()\n-            .createWorkbasketQuery()\n-            .markedForDeletion(true)\n-            .listValues(WorkbasketQueryColumnName.ID, BaseQuery.SortDirection.ASCENDING);\n-\n-    return workbasketList;\n-  }\n-\n-  private int deleteWorkbasketsTransactionally(List<String> workbasketsToBeDeleted) {\n-    int deletedWorkbasketsCount = 0;\n-    if (txProvider != null) {\n-      int count =\n-          (Integer)\n-              txProvider.executeInTransaction(\n-                  () -> {\n-                    try {\n-                      return deleteWorkbaskets(workbasketsToBeDeleted);\n-                    } catch (Exception e) {\n-                      LOGGER.warn(\"Could not delete workbaskets.\", e);\n-                      return 0;\n-                    }\n-                  });\n-      return count;\n-    } else {\n-      try {\n-        deletedWorkbasketsCount = deleteWorkbaskets(workbasketsToBeDeleted);\n-      } catch (Exception e) {\n-        LOGGER.warn(\"Could not delete workbaskets.\", e);\n-      }\n-    }\n-    return deletedWorkbasketsCount;\n-  }\n-\n-  private int deleteWorkbaskets(List<String> workbasketsToBeDeleted)\n-      throws InvalidArgumentException, NotAuthorizedException {\n-\n-    BulkOperationResults<String, TaskanaException> results =\n-        taskanaEngineImpl.getWorkbasketService().deleteWorkbaskets(workbasketsToBeDeleted);\n-    LOGGER.debug(\n-        \"{} workbasket deleted.\", workbasketsToBeDeleted.size() - results.getFailedIds().size());\n-    for (String failedId : results.getFailedIds()) {\n-      LOGGER.warn(\n-          \"Workbasket with id {} could not be deleted. Reason: {}\",\n-          failedId,\n-          results.getErrorForId(failedId));\n-    }\n-    return workbasketsToBeDeleted.size() - results.getFailedIds().size();\n-  }\n-\n-  private void scheduleNextCleanupJob() {\n-    LOGGER.debug(\"Entry to scheduleNextCleanupJob.\");\n-    ScheduledJob job = new ScheduledJob();\n-    job.setType(ScheduledJob.Type.WORKBASKETCLEANUPJOB);\n-    job.setDue(getNextDueForWorkbasketCleanupJob());\n-    taskanaEngineImpl.getJobService().createJob(job);\n-    LOGGER.debug(\"Exit from scheduleNextCleanupJob.\");\n-  }\n-\n-  private Instant getNextDueForWorkbasketCleanupJob() {\n-    Instant nextRunAt = firstRun;\n-    while (nextRunAt.isBefore(Instant.now())) {\n-      nextRunAt = nextRunAt.plus(runEvery);\n-    }\n-    LOGGER.info(\"Scheduling next run of the WorkbasketCleanupJob for {}\", nextRunAt);\n-    return nextRunAt;\n-  }\n-}\n+package pro.taskana.common.internal.jobs;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import pro.taskana.common.api.BaseQuery;\n+import pro.taskana.common.api.BulkOperationResults;\n+import pro.taskana.common.api.ScheduledJob;\n+import pro.taskana.common.api.TaskanaEngine;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.common.api.exceptions.TaskanaException;\n+import pro.taskana.common.internal.transaction.TaskanaTransactionProvider;\n+import pro.taskana.workbasket.api.WorkbasketQueryColumnName;\n+\n+/**\n+ * Job to cleanup completed workbaskets after a period of time if there are no pending tasks\n+ * associated to the workbasket.\n+ */\n+public class WorkbasketCleanupJob extends AbstractTaskanaJob {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(WorkbasketCleanupJob.class);\n+\n+  // Parameter\n+  private Instant firstRun;\n+  private Duration runEvery;\n+  private int batchSize;\n+\n+  public WorkbasketCleanupJob(\n+      TaskanaEngine taskanaEngine,\n+      TaskanaTransactionProvider<Object> txProvider,\n+      ScheduledJob job) {\n+    super(taskanaEngine, txProvider, job);\n+    firstRun = taskanaEngine.getConfiguration().getCleanupJobFirstRun();\n+    runEvery = taskanaEngine.getConfiguration().getCleanupJobRunEvery();\n+    batchSize = taskanaEngine.getConfiguration().getMaxNumberOfUpdatesPerTransaction();\n+  }\n+\n+  @Override\n+  public void run() throws TaskanaException {\n+    LOGGER.info(\"Running job to delete all workbaskets marked for deletion\");\n+    try {\n+      List<String> workbasketsMarkedForDeletion = getWorkbasketsMarkedForDeletion();\n+      int totalNumberOfWorkbasketDeleted = 0;\n+      while (workbasketsMarkedForDeletion.size() > 0) {\n+        int upperLimit = batchSize;\n+        if (upperLimit > workbasketsMarkedForDeletion.size()) {\n+          upperLimit = workbasketsMarkedForDeletion.size();\n+        }\n+        totalNumberOfWorkbasketDeleted +=\n+            deleteWorkbasketsTransactionally(workbasketsMarkedForDeletion.subList(0, upperLimit));\n+        workbasketsMarkedForDeletion.subList(0, upperLimit).clear();\n+      }\n+      LOGGER.info(\n+          \"Job ended successfully. {} workbaskets deleted.\", totalNumberOfWorkbasketDeleted);\n+    } catch (Exception e) {\n+      throw new TaskanaException(\"Error while processing WorkbasketCleanupJob.\", e);\n+    } finally {\n+      scheduleNextCleanupJob();\n+    }\n+  }\n+\n+  /**\n+   * Initializes the WorkbasketCleanupJob schedule. <br>\n+   * All scheduled cleanup jobs are cancelled/deleted and a new one is scheduled.\n+   *\n+   * @param taskanaEngine the taskana engine\n+   */\n+  public static void initializeSchedule(TaskanaEngine taskanaEngine) {\n+    WorkbasketCleanupJob job = new WorkbasketCleanupJob(taskanaEngine, null, null);\n+    job.scheduleNextCleanupJob();\n+  }\n+\n+  private List<String> getWorkbasketsMarkedForDeletion() {\n+    List<String> workbasketList =\n+        taskanaEngineImpl\n+            .getWorkbasketService()\n+            .createWorkbasketQuery()\n+            .markedForDeletion(true)\n+            .listValues(WorkbasketQueryColumnName.ID, BaseQuery.SortDirection.ASCENDING);\n+\n+    return workbasketList;\n+  }\n+\n+  private int deleteWorkbasketsTransactionally(List<String> workbasketsToBeDeleted) {\n+    int deletedWorkbasketsCount = 0;\n+    if (txProvider != null) {\n+      int count =\n+          (Integer)\n+              txProvider.executeInTransaction(\n+                  () -> {\n+                    try {\n+                      return deleteWorkbaskets(workbasketsToBeDeleted);\n+                    } catch (Exception e) {\n+                      LOGGER.warn(\"Could not delete workbaskets.\", e);\n+                      return 0;\n+                    }\n+                  });\n+      return count;\n+    } else {\n+      try {\n+        deletedWorkbasketsCount = deleteWorkbaskets(workbasketsToBeDeleted);\n+      } catch (Exception e) {\n+        LOGGER.warn(\"Could not delete workbaskets.\", e);\n+      }\n+    }\n+    return deletedWorkbasketsCount;\n+  }\n+\n+  private int deleteWorkbaskets(List<String> workbasketsToBeDeleted)\n+      throws InvalidArgumentException, NotAuthorizedException {\n+\n+    BulkOperationResults<String, TaskanaException> results =\n+        taskanaEngineImpl.getWorkbasketService().deleteWorkbaskets(workbasketsToBeDeleted);\n+    LOGGER.debug(\n+        \"{} workbasket deleted.\", workbasketsToBeDeleted.size() - results.getFailedIds().size());\n+    for (String failedId : results.getFailedIds()) {\n+      LOGGER.warn(\n+          \"Workbasket with id {} could not be deleted. Reason: {}\",\n+          failedId,\n+          results.getErrorForId(failedId));\n+    }\n+    return workbasketsToBeDeleted.size() - results.getFailedIds().size();\n+  }\n+\n+  private void scheduleNextCleanupJob() {\n+    LOGGER.debug(\"Entry to scheduleNextCleanupJob.\");\n+    ScheduledJob job = new ScheduledJob();\n+    job.setType(ScheduledJob.Type.WORKBASKETCLEANUPJOB);\n+    job.setDue(getNextDueForWorkbasketCleanupJob());\n+    taskanaEngineImpl.getJobService().createJob(job);\n+    LOGGER.debug(\"Exit from scheduleNextCleanupJob.\");\n+  }\n+\n+  private Instant getNextDueForWorkbasketCleanupJob() {\n+    Instant nextRunAt = firstRun;\n+    while (nextRunAt.isBefore(Instant.now())) {\n+      nextRunAt = nextRunAt.plus(runEvery);\n+    }\n+    LOGGER.info(\"Scheduling next run of the WorkbasketCleanupJob for {}\", nextRunAt);\n+    return nextRunAt;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTgyMA==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376801820", "bodyText": "Why did you add this property?", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:50:54Z", "path": "lib/taskana-spring-example/src/test/java/pro/taskana/TaskanaTransactionIntTest.java", "diffHunk": "@@ -45,19 +40,20 @@\n import pro.taskana.workbasket.api.WorkbasketType;\n import pro.taskana.workbasket.api.exceptions.InvalidWorkbasketException;\n import pro.taskana.workbasket.api.exceptions.WorkbasketAlreadyExistException;\n+import pro.taskana.workbasket.api.exceptions.WorkbasketInUseException;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n import pro.taskana.workbasket.internal.WorkbasketImpl;\n \n /** Test for internal transaction management. */\n @ExtendWith(SpringExtension.class)\n @SpringBootTest(\n     classes = TaskanaConfigTestApplication.class,\n-    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\n+    properties = \"spring.main.allow-bean-definition-overriding=true\")", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTk2MA==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376801960", "bodyText": "And why is it here and not in the application.properties file?", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/lib/taskana-spring-example/src/test/java/pro/taskana/TaskanaTransactionIntTest.java b/lib/taskana-spring-example/src/test/java/pro/taskana/TaskanaTransactionIntTest.java\nindex 2b0e5fd63..7e23f8f9e 100644\n--- a/lib/taskana-spring-example/src/test/java/pro/taskana/TaskanaTransactionIntTest.java\n+++ b/lib/taskana-spring-example/src/test/java/pro/taskana/TaskanaTransactionIntTest.java\n\n@@ -40,7 +45,6 @@ import pro.taskana.workbasket.api.WorkbasketService;\n import pro.taskana.workbasket.api.WorkbasketType;\n import pro.taskana.workbasket.api.exceptions.InvalidWorkbasketException;\n import pro.taskana.workbasket.api.exceptions.WorkbasketAlreadyExistException;\n-import pro.taskana.workbasket.api.exceptions.WorkbasketInUseException;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n import pro.taskana.workbasket.internal.WorkbasketImpl;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMTkwNw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376801907", "bodyText": "Please reformat.", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:52:15Z", "path": "rest/taskana-rest-spring-example-boot/src/main/java/pro/taskana/rest/ExampleRestApplication.java", "diffHunk": "@@ -1,74 +1,73 @@\n-package pro.taskana.rest;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring-example-boot/src/main/java/pro/taskana/rest/ExampleRestApplication.java b/rest/taskana-rest-spring-example-boot/src/main/java/pro/taskana/rest/ExampleRestApplication.java\nindex 4846b27cd..60d402666 100644\n--- a/rest/taskana-rest-spring-example-boot/src/main/java/pro/taskana/rest/ExampleRestApplication.java\n+++ b/rest/taskana-rest-spring-example-boot/src/main/java/pro/taskana/rest/ExampleRestApplication.java\n\n@@ -1,73 +1,73 @@\n-package pro.taskana.rest;\n-\n-import javax.annotation.PostConstruct;\n-import javax.sql.DataSource;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.boot.SpringApplication;\n-import org.springframework.boot.autoconfigure.SpringBootApplication;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.ComponentScan;\n-import org.springframework.context.annotation.DependsOn;\n-import org.springframework.context.annotation.Import;\n-import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n-import org.springframework.scheduling.annotation.EnableScheduling;\n-import org.springframework.transaction.PlatformTransactionManager;\n-\n-import pro.taskana.jobs.TransactionalJobsConfiguration;\n-import pro.taskana.ldap.LdapCacheTestImpl;\n-import pro.taskana.ldap.LdapClient;\n-import pro.taskana.ldap.LdapConfiguration;\n-import pro.taskana.sampledata.SampleDataGenerator;\n-\n-/** Example Application showing the implementation of taskana-rest-spring. */\n-@SpringBootApplication\n-@EnableScheduling\n-@ComponentScan(basePackages = \"pro.taskana\")\n-@SuppressWarnings(\"checkstyle:Indentation\")\n-@Import({\n-  TransactionalJobsConfiguration.class,\n-  LdapConfiguration.class,\n-  RestConfiguration.class,\n-  WebMvcConfig.class\n-})\n-public class ExampleRestApplication {\n-\n-  @Value(\"${taskana.schemaName:TASKANA}\")\n-  public String schemaName;\n-\n-  @Value(\"${generateSampleData:true}\")\n-  public boolean generateSampleData;\n-\n-  @Autowired private SampleDataGenerator sampleDataGenerator;\n-\n-  @Autowired private LdapClient ldapClient;\n-\n-  @Autowired private LdapCacheTestImpl ldapCacheTest;\n-\n-  public static void main(String[] args) {\n-    SpringApplication.run(ExampleRestApplication.class, args);\n-  }\n-\n-  @Bean\n-  public PlatformTransactionManager txManager(DataSource dataSource) {\n-    return new DataSourceTransactionManager(dataSource);\n-  }\n-\n-  @Bean\n-  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n-  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n-    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n-    return sampleDataGenerator;\n-  }\n-\n-  @PostConstruct\n-  private void init() {\n-    if (!ldapClient.useLdap()) {\n-      AccessIdController.setLdapCache(ldapCacheTest);\n-    }\n-    if (generateSampleData) {\n-      sampleDataGenerator.generateSampleData();\n-    }\n-  }\n-}\n+package pro.taskana.rest;\n+\n+import javax.annotation.PostConstruct;\n+import javax.sql.DataSource;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.context.annotation.DependsOn;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n+import org.springframework.scheduling.annotation.EnableScheduling;\n+import org.springframework.transaction.PlatformTransactionManager;\n+\n+import pro.taskana.jobs.TransactionalJobsConfiguration;\n+import pro.taskana.ldap.LdapCacheTestImpl;\n+import pro.taskana.ldap.LdapClient;\n+import pro.taskana.ldap.LdapConfiguration;\n+import pro.taskana.sampledata.SampleDataGenerator;\n+\n+/** Example Application showing the implementation of taskana-rest-spring. */\n+@SpringBootApplication\n+@EnableScheduling\n+@ComponentScan(basePackages = \"pro.taskana\")\n+@SuppressWarnings(\"checkstyle:Indentation\")\n+@Import({\n+  TransactionalJobsConfiguration.class,\n+  LdapConfiguration.class,\n+  RestConfiguration.class,\n+  WebMvcConfig.class\n+})\n+public class ExampleRestApplication {\n+\n+  @Value(\"${taskana.schemaName:TASKANA}\")\n+  public String schemaName;\n+\n+  @Value(\"${generateSampleData:true}\")\n+  public boolean generateSampleData;\n+\n+  @Autowired private SampleDataGenerator sampleDataGenerator;\n+\n+  @Autowired private LdapClient ldapClient;\n+\n+  @Autowired private LdapCacheTestImpl ldapCacheTest;\n+\n+  public static void main(String[] args) {\n+    SpringApplication.run(ExampleRestApplication.class, args);\n+  }\n+\n+  @Bean\n+  public PlatformTransactionManager txManager(DataSource dataSource) {\n+    return new DataSourceTransactionManager(dataSource);\n+  }\n+\n+  @Bean\n+  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n+  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n+    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n+    return sampleDataGenerator;\n+  }\n+\n+  @PostConstruct\n+  private void init() {\n+    if (!ldapClient.useLdap()) {\n+      AccessIdController.setLdapCache(ldapCacheTest);\n+    }\n+    if (generateSampleData) {\n+      sampleDataGenerator.generateSampleData();\n+    }\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjAwNA==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802004", "bodyText": "Please reformat", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:53:48Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/RestHelper.java", "diffHunk": "@@ -1,70 +1,80 @@\n-package pro.taskana;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/RestHelper.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/RestHelper.java\nindex db90ed60c..45011139e 100644\n--- a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/RestHelper.java\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/RestHelper.java\n\n@@ -1,80 +1,70 @@\n-package pro.taskana;\n-\n-import com.fasterxml.jackson.databind.DeserializationFeature;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.core.env.Environment;\n-import org.springframework.hateoas.hal.Jackson2HalModule;\n-import org.springframework.http.HttpEntity;\n-import org.springframework.http.HttpHeaders;\n-import org.springframework.http.MediaType;\n-import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\n-import org.springframework.stereotype.Component;\n-import org.springframework.web.client.RestTemplate;\n-import org.springframework.web.util.UriComponentsBuilder;\n-\n-/** Helps to simplify rest api testing. */\n-@Component\n-public class RestHelper {\n-\n-  public static final RestTemplate template = getRestTemplate();\n-  @Autowired Environment environment;\n-\n-  public String toUrl(String relativeUrl, Object... uriVariables) {\n-    return UriComponentsBuilder.fromPath(relativeUrl)\n-        .scheme(\"http\")\n-        .host(\"127.0.0.1\")\n-        .port(environment.getProperty(\"local.server.port\"))\n-        .build(false)\n-        .expand(uriVariables)\n-        .toString();\n-  }\n-\n-  public HttpEntity<String> defaultRequest() {\n-    return new HttpEntity<>(getHeaders());\n-  }\n-\n-  public HttpHeaders getHeaders() {\n-    HttpHeaders headers = new HttpHeaders();\n-    headers.add(\"Authorization\", \"Basic dGVhbWxlYWRfMTp0ZWFtbGVhZF8x\");\n-    headers.add(\"Content-Type\", \"application/json\");\n-    return headers;\n-  }\n-\n-  public HttpHeaders getHeadersAdmin() {\n-    HttpHeaders headers = new HttpHeaders();\n-    headers.add(\"Authorization\", \"Basic YWRtaW46YWRtaW4=\"); // admin:admin\n-    headers.add(\"Content-Type\", \"application/hal+json\");\n-    return headers;\n-  }\n-\n-  public HttpHeaders getHeadersBusinessAdmin() {\n-    HttpHeaders headers = new HttpHeaders();\n-    // businessadmin:businessadmin\n-    headers.add(\"Authorization\", \"Basic YnVzaW5lc3NhZG1pbjpidXNpbmVzc2FkbWlu\");\n-    headers.add(\"Content-Type\", \"application/hal+json\");\n-    return headers;\n-  }\n-\n-  /**\n-   * Return a REST template which is capable of dealing with responses in HAL format.\n-   *\n-   * @return RestTemplate\n-   */\n-  public static RestTemplate getRestTemplate() {\n-    ObjectMapper mapper = new ObjectMapper();\n-    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n-    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n-    mapper.registerModule(new Jackson2HalModule());\n-\n-    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n-    converter.setSupportedMediaTypes(MediaType.parseMediaTypes(\"application/hal+json\"));\n-    converter.setObjectMapper(mapper);\n-\n-    RestTemplate template = new RestTemplate();\n-    // important to add first to ensure priority\n-    template.getMessageConverters().add(0, converter);\n-    return template;\n-  }\n-}\n+package pro.taskana;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.env.Environment;\n+import org.springframework.hateoas.hal.Jackson2HalModule;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;\n+import org.springframework.stereotype.Component;\n+import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.util.UriComponentsBuilder;\n+\n+/** Helps to simplify rest api testing. */\n+@Component\n+public class RestHelper {\n+\n+  @Autowired Environment environment;\n+\n+  public String toUrl(String relativeUrl, Object... uriVariables) {\n+    return UriComponentsBuilder.fromPath(relativeUrl)\n+        .scheme(\"http\")\n+        .host(\"127.0.0.1\")\n+        .port(environment.getProperty(\"local.server.port\"))\n+        .build(uriVariables)\n+        .toString();\n+  }\n+\n+  public HttpEntity<String> defaultRequest() {\n+    return new HttpEntity<>(getHeaders());\n+  }\n+\n+  public HttpHeaders getHeaders() {\n+    HttpHeaders headers = new HttpHeaders();\n+    headers.add(\"Authorization\", \"Basic dGVhbWxlYWRfMTp0ZWFtbGVhZF8x\");\n+    headers.add(\"Content-Type\", \"application/json\");\n+    return headers;\n+  }\n+\n+  public HttpHeaders getHeadersAdmin() {\n+    HttpHeaders headers = new HttpHeaders();\n+    headers.add(\"Authorization\", \"Basic YWRtaW46YWRtaW4=\"); // admin:admin\n+    headers.add(\"Content-Type\", \"application/hal+json\");\n+    return headers;\n+  }\n+\n+  /**\n+   * Return a REST template which is capable of dealing with responses in HAL format.\n+   *\n+   * @return RestTemplate\n+   */\n+  public static RestTemplate getRestTemplate() {\n+    ObjectMapper mapper = new ObjectMapper();\n+    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n+    mapper.registerModule(new Jackson2HalModule());\n+\n+    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n+    converter.setSupportedMediaTypes(MediaType.parseMediaTypes(\"application/hal+json\"));\n+    converter.setObjectMapper(mapper);\n+\n+    RestTemplate template = new RestTemplate();\n+    // important to add first to ensure priority\n+    template.getMessageConverters().add(0, converter);\n+    return template;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjAyMw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802023", "bodyText": "Please reformat.", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:54:02Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/jobs/AsyncUpdateJobIntTest.java", "diffHunk": "@@ -1,168 +1,168 @@\n-package pro.taskana.jobs;\n-\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.context.SpringBootTest;\n-import org.springframework.core.ParameterizedTypeReference;\n-import org.springframework.hateoas.Link;\n-import org.springframework.http.HttpEntity;\n-import org.springframework.http.HttpMethod;\n-import org.springframework.http.ResponseEntity;\n-import org.springframework.test.context.ActiveProfiles;\n-import org.springframework.test.context.junit.jupiter.SpringExtension;\n-import org.springframework.web.client.RestTemplate;\n-\n-import pro.taskana.RestHelper;\n-import pro.taskana.classification.api.Classification;\n-import pro.taskana.common.api.exceptions.InvalidArgumentException;\n-import pro.taskana.rest.Mapping;\n-import pro.taskana.rest.RestConfiguration;\n-import pro.taskana.rest.resource.ClassificationResource;\n-import pro.taskana.rest.resource.ClassificationResourceAssembler;\n-import pro.taskana.rest.resource.TaskResource;\n-import pro.taskana.rest.resource.TaskResourceAssembler;\n-import pro.taskana.task.api.Task;\n-\n-/** Test async updates. */\n-@ActiveProfiles({\"test\"})\n-@ExtendWith(SpringExtension.class)\n-@SpringBootTest(\n-    classes = RestConfiguration.class,\n-    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n-class AsyncUpdateJobIntTest {\n-\n-  private static final String CLASSIFICATION_ID = \"CLI:100000000000000000000000000000000003\";\n-\n-  static RestTemplate template;\n-\n-  @Autowired ClassificationResourceAssembler classificationResourceAssembler;\n-  @Autowired TaskResourceAssembler taskResourceAssembler;\n-  @Autowired JobScheduler jobScheduler;\n-  @Autowired RestHelper restHelper;\n-\n-  @BeforeAll\n-  static void init() {\n-    template = RestHelper.getRestTemplate();\n-  }\n-\n-  @Test\n-  void testUpdateClassificationPrioServiceLevel() throws Exception {\n-\n-    // 1st step: get old classification :\n-    final Instant before = Instant.now();\n-    final ObjectMapper mapper = new ObjectMapper();\n-\n-    ResponseEntity<ClassificationResource> response =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-            HttpMethod.GET,\n-            new HttpEntity<String>(restHelper.getHeaders()),\n-            ParameterizedTypeReference.forType(ClassificationResource.class));\n-\n-    assertNotNull(response.getBody());\n-    ClassificationResource classification = response.getBody();\n-    assertNotNull(classification.getLink(Link.REL_SELF));\n-\n-    // 2nd step: modify classification and trigger update\n-    classification.removeLinks();\n-    classification.setServiceLevel(\"P5D\");\n-    classification.setPriority(1000);\n-\n-    template.put(\n-        restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-        new HttpEntity<>(mapper.writeValueAsString(classification), restHelper.getHeaders()));\n-\n-    // trigger jobs twice to refresh all entries. first entry on the first call and follow up on the\n-    // seconds call\n-    jobScheduler.triggerJobs();\n-    jobScheduler.triggerJobs();\n-\n-    // verify the classification modified timestamp is after 'before'\n-    ResponseEntity<ClassificationResource> repeatedResponse =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-            HttpMethod.GET,\n-            new HttpEntity<String>(restHelper.getHeaders()),\n-            ParameterizedTypeReference.forType(ClassificationResource.class));\n-\n-    assertNotNull(repeatedResponse.getBody());\n-\n-    ClassificationResource modifiedClassificationResource = repeatedResponse.getBody();\n-    Classification modifiedClassification =\n-        classificationResourceAssembler.toModel(modifiedClassificationResource);\n-\n-    assertFalse(before.isAfter(modifiedClassification.getModified()));\n-\n-    List<String> affectedTasks =\n-        new ArrayList<>(\n-            Arrays.asList(\n-                \"TKI:000000000000000000000000000000000003\",\n-                \"TKI:000000000000000000000000000000000004\",\n-                \"TKI:000000000000000000000000000000000005\",\n-                \"TKI:000000000000000000000000000000000006\",\n-                \"TKI:000000000000000000000000000000000007\",\n-                \"TKI:000000000000000000000000000000000008\",\n-                \"TKI:000000000000000000000000000000000009\",\n-                \"TKI:000000000000000000000000000000000010\",\n-                \"TKI:000000000000000000000000000000000011\",\n-                \"TKI:000000000000000000000000000000000012\",\n-                \"TKI:000000000000000000000000000000000013\",\n-                \"TKI:000000000000000000000000000000000014\",\n-                \"TKI:000000000000000000000000000000000015\",\n-                \"TKI:000000000000000000000000000000000016\",\n-                \"TKI:000000000000000000000000000000000017\",\n-                \"TKI:000000000000000000000000000000000018\",\n-                \"TKI:000000000000000000000000000000000019\",\n-                \"TKI:000000000000000000000000000000000020\",\n-                \"TKI:000000000000000000000000000000000021\",\n-                \"TKI:000000000000000000000000000000000022\",\n-                \"TKI:000000000000000000000000000000000023\",\n-                \"TKI:000000000000000000000000000000000024\",\n-                \"TKI:000000000000000000000000000000000025\",\n-                \"TKI:000000000000000000000000000000000026\",\n-                \"TKI:000000000000000000000000000000000027\",\n-                \"TKI:000000000000000000000000000000000028\",\n-                \"TKI:000000000000000000000000000000000029\",\n-                \"TKI:000000000000000000000000000000000030\",\n-                \"TKI:000000000000000000000000000000000031\",\n-                \"TKI:000000000000000000000000000000000032\",\n-                \"TKI:000000000000000000000000000000000033\",\n-                \"TKI:000000000000000000000000000000000034\",\n-                \"TKI:000000000000000000000000000000000035\",\n-                \"TKI:000000000000000000000000000000000100\",\n-                \"TKI:000000000000000000000000000000000101\",\n-                \"TKI:000000000000000000000000000000000102\",\n-                \"TKI:000000000000000000000000000000000103\"));\n-    for (String taskId : affectedTasks) {\n-      verifyTaskIsModifiedAfterOrEquals(taskId, before);\n-    }\n-  }\n-\n-  private void verifyTaskIsModifiedAfterOrEquals(String taskId, Instant before)\n-      throws InvalidArgumentException {\n-\n-    ResponseEntity<TaskResource> taskResponse =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_TASKS_ID, taskId),\n-            HttpMethod.GET,\n-            new HttpEntity<>(restHelper.getHeadersAdmin()),", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/jobs/AsyncUpdateJobIntTest.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/jobs/AsyncUpdateJobIntTest.java\nindex 086605d25..9b42e4b9d 100644\n--- a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/jobs/AsyncUpdateJobIntTest.java\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/jobs/AsyncUpdateJobIntTest.java\n\n@@ -1,168 +1,168 @@\n-package pro.taskana.jobs;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.context.SpringBootTest;\n-import org.springframework.core.ParameterizedTypeReference;\n-import org.springframework.hateoas.Link;\n-import org.springframework.http.HttpEntity;\n-import org.springframework.http.HttpMethod;\n-import org.springframework.http.ResponseEntity;\n-import org.springframework.test.context.ActiveProfiles;\n-import org.springframework.test.context.junit.jupiter.SpringExtension;\n-import org.springframework.web.client.RestTemplate;\n-\n-import pro.taskana.RestHelper;\n-import pro.taskana.classification.api.Classification;\n-import pro.taskana.common.api.exceptions.InvalidArgumentException;\n-import pro.taskana.rest.Mapping;\n-import pro.taskana.rest.RestConfiguration;\n-import pro.taskana.rest.resource.ClassificationResource;\n-import pro.taskana.rest.resource.ClassificationResourceAssembler;\n-import pro.taskana.rest.resource.TaskResource;\n-import pro.taskana.rest.resource.TaskResourceAssembler;\n-import pro.taskana.task.api.Task;\n-\n-/** Test async updates. */\n-@ActiveProfiles({\"test\"})\n-@ExtendWith(SpringExtension.class)\n-@SpringBootTest(\n-    classes = RestConfiguration.class,\n-    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\n-    properties = \"spring.main.allow-bean-definition-overriding=true\")\n-class AsyncUpdateJobIntTest {\n-\n-  private static final String CLASSIFICATION_ID = \"CLI:100000000000000000000000000000000003\";\n-\n-  @SuppressWarnings(\"checkstyle:DeclarationOrder\")\n-  static RestTemplate template;\n-\n-  @Autowired ClassificationResourceAssembler classificationResourceAssembler;\n-  @Autowired TaskResourceAssembler taskResourceAssembler;\n-  @Autowired JobScheduler jobScheduler;\n-  @Autowired RestHelper restHelper;\n-\n-  @BeforeAll\n-  static void init() {\n-    template = RestHelper.getRestTemplate();\n-  }\n-\n-  @Test\n-  void testUpdateClassificationPrioServiceLevel() throws Exception {\n-\n-    // 1st step: get old classification :\n-    final Instant before = Instant.now();\n-    final ObjectMapper mapper = new ObjectMapper();\n-\n-    ResponseEntity<ClassificationResource> response =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-            HttpMethod.GET,\n-            new HttpEntity<String>(restHelper.getHeaders()),\n-            ParameterizedTypeReference.forType(ClassificationResource.class));\n-\n-    assertThat(response.getBody()).isNotNull();\n-    ClassificationResource classification = response.getBody();\n-    assertThat(classification.getLink(Link.REL_SELF)).isNotNull();\n-\n-    // 2nd step: modify classification and trigger update\n-    classification.removeLinks();\n-    classification.setServiceLevel(\"P5D\");\n-    classification.setPriority(1000);\n-\n-    template.put(\n-        restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-        new HttpEntity<>(mapper.writeValueAsString(classification), restHelper.getHeaders()));\n-\n-    // trigger jobs twice to refresh all entries. first entry on the first call and follow up on the\n-    // seconds call\n-    jobScheduler.triggerJobs();\n-    jobScheduler.triggerJobs();\n-\n-    // verify the classification modified timestamp is after 'before'\n-    ResponseEntity<ClassificationResource> repeatedResponse =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n-            HttpMethod.GET,\n-            new HttpEntity<String>(restHelper.getHeaders()),\n-            ParameterizedTypeReference.forType(ClassificationResource.class));\n-\n-    assertThat(repeatedResponse.getBody()).isNotNull();\n-\n-    ClassificationResource modifiedClassificationResource = repeatedResponse.getBody();\n-    Classification modifiedClassification =\n-        classificationResourceAssembler.toModel(modifiedClassificationResource);\n-\n-    assertThat(before).isBefore(modifiedClassification.getModified());\n-\n-    List<String> affectedTasks =\n-        new ArrayList<>(\n-            Arrays.asList(\n-                \"TKI:000000000000000000000000000000000003\",\n-                \"TKI:000000000000000000000000000000000004\",\n-                \"TKI:000000000000000000000000000000000005\",\n-                \"TKI:000000000000000000000000000000000006\",\n-                \"TKI:000000000000000000000000000000000007\",\n-                \"TKI:000000000000000000000000000000000008\",\n-                \"TKI:000000000000000000000000000000000009\",\n-                \"TKI:000000000000000000000000000000000010\",\n-                \"TKI:000000000000000000000000000000000011\",\n-                \"TKI:000000000000000000000000000000000012\",\n-                \"TKI:000000000000000000000000000000000013\",\n-                \"TKI:000000000000000000000000000000000014\",\n-                \"TKI:000000000000000000000000000000000015\",\n-                \"TKI:000000000000000000000000000000000016\",\n-                \"TKI:000000000000000000000000000000000017\",\n-                \"TKI:000000000000000000000000000000000018\",\n-                \"TKI:000000000000000000000000000000000019\",\n-                \"TKI:000000000000000000000000000000000020\",\n-                \"TKI:000000000000000000000000000000000021\",\n-                \"TKI:000000000000000000000000000000000022\",\n-                \"TKI:000000000000000000000000000000000023\",\n-                \"TKI:000000000000000000000000000000000024\",\n-                \"TKI:000000000000000000000000000000000025\",\n-                \"TKI:000000000000000000000000000000000026\",\n-                \"TKI:000000000000000000000000000000000027\",\n-                \"TKI:000000000000000000000000000000000028\",\n-                \"TKI:000000000000000000000000000000000029\",\n-                \"TKI:000000000000000000000000000000000030\",\n-                \"TKI:000000000000000000000000000000000031\",\n-                \"TKI:000000000000000000000000000000000032\",\n-                \"TKI:000000000000000000000000000000000033\",\n-                \"TKI:000000000000000000000000000000000034\",\n-                \"TKI:000000000000000000000000000000000035\",\n-                \"TKI:000000000000000000000000000000000100\",\n-                \"TKI:000000000000000000000000000000000101\",\n-                \"TKI:000000000000000000000000000000000102\",\n-                \"TKI:000000000000000000000000000000000103\"));\n-    for (String taskId : affectedTasks) {\n-      verifyTaskIsModifiedAfterOrEquals(taskId, before);\n-    }\n-  }\n-\n-  private void verifyTaskIsModifiedAfterOrEquals(String taskId, Instant before)\n-      throws InvalidArgumentException {\n-\n-    ResponseEntity<TaskResource> taskResponse =\n-        template.exchange(\n-            restHelper.toUrl(Mapping.URL_TASKS_ID, taskId),\n-            HttpMethod.GET,\n-            new HttpEntity<>(restHelper.getHeadersAdmin()),\n-            ParameterizedTypeReference.forType(TaskResource.class));\n-\n-    TaskResource taskResource = taskResponse.getBody();\n-    Task task = taskResourceAssembler.toModel(taskResource);\n-\n-    Instant modified = task.getModified();\n-    assertThat(before).as(\"Task \" + task.getId() + \" has not been refreshed.\").isBefore(modified);\n-  }\n-}\n+package pro.taskana.jobs;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.hateoas.Link;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.web.client.RestTemplate;\n+\n+import pro.taskana.RestHelper;\n+import pro.taskana.classification.api.Classification;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.rest.Mapping;\n+import pro.taskana.rest.RestConfiguration;\n+import pro.taskana.rest.resource.ClassificationResource;\n+import pro.taskana.rest.resource.ClassificationResourceAssembler;\n+import pro.taskana.rest.resource.TaskResource;\n+import pro.taskana.rest.resource.TaskResourceAssembler;\n+import pro.taskana.task.api.Task;\n+\n+/** Test async updates. */\n+@ActiveProfiles({\"test\"})\n+@ExtendWith(SpringExtension.class)\n+@SpringBootTest(\n+    classes = RestConfiguration.class,\n+    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+class AsyncUpdateJobIntTest {\n+\n+  private static final String CLASSIFICATION_ID = \"CLI:100000000000000000000000000000000003\";\n+\n+  static RestTemplate template;\n+\n+  @Autowired ClassificationResourceAssembler classificationResourceAssembler;\n+  @Autowired TaskResourceAssembler taskResourceAssembler;\n+  @Autowired JobScheduler jobScheduler;\n+  @Autowired RestHelper restHelper;\n+\n+  @BeforeAll\n+  static void init() {\n+    template = RestHelper.getRestTemplate();\n+  }\n+\n+  @Test\n+  void testUpdateClassificationPrioServiceLevel() throws Exception {\n+\n+    // 1st step: get old classification :\n+    final Instant before = Instant.now();\n+    final ObjectMapper mapper = new ObjectMapper();\n+\n+    ResponseEntity<ClassificationResource> response =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n+            HttpMethod.GET,\n+            new HttpEntity<String>(restHelper.getHeaders()),\n+            ParameterizedTypeReference.forType(ClassificationResource.class));\n+\n+    assertNotNull(response.getBody());\n+    ClassificationResource classification = response.getBody();\n+    assertNotNull(classification.getLink(Link.REL_SELF));\n+\n+    // 2nd step: modify classification and trigger update\n+    classification.removeLinks();\n+    classification.setServiceLevel(\"P5D\");\n+    classification.setPriority(1000);\n+\n+    template.put(\n+        restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n+        new HttpEntity<>(mapper.writeValueAsString(classification), restHelper.getHeaders()));\n+\n+    // trigger jobs twice to refresh all entries. first entry on the first call and follow up on the\n+    // seconds call\n+    jobScheduler.triggerJobs();\n+    jobScheduler.triggerJobs();\n+\n+    // verify the classification modified timestamp is after 'before'\n+    ResponseEntity<ClassificationResource> repeatedResponse =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS_ID, CLASSIFICATION_ID),\n+            HttpMethod.GET,\n+            new HttpEntity<String>(restHelper.getHeaders()),\n+            ParameterizedTypeReference.forType(ClassificationResource.class));\n+\n+    assertNotNull(repeatedResponse.getBody());\n+\n+    ClassificationResource modifiedClassificationResource = repeatedResponse.getBody();\n+    Classification modifiedClassification =\n+        classificationResourceAssembler.toModel(modifiedClassificationResource);\n+\n+    assertFalse(before.isAfter(modifiedClassification.getModified()));\n+\n+    List<String> affectedTasks =\n+        new ArrayList<>(\n+            Arrays.asList(\n+                \"TKI:000000000000000000000000000000000003\",\n+                \"TKI:000000000000000000000000000000000004\",\n+                \"TKI:000000000000000000000000000000000005\",\n+                \"TKI:000000000000000000000000000000000006\",\n+                \"TKI:000000000000000000000000000000000007\",\n+                \"TKI:000000000000000000000000000000000008\",\n+                \"TKI:000000000000000000000000000000000009\",\n+                \"TKI:000000000000000000000000000000000010\",\n+                \"TKI:000000000000000000000000000000000011\",\n+                \"TKI:000000000000000000000000000000000012\",\n+                \"TKI:000000000000000000000000000000000013\",\n+                \"TKI:000000000000000000000000000000000014\",\n+                \"TKI:000000000000000000000000000000000015\",\n+                \"TKI:000000000000000000000000000000000016\",\n+                \"TKI:000000000000000000000000000000000017\",\n+                \"TKI:000000000000000000000000000000000018\",\n+                \"TKI:000000000000000000000000000000000019\",\n+                \"TKI:000000000000000000000000000000000020\",\n+                \"TKI:000000000000000000000000000000000021\",\n+                \"TKI:000000000000000000000000000000000022\",\n+                \"TKI:000000000000000000000000000000000023\",\n+                \"TKI:000000000000000000000000000000000024\",\n+                \"TKI:000000000000000000000000000000000025\",\n+                \"TKI:000000000000000000000000000000000026\",\n+                \"TKI:000000000000000000000000000000000027\",\n+                \"TKI:000000000000000000000000000000000028\",\n+                \"TKI:000000000000000000000000000000000029\",\n+                \"TKI:000000000000000000000000000000000030\",\n+                \"TKI:000000000000000000000000000000000031\",\n+                \"TKI:000000000000000000000000000000000032\",\n+                \"TKI:000000000000000000000000000000000033\",\n+                \"TKI:000000000000000000000000000000000034\",\n+                \"TKI:000000000000000000000000000000000035\",\n+                \"TKI:000000000000000000000000000000000100\",\n+                \"TKI:000000000000000000000000000000000101\",\n+                \"TKI:000000000000000000000000000000000102\",\n+                \"TKI:000000000000000000000000000000000103\"));\n+    for (String taskId : affectedTasks) {\n+      verifyTaskIsModifiedAfterOrEquals(taskId, before);\n+    }\n+  }\n+\n+  private void verifyTaskIsModifiedAfterOrEquals(String taskId, Instant before)\n+      throws InvalidArgumentException {\n+\n+    ResponseEntity<TaskResource> taskResponse =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_TASKS_ID, taskId),\n+            HttpMethod.GET,\n+            new HttpEntity<>(restHelper.getHeadersAdmin()),\n+            ParameterizedTypeReference.forType(TaskResource.class));\n+\n+    TaskResource taskResource = taskResponse.getBody();\n+    Task task = taskResourceAssembler.toModel(taskResource);\n+\n+    Instant modified = task.getModified();\n+    boolean isAfterOrEquals = before.isAfter(modified) || before.equals(modified);\n+    assertFalse(\"Task \" + task.getId() + \" has not been refreshed.\", isAfterOrEquals);\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjAzMg==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802032", "bodyText": "Please reformat", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:54:11Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java", "diffHunk": "@@ -1,36 +1,37 @@\n-package pro.taskana.ldap;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\nindex 721defeb1..721ca2056 100644\n--- a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\n\n@@ -1,37 +1,36 @@\n-package pro.taskana.ldap;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.util.List;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.context.SpringBootTest;\n-import org.springframework.test.context.ActiveProfiles;\n-import org.springframework.test.context.junit.jupiter.SpringExtension;\n-\n-import pro.taskana.common.api.LoggerUtils;\n-import pro.taskana.common.api.exceptions.InvalidArgumentException;\n-import pro.taskana.rest.RestConfiguration;\n-import pro.taskana.rest.resource.AccessIdResource;\n-\n-/** Test Ldap attachment. */\n-@ActiveProfiles({\"test\"})\n-@ExtendWith(SpringExtension.class)\n-@SpringBootTest(\n-    classes = RestConfiguration.class,\n-    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\n-    properties = \"spring.main.allow-bean-definition-overriding=true\")\n-class LdapTest {\n-\n-  @Autowired private LdapClient ldapClient;\n-\n-  @Test\n-  void testFindUsers() throws InvalidArgumentException {\n-    if (ldapClient.useLdap()) {\n-      List<AccessIdResource> usersAndGroups = ldapClient.searchUsersAndGroups(\"ser0\");\n-      System.out.println(\"#### found \" + LoggerUtils.listToString(usersAndGroups));\n-      assertThat(usersAndGroups.size()).isEqualTo(50);\n-    }\n-  }\n+package pro.taskana.ldap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+\n+import pro.taskana.common.api.LoggerUtils;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.rest.RestConfiguration;\n+import pro.taskana.rest.resource.AccessIdResource;\n+\n+/** Test Ldap attachment. */\n+@ActiveProfiles({\"test\"})\n+@ExtendWith(SpringExtension.class)\n+@SpringBootTest(\n+    classes = RestConfiguration.class,\n+    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+class LdapTest {\n+\n+  @Autowired private LdapClient ldapClient;\n+\n+  @Test\n+  void testFindUsers() throws InvalidArgumentException {\n+    if (ldapClient.useLdap()) {\n+      List<AccessIdResource> usersAndGroups = ldapClient.searchUsersAndGroups(\"ser0\");\n+      System.out.println(\"#### found \" + LoggerUtils.listToString(usersAndGroups));\n+      assertEquals(50, usersAndGroups.size());\n+    }\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjA0OQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802049", "bodyText": "Where did these tests go?", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:54:33Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/AccessIdValidationControllerIntTest.java", "diffHunk": "@@ -1,86 +0,0 @@\n-package pro.taskana.rest;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/AccessIdValidationControllerIntTest.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/AccessIdValidationControllerIntTest.java\nnew file mode 100644\nindex 000000000..abffcac8a\n--- /dev/null\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/AccessIdValidationControllerIntTest.java\n\n@@ -0,0 +1,86 @@\n+package pro.taskana.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.test.context.ActiveProfiles;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.web.client.HttpClientErrorException;\n+import org.springframework.web.client.RestTemplate;\n+\n+import pro.taskana.RestHelper;\n+import pro.taskana.ldap.LdapCacheTestImpl;\n+import pro.taskana.rest.resource.AccessIdResource;\n+\n+/** Test AccessIdValidation. */\n+@ActiveProfiles({\"test\"})\n+@ExtendWith(SpringExtension.class)\n+@SpringBootTest(\n+    classes = RestConfiguration.class,\n+    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n+class AccessIdValidationControllerIntTest {\n+\n+  static RestTemplate template;\n+  @Autowired RestHelper restHelper;\n+\n+  @BeforeAll\n+  static void init() {\n+    template = RestHelper.getRestTemplate();\n+  }\n+\n+  @Test\n+  void testGetMatches() {\n+    AccessIdController.setLdapCache(new LdapCacheTestImpl());\n+    HttpEntity<String> request = new HttpEntity<String>(restHelper.getHeaders());\n+    ResponseEntity<List<AccessIdResource>> response =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_ACCESSID) + \"?search-for=ali\",\n+            HttpMethod.GET,\n+            request,\n+            ParameterizedTypeReference.forType(AccessIdListResource.class));\n+\n+    List<AccessIdResource> body = response.getBody();\n+    assertNotNull(body);\n+    assertEquals(3, body.size());\n+    List<String> expectedIds =\n+        new ArrayList<>(Arrays.asList(\"Tralisch, Thea\", \"Bert, Ali\", \"Mente, Ali\"));\n+    for (AccessIdResource accessId : body) {\n+      assertTrue(expectedIds.contains(accessId.getName()));\n+    }\n+  }\n+\n+  @Test\n+  void testBadRequestWhenSearchForIsTooShort() {\n+    AccessIdController.setLdapCache(new LdapCacheTestImpl());\n+    HttpEntity<String> request = new HttpEntity<String>(restHelper.getHeaders());\n+    try {\n+      template.exchange(\n+          restHelper.toUrl(Mapping.URL_ACCESSID) + \"?search-for=al\",\n+          HttpMethod.GET,\n+          request,\n+          ParameterizedTypeReference.forType(List.class));\n+    } catch (HttpClientErrorException e) {\n+      assertEquals(HttpStatus.BAD_REQUEST, e.getStatusCode());\n+      assertTrue(e.getResponseBodyAsString().contains(\"Minimum searchFor length =\"));\n+    }\n+  }\n+\n+  static class AccessIdListResource extends ArrayList<AccessIdResource> {\n+\n+    private static final long serialVersionUID = 1L;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjA1Nw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802057", "bodyText": "Please reformat.", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:54:43Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/ExampleRestApplication.java", "diffHunk": "@@ -1,74 +1,73 @@\n-package pro.taskana.rest;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/ExampleRestApplication.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/ExampleRestApplication.java\nindex 4846b27cd..60d402666 100644\n--- a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/ExampleRestApplication.java\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/rest/ExampleRestApplication.java\n\n@@ -1,73 +1,73 @@\n-package pro.taskana.rest;\n-\n-import javax.annotation.PostConstruct;\n-import javax.sql.DataSource;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.boot.SpringApplication;\n-import org.springframework.boot.autoconfigure.SpringBootApplication;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.ComponentScan;\n-import org.springframework.context.annotation.DependsOn;\n-import org.springframework.context.annotation.Import;\n-import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n-import org.springframework.scheduling.annotation.EnableScheduling;\n-import org.springframework.transaction.PlatformTransactionManager;\n-\n-import pro.taskana.jobs.TransactionalJobsConfiguration;\n-import pro.taskana.ldap.LdapCacheTestImpl;\n-import pro.taskana.ldap.LdapClient;\n-import pro.taskana.ldap.LdapConfiguration;\n-import pro.taskana.sampledata.SampleDataGenerator;\n-\n-/** Example Application showing the implementation of taskana-rest-spring. */\n-@SpringBootApplication\n-@EnableScheduling\n-@ComponentScan(basePackages = \"pro.taskana\")\n-@SuppressWarnings(\"checkstyle:Indentation\")\n-@Import({\n-  TransactionalJobsConfiguration.class,\n-  LdapConfiguration.class,\n-  RestConfiguration.class,\n-  WebMvcConfig.class\n-})\n-public class ExampleRestApplication {\n-\n-  @Value(\"${taskana.schemaName:TASKANA}\")\n-  public String schemaName;\n-\n-  @Value(\"${generateSampleData:true}\")\n-  public boolean generateSampleData;\n-\n-  @Autowired private SampleDataGenerator sampleDataGenerator;\n-\n-  @Autowired private LdapClient ldapClient;\n-\n-  @Autowired private LdapCacheTestImpl ldapCacheTest;\n-\n-  public static void main(String[] args) {\n-    SpringApplication.run(ExampleRestApplication.class, args);\n-  }\n-\n-  @Bean\n-  public PlatformTransactionManager txManager(DataSource dataSource) {\n-    return new DataSourceTransactionManager(dataSource);\n-  }\n-\n-  @Bean\n-  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n-  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n-    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n-    return sampleDataGenerator;\n-  }\n-\n-  @PostConstruct\n-  private void init() {\n-    if (!ldapClient.useLdap()) {\n-      AccessIdController.setLdapCache(ldapCacheTest);\n-    }\n-    if (generateSampleData) {\n-      sampleDataGenerator.generateSampleData();\n-    }\n-  }\n-}\n+package pro.taskana.rest;\n+\n+import javax.annotation.PostConstruct;\n+import javax.sql.DataSource;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.context.annotation.DependsOn;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n+import org.springframework.scheduling.annotation.EnableScheduling;\n+import org.springframework.transaction.PlatformTransactionManager;\n+\n+import pro.taskana.jobs.TransactionalJobsConfiguration;\n+import pro.taskana.ldap.LdapCacheTestImpl;\n+import pro.taskana.ldap.LdapClient;\n+import pro.taskana.ldap.LdapConfiguration;\n+import pro.taskana.sampledata.SampleDataGenerator;\n+\n+/** Example Application showing the implementation of taskana-rest-spring. */\n+@SpringBootApplication\n+@EnableScheduling\n+@ComponentScan(basePackages = \"pro.taskana\")\n+@SuppressWarnings(\"checkstyle:Indentation\")\n+@Import({\n+  TransactionalJobsConfiguration.class,\n+  LdapConfiguration.class,\n+  RestConfiguration.class,\n+  WebMvcConfig.class\n+})\n+public class ExampleRestApplication {\n+\n+  @Value(\"${taskana.schemaName:TASKANA}\")\n+  public String schemaName;\n+\n+  @Value(\"${generateSampleData:true}\")\n+  public boolean generateSampleData;\n+\n+  @Autowired private SampleDataGenerator sampleDataGenerator;\n+\n+  @Autowired private LdapClient ldapClient;\n+\n+  @Autowired private LdapCacheTestImpl ldapCacheTest;\n+\n+  public static void main(String[] args) {\n+    SpringApplication.run(ExampleRestApplication.class, args);\n+  }\n+\n+  @Bean\n+  public PlatformTransactionManager txManager(DataSource dataSource) {\n+    return new DataSourceTransactionManager(dataSource);\n+  }\n+\n+  @Bean\n+  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n+  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n+    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n+    return sampleDataGenerator;\n+  }\n+\n+  @PostConstruct\n+  private void init() {\n+    if (!ldapClient.useLdap()) {\n+      AccessIdController.setLdapCache(ldapCacheTest);\n+    }\n+    if (generateSampleData) {\n+      sampleDataGenerator.generateSampleData();\n+    }\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjA3Mw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802073", "bodyText": "Please reformat", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:55:01Z", "path": "rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/TaskanaWildFlyApplication.java", "diffHunk": "@@ -1,122 +1,121 @@\n-package pro.taskana;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/TaskanaWildFlyApplication.java b/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/TaskanaWildFlyApplication.java\nindex 63a2cf7d9..dc1bc6a2f 100644\n--- a/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/TaskanaWildFlyApplication.java\n+++ b/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/TaskanaWildFlyApplication.java\n\n@@ -1,121 +1,121 @@\n-package pro.taskana;\n-\n-import java.io.InputStream;\n-import java.util.Properties;\n-import javax.annotation.PostConstruct;\n-import javax.naming.Context;\n-import javax.naming.InitialContext;\n-import javax.sql.DataSource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.boot.SpringApplication;\n-import org.springframework.boot.autoconfigure.SpringBootApplication;\n-import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\n-import org.springframework.boot.context.properties.ConfigurationProperties;\n-import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.DependsOn;\n-import org.springframework.context.annotation.Import;\n-import org.springframework.context.annotation.Primary;\n-import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n-import org.springframework.scheduling.annotation.EnableScheduling;\n-import org.springframework.transaction.PlatformTransactionManager;\n-\n-import pro.taskana.jobs.TransactionalJobsConfiguration;\n-import pro.taskana.ldap.LdapCacheTestImpl;\n-import pro.taskana.ldap.LdapClient;\n-import pro.taskana.ldap.LdapConfiguration;\n-import pro.taskana.rest.AccessIdController;\n-import pro.taskana.rest.RestConfiguration;\n-import pro.taskana.rest.WebMvcConfig;\n-import pro.taskana.sampledata.SampleDataGenerator;\n-\n-/**\n- * Example Application showing the implementation of taskana-rest-spring for jboss application\n- * server.\n- */\n-@SpringBootApplication\n-@EnableScheduling\n-@SuppressWarnings(\"checkstyle:Indentation\")\n-@Import({\n-  TransactionalJobsConfiguration.class,\n-  LdapConfiguration.class,\n-  RestConfiguration.class,\n-  WebMvcConfig.class\n-})\n-public class TaskanaWildFlyApplication extends SpringBootServletInitializer {\n-\n-  private static final Logger LOGGER = LoggerFactory.getLogger(TaskanaWildFlyApplication.class);\n-\n-  @Value(\"${taskana.schemaName:TASKANA}\")\n-  public String schemaName;\n-\n-  @Value(\"${generateSampleData:true}\")\n-  public boolean generateSampleData;\n-\n-  @Autowired private SampleDataGenerator sampleDataGenerator;\n-\n-  @Autowired private LdapClient ldapClient;\n-\n-  @Autowired private LdapCacheTestImpl ldapCacheTest;\n-\n-  public static void main(String[] args) {\n-    SpringApplication.run(TaskanaWildFlyApplication.class, args);\n-  }\n-\n-  @Bean\n-  @Primary\n-  @ConfigurationProperties(prefix = \"datasource\")\n-  public DataSourceProperties dataSourceProperties() {\n-    DataSourceProperties props = new DataSourceProperties();\n-    props.setUrl(\n-        \"jdbc:h2:mem:taskana;IGNORECASE=TRUE;LOCK_MODE=0;INIT=CREATE SCHEMA IF NOT EXISTS \"\n-            + schemaName);\n-    return props;\n-  }\n-\n-  @Bean\n-  public DataSource dataSource(DataSourceProperties dsProperties) {\n-    // First try to load Properties and get Datasource via jndi lookup\n-    Context ctx;\n-    DataSource dataSource;\n-    ClassLoader classloader = Thread.currentThread().getContextClassLoader();\n-    try (InputStream propertyStream = classloader.getResourceAsStream(\"application.properties\")) {\n-      Properties properties = new Properties();\n-      ctx = new InitialContext();\n-      properties.load(propertyStream);\n-      dataSource = (DataSource) ctx.lookup(properties.getProperty(\"datasource.jndi\"));\n-      return dataSource;\n-    } catch (Exception e) {\n-      LOGGER.error(\n-          \"Caught exception {} when attempting to start Taskana with Datasource \"\n-              + \"from Jndi. Using default H2 datasource. \",\n-          e);\n-      return dsProperties.initializeDataSourceBuilder().build();\n-    }\n-  }\n-\n-  @Bean\n-  public PlatformTransactionManager txManager(DataSource dataSource) {\n-    return new DataSourceTransactionManager(dataSource);\n-  }\n-\n-  @Bean\n-  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n-  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n-    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n-    return sampleDataGenerator;\n-  }\n-\n-  @PostConstruct\n-  private void init() {\n-    if (!ldapClient.useLdap()) {\n-      AccessIdController.setLdapCache(ldapCacheTest);\n-    }\n-    if (generateSampleData) {\n-      sampleDataGenerator.generateSampleData();\n-    }\n-  }\n-}\n+package pro.taskana;\n+\n+import java.io.InputStream;\n+import java.util.Properties;\n+import javax.annotation.PostConstruct;\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.sql.DataSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.autoconfigure.SpringBootApplication;\n+import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.DependsOn;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Primary;\n+import org.springframework.jdbc.datasource.DataSourceTransactionManager;\n+import org.springframework.scheduling.annotation.EnableScheduling;\n+import org.springframework.transaction.PlatformTransactionManager;\n+\n+import pro.taskana.jobs.TransactionalJobsConfiguration;\n+import pro.taskana.ldap.LdapCacheTestImpl;\n+import pro.taskana.ldap.LdapClient;\n+import pro.taskana.ldap.LdapConfiguration;\n+import pro.taskana.rest.AccessIdController;\n+import pro.taskana.rest.RestConfiguration;\n+import pro.taskana.rest.WebMvcConfig;\n+import pro.taskana.sampledata.SampleDataGenerator;\n+\n+/**\n+ * Example Application showing the implementation of taskana-rest-spring for jboss application\n+ * server.\n+ */\n+@SpringBootApplication\n+@EnableScheduling\n+@SuppressWarnings(\"checkstyle:Indentation\")\n+@Import({\n+  TransactionalJobsConfiguration.class,\n+  LdapConfiguration.class,\n+  RestConfiguration.class,\n+  WebMvcConfig.class\n+})\n+public class TaskanaWildFlyApplication extends SpringBootServletInitializer {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TaskanaWildFlyApplication.class);\n+\n+  @Value(\"${taskana.schemaName:TASKANA}\")\n+  public String schemaName;\n+\n+  @Value(\"${generateSampleData:true}\")\n+  public boolean generateSampleData;\n+\n+  @Autowired private SampleDataGenerator sampleDataGenerator;\n+\n+  @Autowired private LdapClient ldapClient;\n+\n+  @Autowired private LdapCacheTestImpl ldapCacheTest;\n+\n+  public static void main(String[] args) {\n+    SpringApplication.run(TaskanaWildFlyApplication.class, args);\n+  }\n+\n+  @Bean\n+  @Primary\n+  @ConfigurationProperties(prefix = \"datasource\")\n+  public DataSourceProperties dataSourceProperties() {\n+    DataSourceProperties props = new DataSourceProperties();\n+    props.setUrl(\n+        \"jdbc:h2:mem:taskana;IGNORECASE=TRUE;LOCK_MODE=0;INIT=CREATE SCHEMA IF NOT EXISTS \"\n+            + schemaName);\n+    return props;\n+  }\n+\n+  @Bean\n+  public DataSource dataSource(DataSourceProperties dsProperties) {\n+    // First try to load Properties and get Datasource via jndi lookup\n+    Context ctx;\n+    DataSource dataSource;\n+    ClassLoader classloader = Thread.currentThread().getContextClassLoader();\n+    try (InputStream propertyStream = classloader.getResourceAsStream(\"application.properties\")) {\n+      Properties properties = new Properties();\n+      ctx = new InitialContext();\n+      properties.load(propertyStream);\n+      dataSource = (DataSource) ctx.lookup(properties.getProperty(\"datasource.jndi\"));\n+      return dataSource;\n+    } catch (Exception e) {\n+      LOGGER.error(\n+          \"Caught exception {} when attempting to start Taskana with Datasource \"\n+              + \"from Jndi. Using default H2 datasource. \",\n+          e);\n+      return dsProperties.initializeDataSourceBuilder().build();\n+    }\n+  }\n+\n+  @Bean\n+  public PlatformTransactionManager txManager(DataSource dataSource) {\n+    return new DataSourceTransactionManager(dataSource);\n+  }\n+\n+  @Bean\n+  @DependsOn(\"getTaskanaEngine\") // generate sample data after schema was inserted\n+  public SampleDataGenerator generateSampleData(DataSource dataSource) {\n+    sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n+    return sampleDataGenerator;\n+  }\n+\n+  @PostConstruct\n+  private void init() {\n+    if (!ldapClient.useLdap()) {\n+      AccessIdController.setLdapCache(ldapCacheTest);\n+    }\n+    if (generateSampleData) {\n+      sampleDataGenerator.generateSampleData();\n+    }\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjA4OQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802089", "bodyText": "Please reformat", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:55:10Z", "path": "rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/wildfly/security/WildflyWebSecurityConfig.java", "diffHunk": "@@ -1,203 +1,203 @@\n-package pro.taskana.wildfly.security;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/wildfly/security/WildflyWebSecurityConfig.java b/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/wildfly/security/WildflyWebSecurityConfig.java\nindex 5036070fb..b9f60d799 100644\n--- a/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/wildfly/security/WildflyWebSecurityConfig.java\n+++ b/rest/taskana-rest-spring-example-wildfly/src/main/java/pro/taskana/wildfly/security/WildflyWebSecurityConfig.java\n\n@@ -1,203 +1,203 @@\n-package pro.taskana.wildfly.security;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Configuration;\n-import org.springframework.core.annotation.Order;\n-import org.springframework.http.HttpMethod;\n-import org.springframework.security.authentication.AuthenticationManager;\n-import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n-import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n-import org.springframework.security.core.Authentication;\n-import org.springframework.security.core.AuthenticationException;\n-import org.springframework.security.core.GrantedAuthority;\n-import org.springframework.security.core.authority.SimpleGrantedAuthority;\n-import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;\n-import org.springframework.security.core.userdetails.UserDetails;\n-import org.springframework.security.core.userdetails.UsernameNotFoundException;\n-import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider;\n-import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;\n-import org.springframework.security.web.authentication.preauth.j2ee.J2eePreAuthenticatedProcessingFilter;\n-import org.springframework.security.web.jaasapi.JaasApiIntegrationFilter;\n-import org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n-import org.wildfly.security.auth.server.SecurityDomain;\n-import org.wildfly.security.auth.server.SecurityIdentity;\n-import org.wildfly.security.authz.Roles;\n-\n-import pro.taskana.rest.security.WebSecurityConfig;\n-\n-/**\n- * Default basic configuration for taskana web example running on Wildfly / JBoss with Elytron or\n- * JAAS Security.\n- */\n-@Configuration\n-@EnableWebSecurity\n-@Order(1)\n-public class WildflyWebSecurityConfig extends WebSecurityConfig {\n-\n-  @Value(\"${devMode:false}\")\n-  private boolean devMode;\n-\n-  @Bean\n-  public J2eePreAuthenticatedProcessingFilter preAuthFilter() {\n-    J2eePreAuthenticatedProcessingFilter filter = new J2eePreAuthenticatedProcessingFilter();\n-    filter.setAuthenticationManager(preAuthManager());\n-    return filter;\n-  }\n-\n-  @Bean\n-  public AuthenticationManager preAuthManager() {\n-    return new AuthenticationManager() {\n-\n-      @Override\n-      public Authentication authenticate(Authentication authentication)\n-          throws AuthenticationException {\n-        return preauthAuthProvider().authenticate(authentication);\n-      }\n-    };\n-  }\n-\n-  @Bean\n-  public PreAuthenticatedAuthenticationProvider preauthAuthProvider() {\n-    PreAuthenticatedAuthenticationProvider preauthAuthProvider =\n-        new PreAuthenticatedAuthenticationProvider();\n-    preauthAuthProvider.setPreAuthenticatedUserDetailsService(authenticationUserDetailsService());\n-    return preauthAuthProvider;\n-  }\n-\n-  @Bean\n-  public AuthenticationUserDetailsService<PreAuthenticatedAuthenticationToken>\n-      authenticationUserDetailsService() {\n-    return new PreAuthenticatedAuthenticationTokenAuthenticationUserDetailsService();\n-  }\n-\n-  @Override\n-  protected void configure(HttpSecurity http) throws Exception {\n-    http.authorizeRequests()\n-        .antMatchers(\"/css/**\", \"/img/**\")\n-        .permitAll()\n-        .and()\n-        .csrf()\n-        .disable()\n-        .httpBasic()\n-        .and()\n-        .authenticationProvider(preauthAuthProvider())\n-        .authorizeRequests()\n-        .antMatchers(HttpMethod.GET, \"/docs/**\")\n-        .permitAll()\n-        .and()\n-        .addFilter(preAuthFilter())\n-        .addFilterAfter(new ElytronToJaasFilter(), JaasApiIntegrationFilter.class)\n-        .addFilter(jaasApiIntegrationFilter());\n-\n-    if (devMode) {\n-      http.headers()\n-          .frameOptions()\n-          .sameOrigin()\n-          .and()\n-          .authorizeRequests()\n-          .antMatchers(\"/h2-console/**\")\n-          .permitAll();\n-    } else {\n-      addLoginPageConfiguration(http);\n-    }\n-  }\n-\n-  private JaasApiIntegrationFilter jaasApiIntegrationFilter() {\n-    JaasApiIntegrationFilter filter = new JaasApiIntegrationFilter();\n-    filter.setCreateEmptySubject(true);\n-    return filter;\n-  }\n-\n-  private void addLoginPageConfiguration(HttpSecurity http) throws Exception {\n-    http.authorizeRequests()\n-        .anyRequest()\n-        .fullyAuthenticated()\n-        .and()\n-        .formLogin()\n-        .loginPage(\"/login\")\n-        .failureUrl(\"/login?error\")\n-        .defaultSuccessUrl(\"/\")\n-        .permitAll()\n-        .and()\n-        .logout()\n-        .invalidateHttpSession(true)\n-        .clearAuthentication(true)\n-        .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n-        .logoutSuccessUrl(\"/login?logout\")\n-        .deleteCookies(\"JSESSIONID\")\n-        .permitAll();\n-  }\n-\n-  private static class PreAuthenticatedAuthenticationTokenAuthenticationUserDetailsService\n-      implements AuthenticationUserDetailsService<PreAuthenticatedAuthenticationToken> {\n-\n-    @Override\n-    public UserDetails loadUserDetails(PreAuthenticatedAuthenticationToken token)\n-        throws UsernameNotFoundException {\n-      return new MyUserDetails(token);\n-    }\n-\n-    private static class MyUserDetails implements UserDetails {\n-\n-      private static final long serialVersionUID = 1L;\n-      private final PreAuthenticatedAuthenticationToken token;\n-\n-      public MyUserDetails(PreAuthenticatedAuthenticationToken token) {\n-        this.token = token;\n-      }\n-\n-      @Override\n-      public Collection<? extends GrantedAuthority> getAuthorities() {\n-        List<GrantedAuthority> authorities = new ArrayList<>();\n-        SecurityIdentity securityIdentity = getSecurityIdentity();\n-        if (securityIdentity != null) {\n-          Roles roles = securityIdentity.getRoles();\n-          roles.forEach(role -> authorities.add(new SimpleGrantedAuthority(role)));\n-        }\n-        return authorities;\n-      }\n-\n-      @Override\n-      public String getPassword() {\n-        return (String) token.getCredentials();\n-      }\n-\n-      @Override\n-      public String getUsername() {\n-        return token.getName();\n-      }\n-\n-      @Override\n-      public boolean isAccountNonExpired() {\n-        return true;\n-      }\n-\n-      @Override\n-      public boolean isAccountNonLocked() {\n-        return true;\n-      }\n-\n-      @Override\n-      public boolean isCredentialsNonExpired() {\n-        return true;\n-      }\n-\n-      @Override\n-      public boolean isEnabled() {\n-        return true;\n-      }\n-\n-      private SecurityIdentity getSecurityIdentity() {\n-        SecurityDomain current = SecurityDomain.getCurrent();\n-        if (current != null) {\n-          return current.getCurrentSecurityIdentity();\n-        }\n-        return null;\n-      }\n-    }\n-  }\n-}\n+package pro.taskana.wildfly.security;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n+import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n+import org.springframework.security.core.GrantedAuthority;\n+import org.springframework.security.core.authority.SimpleGrantedAuthority;\n+import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;\n+import org.springframework.security.core.userdetails.UserDetails;\n+import org.springframework.security.core.userdetails.UsernameNotFoundException;\n+import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider;\n+import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;\n+import org.springframework.security.web.authentication.preauth.j2ee.J2eePreAuthenticatedProcessingFilter;\n+import org.springframework.security.web.jaasapi.JaasApiIntegrationFilter;\n+import org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n+import org.wildfly.security.auth.server.SecurityDomain;\n+import org.wildfly.security.auth.server.SecurityIdentity;\n+import org.wildfly.security.authz.Roles;\n+\n+import pro.taskana.rest.security.WebSecurityConfig;\n+\n+/**\n+ * Default basic configuration for taskana web example running on Wildfly / JBoss with Elytron or\n+ * JAAS Security.\n+ */\n+@Configuration\n+@EnableWebSecurity\n+@Order(1)\n+public class WildflyWebSecurityConfig extends WebSecurityConfig {\n+\n+  @Value(\"${devMode:false}\")\n+  private boolean devMode;\n+\n+  @Bean\n+  public J2eePreAuthenticatedProcessingFilter preAuthFilter() {\n+    J2eePreAuthenticatedProcessingFilter filter = new J2eePreAuthenticatedProcessingFilter();\n+    filter.setAuthenticationManager(preAuthManager());\n+    return filter;\n+  }\n+\n+  @Bean\n+  public AuthenticationManager preAuthManager() {\n+    return new AuthenticationManager() {\n+\n+      @Override\n+      public Authentication authenticate(Authentication authentication)\n+          throws AuthenticationException {\n+        return preauthAuthProvider().authenticate(authentication);\n+      }\n+    };\n+  }\n+\n+  @Bean\n+  public PreAuthenticatedAuthenticationProvider preauthAuthProvider() {\n+    PreAuthenticatedAuthenticationProvider preauthAuthProvider =\n+        new PreAuthenticatedAuthenticationProvider();\n+    preauthAuthProvider.setPreAuthenticatedUserDetailsService(authenticationUserDetailsService());\n+    return preauthAuthProvider;\n+  }\n+\n+  @Bean\n+  public AuthenticationUserDetailsService<PreAuthenticatedAuthenticationToken>\n+      authenticationUserDetailsService() {\n+    return new PreAuthenticatedAuthenticationTokenAuthenticationUserDetailsService();\n+  }\n+\n+  @Override\n+  protected void configure(HttpSecurity http) throws Exception {\n+    http.authorizeRequests()\n+        .antMatchers(\"/css/**\", \"/img/**\")\n+        .permitAll()\n+        .and()\n+        .csrf()\n+        .disable()\n+        .httpBasic()\n+        .and()\n+        .authenticationProvider(preauthAuthProvider())\n+        .authorizeRequests()\n+        .antMatchers(HttpMethod.GET, \"/docs/**\")\n+        .permitAll()\n+        .and()\n+        .addFilter(preAuthFilter())\n+        .addFilterAfter(new ElytronToJaasFilter(), JaasApiIntegrationFilter.class)\n+        .addFilter(jaasApiIntegrationFilter());\n+\n+    if (devMode) {\n+      http.headers()\n+          .frameOptions()\n+          .sameOrigin()\n+          .and()\n+          .authorizeRequests()\n+          .antMatchers(\"/h2-console/**\")\n+          .permitAll();\n+    } else {\n+      addLoginPageConfiguration(http);\n+    }\n+  }\n+\n+  private JaasApiIntegrationFilter jaasApiIntegrationFilter() {\n+    JaasApiIntegrationFilter filter = new JaasApiIntegrationFilter();\n+    filter.setCreateEmptySubject(true);\n+    return filter;\n+  }\n+\n+  private void addLoginPageConfiguration(HttpSecurity http) throws Exception {\n+    http.authorizeRequests()\n+        .anyRequest()\n+        .fullyAuthenticated()\n+        .and()\n+        .formLogin()\n+        .loginPage(\"/login\")\n+        .failureUrl(\"/login?error\")\n+        .defaultSuccessUrl(\"/\")\n+        .permitAll()\n+        .and()\n+        .logout()\n+        .invalidateHttpSession(true)\n+        .clearAuthentication(true)\n+        .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n+        .logoutSuccessUrl(\"/login?logout\")\n+        .deleteCookies(\"JSESSIONID\")\n+        .permitAll();\n+  }\n+\n+  private static class PreAuthenticatedAuthenticationTokenAuthenticationUserDetailsService\n+      implements AuthenticationUserDetailsService<PreAuthenticatedAuthenticationToken> {\n+\n+    @Override\n+    public UserDetails loadUserDetails(PreAuthenticatedAuthenticationToken token)\n+        throws UsernameNotFoundException {\n+      return new MyUserDetails(token);\n+    }\n+\n+    private static class MyUserDetails implements UserDetails {\n+\n+      private static final long serialVersionUID = 1L;\n+      private final PreAuthenticatedAuthenticationToken token;\n+\n+      public MyUserDetails(PreAuthenticatedAuthenticationToken token) {\n+        this.token = token;\n+      }\n+\n+      @Override\n+      public Collection<? extends GrantedAuthority> getAuthorities() {\n+        List<GrantedAuthority> authorities = new ArrayList<>();\n+        SecurityIdentity securityIdentity = getSecurityIdentity();\n+        if (securityIdentity != null) {\n+          Roles roles = securityIdentity.getRoles();\n+          roles.forEach(role -> authorities.add(new SimpleGrantedAuthority(role)));\n+        }\n+        return authorities;\n+      }\n+\n+      @Override\n+      public String getPassword() {\n+        return (String) token.getCredentials();\n+      }\n+\n+      @Override\n+      public String getUsername() {\n+        return token.getName();\n+      }\n+\n+      @Override\n+      public boolean isAccountNonExpired() {\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isAccountNonLocked() {\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isCredentialsNonExpired() {\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isEnabled() {\n+        return true;\n+      }\n+\n+      private SecurityIdentity getSecurityIdentity() {\n+        SecurityDomain current = SecurityDomain.getCurrent();\n+        if (current != null) {\n+          return current.getCurrentSecurityIdentity();\n+        }\n+        return null;\n+      }\n+    }\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjE3Ng==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802176", "bodyText": "Please reformat", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:56:27Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/ClassificationController.java", "diffHunk": "@@ -1,324 +1,325 @@\n-package pro.taskana.rest;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/ClassificationController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/ClassificationController.java\nindex fadadf62f..856a30fce 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/ClassificationController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/ClassificationController.java\n\n@@ -1,325 +1,324 @@\n-package pro.taskana.rest;\n-\n-import java.util.List;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.hateoas.MediaTypes;\n-import org.springframework.hateoas.config.EnableHypermediaSupport;\n-import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType;\n-import org.springframework.http.HttpStatus;\n-import org.springframework.http.ResponseEntity;\n-import org.springframework.transaction.annotation.Transactional;\n-import org.springframework.util.MultiValueMap;\n-import org.springframework.web.bind.annotation.DeleteMapping;\n-import org.springframework.web.bind.annotation.GetMapping;\n-import org.springframework.web.bind.annotation.PathVariable;\n-import org.springframework.web.bind.annotation.PostMapping;\n-import org.springframework.web.bind.annotation.PutMapping;\n-import org.springframework.web.bind.annotation.RequestBody;\n-import org.springframework.web.bind.annotation.RequestParam;\n-import org.springframework.web.bind.annotation.RestController;\n-\n-import pro.taskana.classification.api.Classification;\n-import pro.taskana.classification.api.ClassificationQuery;\n-import pro.taskana.classification.api.ClassificationService;\n-import pro.taskana.classification.api.ClassificationSummary;\n-import pro.taskana.classification.api.exceptions.ClassificationAlreadyExistException;\n-import pro.taskana.classification.api.exceptions.ClassificationInUseException;\n-import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n-import pro.taskana.common.api.BaseQuery.SortDirection;\n-import pro.taskana.common.api.exceptions.ConcurrencyException;\n-import pro.taskana.common.api.exceptions.DomainNotFoundException;\n-import pro.taskana.common.api.exceptions.InvalidArgumentException;\n-import pro.taskana.common.api.exceptions.NotAuthorizedException;\n-import pro.taskana.rest.resource.ClassificationResource;\n-import pro.taskana.rest.resource.ClassificationResourceAssembler;\n-import pro.taskana.rest.resource.ClassificationSummaryListResource;\n-import pro.taskana.rest.resource.ClassificationSummaryResourceAssembler;\n-import pro.taskana.rest.resource.PagedResources.PageMetadata;\n-\n-/** Controller for all {@link Classification} related endpoints. */\n-@RestController\n-@EnableHypermediaSupport(type = HypermediaType.HAL)\n-public class ClassificationController extends AbstractPagingController {\n-\n-  private static final Logger LOGGER = LoggerFactory.getLogger(ClassificationController.class);\n-\n-  private static final String LIKE = \"%\";\n-\n-  private static final String NAME = \"name\";\n-\n-  private static final String NAME_LIKE = \"name-like\";\n-\n-  private static final String KEY = \"key\";\n-\n-  private static final String DOMAIN = \"domain\";\n-\n-  private static final String CATEGORY = \"category\";\n-\n-  private static final String TYPE = \"type\";\n-\n-  private static final String CUSTOM_1_LIKE = \"custom-1-like\";\n-\n-  private static final String CUSTOM_2_LIKE = \"custom-2-like\";\n-\n-  private static final String CUSTOM_3_LIKE = \"custom-3-like\";\n-\n-  private static final String CUSTOM_4_LIKE = \"custom-4-like\";\n-\n-  private static final String CUSTOM_5_LIKE = \"custom-5-like\";\n-\n-  private static final String CUSTOM_6_LIKE = \"custom-6-like\";\n-\n-  private static final String CUSTOM_7_LIKE = \"custom-7-like\";\n-\n-  private static final String CUSTOM_8_LIKE = \"custom-8-like\";\n-\n-  private static final String SORT_BY = \"sort-by\";\n-\n-  private static final String SORT_DIRECTION = \"order\";\n-\n-  private ClassificationService classificationService;\n-\n-  private ClassificationResourceAssembler classificationResourceAssembler;\n-\n-  private ClassificationSummaryResourceAssembler classificationSummaryResourceAssembler;\n-\n-  ClassificationController(\n-      ClassificationService classificationService,\n-      ClassificationResourceAssembler classificationResourceAssembler,\n-      ClassificationSummaryResourceAssembler classificationSummaryResourceAssembler) {\n-    this.classificationService = classificationService;\n-    this.classificationResourceAssembler = classificationResourceAssembler;\n-    this.classificationSummaryResourceAssembler = classificationSummaryResourceAssembler;\n-  }\n-\n-  @GetMapping(path = Mapping.URL_CLASSIFICATIONS)\n-  @Transactional(readOnly = true, rollbackFor = Exception.class)\n-  public ResponseEntity<ClassificationSummaryListResource> getClassifications(\n-      @RequestParam MultiValueMap<String, String> params) throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to getClassifications(params= {})\", params);\n-    }\n-\n-    ClassificationQuery query = classificationService.createClassificationQuery();\n-    query = applySortingParams(query, params);\n-    query = applyFilterParams(query, params);\n-\n-    PageMetadata pageMetadata = getPageMetadata(params, query);\n-    List<ClassificationSummary> classificationSummaries = getQueryList(query, pageMetadata);\n-\n-    ResponseEntity<ClassificationSummaryListResource> response =\n-        ResponseEntity.ok(\n-            classificationSummaryResourceAssembler.toResources(\n-                classificationSummaries, pageMetadata));\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from getClassifications(), returning {}\", response);\n-    }\n-\n-    return response;\n-  }\n-\n-  @GetMapping(path = Mapping.URL_CLASSIFICATIONS_ID, produces = MediaTypes.HAL_JSON_UTF8_VALUE)\n-  @Transactional(readOnly = true, rollbackFor = Exception.class)\n-  public ResponseEntity<ClassificationResource> getClassification(\n-      @PathVariable String classificationId) throws ClassificationNotFoundException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to getClassification(classificationId= {})\", classificationId);\n-    }\n-\n-    Classification classification = classificationService.getClassification(classificationId);\n-    ResponseEntity<ClassificationResource> response =\n-        ResponseEntity.ok(classificationResourceAssembler.toResource(classification));\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from getClassification(), returning {}\", response);\n-    }\n-\n-    return response;\n-  }\n-\n-  @PostMapping(path = Mapping.URL_CLASSIFICATIONS)\n-  @Transactional(rollbackFor = Exception.class)\n-  public ResponseEntity<ClassificationResource> createClassification(\n-      @RequestBody ClassificationResource resource)\n-      throws NotAuthorizedException, ClassificationAlreadyExistException, DomainNotFoundException,\n-          InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to createClassification(resource= {})\", resource);\n-    }\n-    Classification classification = classificationResourceAssembler.toModel(resource);\n-    classification = classificationService.createClassification(classification);\n-\n-    ResponseEntity<ClassificationResource> response =\n-        ResponseEntity.status(HttpStatus.CREATED)\n-            .body(classificationResourceAssembler.toResource(classification));\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from createClassification(), returning {}\", response);\n-    }\n-\n-    return response;\n-  }\n-\n-  @PutMapping(path = Mapping.URL_CLASSIFICATIONS_ID)\n-  @Transactional(rollbackFor = Exception.class)\n-  public ResponseEntity<ClassificationResource> updateClassification(\n-      @PathVariable(value = \"classificationId\") String classificationId,\n-      @RequestBody ClassificationResource resource)\n-      throws NotAuthorizedException, ClassificationNotFoundException, ConcurrencyException,\n-          InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\n-          \"Entry to updateClassification(classificationId= {}, resource= {})\",\n-          classificationId,\n-          resource);\n-    }\n-\n-    ResponseEntity<ClassificationResource> result;\n-    if (classificationId.equals(resource.classificationId)) {\n-      Classification classification = classificationResourceAssembler.toModel(resource);\n-      classification = classificationService.updateClassification(classification);\n-      result = ResponseEntity.ok(classificationResourceAssembler.toResource(classification));\n-    } else {\n-      throw new InvalidArgumentException(\n-          \"ClassificationId ('\"\n-              + classificationId\n-              + \"') of the URI is not identical with the classificationId ('\"\n-              + resource.getClassificationId()\n-              + \"') of the object in the payload.\");\n-    }\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from updateClassification(), returning {}\", result);\n-    }\n-\n-    return result;\n-  }\n-\n-  @DeleteMapping(path = Mapping.URL_CLASSIFICATIONS_ID)\n-  @Transactional(readOnly = true, rollbackFor = Exception.class)\n-  public ResponseEntity<?> deleteClassification(@PathVariable String classificationId)\n-      throws ClassificationNotFoundException, ClassificationInUseException, NotAuthorizedException {\n-    LOGGER.debug(\"Entry to deleteClassification(classificationId= {})\", classificationId);\n-    classificationService.deleteClassification(classificationId);\n-    ResponseEntity<?> response = ResponseEntity.noContent().build();\n-    LOGGER.debug(\"Exit from deleteClassification(), returning {}\", response);\n-    return response;\n-  }\n-\n-  private ClassificationQuery applySortingParams(\n-      ClassificationQuery query, MultiValueMap<String, String> params)\n-      throws IllegalArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to applySortingParams(query= {}, params= {})\", query, params);\n-    }\n-\n-    // sorting\n-    String sortBy = params.getFirst(SORT_BY);\n-    if (sortBy != null) {\n-      SortDirection sortDirection;\n-      if (params.getFirst(SORT_DIRECTION) != null\n-          && \"desc\".equals(params.getFirst(SORT_DIRECTION))) {\n-        sortDirection = SortDirection.DESCENDING;\n-      } else {\n-        sortDirection = SortDirection.ASCENDING;\n-      }\n-      switch (sortBy) {\n-        case (CATEGORY):\n-          query = query.orderByCategory(sortDirection);\n-          break;\n-        case (DOMAIN):\n-          query = query.orderByDomain(sortDirection);\n-          break;\n-        case (KEY):\n-          query = query.orderByKey(sortDirection);\n-          break;\n-        case (NAME):\n-          query = query.orderByName(sortDirection);\n-          break;\n-        default:\n-          throw new IllegalArgumentException(\"Unknown order '\" + sortBy + \"'\");\n-      }\n-    }\n-    params.remove(SORT_BY);\n-    params.remove(SORT_DIRECTION);\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applySortingParams(), returning {}\", query);\n-    }\n-\n-    return query;\n-  }\n-\n-  private ClassificationQuery applyFilterParams(\n-      ClassificationQuery query, MultiValueMap<String, String> params)\n-      throws InvalidArgumentException {\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Entry to applyFilterParams(query= {}, params= {})\", query, params);\n-    }\n-\n-    if (params.containsKey(NAME)) {\n-      String[] names = extractCommaSeparatedFields(params.get(NAME));\n-      query.nameIn(names);\n-      params.remove(NAME);\n-    }\n-    if (params.containsKey(NAME_LIKE)) {\n-      query.nameLike(LIKE + params.get(NAME_LIKE).get(0) + LIKE);\n-      params.remove(NAME_LIKE);\n-    }\n-    if (params.containsKey(KEY)) {\n-      String[] names = extractCommaSeparatedFields(params.get(KEY));\n-      query.keyIn(names);\n-      params.remove(KEY);\n-    }\n-    if (params.containsKey(CATEGORY)) {\n-      String[] names = extractCommaSeparatedFields(params.get(CATEGORY));\n-      query.categoryIn(names);\n-      params.remove(CATEGORY);\n-    }\n-    if (params.containsKey(DOMAIN)) {\n-      String[] names = extractCommaSeparatedFields(params.get(DOMAIN));\n-      query.domainIn(names);\n-      params.remove(DOMAIN);\n-    }\n-    if (params.containsKey(TYPE)) {\n-      String[] names = extractCommaSeparatedFields(params.get(TYPE));\n-      query.typeIn(names);\n-      params.remove(TYPE);\n-    }\n-    if (params.containsKey(CUSTOM_1_LIKE)) {\n-      query.customAttributeLike(\"1\", LIKE + params.get(CUSTOM_1_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_1_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_2_LIKE)) {\n-      query.customAttributeLike(\"2\", LIKE + params.get(CUSTOM_2_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_2_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_3_LIKE)) {\n-      query.customAttributeLike(\"3\", LIKE + params.get(CUSTOM_3_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_3_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_4_LIKE)) {\n-      query.customAttributeLike(\"4\", LIKE + params.get(CUSTOM_4_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_4_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_5_LIKE)) {\n-      query.customAttributeLike(\"5\", LIKE + params.get(CUSTOM_5_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_5_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_6_LIKE)) {\n-      query.customAttributeLike(\"6\", LIKE + params.get(CUSTOM_6_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_6_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_7_LIKE)) {\n-      query.customAttributeLike(\"7\", LIKE + params.get(CUSTOM_7_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_7_LIKE);\n-    }\n-    if (params.containsKey(CUSTOM_8_LIKE)) {\n-      query.customAttributeLike(\"8\", LIKE + params.get(CUSTOM_8_LIKE).get(0) + LIKE);\n-      params.remove(CUSTOM_8_LIKE);\n-    }\n-\n-    if (LOGGER.isDebugEnabled()) {\n-      LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", query);\n-    }\n-\n-    return query;\n-  }\n-}\n+package pro.taskana.rest;\n+\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.hateoas.config.EnableHypermediaSupport;\n+import org.springframework.hateoas.config.EnableHypermediaSupport.HypermediaType;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.springframework.util.MultiValueMap;\n+import org.springframework.web.bind.annotation.DeleteMapping;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.PutMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import pro.taskana.classification.api.Classification;\n+import pro.taskana.classification.api.ClassificationQuery;\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.classification.api.ClassificationSummary;\n+import pro.taskana.classification.api.exceptions.ClassificationAlreadyExistException;\n+import pro.taskana.classification.api.exceptions.ClassificationInUseException;\n+import pro.taskana.classification.api.exceptions.ClassificationNotFoundException;\n+import pro.taskana.common.api.BaseQuery.SortDirection;\n+import pro.taskana.common.api.exceptions.ConcurrencyException;\n+import pro.taskana.common.api.exceptions.DomainNotFoundException;\n+import pro.taskana.common.api.exceptions.InvalidArgumentException;\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.rest.resource.ClassificationResource;\n+import pro.taskana.rest.resource.ClassificationResourceAssembler;\n+import pro.taskana.rest.resource.ClassificationSummaryListResource;\n+import pro.taskana.rest.resource.ClassificationSummaryResourceAssembler;\n+import pro.taskana.rest.resource.PagedResources.PageMetadata;\n+\n+/** Controller for all {@link Classification} related endpoints. */\n+@RestController\n+@EnableHypermediaSupport(type = HypermediaType.HAL)\n+public class ClassificationController extends AbstractPagingController {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ClassificationController.class);\n+\n+  private static final String LIKE = \"%\";\n+\n+  private static final String NAME = \"name\";\n+\n+  private static final String NAME_LIKE = \"name-like\";\n+\n+  private static final String KEY = \"key\";\n+\n+  private static final String DOMAIN = \"domain\";\n+\n+  private static final String CATEGORY = \"category\";\n+\n+  private static final String TYPE = \"type\";\n+\n+  private static final String CUSTOM_1_LIKE = \"custom-1-like\";\n+\n+  private static final String CUSTOM_2_LIKE = \"custom-2-like\";\n+\n+  private static final String CUSTOM_3_LIKE = \"custom-3-like\";\n+\n+  private static final String CUSTOM_4_LIKE = \"custom-4-like\";\n+\n+  private static final String CUSTOM_5_LIKE = \"custom-5-like\";\n+\n+  private static final String CUSTOM_6_LIKE = \"custom-6-like\";\n+\n+  private static final String CUSTOM_7_LIKE = \"custom-7-like\";\n+\n+  private static final String CUSTOM_8_LIKE = \"custom-8-like\";\n+\n+  private static final String SORT_BY = \"sort-by\";\n+\n+  private static final String SORT_DIRECTION = \"order\";\n+\n+  private ClassificationService classificationService;\n+\n+  private ClassificationResourceAssembler classificationResourceAssembler;\n+\n+  private ClassificationSummaryResourceAssembler classificationSummaryResourceAssembler;\n+\n+  ClassificationController(\n+      ClassificationService classificationService,\n+      ClassificationResourceAssembler classificationResourceAssembler,\n+      ClassificationSummaryResourceAssembler classificationSummaryResourceAssembler) {\n+    this.classificationService = classificationService;\n+    this.classificationResourceAssembler = classificationResourceAssembler;\n+    this.classificationSummaryResourceAssembler = classificationSummaryResourceAssembler;\n+  }\n+\n+  @GetMapping(path = Mapping.URL_CLASSIFICATIONS)\n+  @Transactional(readOnly = true, rollbackFor = Exception.class)\n+  public ResponseEntity<ClassificationSummaryListResource> getClassifications(\n+      @RequestParam MultiValueMap<String, String> params) throws InvalidArgumentException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Entry to getClassifications(params= {})\", params);\n+    }\n+\n+    ClassificationQuery query = classificationService.createClassificationQuery();\n+    query = applySortingParams(query, params);\n+    query = applyFilterParams(query, params);\n+\n+    PageMetadata pageMetadata = getPageMetadata(params, query);\n+    List<ClassificationSummary> classificationSummaries = getQueryList(query, pageMetadata);\n+\n+    ResponseEntity<ClassificationSummaryListResource> response =\n+        ResponseEntity.ok(\n+            classificationSummaryResourceAssembler.toResources(\n+                classificationSummaries, pageMetadata));\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from getClassifications(), returning {}\", response);\n+    }\n+\n+    return response;\n+  }\n+\n+  @GetMapping(path = Mapping.URL_CLASSIFICATIONS_ID)\n+  @Transactional(readOnly = true, rollbackFor = Exception.class)\n+  public ResponseEntity<ClassificationResource> getClassification(\n+      @PathVariable String classificationId) throws ClassificationNotFoundException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Entry to getClassification(classificationId= {})\", classificationId);\n+    }\n+\n+    Classification classification = classificationService.getClassification(classificationId);\n+    ResponseEntity<ClassificationResource> response =\n+        ResponseEntity.ok(classificationResourceAssembler.toResource(classification));\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from getClassification(), returning {}\", response);\n+    }\n+\n+    return response;\n+  }\n+\n+  @PostMapping(path = Mapping.URL_CLASSIFICATIONS)\n+  @Transactional(rollbackFor = Exception.class)\n+  public ResponseEntity<ClassificationResource> createClassification(\n+      @RequestBody ClassificationResource resource)\n+      throws NotAuthorizedException, ClassificationAlreadyExistException, DomainNotFoundException,\n+          InvalidArgumentException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Entry to createClassification(resource= {})\", resource);\n+    }\n+    Classification classification = classificationResourceAssembler.toModel(resource);\n+    classification = classificationService.createClassification(classification);\n+\n+    ResponseEntity<ClassificationResource> response =\n+        ResponseEntity.status(HttpStatus.CREATED)\n+            .body(classificationResourceAssembler.toResource(classification));\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from createClassification(), returning {}\", response);\n+    }\n+\n+    return response;\n+  }\n+\n+  @PutMapping(path = Mapping.URL_CLASSIFICATIONS_ID)\n+  @Transactional(rollbackFor = Exception.class)\n+  public ResponseEntity<ClassificationResource> updateClassification(\n+      @PathVariable(value = \"classificationId\") String classificationId,\n+      @RequestBody ClassificationResource resource)\n+      throws NotAuthorizedException, ClassificationNotFoundException, ConcurrencyException,\n+          InvalidArgumentException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\n+          \"Entry to updateClassification(classificationId= {}, resource= {})\",\n+          classificationId,\n+          resource);\n+    }\n+\n+    ResponseEntity<ClassificationResource> result;\n+    if (classificationId.equals(resource.getClassificationId())) {\n+      Classification classification = classificationResourceAssembler.toModel(resource);\n+      classification = classificationService.updateClassification(classification);\n+      result = ResponseEntity.ok(classificationResourceAssembler.toResource(classification));\n+    } else {\n+      throw new InvalidArgumentException(\n+          \"ClassificationId ('\"\n+              + classificationId\n+              + \"') of the URI is not identical with the classificationId ('\"\n+              + resource.getClassificationId()\n+              + \"') of the object in the payload.\");\n+    }\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from updateClassification(), returning {}\", result);\n+    }\n+\n+    return result;\n+  }\n+\n+  @DeleteMapping(path = Mapping.URL_CLASSIFICATIONS_ID)\n+  @Transactional(readOnly = true, rollbackFor = Exception.class)\n+  public ResponseEntity<?> deleteClassification(@PathVariable String classificationId)\n+      throws ClassificationNotFoundException, ClassificationInUseException, NotAuthorizedException {\n+    LOGGER.debug(\"Entry to deleteClassification(classificationId= {})\", classificationId);\n+    classificationService.deleteClassification(classificationId);\n+    ResponseEntity<?> response = ResponseEntity.noContent().build();\n+    LOGGER.debug(\"Exit from deleteClassification(), returning {}\", response);\n+    return response;\n+  }\n+\n+  private ClassificationQuery applySortingParams(\n+      ClassificationQuery query, MultiValueMap<String, String> params)\n+      throws IllegalArgumentException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Entry to applySortingParams(query= {}, params= {})\", query, params);\n+    }\n+\n+    // sorting\n+    String sortBy = params.getFirst(SORT_BY);\n+    if (sortBy != null) {\n+      SortDirection sortDirection;\n+      if (params.getFirst(SORT_DIRECTION) != null\n+          && \"desc\".equals(params.getFirst(SORT_DIRECTION))) {\n+        sortDirection = SortDirection.DESCENDING;\n+      } else {\n+        sortDirection = SortDirection.ASCENDING;\n+      }\n+      switch (sortBy) {\n+        case (CATEGORY):\n+          query = query.orderByCategory(sortDirection);\n+          break;\n+        case (DOMAIN):\n+          query = query.orderByDomain(sortDirection);\n+          break;\n+        case (KEY):\n+          query = query.orderByKey(sortDirection);\n+          break;\n+        case (NAME):\n+          query = query.orderByName(sortDirection);\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"Unknown order '\" + sortBy + \"'\");\n+      }\n+    }\n+    params.remove(SORT_BY);\n+    params.remove(SORT_DIRECTION);\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from applySortingParams(), returning {}\", query);\n+    }\n+\n+    return query;\n+  }\n+\n+  private ClassificationQuery applyFilterParams(\n+      ClassificationQuery query, MultiValueMap<String, String> params)\n+      throws InvalidArgumentException {\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Entry to applyFilterParams(query= {}, params= {})\", query, params);\n+    }\n+\n+    if (params.containsKey(NAME)) {\n+      String[] names = extractCommaSeparatedFields(params.get(NAME));\n+      query.nameIn(names);\n+      params.remove(NAME);\n+    }\n+    if (params.containsKey(NAME_LIKE)) {\n+      query.nameLike(LIKE + params.get(NAME_LIKE).get(0) + LIKE);\n+      params.remove(NAME_LIKE);\n+    }\n+    if (params.containsKey(KEY)) {\n+      String[] names = extractCommaSeparatedFields(params.get(KEY));\n+      query.keyIn(names);\n+      params.remove(KEY);\n+    }\n+    if (params.containsKey(CATEGORY)) {\n+      String[] names = extractCommaSeparatedFields(params.get(CATEGORY));\n+      query.categoryIn(names);\n+      params.remove(CATEGORY);\n+    }\n+    if (params.containsKey(DOMAIN)) {\n+      String[] names = extractCommaSeparatedFields(params.get(DOMAIN));\n+      query.domainIn(names);\n+      params.remove(DOMAIN);\n+    }\n+    if (params.containsKey(TYPE)) {\n+      String[] names = extractCommaSeparatedFields(params.get(TYPE));\n+      query.typeIn(names);\n+      params.remove(TYPE);\n+    }\n+    if (params.containsKey(CUSTOM_1_LIKE)) {\n+      query.customAttributeLike(\"1\", LIKE + params.get(CUSTOM_1_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_1_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_2_LIKE)) {\n+      query.customAttributeLike(\"2\", LIKE + params.get(CUSTOM_2_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_2_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_3_LIKE)) {\n+      query.customAttributeLike(\"3\", LIKE + params.get(CUSTOM_3_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_3_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_4_LIKE)) {\n+      query.customAttributeLike(\"4\", LIKE + params.get(CUSTOM_4_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_4_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_5_LIKE)) {\n+      query.customAttributeLike(\"5\", LIKE + params.get(CUSTOM_5_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_5_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_6_LIKE)) {\n+      query.customAttributeLike(\"6\", LIKE + params.get(CUSTOM_6_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_6_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_7_LIKE)) {\n+      query.customAttributeLike(\"7\", LIKE + params.get(CUSTOM_7_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_7_LIKE);\n+    }\n+    if (params.containsKey(CUSTOM_8_LIKE)) {\n+      query.customAttributeLike(\"8\", LIKE + params.get(CUSTOM_8_LIKE).get(0) + LIKE);\n+      params.remove(CUSTOM_8_LIKE);\n+    }\n+\n+    if (LOGGER.isDebugEnabled()) {\n+      LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", query);\n+    }\n+\n+    return query;\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjIzOQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802239", "bodyText": "Please reformat.", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:57:14Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/RestConfiguration.java", "diffHunk": "@@ -1,77 +1,78 @@\n-package pro.taskana.rest;", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/RestConfiguration.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/RestConfiguration.java\nindex 96a6392bc..a1c23e819 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/RestConfiguration.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/RestConfiguration.java\n\n@@ -1,78 +1,77 @@\n-package pro.taskana.rest;\n-\n-import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n-import java.sql.SQLException;\n-import javax.sql.DataSource;\n-import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n-import org.springframework.context.ApplicationContext;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.ComponentScan;\n-import org.springframework.context.annotation.Configuration;\n-import org.springframework.context.annotation.Scope;\n-import org.springframework.http.converter.json.SpringHandlerInstantiator;\n-import org.springframework.transaction.annotation.EnableTransactionManagement;\n-\n-import pro.taskana.TaskanaEngineConfiguration;\n-import pro.taskana.classification.api.ClassificationService;\n-import pro.taskana.common.api.TaskanaEngine;\n-import pro.taskana.configuration.SpringTaskanaEngineConfiguration;\n-import pro.taskana.ldap.LdapClient;\n-import pro.taskana.report.api.TaskMonitorService;\n-import pro.taskana.task.api.TaskService;\n-import pro.taskana.workbasket.api.WorkbasketService;\n-\n-/** Configuration for REST service. */\n-@Configuration\n-@ComponentScan\n-@EnableTransactionManagement\n-public class RestConfiguration {\n-\n-  @Value(\"${taskana.schemaName:TASKANA}\")\n-  private String schemaName;\n-\n-  @Bean\n-  public ClassificationService getClassificationService(TaskanaEngine taskanaEngine) {\n-    return taskanaEngine.getClassificationService();\n-  }\n-\n-  @Bean\n-  public TaskService getTaskService(TaskanaEngine taskanaEngine) {\n-    return taskanaEngine.getTaskService();\n-  }\n-\n-  @Bean\n-  public TaskMonitorService getTaskMonitorService(TaskanaEngine taskanaEngine) {\n-    return taskanaEngine.getTaskMonitorService();\n-  }\n-\n-  @Bean\n-  public WorkbasketService getWorkbasketService(TaskanaEngine taskanaEngine) {\n-    return taskanaEngine.getWorkbasketService();\n-  }\n-\n-  @Bean\n-  @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)\n-  public TaskanaEngine getTaskanaEngine(TaskanaEngineConfiguration taskanaEngineConfiguration) {\n-    return taskanaEngineConfiguration.buildTaskanaEngine();\n-  }\n-\n-  @Bean\n-  @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)\n-  public TaskanaEngineConfiguration taskanaEngineConfiguration(DataSource dataSource)\n-      throws SQLException {\n-    return new SpringTaskanaEngineConfiguration(dataSource, true, true, schemaName);\n-  }\n-\n-  @Bean\n-  public LdapClient ldapClient() {\n-    return new LdapClient();\n-  }\n-\n-  // Needed for injection into jackson deserializer.\n-  @Bean\n-  public HandlerInstantiator handlerInstantiator(ApplicationContext context) {\n-    return new SpringHandlerInstantiator(context.getAutowireCapableBeanFactory());\n-  }\n-\n-}\n+package pro.taskana.rest;\n+\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n+import java.sql.SQLException;\n+import javax.sql.DataSource;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.ComponentScan;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.http.converter.json.SpringHandlerInstantiator;\n+import org.springframework.transaction.annotation.EnableTransactionManagement;\n+\n+import pro.taskana.TaskanaEngineConfiguration;\n+import pro.taskana.classification.api.ClassificationService;\n+import pro.taskana.common.api.TaskanaEngine;\n+import pro.taskana.configuration.SpringTaskanaEngineConfiguration;\n+import pro.taskana.ldap.LdapClient;\n+import pro.taskana.report.api.TaskMonitorService;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.workbasket.api.WorkbasketService;\n+\n+/** Configuration for REST service. */\n+@Configuration\n+@ComponentScan\n+@EnableTransactionManagement\n+public class RestConfiguration {\n+\n+  @Value(\"${taskana.schemaName:TASKANA}\")\n+  private String schemaName;\n+\n+  @Bean\n+  public ClassificationService getClassificationService(TaskanaEngine taskanaEngine) {\n+    return taskanaEngine.getClassificationService();\n+  }\n+\n+  @Bean\n+  public TaskService getTaskService(TaskanaEngine taskanaEngine) {\n+    return taskanaEngine.getTaskService();\n+  }\n+\n+  @Bean\n+  public TaskMonitorService getTaskMonitorService(TaskanaEngine taskanaEngine) {\n+    return taskanaEngine.getTaskMonitorService();\n+  }\n+\n+  @Bean\n+  public WorkbasketService getWorkbasketService(TaskanaEngine taskanaEngine) {\n+    return taskanaEngine.getWorkbasketService();\n+  }\n+\n+  @Bean\n+  @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)\n+  public TaskanaEngine getTaskanaEngine(TaskanaEngineConfiguration taskanaEngineConfiguration) {\n+    return taskanaEngineConfiguration.buildTaskanaEngine();\n+  }\n+\n+  @Bean\n+  @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)\n+  public TaskanaEngineConfiguration taskanaEngineConfiguration(DataSource dataSource)\n+      throws SQLException {\n+    return new SpringTaskanaEngineConfiguration(dataSource, true, true, schemaName);\n+  }\n+\n+  @Bean\n+  public LdapClient ldapClient() {\n+    return new LdapClient();\n+  }\n+\n+  // Needed for injection into jackson deserializer.\n+  @Bean\n+  public HandlerInstantiator handlerInstantiator(ApplicationContext context) {\n+    return new SpringHandlerInstantiator(context.getAutowireCapableBeanFactory());\n+  }\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwMjI3Ng==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r376802276", "bodyText": "This should not have happened. Reformat please :)", "author": "mustaphazorgati", "createdAt": "2020-02-09T17:57:48Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/WorkbasketController.java", "diffHunk": "@@ -82,8 +83,7 @@\n \n   private WorkbasketAccessItemResourceAssembler workbasketAccessItemResourceAssembler;\n \n-  WorkbasketController(", "originalCommit": "a2255627b878cae0214c5b0df259ca9f9536ee6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "487382c7e388bfcae160a6e54026398e6a83df84", "chunk": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/WorkbasketController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/WorkbasketController.java\nindex 960736610..ab9376e05 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/WorkbasketController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/WorkbasketController.java\n\n@@ -83,7 +83,8 @@ public class WorkbasketController extends AbstractPagingController {\n \n   private WorkbasketAccessItemResourceAssembler workbasketAccessItemResourceAssembler;\n \n-  WorkbasketController(WorkbasketService workbasketService,\n+  WorkbasketController(\n+      WorkbasketService workbasketService,\n       WorkbasketResourceAssembler workbasketResourceAssembler,\n       WorkbasketSummaryResourceAssembler workbasketSummaryResourceAssembler,\n       DistributionTargetResourceAssembler distributionTargetResourceAssembler,\n"}}, {"oid": "487382c7e388bfcae160a6e54026398e6a83df84", "url": "https://github.com/Taskana/taskana/commit/487382c7e388bfcae160a6e54026398e6a83df84", "message": "TSK-1031: removed unnecessary throws statements", "committedDate": "2020-02-11T13:41:40Z", "type": "commit"}, {"oid": "add2992addaccef50058b415a5e4fd757a8f8df0", "url": "https://github.com/Taskana/taskana/commit/add2992addaccef50058b415a5e4fd757a8f8df0", "message": "TSK-1031: update Spring Boot to 2.2.4.RELEASE except Hateoas.", "committedDate": "2020-02-11T13:43:37Z", "type": "commit"}, {"oid": "baf7761f452bbb60dca079cde8169c765bdbe545", "url": "https://github.com/Taskana/taskana/commit/baf7761f452bbb60dca079cde8169c765bdbe545", "message": "TSK-1031: add printing of surefire plugin in case of failure.", "committedDate": "2020-02-11T13:43:37Z", "type": "commit"}, {"oid": "ea872aea0b260c57a7a2d472a8e6e8857052ec94", "url": "https://github.com/Taskana/taskana/commit/ea872aea0b260c57a7a2d472a8e6e8857052ec94", "message": "TSK-1031: required changes to wildfly/arquillian config", "committedDate": "2020-02-11T13:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NTU0Mw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377665543", "bodyText": "assertThat(response.getBody().getContent()).hasSize(17)", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:25:34Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java", "diffHunk": "@@ -68,15 +76,11 @@ void testGetAllClassificationsKeepingFilters() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(ClassificationSummaryListResource.class));\n-    assertNotNull(response.getBody().getLink(Link.REL_SELF));\n-    assertTrue(\n-        response\n-            .getBody()\n-            .getLink(Link.REL_SELF)\n-            .getHref()\n-            .endsWith(\"/api/v1/classifications?domain=DOMAIN_A&sort-by=key&order=asc\"));\n-    assertEquals(17, response.getBody().getContent().size());\n-    assertEquals(\"A12\", response.getBody().getContent().iterator().next().key);\n+    assertThat(response.getBody().getLink(Link.REL_SELF)).isNotNull();\n+    assertThat(response.getBody().getLink(Link.REL_SELF).getHref())\n+        .endsWith(\"/api/v1/classifications?domain=DOMAIN_A&sort-by=key&order=asc\");\n+    assertThat(response.getBody().getContent().size()).isEqualTo(17);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\nindex a40e41312..f3def5dc2 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n\n@@ -79,7 +79,7 @@ class ClassificationControllerIntTest {\n     assertThat(response.getBody().getLink(Link.REL_SELF)).isNotNull();\n     assertThat(response.getBody().getLink(Link.REL_SELF).getHref())\n         .endsWith(\"/api/v1/classifications?domain=DOMAIN_A&sort-by=key&order=asc\");\n-    assertThat(response.getBody().getContent().size()).isEqualTo(17);\n+    assertThat(response.getBody().getContent()).hasSize(17);\n     assertThat(response.getBody().getContent().iterator().next().key).isEqualTo(\"A12\");\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NTk2Nw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377665967", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:26:13Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java", "diffHunk": "@@ -36,7 +39,7 @@ void testQueryGroupsByDn() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertEquals(1, response.getBody().size());\n+    assertThat(response.getBody().size()).isEqualTo(1);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\nindex c0753a66a..51019b540 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n\n@@ -39,7 +40,7 @@ class AccessIdControllerIntTest {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertThat(response.getBody().size()).isEqualTo(1);\n+    assertThat(response.getBody()).hasSize(1);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NjEyMQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377666121", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:26:27Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java", "diffHunk": "@@ -47,6 +50,42 @@ void testQueryGroupsByCn() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertEquals(1, response.getBody().size());\n+    assertThat(response.getBody().size()).isEqualTo(1);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\nindex c0753a66a..51019b540 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n\n@@ -50,7 +51,7 @@ class AccessIdControllerIntTest {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertThat(response.getBody().size()).isEqualTo(1);\n+    assertThat(response.getBody()).hasSize(1);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NjI5NA==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377666294", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:26:44Z", "path": "rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java", "diffHunk": "@@ -30,7 +30,7 @@ void testFindUsers() throws InvalidArgumentException {\n     if (ldapClient.useLdap()) {\n       List<AccessIdResource> usersAndGroups = ldapClient.searchUsersAndGroups(\"ser0\");\n       System.out.println(\"#### found \" + LoggerUtils.listToString(usersAndGroups));\n-      assertEquals(50, usersAndGroups.size());\n+      assertThat(usersAndGroups.size()).isEqualTo(50);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\nindex 2763c8659..709fa9be0 100644\n--- a/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\n+++ b/rest/taskana-rest-spring-example-common/src/test/java/pro/taskana/ldap/LdapTest.java\n\n@@ -30,7 +30,7 @@ class LdapTest {\n     if (ldapClient.useLdap()) {\n       List<AccessIdResource> usersAndGroups = ldapClient.searchUsersAndGroups(\"ser0\");\n       System.out.println(\"#### found \" + LoggerUtils.listToString(usersAndGroups));\n-      assertThat(usersAndGroups.size()).isEqualTo(50);\n+      assertThat(usersAndGroups).hasSize(50);\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NjUyNg==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377666526", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:27:06Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java", "diffHunk": "@@ -47,6 +50,42 @@ void testQueryGroupsByCn() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertEquals(1, response.getBody().size());\n+    assertThat(response.getBody().size()).isEqualTo(1);\n   }\n+\n+  @Test\n+  void testGetMatches() {\n+    ResponseEntity<List<AccessIdResource>> response =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_ACCESSID) + \"?search-for=ali\",\n+            HttpMethod.GET,\n+            restHelper.defaultRequest(),\n+            ParameterizedTypeReference.forType(AccessIdListResource.class));\n+\n+    List<AccessIdResource> body = response.getBody();\n+    assertThat(body).isNotNull();\n+    assertThat(body.size()).isEqualTo(3);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\nindex c0753a66a..51019b540 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n\n@@ -50,7 +51,7 @@ class AccessIdControllerIntTest {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertThat(response.getBody().size()).isEqualTo(1);\n+    assertThat(response.getBody()).hasSize(1);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NjcwNw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377666707", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:27:23Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java", "diffHunk": "@@ -55,8 +63,8 @@ void testGetAllClassificationsFilterByCustomAttribute() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(ClassificationSummaryListResource.class));\n-    assertNotNull(response.getBody().getLink(Link.REL_SELF));\n-    assertEquals(13, response.getBody().getContent().size());\n+    assertThat(response.getBody().getLink(Link.REL_SELF)).isNotNull();\n+    assertThat(response.getBody().getContent().size()).isEqualTo(13);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\nindex a40e41312..f3def5dc2 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n\n@@ -64,7 +64,7 @@ class ClassificationControllerIntTest {\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(ClassificationSummaryListResource.class));\n     assertThat(response.getBody().getLink(Link.REL_SELF)).isNotNull();\n-    assertThat(response.getBody().getContent().size()).isEqualTo(13);\n+    assertThat(response.getBody().getContent()).hasSize(13);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2Njg2OA==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377666868", "bodyText": "hasSize()", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:27:37Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java", "diffHunk": "@@ -88,21 +92,17 @@ void testGetSecondPageSortedByKey() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(ClassificationSummaryListResource.class));\n-    assertEquals(5, response.getBody().getContent().size());\n-    assertEquals(\"L1050\", response.getBody().getContent().iterator().next().key);\n-    assertNotNull(response.getBody().getLink(Link.REL_SELF));\n-    assertTrue(\n-        response\n-            .getBody()\n-            .getLink(Link.REL_SELF)\n-            .getHref()\n-            .endsWith(\n-                \"/api/v1/classifications?\"\n-                    + \"domain=DOMAIN_A&sort-by=key&order=asc&page=2&page-size=5\"));\n-    assertNotNull(response.getBody().getLink(Link.REL_FIRST));\n-    assertNotNull(response.getBody().getLink(Link.REL_LAST));\n-    assertNotNull(response.getBody().getLink(Link.REL_NEXT));\n-    assertNotNull(response.getBody().getLink(Link.REL_PREVIOUS));\n+    assertThat(response.getBody().getContent().size()).isEqualTo(5);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\nindex a40e41312..f3def5dc2 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n\n@@ -92,7 +92,7 @@ class ClassificationControllerIntTest {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(ClassificationSummaryListResource.class));\n-    assertThat(response.getBody().getContent().size()).isEqualTo(5);\n+    assertThat(response.getBody().getContent()).hasSize(5);\n     assertThat(response.getBody().getContent().iterator().next().key).isEqualTo(\"L1050\");\n     assertThat(response.getBody().getLink(Link.REL_SELF)).isNotNull();\n     assertThat(response.getBody().getLink(Link.REL_SELF).getHref())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2NzA0OQ==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377667049", "bodyText": "Pls use extracting method to have a consistent approach with the other tests", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:27:55Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java", "diffHunk": "@@ -213,52 +212,46 @@ void testCreateClassificationWithParentKeyInDomain_aShouldCreateAClassificationI\n       }\n     }\n \n-    assertEquals(true, foundClassificationCreated);\n+    assertThat(foundClassificationCreated).isTrue();\n   }\n \n   @Test\n   @DirtiesContext\n-  void testReturn400IfCreateClassificationWithIncompatibleParentIdAndKey() throws IOException {\n+  void testReturn400IfCreateClassificationWithIncompatibleParentIdAndKey() {\n     String newClassification =\n         \"{\\\"classificationId\\\":\\\"\\\",\\\"category\\\":\\\"MANUAL\\\",\\\"domain\\\":\\\"DOMAIN_B\\\",\"\n             + \"\\\"key\\\":\\\"NEW_CLASS_P3\\\",\\\"name\\\":\\\"new classification\\\",\"\n             + \"\\\"type\\\":\\\"TASK\\\",\\\"parentId\\\":\\\"CLI:200000000000000000000000000000000015\\\",\"\n             + \"\\\"parentKey\\\":\\\"T2000\\\"}\";\n-\n-    HttpClientErrorException e =\n-        Assertions.assertThrows(\n-            HttpClientErrorException.class,\n-            () ->\n-                template.exchange(\n-                    restHelper.toUrl(Mapping.URL_CLASSIFICATIONS),\n-                    HttpMethod.POST,\n-                    new HttpEntity<>(newClassification, restHelper.getHeaders()),\n-                    ParameterizedTypeReference.forType(ClassificationResource.class)));\n-\n-    assertNotNull(e);\n-    assertEquals(HttpStatus.BAD_REQUEST, e.getStatusCode());\n+    \n+    assertThatThrownBy(\n+        () ->\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_CLASSIFICATIONS),\n+            HttpMethod.POST,\n+            new HttpEntity<>(newClassification, restHelper.getHeaders()),\n+            ParameterizedTypeReference.forType(ClassificationResource.class)))\n+        .isInstanceOf(HttpClientErrorException.class)\n+        .hasFieldOrPropertyWithValue(\"statusCode\", HttpStatus.BAD_REQUEST);", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\nindex a40e41312..f3def5dc2 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/ClassificationControllerIntTest.java\n\n@@ -232,7 +232,8 @@ class ClassificationControllerIntTest {\n             new HttpEntity<>(newClassification, restHelper.getHeaders()),\n             ParameterizedTypeReference.forType(ClassificationResource.class)))\n         .isInstanceOf(HttpClientErrorException.class)\n-        .hasFieldOrPropertyWithValue(\"statusCode\", HttpStatus.BAD_REQUEST);\n+        .extracting(ex -> ((HttpClientErrorException)ex).getStatusCode())\n+          .isEqualTo(HttpStatus.BAD_REQUEST);;\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NjMwNw==", "url": "https://github.com/Taskana/taskana/pull/910#discussion_r377676307", "bodyText": "Pls use the assertThatThrownBy-pattern to be consistent with other tests", "author": "gitgoodjhe", "createdAt": "2020-02-11T14:42:15Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java", "diffHunk": "@@ -47,6 +50,42 @@ void testQueryGroupsByCn() {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertEquals(1, response.getBody().size());\n+    assertThat(response.getBody().size()).isEqualTo(1);\n   }\n+\n+  @Test\n+  void testGetMatches() {\n+    ResponseEntity<List<AccessIdResource>> response =\n+        template.exchange(\n+            restHelper.toUrl(Mapping.URL_ACCESSID) + \"?search-for=ali\",\n+            HttpMethod.GET,\n+            restHelper.defaultRequest(),\n+            ParameterizedTypeReference.forType(AccessIdListResource.class));\n+\n+    List<AccessIdResource> body = response.getBody();\n+    assertThat(body).isNotNull();\n+    assertThat(body.size()).isEqualTo(3);\n+    assertThat(body)\n+        .extracting(AccessIdResource::getName)\n+        .containsExactlyInAnyOrder(\"Tralisch, Thea\", \"Bert, Ali\", \"Mente, Ali\");\n+  }\n+\n+  @Test\n+  void testBadRequestWhenSearchForIsTooShort() {\n+    try {\n+      template.exchange(", "originalCommit": "a82b2bae5509a6c1ee09bfe39159b67a6c70e47e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a94219820188f8152312fb8d6da6836733f964d", "chunk": "diff --git a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\nindex c0753a66a..51019b540 100644\n--- a/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n+++ b/rest/taskana-rest-spring/src/test/java/pro/taskana/rest/AccessIdControllerIntTest.java\n\n@@ -50,7 +51,7 @@ class AccessIdControllerIntTest {\n             HttpMethod.GET,\n             restHelper.defaultRequest(),\n             ParameterizedTypeReference.forType(List.class));\n-    assertThat(response.getBody().size()).isEqualTo(1);\n+    assertThat(response.getBody()).hasSize(1);\n   }\n \n   @Test\n"}}, {"oid": "3a94219820188f8152312fb8d6da6836733f964d", "url": "https://github.com/Taskana/taskana/commit/3a94219820188f8152312fb8d6da6836733f964d", "message": "TSK-1031: formatting issues fixed.", "committedDate": "2020-02-11T15:26:48Z", "type": "commit"}]}