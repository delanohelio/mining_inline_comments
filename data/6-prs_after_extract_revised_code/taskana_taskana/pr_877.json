{"pr_number": 877, "pr_title": "TSK-989 Filter Tasks by planned TimeIntervals (REST)", "pr_createdAt": "2020-01-27T13:26:32Z", "pr_url": "https://github.com/Taskana/taskana/pull/877", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDMyMw==", "url": "https://github.com/Taskana/taskana/pull/877#discussion_r371250323", "bodyText": "please consider making maxTime some kind of constant. also is this somewhere documented within the API documentation? this is like a magic string that suddenly does not need to be a valid timestamp / instant object and still have a meaning.\nPersonally i would just remove this special cases and find a way to give \"null\" or only 1 timestamp such a meaning.", "author": "benjamineckstein", "createdAt": "2020-01-27T13:52:42Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/TaskController.java", "diffHunk": "@@ -330,13 +332,65 @@ private TaskQuery applyFilterParams(TaskQuery taskQuery, MultiValueMap<String, S\n       params.remove(POR_VALUE);\n     }\n \n+    if (params.containsKey(PLANNED)) {\n+\n+      String[] instants = extractCommaSeparatedFields(params.get(PLANNED));\n+\n+      TimeInterval[] timeIntervals = extractTimeIntervals(instants);\n+\n+      taskQuery.plannedWithin(timeIntervals);\n+\n+      params.remove(PLANNED);\n+    }\n+\n     if (LOGGER.isDebugEnabled()) {\n       LOGGER.debug(\"Exit from applyFilterParams(), returning {}\", taskQuery);\n     }\n \n     return taskQuery;\n   }\n \n+  private TimeInterval[] extractTimeIntervals(String[] instants) {\n+\n+    List<TimeInterval> timeIntervalsList = new ArrayList<>();\n+\n+    for (int i = 0; i < instants.length - 1; i += 2) {\n+\n+      TimeInterval timeInterval = determineTimeInterval(instants, i);\n+\n+      if (timeInterval != null) {\n+\n+        timeIntervalsList.add(timeInterval);\n+      }\n+    }\n+\n+    TimeInterval[] timeIntervalArray = new TimeInterval[timeIntervalsList.size()];\n+\n+    TimeInterval[] timeIntervals = timeIntervalsList.toArray(timeIntervalArray);\n+\n+    return timeIntervals;\n+  }\n+\n+  private TimeInterval determineTimeInterval(String[] instants, int i) {\n+\n+    if (!instants[i].equals(\"maxTime\") && !instants[i + 1].equals(\"maxTime\")) {", "originalCommit": "e358972a645b83f84a4180d77b5b935b61725c06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI3OTk3Nw==", "url": "https://github.com/Taskana/taskana/pull/877#discussion_r372279977", "bodyText": "Done. Also, we now offer 2 methods to filter. If one time interval is sufficient, the parameters \"plannedFrom/dueFrom\" and \"plannedTo/dueTo\" can be used. If one of those is left out it is an open time interval (like you suggested). For the other option to use multiple time intervals as filter, the parameter \"planned\" can be used and given an even amount of instants. For open time intervals an \"empty\" string can be used.", "author": "gitgoodjhe", "createdAt": "2020-01-29T09:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4NjA3Nw==", "url": "https://github.com/Taskana/taskana/pull/877#discussion_r372286077", "bodyText": "what happens if someone uses both combinations? -> plannedFrom and planned. Or plannedFrom, plannedTo and planned?\nWhat is the expected & current behaviour? We open a lot of edge cases that need to be defined and handled.", "author": "benjamineckstein", "createdAt": "2020-01-29T09:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI4NzU2MQ==", "url": "https://github.com/Taskana/taskana/pull/877#discussion_r372287561", "bodyText": "There is a check for invalid parameter combos in the new commit. These cases are strictly prohibited, because the time intervals might get overridden otherwise", "author": "gitgoodjhe", "createdAt": "2020-01-29T09:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c5e11dc18fc5b8417f7193c2364dd89e69513799", "chunk": "diff --git a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/TaskController.java b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/TaskController.java\nindex 085427317..afba2a9fb 100644\n--- a/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/TaskController.java\n+++ b/rest/taskana-rest-spring/src/main/java/pro/taskana/rest/TaskController.java\n\n@@ -333,14 +326,40 @@ public class TaskController extends AbstractPagingController {\n     }\n \n     if (params.containsKey(PLANNED)) {\n+      updateTaskQueryWithPlannedOrDueTimeIntervals(taskQuery, params, PLANNED);\n+    }\n+\n+    if (params.containsKey(DUE)) {\n+      updateTaskQueryWithPlannedOrDueTimeIntervals(taskQuery, params, DUE);\n+    }\n+\n+    if (params.containsKey(PLANNED_FROM) && params.containsKey(PLANNED_TO)) {\n+      updateTaskQueryWithPlannedOrDueTimeInterval(taskQuery, params, PLANNED_FROM, PLANNED_TO);\n+\n+    } else if (params.containsKey(PLANNED_FROM) && !params.containsKey(PLANNED_TO)) {\n+\n+      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, PLANNED_FROM);\n+      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, PLANNED_FROM, timeInterval);\n+\n+    } else if (!params.containsKey(PLANNED_FROM) && params.containsKey(PLANNED_TO)) {\n+\n+      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, PLANNED_TO);\n+      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, PLANNED_TO, timeInterval);\n+    }\n+\n+    if (params.containsKey(DUE_FROM) && params.containsKey(DUE_TO)) {\n+      updateTaskQueryWithPlannedOrDueTimeInterval(taskQuery, params, DUE_FROM, DUE_TO);\n \n-      String[] instants = extractCommaSeparatedFields(params.get(PLANNED));\n+    } else if (params.containsKey(DUE_FROM) && !params.containsKey(DUE_TO)) {\n \n-      TimeInterval[] timeIntervals = extractTimeIntervals(instants);\n+      TimeInterval indefiniteTimeInterval = createIndefiniteTimeIntervalFromParam(params, DUE_FROM);\n+      updateTaskQueryWithIndefiniteTimeInterval(\n+          taskQuery, params, DUE_FROM, indefiniteTimeInterval);\n \n-      taskQuery.plannedWithin(timeIntervals);\n+    } else if (!params.containsKey(DUE_FROM) && params.containsKey(DUE_TO)) {\n \n-      params.remove(PLANNED);\n+      TimeInterval timeInterval = createIndefiniteTimeIntervalFromParam(params, DUE_TO);\n+      updateTaskQueryWithIndefiniteTimeInterval(taskQuery, params, DUE_TO, timeInterval);\n     }\n \n     if (LOGGER.isDebugEnabled()) {\n"}}, {"oid": "c5e11dc18fc5b8417f7193c2364dd89e69513799", "url": "https://github.com/Taskana/taskana/commit/c5e11dc18fc5b8417f7193c2364dd89e69513799", "message": "TSK-989 Filter Tasks by planned TimeIntervals (REST)\n\n-Added planned, planned-from and planned-until params in filter list\n-Added due, due-from and due-until params in filter list\n-Implemented needed methods\n-Added Test\n-Updated rest-api.doc\n-Refactored TaskControllerIntTests to use AssertJ", "committedDate": "2020-01-30T09:01:22Z", "type": "commit"}]}