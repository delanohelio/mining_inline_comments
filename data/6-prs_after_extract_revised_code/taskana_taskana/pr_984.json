{"pr_number": 984, "pr_title": "TSK-1143C mismatch between forward and backward calculation between p\u2026", "pr_createdAt": "2020-03-20T16:00:46Z", "pr_url": "https://github.com/Taskana/taskana/pull/984", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxOTYxNA==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396219614", "bodyText": "How can it be that the startTime is null?\nThat parameter is necessary. - Should we throw an exception instead of going to the default?", "author": "mustaphazorgati", "createdAt": "2020-03-23T05:26:42Z", "path": "lib/taskana-core/src/main/java/pro/taskana/common/internal/util/DaysToWorkingDaysConverter.java", "diffHunk": "@@ -74,10 +74,16 @@ public static void setCustomHolidays(List<LocalDate> holidays) {\n   }\n \n   public long convertWorkingDaysToDays(Instant startTime, long numberOfDays) {\n+    if (startTime == null) {", "originalCommit": "7a815271df2c8bbd196b925f9ad04088c55f2a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3NDQwMg==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396374402", "bodyText": "bump", "author": "mustaphazorgati", "createdAt": "2020-03-23T11:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxOTYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkyNjU2MQ==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396926561", "bodyText": "I'll throw an exception if startTime is null.\nWhat do you mean by 'bump' ?", "author": "BerndBreier", "createdAt": "2020-03-24T06:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxOTYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "7e8a9f30c2305810851e4cfe12ccc898a9d4b217", "chunk": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/common/internal/util/DaysToWorkingDaysConverter.java b/lib/taskana-core/src/main/java/pro/taskana/common/internal/util/DaysToWorkingDaysConverter.java\nindex 5f72b3835..dac4330e7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/common/internal/util/DaysToWorkingDaysConverter.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/common/internal/util/DaysToWorkingDaysConverter.java\n\n@@ -75,7 +76,7 @@ public final class DaysToWorkingDaysConverter {\n \n   public long convertWorkingDaysToDays(Instant startTime, long numberOfDays) {\n     if (startTime == null) {\n-      startTime = referenceDate;\n+      throw new SystemException(\"Internal Error: convertWorkingDasToDays was called with a null startTime\");\n     } else if (!startTime.equals(referenceDate)) {\n       refreshReferenceDate(referenceDate);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyMTA3MA==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396221070", "bodyText": "unnecessary parenthesis around the last statement. But doesn't matter :)", "author": "mustaphazorgati", "createdAt": "2020-03-23T05:33:27Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -159,17 +159,53 @@ private TaskImpl updatePlannedDueOnTaskUpdate(\n         Instant planned =\n             (converter.subtractWorkingDaysFromInstant(\n                 newTaskImpl.getDue(), durationPrioHolder.getDuration()));\n-        if (newTaskImpl.getPlanned() != null && !planned.equals(newTaskImpl.getPlanned())) {\n+        // planned may not be the same as newTaskImpl.planned and the request may nevertheless be\n+        // correct.\n+        // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n+        // calculating forward from planned to due will give Tuesday morning as due date, because\n+        // sunday is skipped.\n+        // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n+        // result in a planned date of monday morning which differs from task.planned.\n+        // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n+        // level is not violated and we still must grant the request if the following\n+        // conditions are fulfilled:\n+        // - planned is after newTaskImpl.planned\n+        // - newTaskImpl.planned is not a working day,\n+        // - there is no working day between newTaskImpl.planned and planned.\n+        if (newTaskImpl.getPlanned() != null\n+            && !planned.equals(newTaskImpl.getPlanned())\n+            && (plannedDateViolatesServiceLevel(planned, newTaskImpl.getPlanned()))) {", "originalCommit": "7a815271df2c8bbd196b925f9ad04088c55f2a61", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61ef04985c9795c3559f9c8975c81a834b04e710", "chunk": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 054d5b835..7856d2c5d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n\n@@ -159,51 +159,53 @@ class ServiceLevelHandler {\n         Instant planned =\n             (converter.subtractWorkingDaysFromInstant(\n                 newTaskImpl.getDue(), durationPrioHolder.getDuration()));\n-        // planned may not be the same as newTaskImpl.planned and the request may nevertheless be\n-        // correct.\n-        // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n-        // calculating forward from planned to due will give Tuesday morning as due date, because\n-        // sunday is skipped.\n-        // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n-        // result in a planned date of monday morning which differs from task.planned.\n-        // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n-        // level is not violated and we still must grant the request if the following\n-        // conditions are fulfilled:\n-        // - planned is after newTaskImpl.planned\n-        // - newTaskImpl.planned is not a working day,\n-        // - there is no working day between newTaskImpl.planned and planned.\n-        if (newTaskImpl.getPlanned() != null\n-            && !planned.equals(newTaskImpl.getPlanned())\n-            && (plannedDateViolatesServiceLevel(planned, newTaskImpl.getPlanned()))) {\n-          throw new InvalidArgumentException(\n-              String.format(\n-                  \"Cannot update a task with given planned %s \"\n-                      + \"and due date %s not matching the service level %s.\",\n-                  newTaskImpl.getPlanned(),\n-                  newTaskImpl.getDue(),\n-                  durationPrioHolder.getDuration()));\n-        }\n+        ensureServiceLevelIsNotViolated(newTaskImpl, durationPrioHolder.getDuration(), planned);\n         newTaskImpl.setPlanned(planned);\n       }\n     }\n     return newTaskImpl;\n   }\n \n-  private boolean plannedDateViolatesServiceLevel(\n-      Instant plannedFromBackwardCalculation, Instant taskPlanned) {\n-    if (converter.isWorkingDay(0, taskPlanned)) {\n-      return true;\n-    }\n-    if (taskPlanned.isAfter(plannedFromBackwardCalculation)) {\n-      return true;\n-    }\n-    long days = Duration.between(taskPlanned, plannedFromBackwardCalculation).toDays();\n-    for (long day = 0; day < days; day++) {\n-      if (converter.isWorkingDay(day, taskPlanned)) {\n-        return true;\n+  private void ensureServiceLevelIsNotViolated(\n+      TaskImpl newTaskImpl, Duration duration, Instant planned) throws InvalidArgumentException {\n+    // planned was calculated by subtracting the service level duration from newTaskImpl.due.\n+    // It may not be the same as newTaskImpl.planned and the request may nevertheless be\n+    // correct.\n+    // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n+    // calculating forward from planned to due will give Tuesday morning as due date, because\n+    // sunday is skipped.\n+    // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n+    // result in a planned date of monday morning which differs from task.planned.\n+    // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n+    // level is not violated and we still must grant the request if the following\n+    // conditions are fulfilled:\n+    // - planned is after newTaskImpl.planned\n+    // - newTaskImpl.planned is not a working day,\n+    // - there is no working day between newTaskImpl.planned and planned.\n+    if (newTaskImpl.getPlanned() != null && !newTaskImpl.getPlanned().equals(planned)) {\n+      boolean isServiceLevelViolated = false;\n+      Instant taskPlanned = newTaskImpl.getPlanned();\n+      if (converter.isWorkingDay(0, taskPlanned)) {\n+        isServiceLevelViolated = true;\n+      } else if (taskPlanned.isAfter(planned)) {\n+        isServiceLevelViolated = true;\n+      } else {\n+        long days = Duration.between(taskPlanned, planned).toDays();\n+        for (long day = 0; day < days; day++) {\n+          if (converter.isWorkingDay(day, taskPlanned)) {\n+            isServiceLevelViolated = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (isServiceLevelViolated) {\n+        throw new InvalidArgumentException(\n+            String.format(\n+                \"Cannot update a task with given planned %s \"\n+                    + \"and due date %s not matching the service level %s.\",\n+                newTaskImpl.getPlanned(), newTaskImpl.getDue(), duration));\n       }\n     }\n-    return false;\n   }\n \n   private TaskImpl updatePlannedDueOnCreationOfNewTask(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyMjkzNg==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396222936", "bodyText": "For the sake of readability:\n\nMove this important comment as a JavaDoc comment for the method plannedDateViolatesServiceLevel\ninclude newTaskImpl.getPlanned() != null && !planned.equals(newTaskImpl.getPlanned() into the method plannedDateViolatesServiceLevel (for completeness and reusability)\nMaybe make the method plannedDateViolatesServiceLevel a void return type and let it throw the exception? - I am not sure about this last one\n\nWould this help? What do you think?", "author": "mustaphazorgati", "createdAt": "2020-03-23T05:41:53Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -159,17 +159,53 @@ private TaskImpl updatePlannedDueOnTaskUpdate(\n         Instant planned =\n             (converter.subtractWorkingDaysFromInstant(\n                 newTaskImpl.getDue(), durationPrioHolder.getDuration()));\n-        if (newTaskImpl.getPlanned() != null && !planned.equals(newTaskImpl.getPlanned())) {\n+        // planned may not be the same as newTaskImpl.planned and the request may nevertheless be", "originalCommit": "7a815271df2c8bbd196b925f9ad04088c55f2a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkyNzA0Ng==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396927046", "bodyText": "done", "author": "BerndBreier", "createdAt": "2020-03-24T06:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIyMjkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "61ef04985c9795c3559f9c8975c81a834b04e710", "chunk": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 054d5b835..7856d2c5d 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n\n@@ -159,51 +159,53 @@ class ServiceLevelHandler {\n         Instant planned =\n             (converter.subtractWorkingDaysFromInstant(\n                 newTaskImpl.getDue(), durationPrioHolder.getDuration()));\n-        // planned may not be the same as newTaskImpl.planned and the request may nevertheless be\n-        // correct.\n-        // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n-        // calculating forward from planned to due will give Tuesday morning as due date, because\n-        // sunday is skipped.\n-        // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n-        // result in a planned date of monday morning which differs from task.planned.\n-        // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n-        // level is not violated and we still must grant the request if the following\n-        // conditions are fulfilled:\n-        // - planned is after newTaskImpl.planned\n-        // - newTaskImpl.planned is not a working day,\n-        // - there is no working day between newTaskImpl.planned and planned.\n-        if (newTaskImpl.getPlanned() != null\n-            && !planned.equals(newTaskImpl.getPlanned())\n-            && (plannedDateViolatesServiceLevel(planned, newTaskImpl.getPlanned()))) {\n-          throw new InvalidArgumentException(\n-              String.format(\n-                  \"Cannot update a task with given planned %s \"\n-                      + \"and due date %s not matching the service level %s.\",\n-                  newTaskImpl.getPlanned(),\n-                  newTaskImpl.getDue(),\n-                  durationPrioHolder.getDuration()));\n-        }\n+        ensureServiceLevelIsNotViolated(newTaskImpl, durationPrioHolder.getDuration(), planned);\n         newTaskImpl.setPlanned(planned);\n       }\n     }\n     return newTaskImpl;\n   }\n \n-  private boolean plannedDateViolatesServiceLevel(\n-      Instant plannedFromBackwardCalculation, Instant taskPlanned) {\n-    if (converter.isWorkingDay(0, taskPlanned)) {\n-      return true;\n-    }\n-    if (taskPlanned.isAfter(plannedFromBackwardCalculation)) {\n-      return true;\n-    }\n-    long days = Duration.between(taskPlanned, plannedFromBackwardCalculation).toDays();\n-    for (long day = 0; day < days; day++) {\n-      if (converter.isWorkingDay(day, taskPlanned)) {\n-        return true;\n+  private void ensureServiceLevelIsNotViolated(\n+      TaskImpl newTaskImpl, Duration duration, Instant planned) throws InvalidArgumentException {\n+    // planned was calculated by subtracting the service level duration from newTaskImpl.due.\n+    // It may not be the same as newTaskImpl.planned and the request may nevertheless be\n+    // correct.\n+    // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n+    // calculating forward from planned to due will give Tuesday morning as due date, because\n+    // sunday is skipped.\n+    // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n+    // result in a planned date of monday morning which differs from task.planned.\n+    // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n+    // level is not violated and we still must grant the request if the following\n+    // conditions are fulfilled:\n+    // - planned is after newTaskImpl.planned\n+    // - newTaskImpl.planned is not a working day,\n+    // - there is no working day between newTaskImpl.planned and planned.\n+    if (newTaskImpl.getPlanned() != null && !newTaskImpl.getPlanned().equals(planned)) {\n+      boolean isServiceLevelViolated = false;\n+      Instant taskPlanned = newTaskImpl.getPlanned();\n+      if (converter.isWorkingDay(0, taskPlanned)) {\n+        isServiceLevelViolated = true;\n+      } else if (taskPlanned.isAfter(planned)) {\n+        isServiceLevelViolated = true;\n+      } else {\n+        long days = Duration.between(taskPlanned, planned).toDays();\n+        for (long day = 0; day < days; day++) {\n+          if (converter.isWorkingDay(day, taskPlanned)) {\n+            isServiceLevelViolated = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (isServiceLevelViolated) {\n+        throw new InvalidArgumentException(\n+            String.format(\n+                \"Cannot update a task with given planned %s \"\n+                    + \"and due date %s not matching the service level %s.\",\n+                newTaskImpl.getPlanned(), newTaskImpl.getDue(), duration));\n       }\n     }\n-    return false;\n   }\n \n   private TaskImpl updatePlannedDueOnCreationOfNewTask(\n"}}, {"oid": "61ef04985c9795c3559f9c8975c81a834b04e710", "url": "https://github.com/Taskana/taskana/commit/61ef04985c9795c3559f9c8975c81a834b04e710", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-23T08:10:22Z", "type": "forcePushed"}, {"oid": "86081febf6a0375e44a9b64680e4be9cb1eeeecc", "url": "https://github.com/Taskana/taskana/commit/86081febf6a0375e44a9b64680e4be9cb1eeeecc", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-23T10:57:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3NDIxMg==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396374212", "bodyText": "This is not a JavaDoc ;)", "author": "mustaphazorgati", "createdAt": "2020-03-23T11:13:16Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -159,17 +173,66 @@ private TaskImpl updatePlannedDueOnTaskUpdate(\n         Instant planned =\n             (converter.subtractWorkingDaysFromInstant(\n                 newTaskImpl.getDue(), durationPrioHolder.getDuration()));\n-        if (newTaskImpl.getPlanned() != null && !planned.equals(newTaskImpl.getPlanned())) {\n-          throw new InvalidArgumentException(\n-              \"Cannot update a task with given planned \"\n-                  + \"and due date not matching the service level\");\n-        }\n+        ensureServiceLevelIsNotViolated(newTaskImpl, durationPrioHolder.getDuration(), planned);\n         newTaskImpl.setPlanned(planned);\n+        if (!converter.isWorkingDay(0, newTaskImpl.getDue())) {\n+          newTaskImpl.setDue(getFirstPreceedingWorkingDay(newTaskImpl.getDue()));\n+        }\n       }\n     }\n     return newTaskImpl;\n   }\n \n+  private Instant getFirstPreceedingWorkingDay(Instant due) {\n+    long days = 0;\n+    while (!converter.isWorkingDay(days, due)) {\n+      days--;\n+    }\n+    return due.minus(Duration.ofDays(Math.abs(days)));\n+  }\n+\n+  private void ensureServiceLevelIsNotViolated(\n+      TaskImpl newTaskImpl, Duration duration, Instant planned) throws InvalidArgumentException {\n+    // planned was calculated by subtracting the service level duration from newTaskImpl.due.", "originalCommit": "86081febf6a0375e44a9b64680e4be9cb1eeeecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1NTM1NQ==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396955355", "bodyText": "Now it is javadoc", "author": "BerndBreier", "createdAt": "2020-03-24T07:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3NDIxMg=="}], "type": "inlineReview", "revised_code": {"commit": "8ec4ce6e0b997e4a3bf1540d19bb2ba6be418cd0", "chunk": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 626dcb44b..ac64983e7 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n\n@@ -191,25 +191,28 @@ class ServiceLevelHandler {\n     return due.minus(Duration.ofDays(Math.abs(days)));\n   }\n \n-  private void ensureServiceLevelIsNotViolated(\n-      TaskImpl newTaskImpl, Duration duration, Instant planned) throws InvalidArgumentException {\n-    // planned was calculated by subtracting the service level duration from newTaskImpl.due.\n-    // It may not be the same as newTaskImpl.planned and the request may nevertheless be\n-    // correct.\n-    // Scenario: If task.planned is Saturday morning, and duration is 1 working day, then\n-    // calculating forward from planned to due will give Tuesday morning as due date, because\n-    // sunday is skipped.\n-    // On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n-    // result in a planned date of monday morning which differs from task.planned.\n-    // Therefore, if newTaskImpl.getPlanned is not equal to planned, the service\n-    // level is not violated and we still must grant the request if the following\n-    // conditions are fulfilled:\n-    // - planned is after newTaskImpl.planned\n-    // - newTaskImpl.planned is not a working day,\n-    // - there is no working day between newTaskImpl.planned and planned.\n-    if (newTaskImpl.getPlanned() != null && !newTaskImpl.getPlanned().equals(planned)) {\n+  /**\n+   * Ensure that planned and due of task comply with the associated service level. The 'planned'\n+   * timestamp was calculated by subtracting the service level duration from task.due. It may not be\n+   * the same as task.planned and the request may nevertheless be correct. The following Scenario\n+   * illustrates this: If task.planned is on a Saturday morning, and duration is 1 working day, then\n+   * calculating forward from planned to due will give Tuesday morning as due date, because sunday\n+   * is skipped. On the other hand, calculating from due (Tuesday morning) 1 day backwards will\n+   * result in a planned date of monday morning which differs from task.planned. Therefore, if\n+   * task.getPlanned is not equal to planned, the service level is not violated and we still must\n+   * grant the request if the following conditions are fulfilled: - planned is after task.planned -\n+   * task.planned is not a working day, - there is no working day between task.planned and planned.\n+   *\n+   * @param task the task for the difference between planned and due must be duration\n+   * @param duration the serviceLevel for the task\n+   * @param planned the planned Timestamp thas was calculated based on due and duration\n+   * @throws InvalidArgumentException if service level is violated.\n+   */\n+  private void ensureServiceLevelIsNotViolated(TaskImpl task, Duration duration, Instant planned)\n+      throws InvalidArgumentException {\n+    if (task.getPlanned() != null && !task.getPlanned().equals(planned)) {\n       boolean isServiceLevelViolated = false;\n-      Instant taskPlanned = newTaskImpl.getPlanned();\n+      Instant taskPlanned = task.getPlanned();\n       if (converter.isWorkingDay(0, taskPlanned)) {\n         isServiceLevelViolated = true;\n       } else if (taskPlanned.isAfter(planned)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3NDMzMg==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396374332", "bodyText": "Is this supposed to be an assert? :)", "author": "mustaphazorgati", "createdAt": "2020-03-23T11:13:30Z", "path": "lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java", "diffHunk": "@@ -379,4 +380,37 @@ void testUpdatePlannedAndDue() throws NotAuthorizedException, TaskNotFoundExcept\n     assertThatThrownBy(() -> taskService.updateTask(task))\n         .isInstanceOf(InvalidArgumentException.class);\n   }\n+\n+  @WithAccessId(\n+      userName = \"user_1_2\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testUpdateTaskSetPlannedOrDueToWeekend()\n+      throws NotAuthorizedException, TaskNotFoundException, ClassificationNotFoundException,\n+          InvalidArgumentException, InvalidStateException, ConcurrencyException,\n+          AttachmentPersistenceException {\n+    Task task = taskService.getTask(\"TKI:000000000000000000000000000000000030\"); // SL=P13D\n+    task.setPlanned(getInstant(\"2020-03-21T07:00:00\")); // planned = saturday\n+    task = taskService.updateTask(task);\n+    assertThat(task.getDue()).isEqualTo(getInstant(\"2020-04-09T07:00:00\"));\n+\n+    task.setDue(getInstant(\"2020-04-11T07:00:00\")); // due = saturday\n+    task.setPlanned(null);\n+    task = taskService.updateTask(task);\n+    assertThat(task.getPlanned()).isEqualTo(getInstant(\"2020-03-24T07:00:00\"));\n+\n+    task.setDue(getInstant(\"2020-04-12T07:00:00\")); // due = sunday\n+    task = taskService.updateTask(task);\n+    assertThat(task.getPlanned()).isEqualTo(getInstant(\"2020-03-24T07:00:00\"));\n+\n+    task.setPlanned(getInstant(\"2020-03-21T07:00:00\")); // planned = saturday\n+    task.setDue(getInstant(\"2020-04-09T07:00:00\")); // thursday\n+    task = taskService.updateTask(task);\n+    assertThat(task.getPlanned()).isEqualTo(getInstant(\"2020-03-23T07:00:00\"));\n+\n+    task.setPlanned(getInstant(\"2020-03-03T07:00:00\")); // planned on saturday\n+    task.setDue(getInstant(\"2020-03-22T07:00:00\")); // due = sunday\n+    task = taskService.updateTask(task);\n+    System.out.println(task.getPlanned() + \", \" + task.getDue());", "originalCommit": "86081febf6a0375e44a9b64680e4be9cb1eeeecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MTQ5NQ==", "url": "https://github.com/Taskana/taskana/pull/984#discussion_r396661495", "bodyText": "I missed this. Now there is an assert.", "author": "BerndBreier", "createdAt": "2020-03-23T18:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3NDMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "8ec4ce6e0b997e4a3bf1540d19bb2ba6be418cd0", "chunk": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java\nindex d06ad6742..d11c6c1e0 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/ServiceLevelPriorityAccTest.java\n\n@@ -408,9 +408,9 @@ public class ServiceLevelPriorityAccTest extends AbstractAccTest {\n     task = taskService.updateTask(task);\n     assertThat(task.getPlanned()).isEqualTo(getInstant(\"2020-03-23T07:00:00\"));\n \n-    task.setPlanned(getInstant(\"2020-03-03T07:00:00\")); // planned on saturday\n+    task.setPlanned(getInstant(\"2020-03-03T07:00:00\")); // planned on tuesday\n     task.setDue(getInstant(\"2020-03-22T07:00:00\")); // due = sunday\n     task = taskService.updateTask(task);\n-    System.out.println(task.getPlanned() + \", \" + task.getDue());\n+    assertThat(task.getDue()).isEqualTo(getInstant(\"2020-03-20T07:00:00\")); // friday\n   }\n }\n"}}, {"oid": "8ec4ce6e0b997e4a3bf1540d19bb2ba6be418cd0", "url": "https://github.com/Taskana/taskana/commit/8ec4ce6e0b997e4a3bf1540d19bb2ba6be418cd0", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-23T12:03:16Z", "type": "forcePushed"}, {"oid": "92669c7060ec3c3436437a2c32f15251f98c7677", "url": "https://github.com/Taskana/taskana/commit/92669c7060ec3c3436437a2c32f15251f98c7677", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-23T18:08:15Z", "type": "forcePushed"}, {"oid": "7e8a9f30c2305810851e4cfe12ccc898a9d4b217", "url": "https://github.com/Taskana/taskana/commit/7e8a9f30c2305810851e4cfe12ccc898a9d4b217", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-24T06:33:13Z", "type": "forcePushed"}, {"oid": "365277323ac023acdffef05e4fde653679926b15", "url": "https://github.com/Taskana/taskana/commit/365277323ac023acdffef05e4fde653679926b15", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-24T06:47:59Z", "type": "forcePushed"}, {"oid": "b8a38ce99909025e019bbf4f553c2902237860c7", "url": "https://github.com/Taskana/taskana/commit/b8a38ce99909025e019bbf4f553c2902237860c7", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-24T07:23:56Z", "type": "commit"}, {"oid": "b8a38ce99909025e019bbf4f553c2902237860c7", "url": "https://github.com/Taskana/taskana/commit/b8a38ce99909025e019bbf4f553c2902237860c7", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-24T07:23:56Z", "type": "forcePushed"}]}