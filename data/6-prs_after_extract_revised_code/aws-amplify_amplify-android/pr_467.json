{"pr_number": 467, "pr_title": "[aws-datastore] Refactor SubscriptionProcessor", "pr_createdAt": "2020-05-15T08:12:39Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/467", "timeline": [{"oid": "0f678a49966eac300eb9d21384e52371999aa68e", "url": "https://github.com/aws-amplify/amplify-android/commit/0f678a49966eac300eb9d21384e52371999aa68e", "message": "[aws-datastore] Refactor SubscriptionProcessor\n\nThe logic for the SubscriptionProcessor was split accross an anemic\nclass, the actual SubscriptionProcessor, and then another class called\nRemoteModelMutations. Instead, thisl atter class is combined back into\nthe SubscriptionProcessor.\n\nUnit test coverage is added.\n\nPreviously, the processor would not wait for all of the subscriptions to\nhave been fully established. This resulted in situations where data\ncould be missed on a subscription. To resolve this, wait receipt of a\nsubscription ID before yiedling control of a subscription observable.", "committedDate": "2020-05-15T08:14:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0Mzc5Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/467#discussion_r425843797", "bodyText": "To incorporate, my changes all you would have to do here is:\n        .doOnError(exception -> {\n            LOG.warn(\"An error occurred with the subscription for model \" + clazz.getSimpleName() +\n                \" and operation type \" + subscriptionType.name(), exception.getCause());\n        })\n        .onErrorResumeNext((ObservableSource<GraphQLResponse<ModelWithMetadata<T>>>) Observer::onComplete)\n\nThis basically handles the error by logging it and completing the observable. This prevents the Orchestrator from crashing if there's no API configured or the API is not reachable.\nIf you think it makes sense, we can incorporate this changes here.\nThat's basically what I added in #459", "author": "rjuliano", "createdAt": "2020-05-15T14:33:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessor.java", "diffHunk": "@@ -56,15 +82,47 @@\n      * Start subscribing to model mutations.\n      */\n     void startSubscriptions() {\n-        disposable.add(remoteModelMutations.observe()\n+        Set<Observable<SubscriptionEvent<? extends Model>>> subscriptions = new HashSet<>();\n+        for (Class<? extends Model> clazz : modelProvider.models()) {\n+            for (SubscriptionType subscriptionType : SubscriptionType.values()) {\n+                subscriptions.add(subscriptionObservable(appSync, subscriptionType, clazz));\n+            }\n+        }\n+        disposable.add(Observable.merge(subscriptions)\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n             .subscribe(\n-                mutationOnSubscription -> {\n-                    buffer.onNext(mutationOnSubscription);\n-                    LOG.info(\"Successfully enqueued mutation from subscription: \" + mutationOnSubscription);\n-                },\n-                error -> LOG.warn(\"Error enqueuing mutation from subscription.\", error),\n-                () -> LOG.warn(\"Subscription to remote model mutations is completed.\")\n-            )\n+                buffer::onNext,\n+                buffer::onError,\n+                buffer::onComplete\n+            ));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T extends Model> Observable<SubscriptionEvent<? extends Model>>\n+            subscriptionObservable(AppSync appSync, SubscriptionType subscriptionType, Class<T> clazz) {\n+        return Observable.<GraphQLResponse<ModelWithMetadata<T>>>create(emitter -> {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            SubscriptionMethod method = subscriptionMethodFor(appSync, subscriptionType);\n+            AtomicReference<Cancelable> cancelable = new AtomicReference<>(NoOpCancelable::new);\n+            emitter.setCancellable(cancelable::get);\n+            cancelable.set(method.subscribe(\n+                clazz,\n+                token -> latch.countDown(),\n+                emitter::onNext,\n+                emitter::onError,\n+                emitter::onComplete\n+            ));\n+            latch.await(SUBSCRIPTION_START_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        })", "originalCommit": "0f678a49966eac300eb9d21384e52371999aa68e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1MDM5MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/467#discussion_r425850390", "bodyText": "Java's missing tuple :) I like it. I'll have to remember it's under android.util", "author": "rjuliano", "createdAt": "2020-05-15T14:43:56Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessorTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.syncengine;\n+\n+import android.util.Pair;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.SubscriptionType;\n+import com.amplifyframework.core.Action;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.async.Cancelable;\n+import com.amplifyframework.core.async.NoOpCancelable;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelProvider;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSync;\n+import com.amplifyframework.datastore.appsync.ModelMetadata;\n+import com.amplifyframework.datastore.appsync.ModelWithMetadata;\n+import com.amplifyframework.testmodels.commentsblog.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.random.RandomString;\n+import com.amplifyframework.util.Time;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.robolectric.RobolectricTestRunner;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.Completable;\n+import io.reactivex.Observable;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Tests the {@link SubscriptionProcessor}.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+public final class SubscriptionProcessorTest {\n+    private static final long OPERATION_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(1);\n+\n+    private List<Class<? extends Model>> models;\n+    private AppSync appSync;\n+    private Merger merger;\n+    private SubscriptionProcessor subscriptionProcessor;\n+\n+    /**\n+     * Sets up an {@link SubscriptionProcessor} and associated test dependencies.\n+     * @throws AmplifyException On failure to load model schema registry\n+     */\n+    @Before\n+    public void setup() throws AmplifyException {\n+        ModelProvider modelProvider = AmplifyModelProvider.getInstance();\n+        this.models = sortedModels(modelProvider);\n+        this.appSync = mock(AppSync.class);\n+        this.merger = mock(Merger.class);\n+        this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n+    }\n+\n+    private static List<Class<? extends Model>> sortedModels(ModelProvider modelProvider) throws AmplifyException {\n+        ModelSchemaRegistry modelSchemaRegistry = ModelSchemaRegistry.instance();\n+        modelSchemaRegistry.load(modelProvider.models());\n+        TopologicalOrdering topologicalOrdering =\n+            TopologicalOrdering.forRegisteredModels(modelSchemaRegistry, modelProvider);\n+        Comparator<Class<? extends Model>> comparator = (one, two) -> {\n+            ModelSchema schemaOne = modelSchemaRegistry.getModelSchemaForModelClass(one.getSimpleName());\n+            ModelSchema schemaTwo = modelSchemaRegistry.getModelSchemaForModelClass(two.getSimpleName());\n+            return topologicalOrdering.compare(schemaOne, schemaTwo);\n+        };\n+        List<Class<? extends Model>> models = new ArrayList<>(modelProvider.models());\n+        Collections.sort(models, comparator);\n+        return models;\n+    }\n+\n+    /**\n+     * When {@link SubscriptionProcessor#startSubscriptions()} is invoked,\n+     * the {@link AppSync} client receives subscription requests.\n+     */\n+    @Test\n+    public void appSyncInvokedWhenSubscriptionsStarted() {\n+        arrangeStartedSubscriptions(appSync, models, SubscriptionType.values());\n+\n+        // Act: start some subscriptions.\n+        subscriptionProcessor.startSubscriptions();\n+\n+        // Validate that a request was made to create a subscription for each model and subscription pair\n+        verifySubscriptions(appSync, models, SubscriptionType.values());\n+    }\n+\n+    /**\n+     * When {@link SubscriptionProcessor#startDrainingMutationBuffer()} is called, then the\n+     * {@link Merger} is invoked to begin merging whatever content has shown up on the subscriptions.\n+     * @throws DataStoreException On failure to arrange mocking\n+     * @throws InterruptedException On failure to await latch\n+     */\n+    @Test\n+    public void dataMergedWhenBufferDrained() throws DataStoreException, InterruptedException {\n+        // By default, start the subscriptions up.\n+        arrangeStartedSubscriptions(appSync, models, SubscriptionType.values());\n+\n+        // Arrange some subscription data\n+        BlogOwner model = BlogOwner.builder()\n+            .name(\"John P. Stetson, Jr.\")\n+            .build();\n+        ModelMetadata modelMetadata = new ModelMetadata(model.getId(), false, 1, Time.now());\n+        ModelWithMetadata<BlogOwner> modelWithMetadata = new ModelWithMetadata<>(model, modelMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> response = new GraphQLResponse<>(modelWithMetadata, null);\n+        arrangeDataEmittingSubscription(appSync, BlogOwner.class, SubscriptionType.ON_CREATE, response);\n+\n+        // Merge will be invoked for the subcription data, when we start draining...\n+        CountDownLatch latch = new CountDownLatch(1);\n+        doAnswer(invocation -> {\n+            latch.countDown();\n+            return Completable.complete();\n+        }).when(merger).merge(eq(modelWithMetadata));\n+\n+        // Start draining....\n+        subscriptionProcessor.startSubscriptions();\n+        subscriptionProcessor.startDrainingMutationBuffer();\n+\n+        // Was the data merged?\n+        assertTrue(latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS));\n+    }\n+\n+    @SuppressWarnings(\"SameParameterValue\")\n+    private static <T extends Model> void arrangeDataEmittingSubscription(\n+            AppSync appSync,\n+            Class<T> clazz,\n+            SubscriptionType subscriptionType,\n+            GraphQLResponse<ModelWithMetadata<T>> response) throws DataStoreException {\n+        Answer<Cancelable> answer = invocation -> {\n+            final int startConsumerIndex = 1;\n+            Consumer<String> onStart = invocation.getArgument(startConsumerIndex);\n+            onStart.accept(RandomString.string());\n+\n+            final int dataConsumerIndex = 2;\n+            Consumer<GraphQLResponse<ModelWithMetadata<T>>> onData = invocation.getArgument(dataConsumerIndex);\n+            onData.accept(response);\n+\n+            return new NoOpCancelable();\n+        };\n+        arrangeSubscription(appSync, answer, clazz, subscriptionType);\n+    }\n+\n+    private static void arrangeStartedSubscriptions(\n+        AppSync appSync, List<Class<? extends Model>> classes, SubscriptionType[] subscriptionTypes) {\n+        Answer<Cancelable> answer = invocation -> {\n+            final int startConsumerIndex = 1;\n+            Consumer<String> onStart = invocation.getArgument(startConsumerIndex);\n+            onStart.accept(RandomString.string());\n+            return new NoOpCancelable();\n+        };\n+        arrangeSubscriptions(appSync, answer, classes, subscriptionTypes);\n+    }\n+\n+    private static void arrangeSubscriptions(\n+            AppSync appSync,\n+            Answer<Cancelable> answer,\n+            List<Class<? extends Model>> classes,\n+            SubscriptionType[] subscriptionTypes) {\n+        Observable.fromIterable(classes)\n+            .flatMap(modelClass -> Observable.fromArray(subscriptionTypes)\n+                .map(subscriptionType -> Pair.create(modelClass, subscriptionType)))\n+            .blockingForEach(pair -> arrangeSubscription(appSync, answer, pair.first, pair.second));\n+    }\n+\n+    private static <T extends Model> void arrangeSubscription(\n+            AppSync appSync, Answer<Cancelable> answer, Class<T> clazz, SubscriptionType subscriptionType)\n+            throws DataStoreException {\n+        AppSync stub = doAnswer(answer).when(appSync);\n+        SubscriptionProcessor.SubscriptionMethod method =\n+            SubscriptionProcessor.subscriptionMethodFor(stub, subscriptionType);\n+        method.subscribe(eq(clazz), anyConsumer(), anyConsumer(), anyConsumer(), anyAction());\n+    }\n+\n+    private static void verifySubscriptions(\n+            AppSync appSync, List<Class<? extends Model>> classes, SubscriptionType[] subscriptionTypes) {\n+        Observable.fromIterable(classes)\n+            .flatMap(modelClass -> Observable.fromArray(subscriptionTypes)\n+                .map(subscriptionType -> Pair.create(modelClass, subscriptionType)))", "originalCommit": "0f678a49966eac300eb9d21384e52371999aa68e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad00bc790103cb8e16d9e66f97f3adaf2bf76f3a", "chunk": "diff --git a/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessorTest.java b/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessorTest.java\nindex 6576d2fa..c40aa264 100644\n--- a/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessorTest.java\n+++ b/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SubscriptionProcessorTest.java\n\n@@ -46,7 +46,9 @@ import org.robolectric.RobolectricTestRunner;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"oid": "ad00bc790103cb8e16d9e66f97f3adaf2bf76f3a", "url": "https://github.com/aws-amplify/amplify-android/commit/ad00bc790103cb8e16d9e66f97f3adaf2bf76f3a", "message": "[aws-datastore] Refactor SubscriptionProcessor\n\nThe logic for the SubscriptionProcessor was split accross an anemic\nclass, the actual SubscriptionProcessor, and then another class called\nRemoteModelMutations. Instead, thisl atter class is combined back into\nthe SubscriptionProcessor.\n\nUnit test coverage is added.\n\nPreviously, the processor would not wait for all of the subscriptions to\nhave been fully established. This resulted in situations where data\ncould be missed on a subscription. To resolve this, wait receipt of a\nsubscription ID before yiedling control of a subscription observable.", "committedDate": "2020-05-15T16:16:50Z", "type": "commit"}, {"oid": "ad00bc790103cb8e16d9e66f97f3adaf2bf76f3a", "url": "https://github.com/aws-amplify/amplify-android/commit/ad00bc790103cb8e16d9e66f97f3adaf2bf76f3a", "message": "[aws-datastore] Refactor SubscriptionProcessor\n\nThe logic for the SubscriptionProcessor was split accross an anemic\nclass, the actual SubscriptionProcessor, and then another class called\nRemoteModelMutations. Instead, thisl atter class is combined back into\nthe SubscriptionProcessor.\n\nUnit test coverage is added.\n\nPreviously, the processor would not wait for all of the subscriptions to\nhave been fully established. This resulted in situations where data\ncould be missed on a subscription. To resolve this, wait receipt of a\nsubscription ID before yiedling control of a subscription observable.", "committedDate": "2020-05-15T16:16:50Z", "type": "forcePushed"}]}