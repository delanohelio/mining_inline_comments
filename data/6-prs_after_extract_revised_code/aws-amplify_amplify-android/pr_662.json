{"pr_number": 662, "pr_title": "fix: start orchestrator before any datastore operations", "pr_createdAt": "2020-07-23T06:05:30Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/662", "timeline": [{"oid": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "url": "https://github.com/aws-amplify/amplify-android/commit/d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "message": "Daemon-style orchestrator logic\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. The orchestrator is worked into a kernel driver / system daemon style\n   init / teardown component. Init and teardown are idempotent. If init\n   fails at any point, teardown knows how to cleanup from that point.\n\n3. The orchestrator is changed to use a state machine, with three\n   states:\n\n   a. STOPPED      No sync component is running, and local changes are not\n                   being queued into an offline mutations queue.\n   b. LOCAL_ONLY   Local changes are being buffered into an offline\n                   mutations queue, but are not being transacte with the\n                   cloud\n   c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\n   Logic is added to transition safely between any pair of these states\n   (there are six possible transitions.)\n\n4. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n5. The Orchestrator will atempt to reach the desired target state\n   (LOCAL_ONLY or SYNC_VIA_API) again, before any call to the client\n   DataStore APIs. One guarantee is that the storage observer will be\n   active before the user's data reaches the database. This way, it will\n   deterministically be included into the offline mutations queue. If\n   the target state is SYNC_VIA_API, the initialization continues in the\n   background.\n\nFuture work will further address transient network failures. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle as a whole will be retried. When the network\ngoes down, or when auth fails -- any transient failure -- should result\nin the Orchestrator backing off into LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.", "committedDate": "2020-07-24T06:27:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460272744", "bodyText": "One issue I ran into here was that if I add the DataStore plugin before the API plugin, the Orchestrator goes into LOCAL_ONLY mode:\n// Starts in LOCAL_ONLY\n Amplify.addPlugin(AWSDataStorePlugin())\nAmplify.addPlugin(AWSApiPlugin())\n\nas compared to:\n// Starts in SYNC_VIA_API\nAmplify.addPlugin(AWSApiPlugin())\nAmplify.addPlugin(AWSDataStorePlugin())\n\nIt's kind of a similar situation that we ran into for pluginConfiguration, where we ended up going with a provider-style configuration to delay evaluation of the expression.", "author": "rjuliano", "createdAt": "2020-07-24T20:28:28Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -75,34 +74,28 @@\n     // Keeps track of whether of not the category is initialized yet\n     private final CountDownLatch categoryInitializationsPending;\n \n-    private final AtomicBoolean isOrchestratorReady;\n-\n-    // Used to interrogate plugins, to understand if sync should be automatically turned on\n-    private final ApiCategory api;\n-\n     // User-provided configuration for the plugin.\n     private final DataStoreConfiguration userProvidedConfiguration;\n \n     // Configuration for the plugin that contains settings from the JSON file plus any\n     // overrides provided via the userProvidedConfiguration\n     private DataStoreConfiguration pluginConfiguration;\n \n-    @SuppressLint(\"CheckResult\")\n     private AWSDataStorePlugin(\n             @NonNull ModelProvider modelProvider,\n             @NonNull ModelSchemaRegistry modelSchemaRegistry,\n             @NonNull ApiCategory api,\n             @Nullable DataStoreConfiguration userProvidedConfiguration) {\n         this.sqliteStorageAdapter = SQLiteStorageAdapter.forModels(modelSchemaRegistry, modelProvider);\n         this.categoryInitializationsPending = new CountDownLatch(1);\n-        this.isOrchestratorReady = new AtomicBoolean(false);\n-        this.api = api;\n+        // Used to interrogate plugins, to understand if sync should be automatically turned on\n         this.orchestrator = new Orchestrator(\n             modelProvider,\n             modelSchemaRegistry,\n             sqliteStorageAdapter,\n             AppSyncClient.via(api),\n-            () -> pluginConfiguration\n+            () -> pluginConfiguration,\n+            api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API", "originalCommit": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4ODk0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460288943", "bodyText": "Ahhh, yup, absolutely. Great catch.", "author": "jamesonwilliams", "createdAt": "2020-07-24T21:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "a6e3845b490998b9b6944a515b35e59c538469ea", "chunk": "diff --git a/aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java b/aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java\nindex 363036b5..0257e657 100644\n--- a/aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java\n+++ b/aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java\n\n@@ -95,7 +95,7 @@ public final class AWSDataStorePlugin extends DataStorePlugin<Void> {\n             sqliteStorageAdapter,\n             AppSyncClient.via(api),\n             () -> pluginConfiguration,\n-            api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API\n+            () -> api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API\n         );\n         this.userProvidedConfiguration = userProvidedConfiguration;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460837034", "bodyText": "Need a blank line.", "author": "rjuliano", "createdAt": "2020-07-27T11:54:56Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "originalCommit": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4MjQyMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461082420", "bodyText": "Thanks!", "author": "jamesonwilliams", "createdAt": "2020-07-27T18:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA=="}], "type": "inlineReview", "revised_code": {"commit": "a6e3845b490998b9b6944a515b35e59c538469ea", "chunk": "diff --git a/aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java b/aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java\nindex 94c7f39e..387dd817 100644\n--- a/aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java\n+++ b/aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java\n\n@@ -109,6 +111,7 @@ public final class Orchestrator {\n         this.currentMode = new AtomicReference<>(Mode.STOPPED);\n         this.targetMode = targetMode;\n         this.disposables = new CompositeDisposable();\n+        this.startStopScheduler = Schedulers.single();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzODI5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460838294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Orchestrator.Mode.SYNC_VIA_API\n          \n          \n            \n                            () -> Orchestrator.Mode.SYNC_VIA_API", "author": "rjuliano", "createdAt": "2020-07-27T11:57:25Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -84,15 +84,17 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n                 modelSchemaRegistry,\n                 localStorageAdapter,\n                 appSync,\n-                DataStoreConfiguration::defaults\n+                DataStoreConfiguration::defaults,\n+                Orchestrator.Mode.SYNC_VIA_API", "originalCommit": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a6e3845b490998b9b6944a515b35e59c538469ea", "chunk": "diff --git a/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java b/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java\nindex 80c7ddd2..6698af0c 100644\n--- a/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java\n+++ b/aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java\n\n@@ -85,7 +96,7 @@ public final class OrchestratorTest {\n                 localStorageAdapter,\n                 appSync,\n                 DataStoreConfiguration::defaults,\n-                Orchestrator.Mode.SYNC_VIA_API\n+                () -> Orchestrator.Mode.SYNC_VIA_API\n             );\n \n         // Arrange: orchestrator is running\n"}}, {"oid": "a6e3845b490998b9b6944a515b35e59c538469ea", "url": "https://github.com/aws-amplify/amplify-android/commit/a6e3845b490998b9b6944a515b35e59c538469ea", "message": "fix: daemon style lifecycle for orchestrator\n\nThe state machine in the orchestrator is changed. The three possible\nstates are now:\n\n  a. STOPPED      No sync component is running, and local changes are not\n                  being queued into an offline mutations queue.\n  b. LOCAL_ONLY   Local changes are being buffered into an offline\n                  mutations queue, but are not being transacte with the\n                  cloud\n  c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\nLogic is added to transition safely between any pair of these states\n(there are six possible transitions.)\n\nIf the Orchestrator fails to start up cleanly, then tear down any/all\ncopmonents that were started, and enter offline-only mode.\n\n0. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. Surface exceptions from the hydrate() call on the SyncProcessor. This\n   way, if the sync fails, the orchestrator will catch the exception,\n   and begin a graceful shutdown sequence.\n\nSome changes amde in the test code include:\n\n0. Mock AppSync behaviors in the OrchestratorTest. Previously, the\n   subcription code was not being included in the test. Once exercised,\n   it became necessarily to fulfill the missing mocks.\n\n1. Start listening for HubEvents in AWSDataStorePluginTest _before_ they\n   will be published. This will help to ensure we always can catch them,\n   in th tests.\n\n2. Since the SyncEngine errors are no longer gobbled, the behavior of\n   userProvidedErrorCallbackInvokedOnFailure has changed. We now\n   expect only a single call to the user-provided error callback,\n   instead of _many_ consecutives ones, as before.\n\n3. Add a version of Latch#await(int, TimeUnit) which allows a custom\n   wait time to be provided. This is useful in the orchestrator code,\n   where longer-than-usual timeouts are encountered.\n\nFuture work will address transient network failures, further. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle *as a whole* should be retried. When the\nnetwork goes down, or when auth fails -- any transient failure -- the\nOrchestrator should back off and enter LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/636", "committedDate": "2020-07-29T22:24:07Z", "type": "commit"}, {"oid": "a6e3845b490998b9b6944a515b35e59c538469ea", "url": "https://github.com/aws-amplify/amplify-android/commit/a6e3845b490998b9b6944a515b35e59c538469ea", "message": "fix: daemon style lifecycle for orchestrator\n\nThe state machine in the orchestrator is changed. The three possible\nstates are now:\n\n  a. STOPPED      No sync component is running, and local changes are not\n                  being queued into an offline mutations queue.\n  b. LOCAL_ONLY   Local changes are being buffered into an offline\n                  mutations queue, but are not being transacte with the\n                  cloud\n  c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\nLogic is added to transition safely between any pair of these states\n(there are six possible transitions.)\n\nIf the Orchestrator fails to start up cleanly, then tear down any/all\ncopmonents that were started, and enter offline-only mode.\n\n0. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. Surface exceptions from the hydrate() call on the SyncProcessor. This\n   way, if the sync fails, the orchestrator will catch the exception,\n   and begin a graceful shutdown sequence.\n\nSome changes amde in the test code include:\n\n0. Mock AppSync behaviors in the OrchestratorTest. Previously, the\n   subcription code was not being included in the test. Once exercised,\n   it became necessarily to fulfill the missing mocks.\n\n1. Start listening for HubEvents in AWSDataStorePluginTest _before_ they\n   will be published. This will help to ensure we always can catch them,\n   in th tests.\n\n2. Since the SyncEngine errors are no longer gobbled, the behavior of\n   userProvidedErrorCallbackInvokedOnFailure has changed. We now\n   expect only a single call to the user-provided error callback,\n   instead of _many_ consecutives ones, as before.\n\n3. Add a version of Latch#await(int, TimeUnit) which allows a custom\n   wait time to be provided. This is useful in the orchestrator code,\n   where longer-than-usual timeouts are encountered.\n\nFuture work will address transient network failures, further. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle *as a whole* should be retried. When the\nnetwork goes down, or when auth fails -- any transient failure -- the\nOrchestrator should back off and enter LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/636", "committedDate": "2020-07-29T22:24:07Z", "type": "forcePushed"}]}