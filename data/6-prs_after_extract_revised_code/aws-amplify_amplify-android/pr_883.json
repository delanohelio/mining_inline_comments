{"pr_number": 883, "pr_title": "feature(aws-datastore): handle mutation conflicts", "pr_createdAt": "2020-10-07T07:49:21Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/883", "timeline": [{"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called.", "committedDate": "2020-10-08T10:25:34Z", "type": "commit"}, {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called.", "committedDate": "2020-10-08T10:25:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjkxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501716916", "bodyText": "\ud83e\udd2f", "author": "rjuliano", "createdAt": "2020-10-08T13:23:51Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f501a891a4f6befb36a838354f1e123d11d04175", "chunk": "diff --git a/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java b/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\nindex b48b6f9c..8201271f 100644\n--- a/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\n+++ b/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\n\n@@ -15,8 +15,6 @@\n \n package com.amplifyframework.datastore.appsync;\n \n-import androidx.core.util.ObjectsCompat;\n-\n import com.amplifyframework.api.graphql.GraphQLRequest;\n import com.amplifyframework.api.graphql.GraphQLResponse;\n import com.amplifyframework.api.graphql.PaginatedResult;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NDA3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501754072", "bodyText": "How about we move this inside of AppSyncExtensions and just make the getter return the enum?\nInstead of this current code:\npublic String getErrorType() {\n    return errorType;\n}\n\ndo something like:\npublic AppSyncErrorType getErrorType() {\n    return AppSyncErrorType.fromErrorType(errorType);\n}", "author": "richardmcclellan", "createdAt": "2020-10-08T14:12:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.util.Empty;\n+import com.amplifyframework.util.GsonFactory;\n+import com.amplifyframework.util.TypeMaker;\n+\n+import com.google.gson.Gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * It is possible for the client and server to have two copies of one logical entity,\n+ * each containing different contents, but each believing that it is the latest\n+ * copy of the data. When the client tries to mutate the server's data, AppSync's response\n+ * may contain a GraphQLError with errorType as ConflictUnhandled.\n+ *\n+ * This ConflictUnhandledError class models that response data.\n+ *\n+ * @param <T> Type of model for which a conflict occurred between client & server versions.\n+ * @see <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\">\n+ *     AppSync Conflict Detection & Sync Errors\n+ *     </a>\n+ */\n+public final class ConflictUnhandledError<T extends Model> {\n+    private final ModelWithMetadata<T> serverVersion;\n+\n+    private ConflictUnhandledError(ModelWithMetadata<T> serverVersion) {\n+        this.serverVersion = serverVersion;\n+    }\n+\n+    /**\n+     * Iterates over a list of GraphQL.Error, checking to see if any of them\n+     * contain 'ConflictUnhandled' as the errorType.\n+     * @param typeOfConflictingData The class of the model experiencing conflict\n+     * @param errors A list of GraphQL errors, as received in response to a mutation\n+     * @param <T> The type of model experiencing conflict, if applicable\n+     * @return A model of the first ConflictUnhandled error found in the GraphQL error list.\n+     *         If there is no ConflictUnhandledError in the list, returns null.\n+     */\n+    @Nullable\n+    public static <T extends Model> ConflictUnhandledError<T> findFirst(\n+            @NonNull Class<T> typeOfConflictingData,\n+            @Nullable List<GraphQLResponse.Error> errors) {\n+        if (Empty.check(errors)) {\n+            return null;\n+        }\n+\n+        Gson gson = GsonFactory.instance();\n+\n+        for (GraphQLResponse.Error error : errors) {\n+            if (Empty.check(error.getExtensions())) {\n+                continue;\n+            }\n+\n+            AppSyncExtensions appSyncExtensions = new AppSyncExtensions(error.getExtensions());\n+            AppSyncErrorType errorType = AppSyncErrorType.fromErrorType(appSyncExtensions.getErrorType());", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NDQ1NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501854455", "bodyText": "Good call. I will do this.", "author": "jamesonwilliams", "createdAt": "2020-10-08T16:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NDA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f501a891a4f6befb36a838354f1e123d11d04175", "chunk": "diff --git a/aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java b/aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java\nindex 3b1c8ced..12252e67 100644\n--- a/aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java\n+++ b/aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java\n\n@@ -75,8 +75,7 @@ public final class ConflictUnhandledError<T extends Model> {\n             }\n \n             AppSyncExtensions appSyncExtensions = new AppSyncExtensions(error.getExtensions());\n-            AppSyncErrorType errorType = AppSyncErrorType.fromErrorType(appSyncExtensions.getErrorType());\n-            if (!AppSyncErrorType.CONFLICT_UNHANDLED.equals(errorType)) {\n+            if (!AppSyncExtensions.AppSyncErrorType.CONFLICT_UNHANDLED.equals(appSyncExtensions.getErrorType())) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3OTU2NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501779564", "bodyText": "Ick... so what's the issue exactly for needing this workaround?", "author": "richardmcclellan", "createdAt": "2020-10-08T14:45:14Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.\n+ */\n+public final class AppSyncMockingTest {\n+    private static final long TIMEOUT_SECONDS = 2;\n+\n+    private AppSync appSync;\n+\n+    /**\n+     * Sets up an AppSync mock.\n+     */\n+    @Before\n+    public void setup() {\n+        this.appSync = mock(AppSync.class);\n+    }\n+\n+    /**\n+     * When mockFailure() is called on the SyncConfigurator, the AppSync mock\n+     * will emit the provided failure.\n+     * @throws DataStoreException On failure to get a SyncConfigurator via sync()\n+     */\n+    @Test\n+    public void mockFailureForSync() throws DataStoreException {\n+        DataStoreException failure = new DataStoreException(\"Foo\", \"Bar\");\n+        AppSyncMocking.sync(appSync).mockFailure(failure);\n+\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+        Single\n+            .create(emitter -> appSync.sync(request, emitter::onSuccess, emitter::onError))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertError(failure);\n+    }\n+\n+    /**\n+     * The {@link SyncConfigurator#mockSuccessResponse(Class, ModelWithMetadata[])}\n+     * method allows you to configure a collection of {@link ModelWithMetadata} to be\n+     * included in a successful {@link GraphQLResponse}, emitted from the\n+     * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)} operation.\n+     * @throws DataStoreException On failure to configure the mock behavior\n+     */\n+    @Test\n+    public void mockSuccessResponsesForSync() throws DataStoreException {\n+        // Act: configure the mock\n+        AppSyncMocking.sync(appSync)\n+            .mockSuccessResponse(BlogOwner.class, StrawMen.JOE, StrawMen.TONY);\n+\n+        // Build a request object. This will itself test the mockSuccessResponse(),\n+        // since that method configures this call to return a meaningful result.\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+\n+        // Lastly, when we actually call sync, we should see the expected response,\n+        // As a result of the mockSuccessResponse() on the AppSyncMocking.\n+        Single\n+            .<GraphQLResponse<PaginatedResult<ModelWithMetadata<BlogOwner>>>>create(emitter ->\n+                appSync.sync(request, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete()\n+            // TODO: response items change order. Why?\n+            .assertValue(response -> {\n+                if (response.hasErrors() || !response.hasData()) {\n+                    return false;\n+                }\n+                return Observable.fromIterable(response.getData().getItems())\n+                    .toList()\n+                    .map(HashSet::new)\n+                    .blockingGet()\n+                    .equals(new HashSet<>(Arrays.asList(StrawMen.JOE, StrawMen.TONY)));\n+            });\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will return a successful creation response\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockSuccessResponseForCreate() {\n+        AppSyncMocking.create(appSync).mockSuccessResponse(StrawMen.JOE_MODEL);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(StrawMen.JOE, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will emit a response containing the provided GraphQL errors\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockErrorResponseForCreate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.create(appSync).mockErrorResponse(StrawMen.JOE_MODEL, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the UpdateConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its update() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForUpdate() {\n+        AppSyncMocking.update(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata updatedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), false, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithUpdatedMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, updatedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithUpdatedMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.TONY_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * mockErrorResponse() on the UpdateConfigurator will prepare the\n+     * bound AppSync instance to return an error response whenever\n+     * its update() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForUpdate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.update(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.JOE_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForDelete() {\n+        AppSyncMocking.delete(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata deletedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), true, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithDeleteMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, deletedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithDeleteMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.delete(\n+                    BlogOwner.class,\n+                    StrawMen.TONY_MODEL.getId(),\n+                    1,\n+                    MatchAllQueryPredicate.instance(),\n+                    emitter::onSuccess,\n+                    emitter::onError\n+                )\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will be configured to emit an error\n+     * response whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForDelete() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.delete(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .create(emitter -> appSync.delete(\n+                BlogOwner.class,\n+                StrawMen.JOE_MODEL.getId(),\n+                1,\n+                MatchAllQueryPredicate.instance(),\n+                emitter::onSuccess,\n+                emitter::onError\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for creations events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnCreate() {\n+        AppSyncMocking.onCreate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onCreate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for update events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnUpdate() {\n+        AppSyncMocking.onUpdate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onUpdate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for delete events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnDelete() {\n+        AppSyncMocking.onDelete(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onDelete(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    private static Predicate<GraphQLResponse<ModelWithMetadata<BlogOwner>>> equalsRelaxingTimestamp(\n+            GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse) {\n+        return response -> {\n+            if (!ObjectsCompat.equals(expectedResponse.getErrors(), response.getErrors())) {\n+                return false;\n+            }\n+            ModelWithMetadata<BlogOwner> expectedMwm = expectedResponse.getData();\n+            ModelWithMetadata<BlogOwner> mwm = response.getData();\n+            return equalsRelaxingTimestamp(expectedMwm).test(mwm);\n+        };\n+    }\n+\n+    private static Predicate<ModelWithMetadata<BlogOwner>> equalsRelaxingTimestamp(", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NDA1Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501854052", "bodyText": "In AppSyncMocking, I have a couple of flavors of the mockSuccessResponse(...) which internally create their own Temporal.Timestamp.now(). (So, I can't know what it is, outside, in this unit test.)\nHowever, I just realized that I could test the other flavors of mockSuccessResponse(...), instead -- the ones that will allow me to supply a known timestamp. That would get rid of these kludges and clean things up quite a bit. I'll do that.", "author": "jamesonwilliams", "createdAt": "2020-10-08T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3OTU2NA=="}], "type": "inlineReview", "revised_code": {"commit": "f501a891a4f6befb36a838354f1e123d11d04175", "chunk": "diff --git a/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java b/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\nindex b48b6f9c..8201271f 100644\n--- a/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\n+++ b/aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java\n\n@@ -15,8 +15,6 @@\n \n package com.amplifyframework.datastore.appsync;\n \n-import androidx.core.util.ObjectsCompat;\n-\n import com.amplifyframework.api.graphql.GraphQLRequest;\n import com.amplifyframework.api.graphql.GraphQLResponse;\n import com.amplifyframework.api.graphql.PaginatedResult;\n"}}, {"oid": "f501a891a4f6befb36a838354f1e123d11d04175", "url": "https://github.com/aws-amplify/amplify-android/commit/f501a891a4f6befb36a838354f1e123d11d04175", "message": "FIXUP: address PR feedback from Richard", "committedDate": "2020-10-08T17:21:24Z", "type": "commit"}, {"oid": "2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "url": "https://github.com/aws-amplify/amplify-android/commit/2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "message": "Merge remote-tracking branch 'origin/main' into conflict_handler", "committedDate": "2020-10-08T17:26:37Z", "type": "commit"}]}