{"pr_number": 1001, "pr_title": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans", "pr_createdAt": "2020-04-03T17:07:07Z", "pr_url": "https://github.com/apple/servicetalk/pull/1001", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MDA0OQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403190049", "bodyText": "We do not use Optional anywhere else, can we make localAddress @Nullable instead?", "author": "NiteshKant", "createdAt": "2020-04-03T17:48:34Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -164,29 +84,7 @@ public Builder collectorAddress(SocketAddress collectorAddress) {\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = localAddress;\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the format.\n-         *\n-         * @param encoder the {@link Encoder} to use.\n-         * @return this.\n-         */\n-        public Builder encoder(Encoder encoder) {\n-            this.encoder = requireNonNull(encoder);\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the transport.\n-         *\n-         * @param transport the {@link Transport} to use.\n-         * @return this.\n-         */\n-        public Builder protocol(Transport transport) {\n-            this.transport = requireNonNull(transport);\n+            this.localAddress = Optional.of(requireNonNull(localAddress));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -84,25 +82,26 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, Closeab\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = Optional.of(requireNonNull(localAddress));\n+            this.localAddress = requireNonNull(localAddress);\n             return this;\n         }\n \n         /**\n-         * Note that this may block while the underlying channel is bound/connected.\n-         * @return An interface which can publish tracing data using the zipkin API.\n+         * Builds the ZipkinPublisher with supplied options.\n+         *\n+         * @return A ZipkinPublisher which can publish tracing data using the zipkin Reporter API.\n          */\n         public ZipkinPublisher build() {\n-            if (reporter == null) {\n-                reporter = new LoggingReporter();\n-            }\n             return new ZipkinPublisher(serviceName, reporter, localAddress);\n         }\n+\n     }\n \n-    private static Endpoint buildEndpoint(String serviceName, Optional<InetSocketAddress> localSocketAddress) {\n+    private static Endpoint buildEndpoint(String serviceName, @Nullable InetSocketAddress localSocketAddress) {\n         final Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n-        localSocketAddress.ifPresent(address -> builder.ip(address.getAddress()).port(address.getPort()));\n+        if (localSocketAddress != null) {\n+            builder.ip(localSocketAddress.getAddress()).port(localSocketAddress.getPort());\n+        }\n         return builder.build();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MjMxNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403192316", "bodyText": "Javadocs on this method are outdated as we do not create a channel here.", "author": "NiteshKant", "createdAt": "2020-04-03T17:51:00Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -84,25 +82,26 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, Closeab\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = Optional.of(requireNonNull(localAddress));\n+            this.localAddress = requireNonNull(localAddress);\n             return this;\n         }\n \n         /**\n-         * Note that this may block while the underlying channel is bound/connected.\n-         * @return An interface which can publish tracing data using the zipkin API.\n+         * Builds the ZipkinPublisher with supplied options.\n+         *\n+         * @return A ZipkinPublisher which can publish tracing data using the zipkin Reporter API.\n          */\n         public ZipkinPublisher build() {\n-            if (reporter == null) {\n-                reporter = new LoggingReporter();\n-            }\n             return new ZipkinPublisher(serviceName, reporter, localAddress);\n         }\n+\n     }\n \n-    private static Endpoint buildEndpoint(String serviceName, Optional<InetSocketAddress> localSocketAddress) {\n+    private static Endpoint buildEndpoint(String serviceName, @Nullable InetSocketAddress localSocketAddress) {\n         final Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n-        localSocketAddress.ifPresent(address -> builder.ip(address.getAddress()).port(address.getPort()));\n+        if (localSocketAddress != null) {\n+            builder.ip(localSocketAddress.getAddress()).port(localSocketAddress.getPort());\n+        }\n         return builder.build();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MzQxMw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403193413", "bodyText": "As this class requires a Reporter, we should make it explicit by taking Reporter<Span> as an argument in the build() method. Users can pass in a noop/logging reporter if they like.", "author": "NiteshKant", "createdAt": "2020-04-03T17:52:17Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.\n          */\n         public ZipkinPublisher build() {\n-            return new ZipkinPublisher(serviceName, collectorAddress, localAddress, encoder, transport);\n-        }\n-    }\n-\n-    private ZipkinPublisher(String serviceName,\n-                            SocketAddress collectorAddress,\n-                            @Nullable InetSocketAddress localAddress,\n-                            Encoder encoder,\n-                            Transport transport) {\n-        requireNonNull(serviceName);\n-        requireNonNull(collectorAddress);\n-        requireNonNull(encoder);\n-        requireNonNull(transport);\n-\n-        endpoint = buildEndpoint(serviceName, localAddress);\n-\n-        group = createEventLoopGroup(1, new DefaultThreadFactory(\"zipkin-publisher\", true));\n-        try {\n-            final Bootstrap bootstrap = transport.buildBootstrap(group, encoder, collectorAddress);\n-            channel = bootstrap.bind(0).sync().channel();\n-        } catch (InterruptedException e) {\n-            currentThread().interrupt(); // Reset the interrupted flag.\n-            throw new IllegalStateException(\"Failed to create \" + transport + \" client\");\n-        } catch (Exception e) {\n-            logger.warn(\"Failed to create {} client\", transport, e);\n-            group.shutdownGracefully(0, 0, SECONDS);\n-            throw e;\n+            if (reporter == null) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -84,25 +82,26 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, Closeab\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = Optional.of(requireNonNull(localAddress));\n+            this.localAddress = requireNonNull(localAddress);\n             return this;\n         }\n \n         /**\n-         * Note that this may block while the underlying channel is bound/connected.\n-         * @return An interface which can publish tracing data using the zipkin API.\n+         * Builds the ZipkinPublisher with supplied options.\n+         *\n+         * @return A ZipkinPublisher which can publish tracing data using the zipkin Reporter API.\n          */\n         public ZipkinPublisher build() {\n-            if (reporter == null) {\n-                reporter = new LoggingReporter();\n-            }\n             return new ZipkinPublisher(serviceName, reporter, localAddress);\n         }\n+\n     }\n \n-    private static Endpoint buildEndpoint(String serviceName, Optional<InetSocketAddress> localSocketAddress) {\n+    private static Endpoint buildEndpoint(String serviceName, @Nullable InetSocketAddress localSocketAddress) {\n         final Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n-        localSocketAddress.ifPresent(address -> builder.ip(address.getAddress()).port(address.getPort()));\n+        if (localSocketAddress != null) {\n+            builder.ip(localSocketAddress.getAddress()).port(localSocketAddress.getPort());\n+        }\n         return builder.build();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTQ5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195494", "bodyText": "Consider moving these non-null checks closer to where they are accepted from the user, i.e. in the Builder", "author": "NiteshKant", "createdAt": "2020-04-03T17:54:33Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -15,6 +15,8 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTg2OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195868", "bodyText": "This can be final", "author": "NiteshKant", "createdAt": "2020-04-03T17:54:58Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);\n+        this.endpoint = buildEndpoint(requireNonNull(serviceName), requireNonNull(localSocketAddress));\n     }\n \n     /**\n      * Builder for {@link ZipkinPublisher}.\n      */\n     public static final class Builder {\n         private String serviceName;", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -15,6 +15,8 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NjUyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403196520", "bodyText": "Looks like this is unused.", "author": "NiteshKant", "createdAt": "2020-04-03T17:55:39Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -15,6 +15,8 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzE1Mg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403197152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ZipkinPublisher(String serviceName,\n          \n          \n            \n                                        Reporter<Span> reporter,\n          \n          \n            \n                                        Optional<InetSocketAddress> localSocketAddress) {\n          \n          \n            \n                private ZipkinPublisher(final String serviceName,\n          \n          \n            \n                                        final Reporter<Span> reporter,\n          \n          \n            \n                                        final Optional<InetSocketAddress> localSocketAddress) {", "author": "NiteshKant", "createdAt": "2020-04-03T17:56:23Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -15,6 +15,8 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODE0NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403198144", "bodyText": "As this class is not doing any batching, it does not need to worry about flushing. We can move this to the entity(i.e. a Reporter implementation) that will do batching in the future.", "author": "NiteshKant", "createdAt": "2020-04-03T17:57:34Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +147,42 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (reporter instanceof Flushable) {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDg3Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404364873", "bodyText": "Reporters may batch and this need to flush them in case they are.", "author": "colestanfield", "createdAt": "2020-04-06T20:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -151,38 +153,49 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, Closeab\n         reporter.report(s);\n     }\n \n+    /**\n+     * Attempts to flush and close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the flush and close is done\n+     */\n     @Override\n-    public void close() {\n+    public Completable closeAsync() {\n+        // Some Reporter implementations may batch and need an explicit flush before closing (AsyncReporter)\n+        Completable flush = Completable.completed();\n         if (reporter instanceof Flushable) {\n-            try {\n-                ((Flushable) reporter).flush();\n-            } catch (IOException e) {\n-                logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n-            }\n+            flush = globalExecutionContext().executor().submit(() -> {\n+                try {\n+                    ((Flushable) reporter).flush();\n+                } catch (IOException e) {\n+                    logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n+                }\n+            });\n         }\n-        if (reporter instanceof Closeable) {\n-            try {\n-                ((Closeable) reporter).close();\n-            } catch (IOException e) {\n-                logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n-            }\n+        // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n+        Completable close = Completable.completed();\n+        if (reporter instanceof AsyncCloseable) {\n+            close = ((AsyncCloseable) reporter).closeAsync();\n+        } else if (reporter instanceof Closeable) {\n+            close = globalExecutionContext().executor().submit(() -> {\n+                try {\n+                    ((Closeable) reporter).close();\n+                } catch (IOException e) {\n+                    logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n+                }\n+            });\n         }\n+        return flush.concat(close);\n     }\n \n-    static final class LoggingReporter implements Reporter<Span> {\n-        final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class.getName());\n-\n-        @Override\n-        public void report(zipkin2.Span span) {\n-            requireNonNull(span);\n-            if (logger.isInfoEnabled()) {\n-                logger.info(span.toString());\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"LoggingReporter{name=\" + logger.getName() + \"}\";\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5OTIxNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403199217", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private SocketAddress collectorAddress;\n          \n          \n            \n                    private final SocketAddress collectorAddress;", "author": "NiteshKant", "createdAt": "2020-04-03T17:58:45Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403200023", "bodyText": "Javadocs are required for all public classes and methods.", "author": "NiteshKant", "createdAt": "2020-04-03T17:59:39Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTk4MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403225980", "bodyText": "Also make this AsyncCloseable", "author": "NiteshKant", "createdAt": "2020-04-03T18:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDU2Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403214563", "bodyText": "Few improvements here (feel free to do as a follow up):\n\nAdd a method on the Builder to accept an ST IoExecutor which can then be converted to a netty EventLoopGroup using this.\nIf the user does not provide an IoExecutor use one from the GlobalExecutionContext\nAdd a method on the Builder to optionally enable wire logging like we do in clients/servers and add a netty LoggingHandler. It is useful to debug network activity.", "author": "NiteshKant", "createdAt": "2020-04-03T18:16:40Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTcwMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403215700", "bodyText": "Can you also make this an AsyncCloseable? If you do close() can just delegate to closeAsync()", "author": "NiteshKant", "createdAt": "2020-04-03T18:18:01Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 98b5e4f0f..85f91a30d 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -15,6 +15,8 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjk1Nw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403216957", "bodyText": "As we are always doing writeAndFlush() this isn't really useful?", "author": "NiteshKant", "createdAt": "2020-04-03T18:19:32Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MzkxOQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404363919", "bodyText": "Removed", "author": "colestanfield", "createdAt": "2020-04-06T20:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNzc5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403217794", "bodyText": "Once we do use ST's IoExecutor we do not need to manage the lifecycle as either it is global or managed by user.", "author": "NiteshKant", "createdAt": "2020-04-03T18:20:27Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.flush();\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        channel.close();\n+        group.shutdownGracefully(0, 1, SECONDS);", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2Mzk3OQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404363979", "bodyText": "done", "author": "colestanfield", "createdAt": "2020-04-06T20:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNzc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTQ4OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403219488", "bodyText": "Use the ByteBufAllocator set in the ctx?\nctx.alloc().buffer(bytes.length).writeBytes(bytes)", "author": "NiteshKant", "createdAt": "2020-04-03T18:22:37Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDEyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403220120", "bodyText": "Also pass the promise to the write call", "author": "NiteshKant", "createdAt": "2020-04-03T18:23:22Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));", "originalCommit": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb283b726c00a74057d2ac92c52d6afff316ae57", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 2674072e7..46375602f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -15,17 +15,22 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher.reporter;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOutboundHandlerAdapter;\n import io.netty.channel.ChannelPromise;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.FixedRecvByteBufAllocator;\n import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n+import io.netty.handler.logging.LoggingHandler;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Component;\n"}}, {"oid": "eb283b726c00a74057d2ac92c52d6afff316ae57", "url": "https://github.com/apple/servicetalk/commit/eb283b726c00a74057d2ac92c52d6afff316ae57", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-06T20:20:35Z", "type": "forcePushed"}, {"oid": "04dc92872870995f77ab84bcf855365e92777037", "url": "https://github.com/apple/servicetalk/commit/04dc92872870995f77ab84bcf855365e92777037", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-06T20:28:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODg1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408851", "bodyText": "not sure why this has been pkg-private but it can be private now.", "author": "NiteshKant", "createdAt": "2020-04-06T21:47:54Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODkyMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408920", "bodyText": "Javadocs please \ud83d\ude04", "author": "NiteshKant", "createdAt": "2020-04-06T21:48:03Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMDA1NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404410054", "bodyText": "Retain the \"may block comment\" from the original class?\nNote that this may block while the underlying channel is bound/connected.", "author": "NiteshKant", "createdAt": "2020-04-06T21:50:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTg2Mw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404411863", "bodyText": "Mention at what level we will log, reference:\nhttps://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77", "author": "NiteshKant", "createdAt": "2020-04-06T21:54:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjEzOQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404412139", "bodyText": "We generally log at Trace level, you can pass the level to the LoggingHandler, default is DEBUG", "author": "NiteshKant", "createdAt": "2020-04-06T21:55:05Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMzEzMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404413130", "bodyText": "Log instead?", "author": "NiteshKant", "createdAt": "2020-04-06T21:56:56Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxNTMzNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404415336", "bodyText": "We still need to close the channel. You can make this class public and use it here:\nreturn new NettyFutureCompletable(channel::closeFuture);\nBetter to create an keep this NettyFutureCompletable instance in the constructor.", "author": "NiteshKant", "createdAt": "2020-04-06T22:02:02Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyOTEzNQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404429135", "bodyText": "Once you move to NettyFutureCompletable this issue becomes moot but as a general concept; setting state like this before returning an async source means state change is eager as opposed to the expected lazy semantics from the returned async source.", "author": "NiteshKant", "createdAt": "2020-04-06T22:34:53Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5NTkxNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404495917", "bodyText": "Very true. Happened when I copy-pasted from the old blocking close() method.", "author": "colestanfield", "createdAt": "2020-04-07T02:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyOTEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDQyOA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430428", "bodyText": "Once you change closeAsync() below to close the channel, you can just use channel.isActive().", "author": "NiteshKant", "createdAt": "2020-04-06T22:38:22Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDY5NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430694", "bodyText": "You may want to instead use StacklessClosedChannelException", "author": "NiteshKant", "createdAt": "2020-04-06T22:39:04Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cedc692217938361cb918f75d62f7c39b3ff4e91", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 9204f8817..1a922d9d2 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -51,6 +51,9 @@ import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.glo\n import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n \n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n \n     private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzI1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404433251", "bodyText": "We should also override closeAsyncGracefully() to correctly delegate the same to the Reporter. Typically we create an AsyncCloseable in the constructor and delegate to it from respective methods. In this case the AsyncCloseable can be created in the constructor like:\ncloseable = AsyncCloseables.toAsyncCloseable(graceful -> {\n    Completable flush = Completable.completed();\n    if (reporter instanceof Flushable) {\n        flush = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Flushable) reporter).flush();\n            } catch (IOException e) {\n                logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n    Completable close = Completable.completed();\n    if (reporter instanceof AsyncCloseable) {\n        close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n                ((AsyncCloseable) reporter).closeAsync();\n    } else if (reporter instanceof Closeable) {\n        close = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Closeable) reporter).close();\n            } catch (IOException e) {\n                logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    return flush.concat(close);\n});", "author": "NiteshKant", "createdAt": "2020-04-06T22:45:43Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +149,53 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Attempts to flush and close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the flush and close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {", "originalCommit": "04dc92872870995f77ab84bcf855365e92777037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a714b13acfa948d4ffcecd980af148a723e4eb67", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 7a7af3889..09bd5293c 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -154,48 +184,30 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCl\n     }\n \n     /**\n-     * Attempts to flush and close the configured {@link Reporter}.\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() {\n+        closeable.onClose();\n+    }\n+\n+    /**\n+     * Attempts to close the configured {@link Reporter}.\n      *\n-     * @return a {@link Completable} that is completed when the flush and close is done\n+     * @return a {@link Completable} that is completed when the close is done\n      */\n     @Override\n     public Completable closeAsync() {\n-        // Some Reporter implementations may batch and need an explicit flush before closing (AsyncReporter)\n-        Completable flush = Completable.completed();\n-        if (reporter instanceof Flushable) {\n-            flush = globalExecutionContext().executor().submit(() -> {\n-                try {\n-                    ((Flushable) reporter).flush();\n-                } catch (IOException e) {\n-                    logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n-                }\n-            });\n-        }\n-        // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n-        Completable close = Completable.completed();\n-        if (reporter instanceof AsyncCloseable) {\n-            close = ((AsyncCloseable) reporter).closeAsync();\n-        } else if (reporter instanceof Closeable) {\n-            close = globalExecutionContext().executor().submit(() -> {\n-                try {\n-                    ((Closeable) reporter).close();\n-                } catch (IOException e) {\n-                    logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n-                }\n-            });\n-        }\n-        return flush.concat(close);\n+        return closeable.closeAsync();\n     }\n \n     /**\n-     * Blocking close method delegates to {@link #closeAsync()}.\n+     * Attempts to flush and close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the flush and close is done\n      */\n     @Override\n-    public void close() {\n-        try {\n-            closeAsync().toFuture().get();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n     }\n }\n"}}, {"oid": "cedc692217938361cb918f75d62f7c39b3ff4e91", "url": "https://github.com/apple/servicetalk/commit/cedc692217938361cb918f75d62f7c39b3ff4e91", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T02:02:40Z", "type": "forcePushed"}, {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T07:29:37Z", "type": "commit"}, {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "committedDate": "2020-04-07T07:29:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404941468", "bodyText": "onClose() isn't appropriate here as it does not actually close, also we need to subscribe here as close() is synchronous.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void close() {\n          \n          \n            \n                    closeable.onClose();\n          \n          \n            \n                }\n          \n          \n            \n                public void close() throws Exception {\n          \n          \n            \n                    closeable.closeAsync().toFuture().get();\n          \n          \n            \n                }", "author": "NiteshKant", "createdAt": "2020-04-07T16:22:13Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() {\n+        closeable.onClose();\n+    }", "originalCommit": "a714b13acfa948d4ffcecd980af148a723e4eb67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MjkxMA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404942910", "bodyText": "@colestanfield I will just commit this suggestion", "author": "NiteshKant", "createdAt": "2020-04-07T16:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NDQyNw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404944427", "bodyText": "Yikes ... compilation failure, Lemme fix this.", "author": "NiteshKant", "createdAt": "2020-04-07T16:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 09bd5293c..3992641db 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -187,8 +187,8 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCl\n      * Blocking close method delegates to {@link #closeAsync()}.\n      */\n     @Override\n-    public void close() {\n-        closeable.onClose();\n+    public void close() throws Exception {\n+        closeable.closeAsync().toFuture().get();\n     }\n \n     /**\n"}}, {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "url": "https://github.com/apple/servicetalk/commit/2aac83d68480ef701171f98fa611d73ee5fd3b81", "message": "Use `closeAsync()` in `close()`", "committedDate": "2020-04-07T16:23:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2OTc2Ng==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404969766", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;", "author": "NiteshKant", "createdAt": "2020-04-07T17:03:08Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,95 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;", "originalCommit": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2dd7864b573e54ee001fac3951bb45cf365bd160", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 3992641db..bd79f0176 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -37,6 +37,7 @@ import java.util.Map;\n import javax.annotation.Nullable;\n \n import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n import static java.util.Objects.requireNonNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDI1Nw==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404970257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return closeable.closeAsync();\n          \n          \n            \n                    return awaitTermination(closeable.closeAsync().toFuture());", "author": "NiteshKant", "createdAt": "2020-04-07T17:03:43Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() throws Exception {\n+        closeable.closeAsync().toFuture().get();\n+    }\n+\n+    /**\n+     * Attempts to close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();", "originalCommit": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2dd7864b573e54ee001fac3951bb45cf365bd160", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 3992641db..bd79f0176 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -198,7 +199,7 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCl\n      */\n     @Override\n     public Completable closeAsync() {\n-        return closeable.closeAsync();\n+        return awaitTermination(closeable.closeAsync().toFuture());\n     }\n \n     /**\n"}}, {"oid": "2dd7864b573e54ee001fac3951bb45cf365bd160", "url": "https://github.com/apple/servicetalk/commit/2dd7864b573e54ee001fac3951bb45cf365bd160", "message": "Correctly implement `close()`", "committedDate": "2020-04-07T17:04:47Z", "type": "commit"}, {"oid": "957d185d4db98fb935624c75e44843a1d6691510", "url": "https://github.com/apple/servicetalk/commit/957d185d4db98fb935624c75e44843a1d6691510", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T19:18:51Z", "type": "forcePushed"}, {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97", "url": "https://github.com/apple/servicetalk/commit/478bf211dd809661394e56bad48d4a3b919f7a97", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T19:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEwMDQyNg==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405100426", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            close = ((AsyncCloseable) reporter).closeAsyncGracefully();\n          \n          \n            \n                            close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n          \n          \n            \n                                    ((AsyncCloseable) reporter).closeAsync();", "author": "NiteshKant", "createdAt": "2020-04-07T20:43:46Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,96 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n-public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n+public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCloseable, Closeable {\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n-\n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private ZipkinPublisher(final String serviceName,\n+                            final Reporter<Span> reporter,\n+                            @Nullable final InetSocketAddress localSocketAddress) {\n+        this.reporter = reporter;\n+        this.endpoint = buildEndpoint(serviceName, localSocketAddress);\n+        this.closeable = toAsyncCloseable(graceful -> {\n+            // Some Reporter implementations may batch and need an explicit flush before closing (AsyncReporter)\n+            Completable flush = Completable.completed();\n+            if (graceful && reporter instanceof Flushable) {\n+                flush = globalExecutionContext().executor().submit(() -> {\n+                    try {\n+                        ((Flushable) reporter).flush();\n+                    } catch (IOException e) {\n+                        logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n+                    }\n+                });\n             }\n-        };\n-\n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+            // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n+            Completable close = Completable.completed();\n+            if (reporter instanceof AsyncCloseable) {\n+                close = ((AsyncCloseable) reporter).closeAsyncGracefully();", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\nindex 1e8fdfaac..6341fad39 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java\n\n@@ -72,7 +72,8 @@ public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCl\n             // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n             Completable close = Completable.completed();\n             if (reporter instanceof AsyncCloseable) {\n-                close = ((AsyncCloseable) reporter).closeAsyncGracefully();\n+                close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n+                        ((AsyncCloseable) reporter).closeAsync();\n             } else if (reporter instanceof Closeable) {\n                 close = globalExecutionContext().executor().submit(() -> {\n                     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n          \n          \n            \n                     * {@link Executor}.\n          \n          \n            \n                     * Sets an {@link Executor} to use when required. \n          \n      \n    \n    \n  \n\nAvoid stating defaults in documentation.", "author": "NiteshKant", "createdAt": "2020-04-07T21:15:06Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyMDc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405120751", "bodyText": "Why?", "author": "colestanfield", "createdAt": "2020-04-07T21:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTAxNQ==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405135015", "bodyText": "Stating defaults in docs means that we have less flexibility to change them in the future. If a user cares about a default value (more than just knowledge), it is a better option to explicitly use that default value so that if the defaults change they are not surprised.", "author": "NiteshKant", "createdAt": "2020-04-07T21:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 5eaaaea53..2618e9c3f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -151,10 +151,9 @@ public final class UdpReporter extends Component implements Reporter<Span>, Asyn\n         }\n \n         /**\n-         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n-         * {@link Executor}.\n+         * Sets an {@link Executor} to use when required.\n          *\n-         * @param executor {@link Executor} to offload close to\n+         * @param executor {@link Executor} to use\n          * @return {@code this}\n          */\n         public Builder executor(Executor executor) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzU3NA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param executor {@link Executor} to offload close to\n          \n          \n            \n                     * @param executor {@link Executor} to use.", "author": "NiteshKant", "createdAt": "2020-04-07T21:15:18Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 5eaaaea53..2618e9c3f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -151,10 +151,9 @@ public final class UdpReporter extends Component implements Reporter<Span>, Asyn\n         }\n \n         /**\n-         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n-         * {@link Executor}.\n+         * Sets an {@link Executor} to use when required.\n          *\n-         * @param executor {@link Executor} to offload close to\n+         * @param executor {@link Executor} to use\n          * @return {@code this}\n          */\n         public Builder executor(Executor executor) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzk1MA==", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117950", "bodyText": "Also override closeAsyncGracefully()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                public Completable closeAsyncGracefully() {\n          \n          \n            \n                    return closeable.closeAsyncGracefully();\n          \n          \n            \n                }", "author": "NiteshKant", "createdAt": "2020-04-07T21:16:09Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to\n+         * @return {@code this}\n+         */\n+        public Builder executor(Executor executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         * <p>\n+         * All wire events will be logged at {@link Level#TRACE TRACE} level.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         * <p>\n+         * This method may block while the underlying UDP channel is being bound.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName, LogLevel.TRACE));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (!channel.isActive()) {\n+            throw new RuntimeException(StacklessClosedChannelException.newInstance(this.getClass(), \"report\"));\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }", "originalCommit": "478bf211dd809661394e56bad48d4a3b919f7a97", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "chunk": "diff --git a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\nindex 5eaaaea53..2618e9c3f 100644\n--- a/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n+++ b/servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java\n\n@@ -151,10 +151,9 @@ public final class UdpReporter extends Component implements Reporter<Span>, Asyn\n         }\n \n         /**\n-         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n-         * {@link Executor}.\n+         * Sets an {@link Executor} to use when required.\n          *\n-         * @param executor {@link Executor} to offload close to\n+         * @param executor {@link Executor} to use\n          * @return {@code this}\n          */\n         public Builder executor(Executor executor) {\n"}}, {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T21:36:05Z", "type": "commit"}, {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "message": "Properly implementing UdpReporter\u2019s close method", "committedDate": "2020-04-07T21:36:05Z", "type": "forcePushed"}]}