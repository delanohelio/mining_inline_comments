{"pr_number": 932, "pr_title": "gRPC filters override configured execution strategy for the route", "pr_createdAt": "2020-02-04T22:16:49Z", "pr_url": "https://github.com/apple/servicetalk/pull/932", "timeline": [{"oid": "339a2b7b8d335c0e0d39556a4ebe22cee7e0fee9", "url": "https://github.com/apple/servicetalk/commit/339a2b7b8d335c0e0d39556a4ebe22cee7e0fee9", "message": "gRPC filters override configured execution strategy for the route\n\nMotivation:\n\nWhen users append a service filter using `ServiceFactory`, it\nreconstructs the `GrpcService` interface from registered routes,\nwraps it with the filter, and re-registers the service again as\nan independent routes. This logic does not preserve the execution\nstrategy that was used to register the original route and it\nuses the default strategy for a route.\n\nModifications:\n\n- Save the route execution strategy if it was configured for the\noriginal route;\n- Use saved execution strategy when we re-register filtered routes;\n- Add tests to verify the execution strategy configuration when\nusers apply a filter;\n- Close `GrpcPayloadWriter` in the conversion layer from\n`BlockingStreamingRoute` to `StreamingRoute`, because users of\n`BlockingRequestStreamingRoute` does not have access to it;\n\nResult:\n\ngRPC filters does not override configured execution strategy for\nthe route.", "committedDate": "2020-02-04T02:36:34Z", "type": "commit"}, {"oid": "429aebc7d787241a20b08683ba29e7fab2578fcd", "url": "https://github.com/apple/servicetalk/commit/429aebc7d787241a20b08683ba29e7fab2578fcd", "message": "Verify `RouteExecutionStrategy` annotation is ignored on the service filter", "committedDate": "2020-02-04T02:36:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r374957744", "bodyText": "@NiteshKant should we account for users that may try-catch routes registration? If they register the same path 2+ times with different route implementations, we will override the strategy here, but later we throw an exception saying that this path was already registered. If users try-catch this exception, internal state will be modified. I can move this executionStrategies.put after we register a route if necessary.", "author": "idelpivnitskiy", "createdAt": "2020-02-04T22:24:39Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,9 +187,18 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n-        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n-                noOffloadsStrategy());\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n+        // filtered routes:\n+        final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);\n+        if (saved != NULL) {\n+            return saved;\n+        }\n+        final GrpcExecutionStrategy computed = getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz,\n+                strategyFactory, errors, noOffloadsStrategy());\n+        // Save computed value even if it's null to prevent analysing annotations on a service filter class\n+        executionStrategies.put(path, computed);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNDUwOA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375424508", "bodyText": "but later we throw an exception saying that this path was already registered.\n\n\nDid you mean that we will ignore the strategy for a subsequent registration? We are not using executionStrategies to check for duplicate registration, are we?\nI think we should account for cases when a registration exception is caught and retried unless we have a strong reason to believe that is invalid. AFAIR, this is required only for disallowing filters to specify the strategy annotation, rite? I have not thought of that case as to whether it is good or bad, so if we need special code to disallow it, lets refrain from doing that for now and have \"behavior when strategy annotation is defined on filters is undefined\" as our answer.", "author": "NiteshKant", "createdAt": "2020-02-05T18:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxNTUxOQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375615519", "bodyText": "I was thinking about a use-case like this:\nServiceFactory.Builder builder = new ServiceFactory.Builder();\nbuilder.testBlocking(noOffloadsStrategy(), serviceImpl);\ntry {\n    builder.testBlocking(anotherStrategy, anotherServiceImpl);\n} catch (IllegalStateException e) {\n    // ignore that this route was already registered\n}\nDon't think we need to verify duplication for the executionStrategies map, because we already do that for routes. An additional check will be useless.\nIn my first impl I stored execution strategy before I verified routes duplication. That's why in the example above users will be in the state when they have serviceImpl with anotherStrategy.\nNow I moved executionStrategies.put(...) after we verify routes duplication. So, nothing will corrupt the internal state.\n\nAFAIR, this is required only for disallowing filters to specify the strategy annotation, rite? I have not thought of that case as to whether it is good or bad.\n\nRight. As we discussed before, ST policy is that if you configure an execution strategy for the route, ST will use it regardless of filters/influencers/etc.\nThe case here is that grpc filter implements the same service interface. Therefore, users can accidentally add @RouteExecutionStrategy annotation on the filter. I think we should ignore it.\n\nso if we need special code to disallow it, lets refrain from doing that for now and have \"behavior when strategy annotation is defined on filters is undefined\" as our answer.\n\nThe code to disallow annotation inspection for filters is trivial. It's just getOrDefault vs get on the map to distinguish key-null entry vs entry for this key does not exist.\nDefined behavior is always better than undefined. I've added this test to demonstrate the problem: https://github.com/apple/servicetalk/pull/932/files#diff-4fbfd0eed0161987f94f03bc6d9e3203R262-R279", "author": "idelpivnitskiy", "createdAt": "2020-02-06T02:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1Nzc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\nindex 0892e304a..f817ebf9e 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n\n@@ -188,17 +188,15 @@ public abstract class GrpcRoutes<Service extends GrpcService> {\n \n     @Nullable\n     private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n-        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n-        // filtered routes:\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This happens when we re-register\n+        // filtered routes and have to use the original execution strategy for the route instead of analysing\n+        // annotations on a service-filter class.\n         final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);\n         if (saved != NULL) {\n             return saved;\n         }\n-        final GrpcExecutionStrategy computed = getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz,\n-                strategyFactory, errors, noOffloadsStrategy());\n-        // Save computed value even if it's null to prevent analysing annotations on a service filter class\n-        executionStrategies.put(path, computed);\n-        return computed;\n+        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n+                noOffloadsStrategy());\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMDMxNQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375410315", "bodyText": "If onError() throws from the above catch block and then grpcPayloadWriter.close() also throws, concurrentTerminalSubscriber will ignore this call. You can instead use concurrentTerminalSubscriber.processOnError() which returns false if it did not deliver the error, in which case we should log.", "author": "NiteshKant", "createdAt": "2020-02-05T17:49:33Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java", "diffHunk": "@@ -107,30 +107,38 @@ public Completable closeAsyncGracefully() {\n                 return new Publisher<Resp>() {\n                     @Override\n                     protected void handleSubscribe(final Subscriber<? super Resp> subscriber) {\n-                        ConnectablePayloadWriter<Resp> connectablePayloadWriter = new ConnectablePayloadWriter<>();\n-                        Publisher<Resp> pub = connectablePayloadWriter.connect();\n-                        Subscriber<? super Resp> concurrentTerminalSubscriber =\n+                        final ConnectablePayloadWriter<Resp> connectablePayloadWriter =\n+                                new ConnectablePayloadWriter<>();\n+                        final Publisher<Resp> pub = connectablePayloadWriter.connect();\n+                        final Subscriber<? super Resp> concurrentTerminalSubscriber =\n                                 new ConcurrentTerminalSubscriber<>(subscriber, false);\n                         toSource(pub).subscribe(concurrentTerminalSubscriber);\n+                        final GrpcPayloadWriter<Resp> grpcPayloadWriter = new GrpcPayloadWriter<Resp>() {\n+                            @Override\n+                            public void write(final Resp resp) throws IOException {\n+                                connectablePayloadWriter.write(resp);\n+                            }\n+\n+                            @Override\n+                            public void close() throws IOException {\n+                                connectablePayloadWriter.close();\n+                            }\n+\n+                            @Override\n+                            public void flush() throws IOException {\n+                                connectablePayloadWriter.flush();\n+                            }\n+                        };\n                         try {\n-                            original.handle(ctx, request.toIterable(), new GrpcPayloadWriter<Resp>() {\n-                                @Override\n-                                public void write(final Resp resp) throws IOException {\n-                                    connectablePayloadWriter.write(resp);\n-                                }\n-\n-                                @Override\n-                                public void close() throws IOException {\n-                                    connectablePayloadWriter.close();\n-                                }\n-\n-                                @Override\n-                                public void flush() throws IOException {\n-                                    connectablePayloadWriter.flush();\n-                                }\n-                            });\n+                            original.handle(ctx, request.toIterable(), grpcPayloadWriter);\n                         } catch (Throwable t) {\n                             concurrentTerminalSubscriber.onError(t);\n+                        } finally {\n+                            try {\n+                                grpcPayloadWriter.close();\n+                            } catch (IOException e) {\n+                                concurrentTerminalSubscriber.onError(e);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\nindex befe92e39..86d3892ad 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\n\n@@ -110,7 +116,7 @@ final class GrpcRouteConversions {\n                         final ConnectablePayloadWriter<Resp> connectablePayloadWriter =\n                                 new ConnectablePayloadWriter<>();\n                         final Publisher<Resp> pub = connectablePayloadWriter.connect();\n-                        final Subscriber<? super Resp> concurrentTerminalSubscriber =\n+                        final ConcurrentTerminalSubscriber<? super Resp> concurrentTerminalSubscriber =\n                                 new ConcurrentTerminalSubscriber<>(subscriber, false);\n                         toSource(pub).subscribe(concurrentTerminalSubscriber);\n                         final GrpcPayloadWriter<Resp> grpcPayloadWriter = new GrpcPayloadWriter<Resp>() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNDY1MA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375414650", "bodyText": "It seems like it is trivial to create a merged map for strategies from all routes instead of ignoring them. It is better to not make exceptions here and make sure we have strategies when defined.", "author": "NiteshKant", "createdAt": "2020-02-05T17:57:56Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -159,7 +171,9 @@ public Completable closeAsyncGracefully() {\n             builders[i] = allRoutes[i].routeBuilder;\n             errors.addAll(allRoutes[i].errors);\n         }\n-        return new GrpcRoutes<GrpcService>(GrpcRouter.Builder.merge(builders), errors) {\n+        // At the time of merging all GrpcRoutes together we don't need an executionStrategies map and can pass an empty", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\nindex 0892e304a..816fbbd27 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n\n@@ -166,14 +165,15 @@ public abstract class GrpcRoutes<Service extends GrpcService> {\n \n     static GrpcRoutes<?> merge(GrpcRoutes<?>... allRoutes) {\n         final GrpcRouter.Builder[] builders = new GrpcRouter.Builder[allRoutes.length];\n+        final Map<String, GrpcExecutionStrategy> executionStrategies = new HashMap<>();\n         final Set<String> errors = new TreeSet<>();\n         for (int i = 0; i < allRoutes.length; i++) {\n-            builders[i] = allRoutes[i].routeBuilder;\n-            errors.addAll(allRoutes[i].errors);\n+            final GrpcRoutes<?> route = allRoutes[i];\n+            builders[i] = route.routeBuilder;\n+            executionStrategies.putAll(route.executionStrategies);\n+            errors.addAll(route.errors);\n         }\n-        // At the time of merging all GrpcRoutes together we don't need an executionStrategies map and can pass an empty\n-        // map instead:\n-        return new GrpcRoutes<GrpcService>(GrpcRouter.Builder.merge(builders), emptyMap(), errors) {\n+        return new GrpcRoutes<GrpcService>(GrpcRouter.Builder.merge(builders), executionStrategies, errors) {\n             @Override\n             protected void registerRoutes(final GrpcService service) {\n                 throw new UnsupportedOperationException(\"Merged service factory can not register routes.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzcwMA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375417700", "bodyText": "Just use get() and eliminate defining NULL as default?\nfinal GrpcExecutionStrategy saved = executionStrategies.get(path);\nif (saved != null) {\n    return saved;\n}", "author": "NiteshKant", "createdAt": "2020-02-05T18:03:38Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,9 +187,18 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n-        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n-                noOffloadsStrategy());\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n+        // filtered routes:\n+        final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);", "originalCommit": "429aebc7d787241a20b08683ba29e7fab2578fcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxNTU0OQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375615549", "bodyText": "Let's continue this discussion here: #932 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-02-06T02:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNzcwMA=="}], "type": "inlineReview", "revised_code": {"commit": "0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\nindex 0892e304a..f817ebf9e 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n\n@@ -188,17 +188,15 @@ public abstract class GrpcRoutes<Service extends GrpcService> {\n \n     @Nullable\n     private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n-        // Check if we already have a computed GrpcExecutionStrategy for this path. This may happen when we re-register\n-        // filtered routes:\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This happens when we re-register\n+        // filtered routes and have to use the original execution strategy for the route instead of analysing\n+        // annotations on a service-filter class.\n         final GrpcExecutionStrategy saved = executionStrategies.getOrDefault(path, NULL);\n         if (saved != NULL) {\n             return saved;\n         }\n-        final GrpcExecutionStrategy computed = getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz,\n-                strategyFactory, errors, noOffloadsStrategy());\n-        // Save computed value even if it's null to prevent analysing annotations on a service filter class\n-        executionStrategies.put(path, computed);\n-        return computed;\n+        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n+                noOffloadsStrategy());\n     }\n \n     /**\n"}}, {"oid": "ae048c8fc858df0de1ffde7168877ff1330a7b82", "url": "https://github.com/apple/servicetalk/commit/ae048c8fc858df0de1ffde7168877ff1330a7b82", "message": "Merge remote-tracking branch 'upstream/master' into grpc-filters-es", "committedDate": "2020-02-06T01:35:49Z", "type": "commit"}, {"oid": "a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "url": "https://github.com/apple/servicetalk/commit/a2e87e92ad5eee48d099f023e44ce91c3a33f6e8", "message": "Address comments", "committedDate": "2020-02-06T01:51:14Z", "type": "commit"}, {"oid": "0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "url": "https://github.com/apple/servicetalk/commit/0fbb4fbbff1808d58bb6d9b5cee6d150140c40e3", "message": "Save execution strategy after we verified route was not registered twice", "committedDate": "2020-02-06T02:09:48Z", "type": "commit"}, {"oid": "5820d3310904811ba595fefc4ac5c84a0639f349", "url": "https://github.com/apple/servicetalk/commit/5820d3310904811ba595fefc4ac5c84a0639f349", "message": "Move executionStrategies map from GrpcRoutes to GrpcRouter", "committedDate": "2020-02-06T02:23:25Z", "type": "commit"}, {"oid": "f32710c634351a6e08f374fce548947454756ed0", "url": "https://github.com/apple/servicetalk/commit/f32710c634351a6e08f374fce548947454756ed0", "message": "Revert unnecessary modifications", "committedDate": "2020-02-06T02:41:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYxMzQwNA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r375613404", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                LOGGER.error(\"Cannot close GrpcPayloadWriter\", e);\n          \n          \n            \n                                                LOGGER.error(\"Failed to close GrpcPayloadWriter\", e);", "author": "NiteshKant", "createdAt": "2020-02-06T02:33:02Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java", "diffHunk": "@@ -137,7 +143,9 @@ public void flush() throws IOException {\n                             try {\n                                 grpcPayloadWriter.close();\n                             } catch (IOException e) {\n-                                concurrentTerminalSubscriber.onError(e);\n+                                if (!concurrentTerminalSubscriber.processOnError(e)) {\n+                                    LOGGER.error(\"Cannot close GrpcPayloadWriter\", e);", "originalCommit": "5820d3310904811ba595fefc4ac5c84a0639f349", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0cc9f70c83e8452835a5845f662daa3431782aa", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\nindex 86d3892ad..f3e674390 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouteConversions.java\n\n@@ -144,7 +144,7 @@ final class GrpcRouteConversions {\n                                 grpcPayloadWriter.close();\n                             } catch (IOException e) {\n                                 if (!concurrentTerminalSubscriber.processOnError(e)) {\n-                                    LOGGER.error(\"Cannot close GrpcPayloadWriter\", e);\n+                                    LOGGER.error(\"Failed to close GrpcPayloadWriter\", e);\n                                 }\n                             }\n                         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA1OTE3NA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376059174", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            executionStrategies.putAll(executionStrategies);\n          \n          \n            \n                            executionStrategies.putAll(builder.executionStrategies);\n          \n      \n    \n    \n  \n\nIf it is simple, add a test to verify, else it is OK.", "author": "NiteshKant", "createdAt": "2020-02-06T20:16:40Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java", "diffHunk": "@@ -196,18 +200,25 @@ RouteProviders drainRoutes() {\n             return new RouteProviders(allRoutes);\n         }\n \n+        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,\n+                                                                 final GrpcExecutionStrategy defaultValue) {\n+            return executionStrategies.getOrDefault(path, defaultValue);\n+        }\n+\n         static GrpcRouter.Builder merge(final GrpcRouter.Builder... builders) {\n             final Map<String, RouteProvider> routes = new HashMap<>();\n             final Map<String, RouteProvider> streamingRoutes = new HashMap<>();\n             final Map<String, RouteProvider> blockingRoutes = new HashMap<>();\n             final Map<String, RouteProvider> blockingStreamingRoutes = new HashMap<>();\n+            final Map<String, GrpcExecutionStrategy> executionStrategies = new HashMap<>();\n             for (Builder builder : builders) {\n                 mergeRoutes(routes, builder.routes);\n                 mergeRoutes(streamingRoutes, builder.streamingRoutes);\n                 mergeRoutes(blockingRoutes, builder.blockingRoutes);\n                 mergeRoutes(blockingStreamingRoutes, builder.blockingStreamingRoutes);\n+                executionStrategies.putAll(executionStrategies);", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0cc9f70c83e8452835a5845f662daa3431782aa", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\nindex 4b780d66a..146e85195 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n\n@@ -200,8 +200,7 @@ final class GrpcRouter {\n             return new RouteProviders(allRoutes);\n         }\n \n-        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,\n-                                                                 final GrpcExecutionStrategy defaultValue) {\n+        GrpcExecutionStrategy executionStrategyFor(final String path, final GrpcExecutionStrategy defaultValue) {\n             return executionStrategies.getOrDefault(path, defaultValue);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MTI4MA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376061280", "bodyText": "Rename alreadyRegisteredExecutionStrategy => executionStrategyFor()\nIt does not seem like \"already registered\" is providing any additional value here.", "author": "NiteshKant", "createdAt": "2020-02-06T20:21:24Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java", "diffHunk": "@@ -196,18 +200,25 @@ RouteProviders drainRoutes() {\n             return new RouteProviders(allRoutes);\n         }\n \n+        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0cc9f70c83e8452835a5845f662daa3431782aa", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\nindex 4b780d66a..146e85195 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n\n@@ -200,8 +200,7 @@ final class GrpcRouter {\n             return new RouteProviders(allRoutes);\n         }\n \n-        GrpcExecutionStrategy alreadyRegisteredExecutionStrategy(final String path,\n-                                                                 final GrpcExecutionStrategy defaultValue) {\n+        GrpcExecutionStrategy executionStrategyFor(final String path, final GrpcExecutionStrategy defaultValue) {\n             return executionStrategies.getOrDefault(path, defaultValue);\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376064734", "bodyText": "null executionStrategy has no semantic meaning from a user point of view. We use it as a short-cut internally to avoid method overloads. If we only add non-null strategy for a path in GrpcRouter methods, can we simplify this as null value meaning no strategy is defined?", "author": "NiteshKant", "createdAt": "2020-02-06T20:29:10Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -173,7 +177,15 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n     }\n \n     @Nullable\n-    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n+    private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n+        // Check if we already have a computed GrpcExecutionStrategy for this path. This happens when we re-register\n+        // filtered routes and have to use the original execution strategy for the route instead of analysing\n+        // annotations on a service-filter class. Because previously registered strategy could be null, we use NULL", "originalCommit": "f32710c634351a6e08f374fce548947454756ed0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjExNDA2Mg==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376114062", "bodyText": "This null is not visible for users. null will be here only when users use ServiceFactory.Builder methods that do not take execution strategy and they do not add annotations on the service. For a null use-case we define execution strategy based on the method API: \n  \n    \n      servicetalk/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java\n    \n    \n         Line 259\n      in\n      412222c\n    \n    \n    \n    \n\n        \n          \n           }, strategy -> executionStrategy == null ? strategy : executionStrategy),", "author": "idelpivnitskiy", "createdAt": "2020-02-06T22:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyNTM0OQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376125349", "bodyText": "I understand that. I am questioning the need for this awkward NULL marker used here which is trying to distinguish between whether the value stored in the executionStrategies Map for a path is null or there is no mapping for that path.\nIf we do not put a null value in the executionStrategies Map then we do not need this NULL marker here, rite?", "author": "NiteshKant", "createdAt": "2020-02-06T22:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NzgxNg==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376177816", "bodyText": "The stored path<->null pair helps to understand that we already processed annotations for this route and an execution strategy for this route was null (therefore, we have to infer an execution strategy based on the route API).\nIf we won't store path<->null pair, we don't have a way to distinguish between \"we already know that the execution strategy for this route is null\" (this is when we re-register route with a filter) and \"we don't know the execution strategy for this route and have to process annotations\" (first-time registration of the route).", "author": "idelpivnitskiy", "createdAt": "2020-02-07T01:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3ODAyOA==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376178028", "bodyText": "We need to know this difference because the same code path is used for initial route registration and re-registration of the filtered route.", "author": "idelpivnitskiy", "createdAt": "2020-02-07T01:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwMTk1Nw==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376501957", "bodyText": "@NiteshKant if the main concern is the awkward NULL marker, I've pushed an alternative impl using a boolean flag: fd575fd\nLMK if this approach looks better.", "author": "idelpivnitskiy", "createdAt": "2020-02-07T17:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0MTc2MQ==", "url": "https://github.com/apple/servicetalk/pull/932#discussion_r376541761", "bodyText": "IMHO the boolean approach is slightly worse than what you had earlier as it stores state(registerFilters) assuming interactions from GrpcServiceFactory#applyFilterToRoutes().\nIt seems we are working around code to support \"filters should not have strategy annotation\" scenario. Since you seem to be convinced that scenario needs to be validated, lets go with what you had before (NULL marker approach) which looks like a lesser evil.", "author": "NiteshKant", "createdAt": "2020-02-07T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2NDczNA=="}], "type": "inlineReview", "revised_code": {"commit": "b0cc9f70c83e8452835a5845f662daa3431782aa", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\nindex 1dff1e9aa..b98edf20a 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java\n\n@@ -180,9 +180,10 @@ public abstract class GrpcRoutes<Service extends GrpcService> {\n     private GrpcExecutionStrategy executionStrategy(final String path, final Method method, final Class<?> clazz) {\n         // Check if we already have a computed GrpcExecutionStrategy for this path. This happens when we re-register\n         // filtered routes and have to use the original execution strategy for the route instead of analysing\n-        // annotations on a service-filter class. Because previously registered strategy could be null, we use NULL\n+        // annotations on a service-filter class. Because previously registered strategy could be null (if user did not\n+        // configure it using ServiceFactory.Builder methods or via @RouteExecutionStrategy annotation), we use NULL\n         // object as a marker to understand there was no strategy for this path.\n-        final GrpcExecutionStrategy saved = routeBuilder.alreadyRegisteredExecutionStrategy(path, NULL);\n+        final GrpcExecutionStrategy saved = routeBuilder.executionStrategyFor(path, NULL);\n         if (saved != NULL) {\n             return saved;\n         }\n"}}, {"oid": "b0cc9f70c83e8452835a5845f662daa3431782aa", "url": "https://github.com/apple/servicetalk/commit/b0cc9f70c83e8452835a5845f662daa3431782aa", "message": "Address comments", "committedDate": "2020-02-06T22:14:54Z", "type": "commit"}, {"oid": "fd575fdf701a6da07743d95068edec6df9525b6f", "url": "https://github.com/apple/servicetalk/commit/fd575fdf701a6da07743d95068edec6df9525b6f", "message": "Use `boolean` flag instead of dummy `NULL` object", "committedDate": "2020-02-07T16:58:48Z", "type": "commit"}, {"oid": "385b321e9c7e204508e91849def96dba06e3ad04", "url": "https://github.com/apple/servicetalk/commit/385b321e9c7e204508e91849def96dba06e3ad04", "message": "Revert \"Use `boolean` flag instead of dummy `NULL` object\"\n\nThis reverts commit fd575fdf701a6da07743d95068edec6df9525b6f.", "committedDate": "2020-02-07T18:39:34Z", "type": "commit"}]}