{"pr_number": 1014, "pr_title": "Publisher#flatMapMergeSingle potential queue drain visibility issue", "pr_createdAt": "2020-04-14T20:19:04Z", "pr_url": "https://github.com/apple/servicetalk/pull/1014", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408414179", "bodyText": "shouldn't we release in a finally block ?", "author": "normanmaurer", "createdAt": "2020-04-14T20:27:12Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,23 +223,31 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            for (;;) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    ++drainCount;\n+                    sendToTarget(t);\n+                }\n+                if (releasePendingLock(emittingUpdater, this)) {", "originalCommit": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNDYxNA==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408434614", "bodyText": "good point ... let me make this more robust.", "author": "Scottmitch", "createdAt": "2020-04-14T21:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "chunk": "diff --git a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\nindex 5c4327045..364c4c786 100644\n--- a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n+++ b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n\n@@ -219,28 +225,37 @@ final class PublisherFlatMapSingle<T, R> extends AbstractAsynchronousPublisherOp\n         }\n \n         private void enqueueAndDrain(Object item) {\n-            Subscription s = subscription;\n-            assert s != null;\n-\n             if (!pending.offer(item)) {\n-                enqueueAndDrainFail(item);\n+                enqueueAndDrainFailed(item);\n             }\n-            drainPending(s);\n+            drainPending();\n         }\n \n-        private void drainPending(Subscription subscription) {\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            assert subscription != null;\n             long drainCount = 0;\n-            for (;;) {\n-                if (!acquirePendingLock(emittingUpdater, this)) {\n-                    break;\n-                }\n-                Object t;\n-                while ((t = pending.poll()) != null) {\n-                    ++drainCount;\n-                    sendToTarget(t);\n-                }\n-                if (releasePendingLock(emittingUpdater, this)) {\n-                    break;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408717440", "bodyText": "nit: should we use addSuppressed(...) when delayedCause != null", "author": "normanmaurer", "createdAt": "2020-04-15T09:48:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +224,58 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;", "originalCommit": "8a525a8eae60877e0a37fa66f020c67588e0fbe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3ODk4Ng==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r409178986", "bodyText": "lets discuss on #1011 (comment)", "author": "Scottmitch", "createdAt": "2020-04-15T22:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA=="}], "type": "inlineReview", "revised_code": {"commit": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "chunk": "diff --git a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\nindex 9da444fcb..364c4c786 100644\n--- a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n+++ b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n\n@@ -220,16 +225,15 @@ final class PublisherFlatMapSingle<T, R> extends AbstractAsynchronousPublisherOp\n         }\n \n         private void enqueueAndDrain(Object item) {\n-            Subscription s = subscription;\n-            assert s != null;\n-\n             if (!pending.offer(item)) {\n-                enqueueAndDrainFail(item);\n+                enqueueAndDrainFailed(item);\n             }\n-            drainPending(s);\n+            drainPending();\n         }\n \n-        private void drainPending(Subscription subscription) {\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            assert subscription != null;\n             long drainCount = 0;\n             Throwable delayedCause = null;\n             while (acquirePendingLock(emittingUpdater, this)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157465", "bodyText": "Just wondering why the others need to be public and this can be private ...", "author": "normanmaurer", "createdAt": "2020-04-17T11:17:22Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "originalCommit": "da043d3580ecb4737eef739b272693358f074539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MDcyMQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410350721", "bodyText": "its a good question. I would like to investigate making them all private and instead expose lock methods, but didn't want to expand the scope of this PR: #1023", "author": "Scottmitch", "createdAt": "2020-04-17T16:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExNzE2MQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r412117161", "bodyText": "sounds good...", "author": "normanmaurer", "createdAt": "2020-04-21T11:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b79e1bfe466f985ba3a373126af2a413df0f66c", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java\nindex 8ef549256..d76041b2e 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java\n\n@@ -15,22 +15,14 @@\n  */\n package io.servicetalk.concurrent.internal;\n \n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Queue;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n-import java.util.function.Consumer;\n \n /**\n  * Utilities which can be used for concurrency.\n  */\n public final class ConcurrentUtils {\n-    private static final int NOT_EXECUTING_EXCLUSIVE = 0;\n-    private static final int EXECUTING_EXCLUSIVE = 1;\n-    private static final int CONCURRENT_EXECUTE_EXCLUSIVE = 2;\n-\n-    public static final int CONCURRENT_IDLE = 0;\n-    public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_IDLE = 0;\n+    private static final int CONCURRENT_EMITTING = 1;\n     private static final int CONCURRENT_PENDING = 2;\n \n     private ConcurrentUtils() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1Nzg2OQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157869", "bodyText": "nit: ...DrainFailed ?", "author": "normanmaurer", "createdAt": "2020-04-17T11:18:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +231,62 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (drainCount != 0) {\n                 // We ignore overflow here because once we get to this extreme, we won't be able to account for more\n                 // data anyways.\n-                sourceEmittedUpdater.addAndGet(this, drainedCount);\n+                sourceEmittedUpdater.addAndGet(this, drainCount);\n                 int actualSourceRequestN = calculateSourceRequested(requestedUpdater, sourceRequestedUpdater,\n                         sourceEmittedUpdater, source.maxConcurrency, this);\n                 if (actualSourceRequestN != 0) {\n                     subscription.request(actualSourceRequestN);\n                 }\n             }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {", "originalCommit": "da043d3580ecb4737eef739b272693358f074539", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "chunk": "diff --git a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\nindex ef64cf3fb..364c4c786 100644\n--- a/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n+++ b/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java\n\n@@ -227,17 +225,15 @@ final class PublisherFlatMapSingle<T, R> extends AbstractAsynchronousPublisherOp\n         }\n \n         private void enqueueAndDrain(Object item) {\n-            Subscription s = subscription;\n-            assert s != null;\n-\n             if (!pending.offer(item)) {\n-                enqueueAndDrainFail(item);\n+                enqueueAndDrainFailed(item);\n             }\n-            drainPending(s);\n+            drainPending();\n         }\n \n         @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n-        private void drainPending(Subscription subscription) {\n+        private void drainPending() {\n+            assert subscription != null;\n             long drainCount = 0;\n             Throwable delayedCause = null;\n             while (acquirePendingLock(emittingUpdater, this)) {\n"}}, {"oid": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "url": "https://github.com/apple/servicetalk/commit/b65d07d1426d1378179889947ab2d439ceb6d8b9", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-27T22:59:07Z", "type": "forcePushed"}, {"oid": "3b79e1bfe466f985ba3a373126af2a413df0f66c", "url": "https://github.com/apple/servicetalk/commit/3b79e1bfe466f985ba3a373126af2a413df0f66c", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-28T04:01:28Z", "type": "forcePushed"}, {"oid": "cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "url": "https://github.com/apple/servicetalk/commit/cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-28T04:02:23Z", "type": "forcePushed"}, {"oid": "550413afb290968388de8599cd729a248024a68b", "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-05-01T01:16:52Z", "type": "commit"}, {"oid": "550413afb290968388de8599cd729a248024a68b", "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-05-01T01:16:52Z", "type": "forcePushed"}]}