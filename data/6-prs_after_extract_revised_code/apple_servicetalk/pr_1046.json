{"pr_number": 1046, "pr_title": "DelayedSubscription no longer uses ConcurrentSubscription internally", "pr_createdAt": "2020-05-09T23:01:13Z", "pr_url": "https://github.com/apple/servicetalk/pull/1046", "timeline": [{"oid": "015749c3379424f79525cb3a58daffaca113b09c", "url": "https://github.com/apple/servicetalk/commit/015749c3379424f79525cb3a58daffaca113b09c", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription.", "committedDate": "2020-05-10T02:51:48Z", "type": "forcePushed"}, {"oid": "d23e3ce4972aec62c6c873de0753b609814e6d77", "url": "https://github.com/apple/servicetalk/commit/d23e3ce4972aec62c6c873de0753b609814e6d77", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription.", "committedDate": "2020-05-10T02:55:03Z", "type": "forcePushed"}, {"oid": "27248b97dd20cff013b118323f2fcf0811648678", "url": "https://github.com/apple/servicetalk/commit/27248b97dd20cff013b118323f2fcf0811648678", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription.", "committedDate": "2020-05-10T02:59:10Z", "type": "forcePushed"}, {"oid": "2675899f2f37ccc9ba4f968dae221cc4b9303845", "url": "https://github.com/apple/servicetalk/commit/2675899f2f37ccc9ba4f968dae221cc4b9303845", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription.", "committedDate": "2020-05-10T03:03:00Z", "type": "forcePushed"}, {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "url": "https://github.com/apple/servicetalk/commit/fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription.", "committedDate": "2020-05-10T03:04:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxNjM2Mg==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423216362", "bodyText": "nit: I like to use << 1 etc", "author": "normanmaurer", "createdAt": "2020-05-11T17:54:33Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;", "originalCommit": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MDE2NQ==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423250165", "bodyText": "these defines are the 3 most negative numbers in succession, and not used in bit masking. there is also an optimization since they are sequential and negative most values which uses <= to avoid explicit checks of each value when all of them take the same code path.", "author": "Scottmitch", "createdAt": "2020-05-11T18:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxNjM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\nindex bbd5c90de..ad185ec54 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n\n@@ -45,16 +45,14 @@ public final class DelayedSubscription implements Subscription {\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n-     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n-     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public boolean delayedSubscription(Subscription delayedSubscription) {\n+    public void delayedSubscription(Subscription delayedSubscription) {\n         requireNonNull(delayedSubscription);\n         for (;;) {\n             final long prevRequested = requested;\n             if (prevRequested <= INVALID_GREATEST_VALUE) {\n                 delayedSubscription.cancel();\n-                return false;\n+                break;\n             } else if (requestedUpdater.compareAndSet(this, prevRequested, SUBSCRIPTION_SETTING)) {\n                 if (prevRequested != 0) {\n                     delayedSubscription.request(prevRequested);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NzM1MA==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423387350", "bodyText": "Considering the case:\n\nInitial requested == 0\nThread 1 invokes delayedSubscription, does requested = SUBSCRIPTION_SETTING.\nThread 2 does request(0), does requested = -1.\nThread 1 goes to the next for loop iteration and does delayedSubscription.request(-1) because prevRequested == -1.\nWhile both values 0 and -1 are illegal according to rule 3.9 it doesn't sound right that we change the original n value from 0 to -1. I'm not sure if this is acceptable or not.\nIf not, consider having another state that will represent request(0): REQUESTED_ZERO = SUBSCRIPTION_CANCEL_PENDING + 1.", "author": "idelpivnitskiy", "createdAt": "2020-05-12T00:02:47Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;\n \n     /**\n      * Set the delayed {@link Subscription}. This method can only be called a single time and\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n+     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n+     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public void delayedSubscription(Subscription delayedSubscription) {\n-        // Temporarily wrap in a ConcurrentSubscription to prevent concurrent invocation between this thread and\n-        // a thread which may be interacting with this class's Subscription API.\n-        final Subscription concurrentSubscription = wrap(delayedSubscription);\n-        if (!currentUpdater.compareAndSet(this, null, concurrentSubscription)) {\n-            delayedSubscription.cancel();\n-        } else {\n-            tryDrainRequested(concurrentSubscription);\n-\n-            // Unwrap the concurrent subscription because there will be no more concurrency.\n-            currentUpdater.compareAndSet(this, concurrentSubscription, delayedSubscription);\n+    public boolean delayedSubscription(Subscription delayedSubscription) {\n+        requireNonNull(delayedSubscription);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested <= INVALID_GREATEST_VALUE) {\n+                delayedSubscription.cancel();\n+                return false;\n+            } else if (requestedUpdater.compareAndSet(this, prevRequested, SUBSCRIPTION_SETTING)) {\n+                if (prevRequested != 0) {\n+                    delayedSubscription.request(prevRequested);\n+                }\n+                // Set the subscription before CAS to make it visible to the thread interacting with the Subscription.\n+                // The Subscription thread won't use the state unless the CAS to SUBSCRIPTION_SET is successful, so\n+                // there will be no concurrency introduced by this operation.\n+                subscription = delayedSubscription;\n+                if (requestedUpdater.compareAndSet(this, SUBSCRIPTION_SETTING, SUBSCRIPTION_SET)) {\n+                    return true;\n+                }\n+            }\n         }\n     }\n \n     @Override\n     public void request(long n) {\n-        Subscription current = this.current;\n-        if (current != null) {\n-            current.request(n);\n-        } else {\n-            if (isRequestNValid(n)) {\n-                requestedUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            } else {\n-                // Although 0 is invalid we use it to signify that we have drained the pending request count,\n-                // so in this case we use MIN_VALUE so we can still pass through an invalid number only once.\n-                requested = n == 0 ? MIN_VALUE : n;\n-            }\n-            current = this.current;\n-            if (current != null) {\n-                tryDrainRequested(current);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested == SUBSCRIPTION_SET) {\n+                assert subscription != null;\n+                subscription.request(n);\n+                break;\n+            } else if (prevRequested == SUBSCRIPTION_SETTING) {\n+                if (requestedUpdater.compareAndSet(this, SUBSCRIPTION_SETTING, addRequestN(0, n))) {", "originalCommit": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5ODM4Nw==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423398387", "bodyText": "we are overloading the long domain to serve multiple purposes:\n\nconcurrency control\naccumulation of demand\nrepresenting invalid demand\nrepresenting cancel\n\nThe trade-off is we lose some fidelity (e.g. minimum of 3 invalid request(n) values) on the \"representing invalid demand\" in order to represent these state transition. Ideally we preserve the original n for debuggability but we use a similar approach in other places to reduce state and consolidate atomic operations on a single field.\nWe can preserve 0 via some additional mapping/unmapping if we think that is more likely to be used than some other negative number (doesn't seem unreasonable), but also don't think it is a hard requirement based upon the spec.", "author": "Scottmitch", "createdAt": "2020-05-12T00:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NzM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\nindex bbd5c90de..ad185ec54 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n\n@@ -45,16 +45,14 @@ public final class DelayedSubscription implements Subscription {\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n-     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n-     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public boolean delayedSubscription(Subscription delayedSubscription) {\n+    public void delayedSubscription(Subscription delayedSubscription) {\n         requireNonNull(delayedSubscription);\n         for (;;) {\n             final long prevRequested = requested;\n             if (prevRequested <= INVALID_GREATEST_VALUE) {\n                 delayedSubscription.cancel();\n-                return false;\n+                break;\n             } else if (requestedUpdater.compareAndSet(this, prevRequested, SUBSCRIPTION_SETTING)) {\n                 if (prevRequested != 0) {\n                     delayedSubscription.request(prevRequested);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NzM0OQ==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423397349", "bodyText": "I did a quick check on usages of this method and we always call it from onSubscribe(). Can we simply disallow calling this method twice? This will do two things:\n\nFail fast for unexpected usage (we do not expect this to be called more than once)\nSimplify contract (returned boolean should always be true)", "author": "NiteshKant", "createdAt": "2020-05-12T00:37:26Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;\n \n     /**\n      * Set the delayed {@link Subscription}. This method can only be called a single time and\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n+     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n+     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public void delayedSubscription(Subscription delayedSubscription) {\n-        // Temporarily wrap in a ConcurrentSubscription to prevent concurrent invocation between this thread and\n-        // a thread which may be interacting with this class's Subscription API.\n-        final Subscription concurrentSubscription = wrap(delayedSubscription);\n-        if (!currentUpdater.compareAndSet(this, null, concurrentSubscription)) {\n-            delayedSubscription.cancel();\n-        } else {\n-            tryDrainRequested(concurrentSubscription);\n-\n-            // Unwrap the concurrent subscription because there will be no more concurrency.\n-            currentUpdater.compareAndSet(this, concurrentSubscription, delayedSubscription);\n+    public boolean delayedSubscription(Subscription delayedSubscription) {\n+        requireNonNull(delayedSubscription);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested <= INVALID_GREATEST_VALUE) {", "originalCommit": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQwNTc1OA==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423405758", "bodyText": "discussed offline. for now I'll just stick with void return type as boolean isn't strictly required. future considerations for throwing:\n\nmore aggressive breaking change that could potentially break downstream onSubscribe propagation such that a subsequent onError is called without a prior onSubscribe:\n\nonSubscribe(s) {\n  mySubscription.delayedSubscription(s);\n...\n  downstreamSubscriber.onSubscribe(mySubscription);\n}\nonError(cause) {\n  downstreamSubscriber.onError(cause); // onSubscribe wasn't called\n}\n\n\ninvestigation required if DelayedCancellable (which is used in similar capacity for Single/Completable) should follow the same behavior (currently they are both void)", "author": "Scottmitch", "createdAt": "2020-05-12T01:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2MjQ5Mw==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423862493", "bodyText": "more aggressive breaking change that could potentially break downstream onSubscribe propagation such that a subsequent onError is called without a prior onSubscribe\n\nThe scenario we are talking about is when onSubscribe() is called twice. Presumably the first onSubscribe() correctly went through to downstream, if so, then sending it the second time isn't really expected. Additionally, silently cancelling the Subscription is arguably less useful than bubbling up the error.\nDeferring the change sounds good if we are not going out of our way to support it.", "author": "NiteshKant", "createdAt": "2020-05-12T16:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\nindex bbd5c90de..ad185ec54 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n\n@@ -45,16 +45,14 @@ public final class DelayedSubscription implements Subscription {\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n-     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n-     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public boolean delayedSubscription(Subscription delayedSubscription) {\n+    public void delayedSubscription(Subscription delayedSubscription) {\n         requireNonNull(delayedSubscription);\n         for (;;) {\n             final long prevRequested = requested;\n             if (prevRequested <= INVALID_GREATEST_VALUE) {\n                 delayedSubscription.cancel();\n-                return false;\n+                break;\n             } else if (requestedUpdater.compareAndSet(this, prevRequested, SUBSCRIPTION_SETTING)) {\n                 if (prevRequested != 0) {\n                     delayedSubscription.request(prevRequested);\n"}}, {"oid": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "url": "https://github.com/apple/servicetalk/commit/5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "message": "DelayedSubscription ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription.", "committedDate": "2020-05-12T00:57:37Z", "type": "forcePushed"}, {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c", "url": "https://github.com/apple/servicetalk/commit/1805508ccdd26b5696800e275d1a5b3ce254159c", "message": "DelayedSubscription no longer uses ConcurrentSubscription internally\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription.", "committedDate": "2020-05-12T00:58:44Z", "type": "commit"}, {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c", "url": "https://github.com/apple/servicetalk/commit/1805508ccdd26b5696800e275d1a5b3ce254159c", "message": "DelayedSubscription no longer uses ConcurrentSubscription internally\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription.", "committedDate": "2020-05-12T00:58:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3NTQzMA==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423875430", "bodyText": "nit: INVALID_SMALLEST_VALUE is more appropriate as these are all negative values.", "author": "NiteshKant", "createdAt": "2020-05-12T16:35:56Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,28 +18,26 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;", "originalCommit": "1805508ccdd26b5696800e275d1a5b3ce254159c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NDc1Mg==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423994752", "bodyText": "it is the greatest value out of the control values (all control values are more negative than this) and used in conditionals to determine if a value is a \"control value\" or not via <= (e.g. prevRequested <= INVALID_GREATEST_VALUE)", "author": "Scottmitch", "createdAt": "2020-05-12T19:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3NTQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwMzI4Nw==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r424003287", "bodyText": "I'll rename to GREATEST_CONTROL_VALUE to clarify.", "author": "Scottmitch", "createdAt": "2020-05-12T20:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3NTQzMA=="}], "type": "inlineReview", "revised_code": {"commit": "1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\nindex ad185ec54..88ef8865e 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n\n@@ -32,7 +32,7 @@ public final class DelayedSubscription implements Subscription {\n     private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n     private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n     private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n-    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n+    private static final long GREATEST_CONTROL_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n             newUpdater(DelayedSubscription.class, \"requested\");\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2ODM0OA==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423968348", "bodyText": "If you merge requested and Subscription fields in a single Object state then you can simplify the state-machine and reduce fields here.\n(requested handling may be simplified, I haven't thought about it, but this gives the idea of what I am suggesting)\npublic final class DelayedSubscription implements Subscription {\n    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Object> stateUpdater =\n            AtomicReferenceFieldUpdater.newUpdater(DelayedSubscription.class, Object.class, \"state\");\n    private static final Object STATE_CANCELLED = new Object();\n    private static final Object STATE_TERMINATED = new Object();\n    private volatile Object state = 0L;\n\n    /**\n     * Set the delayed {@link Subscription}. This method can only be called a single time and\n     * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n     *\n     * @param delayedSubscription The delayed {@link Subscription}.\n     */\n    public void delayedSubscription(Subscription delayedSubscription) {\n        requireNonNull(delayedSubscription);\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_TERMINATED || cState instanceof Subscription) {\n                delayedSubscription.cancel();\n                return;\n            }\n            if (cState == STATE_CANCELLED && stateUpdater.compareAndSet(this, cState, STATE_TERMINATED)) {\n                delayedSubscription.cancel();\n                return;\n            }\n\n            if (cState instanceof Long && stateUpdater.compareAndSet(this, cState, 0L)) {\n                long requested = (Long) cState;\n                if (requested > 0 || requested == MIN_VALUE) {\n                    delayedSubscription.request(requested);\n                }\n                if (stateUpdater.compareAndSet(this, 0L, delayedSubscription)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void request(long n) {\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_CANCELLED || cState == STATE_TERMINATED) {\n                return;\n            }\n            if (cState instanceof Subscription) {\n                Subscription s = (Subscription) cState;\n                s.request(n);\n                return;\n            }\n            if (cState instanceof Long) {\n                Long prevReq = (Long) cState;\n                if (n > 0 &&\n                        stateUpdater.compareAndSet(this, cState, addWithOverflowProtectionIfNotNegative(prevReq, n))\n                        || n <= 0 && stateUpdater.compareAndSet(this, cState, MIN_VALUE)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void cancel() {\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_CANCELLED || cState == STATE_TERMINATED) {\n                return;\n            }\n            if (cState instanceof Subscription) {\n                Subscription s = (Subscription) cState;\n                s.cancel();\n                return;\n            }\n            if (cState instanceof Long && stateUpdater.compareAndSet(this, cState, STATE_CANCELLED)) {\n                return;\n            }\n        }\n    }\n}", "author": "NiteshKant", "createdAt": "2020-05-12T19:07:21Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,28 +18,26 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;", "originalCommit": "1805508ccdd26b5696800e275d1a5b3ce254159c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwMTMzMA==", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r424001330", "bodyText": "lets consider this alternative approach as a followup PR. the impacts of boxing/unboxing and additional object allocation need to be considered/evaluated. the motivation for this PR was avoiding intermediate allocations.", "author": "Scottmitch", "createdAt": "2020-05-12T20:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2ODM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\nindex ad185ec54..88ef8865e 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java\n\n@@ -32,7 +32,7 @@ public final class DelayedSubscription implements Subscription {\n     private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n     private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n     private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n-    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n+    private static final long GREATEST_CONTROL_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n             newUpdater(DelayedSubscription.class, \"requested\");\n \n"}}, {"oid": "1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "url": "https://github.com/apple/servicetalk/commit/1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "message": "INVALID_GREATEST_VALUE -> GREATEST_CONTROL_VALUE", "committedDate": "2020-05-12T20:09:56Z", "type": "commit"}]}