{"pr_number": 1034, "pr_title": "More robust exception handling from Subscribers", "pr_createdAt": "2020-04-29T17:35:58Z", "pr_url": "https://github.com/apple/servicetalk/pull/1034", "timeline": [{"oid": "57b744a27a3a2c285dfd2a85e673925cf3703ac1", "url": "https://github.com/apple/servicetalk/commit/57b744a27a3a2c285dfd2a85e673925cf3703ac1", "message": "More robust exception handling from Subscribers\n\nMotivation:\nThe ReactiveStreams specification states that Publisher#subscribe must\nnot throw [1] and also that Subscriber methods must not throw [2].\nHowever in practice these methods may throw and we need to make a best\neffort to propagate exceptions and preserve the asynchronous control\nflow. SubscriberUtils has utility methods deliverTerminalFromSource and\nhandleExceptionFromOnSubscribe to help with this task. However the\nlatter method may propagate exceptions which will result in our error\nrecovery code delivering multiple onSubscribe and onError calls which\nfurther violates the ReactiveStreams specification [1][3]. Here is an\nexample:\n\n```\nNeverPublisher#subscribe()\nsubscriber.onSubscribe(..)\ncatch(cause)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause)\ncatch(cause2)  (in Publisher#handleSubscribe(..))\ndeliverTerminalFromSource(..)\nsubscriber.onSubscribe(..) // duplicate call by our error recovery\ncatch(cause3)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause3) // duplicate call by our error recovery\n```\n\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.9\n[2] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.13\n[3] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.7\n\nModifications:\n- SubscriberUtils#handleExceptionFromOnSubscribe should not re-throw\n- Usage of IGNORE_CANCEL and EMPTY_SUBSCRIPTION should be investigated\nto utilize the SubscriberUtils methods to minimize impact of invalid\nSubscribers and preserve asynchronous control flow\n\nResult:\nMore robust best-effort error recovery in the event of invalid\nSubscribers throwing exceptions.", "committedDate": "2020-04-29T18:01:41Z", "type": "forcePushed"}, {"oid": "d20bfac941a764c0c01374615cab5ada90361bb8", "url": "https://github.com/apple/servicetalk/commit/d20bfac941a764c0c01374615cab5ada90361bb8", "message": "More robust exception handling from Subscribers\n\nMotivation:\nThe ReactiveStreams specification states that Publisher#subscribe must\nnot throw [1] and also that Subscriber methods must not throw [2].\nHowever in practice these methods may throw and we need to make a best\neffort to propagate exceptions and preserve the asynchronous control\nflow. SubscriberUtils has utility methods deliverTerminalFromSource and\nhandleExceptionFromOnSubscribe to help with this task. However the\nlatter method may propagate exceptions which will result in our error\nrecovery code delivering multiple onSubscribe and onError calls which\nfurther violates the ReactiveStreams specification [1][3]. Here is an\nexample:\n\n```\nNeverPublisher#subscribe()\nsubscriber.onSubscribe(..)\ncatch(cause)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause)\ncatch(cause2)  (in Publisher#handleSubscribe(..))\ndeliverTerminalFromSource(..)\nsubscriber.onSubscribe(..) // duplicate call by our error recovery\ncatch(cause3)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause3) // duplicate call by our error recovery\n```\n\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.9\n[2] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.13\n[3] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.7\n\nModifications:\n- SubscriberUtils#handleExceptionFromOnSubscribe should not re-throw\n- Usage of IGNORE_CANCEL and EMPTY_SUBSCRIPTION should be investigated\nto utilize the SubscriberUtils methods to minimize impact of invalid\nSubscribers and preserve asynchronous control flow\n\nResult:\nMore robust best-effort error recovery in the event of invalid\nSubscribers throwing exceptions.", "committedDate": "2020-04-29T19:37:10Z", "type": "commit"}, {"oid": "d20bfac941a764c0c01374615cab5ada90361bb8", "url": "https://github.com/apple/servicetalk/commit/d20bfac941a764c0c01374615cab5ada90361bb8", "message": "More robust exception handling from Subscribers\n\nMotivation:\nThe ReactiveStreams specification states that Publisher#subscribe must\nnot throw [1] and also that Subscriber methods must not throw [2].\nHowever in practice these methods may throw and we need to make a best\neffort to propagate exceptions and preserve the asynchronous control\nflow. SubscriberUtils has utility methods deliverTerminalFromSource and\nhandleExceptionFromOnSubscribe to help with this task. However the\nlatter method may propagate exceptions which will result in our error\nrecovery code delivering multiple onSubscribe and onError calls which\nfurther violates the ReactiveStreams specification [1][3]. Here is an\nexample:\n\n```\nNeverPublisher#subscribe()\nsubscriber.onSubscribe(..)\ncatch(cause)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause)\ncatch(cause2)  (in Publisher#handleSubscribe(..))\ndeliverTerminalFromSource(..)\nsubscriber.onSubscribe(..) // duplicate call by our error recovery\ncatch(cause3)\nhandleExceptionFromOnSubscribe(..)\nsubscriber.onError(cause3) // duplicate call by our error recovery\n```\n\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.9\n[2] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.13\n[3] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.7\n\nModifications:\n- SubscriberUtils#handleExceptionFromOnSubscribe should not re-throw\n- Usage of IGNORE_CANCEL and EMPTY_SUBSCRIPTION should be investigated\nto utilize the SubscriberUtils methods to minimize impact of invalid\nSubscribers and preserve asynchronous control flow\n\nResult:\nMore robust best-effort error recovery in the event of invalid\nSubscribers throwing exceptions.", "committedDate": "2020-04-29T19:37:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI3MTAzNQ==", "url": "https://github.com/apple/servicetalk/pull/1034#discussion_r418271035", "bodyText": "The name seems misleading, perhaps you wanted to name this deliverTerminalFromSource?", "author": "NiteshKant", "createdAt": "2020-04-30T20:31:14Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java", "diffHunk": "@@ -335,4 +349,39 @@ public static void handleExceptionFromOnSubscribe(CompletableSource.Subscriber s\n             LOGGER.info(\"Ignoring exception from onComplete of Subscriber {}.\", subscriber, t);\n         }\n     }\n+\n+    /**\n+     * Invokes {@link SingleSource.Subscriber#onSuccess(Object)} ignoring an occurred exception if any.\n+     * @param subscriber The {@link SingleSource.Subscriber} that may throw an exception from\n+     * {@link SingleSource.Subscriber#onSuccess(Object)}.\n+     * @param value The value to pass to {@link SingleSource.Subscriber#onSuccess(Object)}.\n+     * @param <T> The type of {@link SingleSource.Subscriber}.\n+     */\n+    public static <T> void safeOnComplete(SingleSource.Subscriber<T> subscriber, @Nullable T value) {", "originalCommit": "d20bfac941a764c0c01374615cab5ada90361bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTI5MA==", "url": "https://github.com/apple/servicetalk/pull/1034#discussion_r418329290", "bodyText": "good catch ... this method should be broken up into deliverTerminalFromSource and safeOnComplete", "author": "Scottmitch", "createdAt": "2020-04-30T22:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI3MTAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ac9c081e4d94516ee80c05eef0a7663f5615b63e", "chunk": "diff --git a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java\nindex d2b992e1f..71b42daee 100644\n--- a/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java\n+++ b/servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java\n\n@@ -354,16 +371,9 @@ public final class SubscriberUtils {\n      * Invokes {@link SingleSource.Subscriber#onSuccess(Object)} ignoring an occurred exception if any.\n      * @param subscriber The {@link SingleSource.Subscriber} that may throw an exception from\n      * {@link SingleSource.Subscriber#onSuccess(Object)}.\n-     * @param value The value to pass to {@link SingleSource.Subscriber#onSuccess(Object)}.\n      * @param <T> The type of {@link SingleSource.Subscriber}.\n      */\n     public static <T> void safeOnComplete(SingleSource.Subscriber<T> subscriber, @Nullable T value) {\n-        try {\n-            subscriber.onSubscribe(IGNORE_CANCEL);\n-        } catch (Throwable t) {\n-            handleExceptionFromOnSubscribe(subscriber, t);\n-            return;\n-        }\n         try {\n             subscriber.onSuccess(value);\n         } catch (Throwable t) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NDk5OA==", "url": "https://github.com/apple/servicetalk/pull/1034#discussion_r418284998", "bodyText": "This seems to be different than what was happening before as we are not cancelling the subscription any more. I think the assumption here is that this exception will bubble up to the source which effectively cancels the subscription?", "author": "NiteshKant", "createdAt": "2020-04-30T20:58:25Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java", "diffHunk": "@@ -74,24 +73,22 @@ private Flush() {\n         public void onSubscribe(Subscription subscription) {\n             try {\n                 writeEventsListener.writeStarted();\n-            } catch (Throwable t) {\n-                subscription.cancel();\n-                subscriber.onSubscribe(EMPTY_SUBSCRIPTION);\n-                subscriber.onError(t);\n-                return;\n-            }\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) {\n-                    subscription.request(n);\n-                }\n+            } finally {\n+                // As long as we call onSubscribe we can let exceptions propagate and the source should terminate\n+                // this Subscriber for cleanup.\n+                subscriber.onSubscribe(new Subscription() {", "originalCommit": "d20bfac941a764c0c01374615cab5ada90361bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1034#discussion_r418329751", "bodyText": "Correct. I attempted to articulate that in the comment above but let me expand on this to clarify more.", "author": "Scottmitch", "createdAt": "2020-04-30T22:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI4NDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "ac9c081e4d94516ee80c05eef0a7663f5615b63e", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java\nindex 9fd3f7614..b11dbde55 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java\n\n@@ -74,8 +74,9 @@ final class Flush {\n             try {\n                 writeEventsListener.writeStarted();\n             } finally {\n-                // As long as we call onSubscribe we can let exceptions propagate and the source should terminate\n-                // this Subscriber for cleanup.\n+                // Any exceptions that occur will escape this method and bubble up to the Source. If this occurs the\n+                // Subscription is considered cancelled and the Source should terminate this Subscriber with an onError.\n+                // Before the exception propagates we must call onSubscribe so subscriber is ready for onError.\n                 subscriber.onSubscribe(new Subscription() {\n                     @Override\n                     public void request(long n) {\n"}}, {"oid": "ac9c081e4d94516ee80c05eef0a7663f5615b63e", "url": "https://github.com/apple/servicetalk/commit/ac9c081e4d94516ee80c05eef0a7663f5615b63e", "message": "review comments", "committedDate": "2020-04-30T22:45:11Z", "type": "commit"}, {"oid": "e66a2fa40e70e8d133be4acde527a48a614fad9d", "url": "https://github.com/apple/servicetalk/commit/e66a2fa40e70e8d133be4acde527a48a614fad9d", "message": "disambiguate method names", "committedDate": "2020-04-30T23:57:12Z", "type": "commit"}]}