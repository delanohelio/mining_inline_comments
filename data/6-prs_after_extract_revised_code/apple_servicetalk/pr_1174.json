{"pr_number": 1174, "pr_title": "Introduce HTTP content encoding H1 & H2", "pr_createdAt": "2020-10-12T17:33:26Z", "pr_url": "https://github.com/apple/servicetalk/pull/1174", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxNDE0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r504914148", "bodyText": "Hold on reviewing this part, after some discussions, I need to consider controlling demand from within. I am looking at the Processor API to see how this can be hooked.", "author": "tkountis", "createdAt": "2020-10-14T19:17:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final HttpHeaders headers, final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+        return from", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex b8df7b4a5..c9dcb554d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -52,21 +52,20 @@ import javax.annotation.Nullable;\n \n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n-import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements ContentCodec {\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n \n-    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    private final CharSequence encoding;\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n \n-    AbstractZipContentCodec(final CharSequence encoding) {\n-        this.encoding = encoding;\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NjA0Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508186046", "bodyText": "What is the motivation for having 2 different interfaces: ContentCoding and ContentCodec? Do we expect any other methods on ContentCoding interface in future?\nDid you consider merging these two together? Looks like the name is a required characteristic of a ContentCodec. Can not imagine a case of having ContentCoding that returns GzipContentCodec with a different name.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T03:23:31Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ */\n+public interface ContentCoding {\n+\n+    /**\n+     * A string representation for the content coding.\n+     *\n+     * @return a string representation for the content coding.\n+     */\n+    String name();\n+\n+    /**\n+     * The codec that supports encoding/decoding for this type of content coding.\n+     *\n+     * @return a shared instance of the codec for that content coding\n+     */\n+    ContentCodec codec();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MDU1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508340558", "bodyText": "Agree, I believe its a leftover from my conversion between enum & interface for the coding, but there is no benefit from keeping them separate.", "author": "tkountis", "createdAt": "2020-10-20T09:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NjA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\nsimilarity index 57%\nrename from servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\nindex 8eb1e058b..bff3e9a60 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\n\n@@ -15,22 +15,36 @@\n  */\n package io.servicetalk.http.api;\n \n-/**\n- * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n- */\n-public interface ContentCoding {\n-\n-    /**\n-     * A string representation for the content coding.\n-     *\n-     * @return a string representation for the content coding.\n-     */\n-    String name();\n-\n-    /**\n-     * The codec that supports encoding/decoding for this type of content coding.\n-     *\n-     * @return a shared instance of the codec for that content coding\n-     */\n-    ContentCodec codec();\n+import java.nio.charset.Charset;\n+import javax.annotation.Nullable;\n+\n+interface Uri {\n+    String uri();\n+\n+    @Nullable\n+    String scheme();\n+\n+    @Nullable\n+    String authority();\n+\n+    @Nullable\n+    String userInfo();\n+\n+    @Nullable\n+    String host();\n+\n+    int port();\n+\n+    String path();\n+\n+    String path(Charset charset);\n+\n+    @Nullable\n+    String query();\n+\n+    @Nullable\n+    String query(Charset charset);\n+\n+    @Nullable\n+    String fragment();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508187518", "bodyText": "When users may need non-streaming variants in a context of HTTP?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T03:29:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n+        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MTMwNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508341304", "bodyText": "This is not an exposed API to the user.\nThe service will use internally to do the work, in which case it only works with plain blocking and the streaming versions.", "author": "tkountis", "createdAt": "2020-10-20T09:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyMzY2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508723664", "bodyText": "Discussed offline, this looks like a leftover from intermediate work, we need only streaming API for HTTP.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nindex e995d2b33..2f78cb182 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n\n@@ -17,48 +17,43 @@ package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Publisher;\n \n /**\n- * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ * Used to encode and decode {@link Buffer}s.\n+ *\n  * This instance is shared therefore it must provide thread safety semantics.\n  */\n public interface ContentCodec {\n \n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n-        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n     }\n \n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param offset the offset of the source to start reading from\n      * @param length the total length available for reading\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the encoded contents.\n-     *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n-     * @param from the {@link Publisher} buffer to encode\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers encoded\n-     */\n-    Publisher<Buffer> encode(HttpHeaders headers, Publisher<Buffer> from, BufferAllocator allocator);\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n \n     /**\n      * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195581", "bodyText": "Did you explore an oportunity to merge ContentCodec and MessageCodec from gRPC into one interface?\nThe main idea that components should be reused between different protocols. Serializer API is a good example. We have HttpSerializer that manages headers, but the implementation of Serializer interface is protocol-agnostic.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:01:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface ContentCodec {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MzI4MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508343281", "bodyText": "A few times yes, I played with having the two together. However, at the end I chose to keep them separate. There is one fundamental difference between the Message & Content codecs, and that's their lifecycle. The former is a lifecycle per message, but the latter maintains context of the encoders for the whole payload. There are some code similarities on the aggregated signatures, but its not that much to worth keeping them in one place for now.", "author": "tkountis", "createdAt": "2020-10-20T09:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyODYwOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508728609", "bodyText": "I think we can merge streaming and non-streaming variants in a single interface and make the streaming variant in the way it applies the non-streaming method as a mapping function for each chunk. Some compression algorithms work in this way, like LZ4. It will reduce the need for implementing a streaming variant when it's not necessary, like for grpc.\nAnother way is to provide ContentCodec and StreamingContentCodec interfaces. The main idea is to make the compression/decompression logic protocol agnostic, without embedding the logic that manages headers, for cases if we have more protocols in the future. That way users will be able to reuse the codec algorithms without implementing a custom codec for each protocol.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNDkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518434915", "bodyText": "This discussion moves to #1198 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nindex e995d2b33..2f78cb182 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n\n@@ -17,48 +17,43 @@ package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Publisher;\n \n /**\n- * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ * Used to encode and decode {@link Buffer}s.\n+ *\n  * This instance is shared therefore it must provide thread safety semantics.\n  */\n public interface ContentCodec {\n \n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n-        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n     }\n \n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param offset the offset of the source to start reading from\n      * @param length the total length available for reading\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the encoded contents.\n-     *\n-     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n-     * @param from the {@link Publisher} buffer to encode\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers encoded\n-     */\n-    Publisher<Buffer> encode(HttpHeaders headers, Publisher<Buffer> from, BufferAllocator allocator);\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n \n     /**\n      * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTczMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195731", "bodyText": "This method is used only in tests and internal unitily, can we make it pkg-private for now?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:02:06Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding gzip() {\n+        return GZIP;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n+    }\n+\n+    /**\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n+     */\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n+    }\n+\n+    /**\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns {@code null} if {@code name} is {@code null} or empty.\n+     * If {@code name} is {@code 'identity'} this will always result in\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     *\n+     * @param allowedList the source list to find a matching encoding in\n+     * @param name the encoding name used for the matching predicate\n+     * @return an encoding from the allowed-list matching the {@code name},\n+     *          otherwise {@code null} if {@code name} is {@code null} or empty\n+     */\n+    @Nullable\n+    public static ContentCoding encodingFor(final Collection<ContentCoding> allowedList,", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 806238db5..bd5b2d48b 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,78 +15,85 @@\n  */\n package io.servicetalk.http.api;\n \n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.DeflateStreamingContentCodingBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.GzipStreamingContentCodingBuilder;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Default available encoding implementations.\n- * Encoding {@link #none()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n  */\n public final class ContentCodings {\n \n-    static final CharSequence GZIP_HEADER = \"gzip\";\n-    static final CharSequence DEFLATE_HEADER = \"deflate\";\n-\n-    private static final ContentCoding NONE =\n-            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final ContentCoding GZIP =\n-            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n \n-    private static final ContentCoding DEFLATE =\n-            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n-\n-    private static final Set<ContentCoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n \n     private ContentCodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link ContentCoding}.\n-     * @return the default, always supported 'identity' {@link ContentCoding}\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding none() {\n-        return NONE;\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n     }\n \n     /**\n-     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n      */\n-    public static ContentCoding gzip() {\n-        return GZIP;\n+    public static DefaultStreamingContentCodingBuilder gzip() {\n+        return new GzipStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding deflate() {\n-        return DEFLATE;\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n     }\n \n     /**\n-     * Returns a list of all {@link ContentCoding}s included by default.\n-     * @return a list of all {@link ContentCoding}s included by default\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n      */\n-    public static Set<ContentCoding> all() {\n-        return ALL;\n+    public static DefaultStreamingContentCodingBuilder deflate() {\n+        return new DeflateStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195857", "bodyText": "Why none is prefered instead of standard identity?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:02:40Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NDU0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508344541", "bodyText": "I like identity more, the only reason I kept none around was that it was already there as a keywords for gRPC and thus I kept the same language. Its a bit more fluent from a user's perspective, but I really have no hard preference.", "author": "tkountis", "createdAt": "2020-10-20T09:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyOTg4MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508729880", "bodyText": "Let's rename to identity in for both protocols. It helps reduce thinking when the name matches the header value.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 806238db5..bd5b2d48b 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,78 +15,85 @@\n  */\n package io.servicetalk.http.api;\n \n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.DeflateStreamingContentCodingBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.GzipStreamingContentCodingBuilder;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Default available encoding implementations.\n- * Encoding {@link #none()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n  */\n public final class ContentCodings {\n \n-    static final CharSequence GZIP_HEADER = \"gzip\";\n-    static final CharSequence DEFLATE_HEADER = \"deflate\";\n-\n-    private static final ContentCoding NONE =\n-            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final ContentCoding GZIP =\n-            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n \n-    private static final ContentCoding DEFLATE =\n-            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n-\n-    private static final Set<ContentCoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n \n     private ContentCodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link ContentCoding}.\n-     * @return the default, always supported 'identity' {@link ContentCoding}\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding none() {\n-        return NONE;\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n     }\n \n     /**\n-     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n      */\n-    public static ContentCoding gzip() {\n-        return GZIP;\n+    public static DefaultStreamingContentCodingBuilder gzip() {\n+        return new GzipStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding deflate() {\n-        return DEFLATE;\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n     }\n \n     /**\n-     * Returns a list of all {@link ContentCoding}s included by default.\n-     * @return a list of all {@link ContentCoding}s included by default\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n      */\n-    public static Set<ContentCoding> all() {\n-        return ALL;\n+    public static DefaultStreamingContentCodingBuilder deflate() {\n+        return new DeflateStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5ODU4Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508198586", "bodyText": "There is also arrayOffset() method that is important in this case. See an example here: \n  \n    \n      servicetalk/servicetalk-buffer-api/src/main/java/io/servicetalk/buffer/api/ReadOnlyByteBuffer.java\n    \n    \n         Line 113\n      in\n      c3b3504\n    \n    \n    \n    \n\n        \n          \n           dst.setBytes(dstIndex, buffer.array(), buffer.arrayOffset() + index, length);", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:14:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzQ0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518437448", "bodyText": "This is not resolved, you need to do output.write(src.array(), src.arrayOffset()+ offset, length), bcz a Buffer may have an internal offset for the backing byte array.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5ODU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex b8df7b4a5..c9dcb554d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -52,21 +52,20 @@ import javax.annotation.Nullable;\n \n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n-import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements ContentCodec {\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n \n-    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    private final CharSequence encoding;\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n \n-    AbstractZipContentCodec(final CharSequence encoding) {\n-        this.encoding = encoding;\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508199061", "bodyText": "Did you consider using netty's implementations instead? We can create an EmbeddedChannel with a single compression codec from netty and use it for async decompression. It will also handle buffering for you.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:15:51Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final HttpHeaders headers, final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(ONE_KB);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public final Buffer decode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newInflaterInputStream(asInputStream(src));\n+\n+            int read = dst.setBytesUntilEndStream(0, input, ONE_KB);\n+            dst.writerIndex(read);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(input);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> decode(final Publisher<Buffer> from, final BufferAllocator allocator) {\n+        return from.liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+\n+            @Nullable\n+            Buffer dst;\n+            @Nullable\n+            Inflater inflater;\n+            @Nullable\n+            ZLibStreamDecoder streamDecoder;\n+\n+            @Override\n+            public void onSubscribe(final PublisherSource.Subscription subscription) {\n+                dst = allocator.newBuffer(ONE_KB);\n+                inflater = newRawInflater();\n+                streamDecoder = new ZLibStreamDecoder(dst, inflater, supportsChecksum());\n+                subscriber.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Buffer src) {\n+                assert streamDecoder != null;\n+                assert src != null;\n+\n+                Buffer part;\n+                try {\n+                    if (streamDecoder.isFinished()) {\n+                        throw new IllegalStateException(\"Stream encoder previously closed but more input arrived \");\n+                    }\n+\n+                    part = streamDecoder.decode(src);\n+                    subscriber.onNext(part != null ? part : EMPTY_BUFFER);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onError(t);\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onComplete();\n+            }\n+        });\n+    }\n+\n+    private void closeQuietly(@Nullable final Closeable closeable) {\n+        try {\n+            if (closeable != null) {\n+                closeable.close();\n+            }\n+        } catch (IOException e) {\n+            LOGGER.error(\"Unexpected IO exception while closing buffer streams\", e);\n+        }\n+    }\n+\n+    // Code forked from Netty's JdkZlibDecoder\n+    static class ZLibStreamDecoder {\n+        private static final int FHCRC = 0x02;\n+        private static final int FEXTRA = 0x04;\n+        private static final int FNAME = 0x08;", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjU3NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508346574", "bodyText": "This is Netty's implementation, unless you are referring to keeping everything on the transport layer, in which I did consider it, and chose to go with this approach for a few reasons.\n\nIt allows from a much easier codec interface for a user to implement if they want custom encoder\nIt allows for cold reads, on the receiving side, it will be decompressed when you need it, and not necessarily inside the event loop.\nIt is consistent with gRPC experience", "author": "tkountis", "createdAt": "2020-10-20T09:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMjU3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508732579", "bodyText": "Discussed offline the approach with EmbeddedChannel:\nIt won't require changing our public API or doing all the work in the transport layer on the event loop, we will just use a synthetic EmbeddedChannel internally instead of Input/Output streams to avoid manual parsing of the compression headers. The only downside is that we will need to depend on netty packages. Therefore, our implementations will need to be in a separate module, something like servicetalk-content-coding-netty.\nLet's finish changes for the public API and then we can reconsider the internal implementations.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex b8df7b4a5..c9dcb554d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -52,21 +52,20 @@ import javax.annotation.Nullable;\n \n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n-import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements ContentCodec {\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n \n-    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    private final CharSequence encoding;\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n \n-    AbstractZipContentCodec(final CharSequence encoding) {\n-        this.encoding = encoding;\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508200801", "bodyText": "The configuration of the compressor is very important aspect. The default level and buffer size does not fit for all use-cases. Did you explore a builder approach for each implementation that will provide these options?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:23:20Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding gzip() {\n+        return GZIP;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding deflate() {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNzk1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508207955", "bodyText": "Another thing to consider as part of the configuration of the decompressor is a protection against ZIP bomb [1]. Users should be able to specify a maximum size to decompress. And ST should stop decompressing if the produced output is higher than that thresold and file the request or response.\n\nhttps://en.wikipedia.org/wiki/Zip_bomb", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODc3OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508348778", "bodyText": "Nice topic, hmm I didn't TBH, and even though I want to keep this simple, it might worth doing that sooner rather than later to have a complete API at least instead of possibly breaking it later. Good catch, especially the zip bomb.", "author": "tkountis", "createdAt": "2020-10-20T09:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMzcwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508733703", "bodyText": "The ContentCodings factory class is good for discoverability. We can keep it, but instead of a ContentCoding it may return builders for deflate and gzip.\nLook it the approach in HttpProtocolConfigs.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 806238db5..bd5b2d48b 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,78 +15,85 @@\n  */\n package io.servicetalk.http.api;\n \n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.DeflateStreamingContentCodingBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodingBuilder.GzipStreamingContentCodingBuilder;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Default available encoding implementations.\n- * Encoding {@link #none()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n  */\n public final class ContentCodings {\n \n-    static final CharSequence GZIP_HEADER = \"gzip\";\n-    static final CharSequence DEFLATE_HEADER = \"deflate\";\n-\n-    private static final ContentCoding NONE =\n-            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final ContentCoding GZIP =\n-            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n \n-    private static final ContentCoding DEFLATE =\n-            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n-\n-    private static final Set<ContentCoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n \n     private ContentCodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link ContentCoding}.\n-     * @return the default, always supported 'identity' {@link ContentCoding}\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding none() {\n-        return NONE;\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n     }\n \n     /**\n-     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n      */\n-    public static ContentCoding gzip() {\n-        return GZIP;\n+    public static DefaultStreamingContentCodingBuilder gzip() {\n+        return new GzipStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding deflate() {\n-        return DEFLATE;\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n     }\n \n     /**\n-     * Returns a list of all {@link ContentCoding}s included by default.\n-     * @return a list of all {@link ContentCoding}s included by default\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodingBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n      */\n-    public static Set<ContentCoding> all() {\n-        return ALL;\n+    public static DefaultStreamingContentCodingBuilder deflate() {\n+        return new DeflateStreamingContentCodingBuilder();\n     }\n \n     /**\n-     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMjkzNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508202934", "bodyText": "newAsciiString is useful when we have content as Buffer and want to give users its CharSequence representation without copying. If you already have a String, there is no need to wrap it with newAsciiString.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:32:18Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 6624def92..3b37ea138 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -656,24 +659,25 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n+                                                  final Collection<StreamingContentCodec> encodings) {\n+        final HttpHeaders headers = metaData.headers();\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (ContentCoding enc : encodings) {\n-            if (enc == none()) {\n+        for (StreamingContentCodec enc : encodings) {\n+            if (enc == identity()) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMzA1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508203056", "bodyText": "Consider doing builder.toString() only if this is true.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:32:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 6624def92..3b37ea138 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -656,24 +659,25 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n+                                                  final Collection<StreamingContentCodec> encodings) {\n+        final HttpHeaders headers = metaData.headers();\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (ContentCoding enc : encodings) {\n-            if (enc == none()) {\n+        for (StreamingContentCodec enc : encodings) {\n+            if (enc == identity()) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNjc2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508206764", "bodyText": "There are cases when identity can be disabled: https://tools.ietf.org/html/rfc7231#section-5.3.4\nSee identity;q=0 value.\nWe don't need to address this as part of this PR, but good thing to consider for the general control flow.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:48:11Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n+        }\n+    }\n+\n+    /**\n+     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n+     * <p>\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     *\n+     * @param headers The request headers\n+     * @param serverSupportedEncodings The supported encodings as configured for the server\n+     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     */\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+        // Fast path, server has no encodings configured or has only None configured as encoding\n+        if (serverSupportedEncodings.isEmpty() ||\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n+        }\n+\n+        Set<ContentCoding> clientSupportedEncodings =\n+                readAcceptEncoding(headers, serverSupportedEncodings);\n+        return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n+    }\n+\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n+        // Fast path, Client has no encodings configured, or has None as the only encoding configured\n+        if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2MjE5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525262191", "bodyText": "#1214", "author": "tkountis", "createdAt": "2020-11-17T15:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNjc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 6624def92..3b37ea138 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -656,24 +659,25 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n+                                                  final Collection<StreamingContentCodec> encodings) {\n+        final HttpHeaders headers = metaData.headers();\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (ContentCoding enc : encodings) {\n-            if (enc == none()) {\n+        for (StreamingContentCodec enc : encodings) {\n+            if (enc == identity()) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508209096", "bodyText": "Continuing discussion of ZIP bombs [1], there is a frequent use-case for the server-side, that users want respond with compressed data, but need to reject all requests with compressed payload body. This is a good discussion on the topic [2].\nHow can we allow this configuration for the server-side?\nAlso, worth thinking about GrpcServer builder.\nNot necessary to implement this feature as part of this PR, but good to adjust configuration API to support that in a follow-up.\n\nhttps://en.wikipedia.org/wiki/Zip_bomb\nhttps://stackoverflow.com/questions/13031968/compressing-http-post-data-sent-from-browser", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:56:17Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java", "diffHunk": "@@ -36,4 +38,13 @@\n      * @return {@link HttpHeadersFactory} to be used for creating {@link HttpHeaders} when decoding HTTP messages\n      */\n     HttpHeadersFactory headersFactory();\n+\n+    /**\n+     * A collection of all {@link ContentCoding}s the endpoint supports.\n+     * The list will be advertised as part of the Accept-Encoding header.\n+     *\n+     * @return The list of supported {@link ContentCoding}s for this endpoint.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    Set<ContentCoding> supportedEncodings();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0OTk3Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508349977", "bodyText": "I believe this is doable as is now. If you provide NO supported-encodings for the server, then any encoded request will fail, and you can manually enable a response encoding using the HttpMetadata.encoding()", "author": "tkountis", "createdAt": "2020-10-20T09:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNjkzNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508736937", "bodyText": "Agreed, this is a way to work around the issue, but it looks like a most-common use-case for the server-side to have a compression for responses only.\nIt looks like if we move this configuration to the client/server builder, we will have better control. For example, server's builder may have 2 overloads: one to support compression in both ways, another overload to support it only for responses.\nHaving it on the builder will also help:\n\nto avoid duplication. Hard to imagine that users need compression for h1, but don't need it for h2. Therefore, makes more sense to keep them applied for all supported transport protocols.\nto consolidate logic in the filter instead of expanding responsibility of NettyHttpServer and client connections.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2OTk1OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508869959", "bodyText": "Btw, we should also account for the proxy use-case: a gateway proxy service that resends the response from downstream backend as-is, when the response is already compressed.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T22:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java\nindex 30fbd75a4..99ef271eb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java\n\n@@ -38,13 +36,4 @@ public interface HttpProtocolConfig {\n      * @return {@link HttpHeadersFactory} to be used for creating {@link HttpHeaders} when decoding HTTP messages\n      */\n     HttpHeadersFactory headersFactory();\n-\n-    /**\n-     * A collection of all {@link ContentCoding}s the endpoint supports.\n-     * The list will be advertised as part of the Accept-Encoding header.\n-     *\n-     * @return The list of supported {@link ContentCoding}s for this endpoint.\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    Set<ContentCoding> supportedEncodings();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508211571", "bodyText": "We should also have intergration tests with some other server implementation. For example, consider running a netty server to make sure it can decompress data produced by ST and vice versa.\nFor grpc we can do that with grpc-java, in a follow-up PR.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:05:17Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingStreamingHttpClient;\n+import io.servicetalk.http.api.ContentCoding;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpHeaders;\n+import io.servicetalk.http.api.HttpProtocolConfig;\n+import io.servicetalk.http.api.HttpServerBuilder;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.ContentCodings.deflate;\n+import static io.servicetalk.http.api.ContentCodings.encodingFor;\n+import static io.servicetalk.http.api.ContentCodings.gzip;\n+import static io.servicetalk.http.api.ContentCodings.none;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.lang.String.valueOf;\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ContentCodingTest {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MDQyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508350422", "bodyText": "\ud83d\udc4d Sure, I will keep this as a separate PR.", "author": "tkountis", "createdAt": "2020-10-20T09:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2MzM1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525263358", "bodyText": "#1215", "author": "tkountis", "createdAt": "2020-11-17T15:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java b/servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\nsimilarity index 58%\nrename from servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java\nrename to servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\nindex a6aef1c7b..6475319a3 100644\n--- a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java\n+++ b/servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\n\n@@ -13,24 +13,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.http.netty;\n+package io.servicetalk.http.api;\n \n import io.servicetalk.concurrent.api.Single;\n import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n-import io.servicetalk.http.api.BlockingStreamingHttpClient;\n-import io.servicetalk.http.api.ContentCoding;\n-import io.servicetalk.http.api.HttpClient;\n-import io.servicetalk.http.api.HttpHeaders;\n-import io.servicetalk.http.api.HttpProtocolConfig;\n-import io.servicetalk.http.api.HttpServerBuilder;\n-import io.servicetalk.http.api.HttpServiceContext;\n-import io.servicetalk.http.api.StreamingHttpClient;\n-import io.servicetalk.http.api.StreamingHttpRequest;\n-import io.servicetalk.http.api.StreamingHttpResponse;\n-import io.servicetalk.http.api.StreamingHttpResponseFactory;\n-import io.servicetalk.http.api.StreamingHttpService;\n-import io.servicetalk.http.api.StreamingHttpServiceFilter;\n-import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n import io.servicetalk.transport.api.ServerContext;\n \n import org.junit.After;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508215398", "bodyText": "Can client-side users configure compression on the builder and then have it for all requests?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:19:13Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingStreamingHttpClient;\n+import io.servicetalk.http.api.ContentCoding;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpHeaders;\n+import io.servicetalk.http.api.HttpProtocolConfig;\n+import io.servicetalk.http.api.HttpServerBuilder;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.ContentCodings.deflate;\n+import static io.servicetalk.http.api.ContentCodings.encodingFor;\n+import static io.servicetalk.http.api.ContentCodings.gzip;\n+import static io.servicetalk.http.api.ContentCodings.none;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.lang.String.valueOf;\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 512;\n+    private static final AtomicBoolean ASYNC_ERROR = new AtomicBoolean(false);\n+\n+    private static final Function<TestEncodingScenario, StreamingHttpServiceFilterFactory> REQ_RESP_VERIFIER = (options)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCoding reqEncoding = options.requestEncoding;\n+                    final Set<ContentCoding> clientSupportedEncodings = options.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer()).collect(StringBuilder::new,\n+                                StringBuilder::append).toFuture().get().toString();\n+\n+                        assertEquals(payload((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = (clientSupportedEncodings == null) ?\n+                                emptyList() :\n+                                clientSupportedEncodings.stream()\n+                                        .filter((enc) -> enc != none())\n+                                        .map((ContentCoding::name))\n+                                        .collect(toList());\n+\n+                        if (reqEncoding != none()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"null\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertEquals(expectedReqAcceptedEncodings, actualReqAcceptedEncodings);\n+                        }\n+                    } catch (Throwable t) {\n+                        ASYNC_ERROR.set(true);\n+                        t.printStackTrace();\n+                        throw new RuntimeException(t);\n+                    }\n+\n+                    return super.handle(ctx, request, responseFactory);\n+                }\n+            };\n+        }\n+    };\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final HttpServerBuilder httpServerBuilder;\n+    private final ServerContext serverContext;\n+    private final HttpClient client;\n+    protected final TestEncodingScenario testEncodingScenario;\n+    private final boolean expectedSuccess;\n+\n+    public ContentCodingTest(final Set<ContentCoding> serverSupportedEncodings,\n+                             final Set<ContentCoding> clientSupportedEncodings,\n+                             final ContentCoding requestEncoding, final boolean expectedSuccess,\n+                             final Protocol protocol) throws Exception {\n+        this.testEncodingScenario = new TestEncodingScenario(requestEncoding, clientSupportedEncodings,\n+                serverSupportedEncodings, protocol);\n+        this.expectedSuccess = expectedSuccess;\n+\n+        httpServerBuilder = HttpServers.forAddress(localAddress(0)).enableWireLogging(\"server\");\n+        serverContext = listenAndAwait();\n+        client = newClient();\n+    }\n+\n+    @Parameterized.Parameters(name = \"server-supported-encodings={0} client-supported-encodings={1} \" +\n+            \"request-encoding={2} expected-success={3} protocol={4}\")\n+    public static Object[][] params() {\n+        return new Object[][] {\n+                {null, null, none(), true, Protocol.H1},\n+                {null, null, none(), true, Protocol.H2},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {null, of(deflate(), none()), deflate(), false, Protocol.H1},\n+                {null, of(deflate(), none()), deflate(), false, Protocol.H2},\n+                {of(gzip(), deflate(), none()), null, none(), true, Protocol.H1},\n+                {of(gzip(), deflate(), none()), null, none(), true, Protocol.H2},\n+                {of(none(), gzip(), deflate()), of(gzip(), none()), gzip(), true, Protocol.H1},\n+                {of(none(), gzip(), deflate()), of(gzip(), none()), gzip(), true, Protocol.H2},\n+                {of(none(), gzip(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H1},\n+                {of(none(), gzip(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H2},\n+                {of(none(), gzip()), of(deflate(), none()), deflate(), false, Protocol.H1},\n+                {of(none(), gzip()), of(deflate(), none()), deflate(), false, Protocol.H2},\n+                {of(none(), deflate()), of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {of(none(), deflate()), of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {of(none(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H1},\n+                {of(none(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H2},\n+                {of(none(), deflate()), null, none(), true, Protocol.H1},\n+                {of(none(), deflate()), null, none(), true, Protocol.H2},\n+                {of(gzip()), of(none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), gzip(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), gzip(), true, Protocol.H2},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {null, of(gzip(), deflate(), none()), deflate(), false, Protocol.H1},\n+                {null, of(gzip(), deflate(), none()), deflate(), false, Protocol.H2},\n+                {null, of(gzip(), none()), none(), true, Protocol.H1},\n+                {null, of(gzip(), none()), none(), true, Protocol.H2},\n+        };\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        ASYNC_ERROR.set(false);\n+        try {\n+            client.close();\n+        } finally {\n+            serverContext.close();\n+        }\n+    }\n+\n+    private ServerContext listenAndAwait() throws Exception {\n+        HttpProtocolConfig config = testEncodingScenario.protocol.build(testEncodingScenario.serverSupported);\n+\n+        StreamingHttpService service = (ctx, request, responseFactory) -> Single.succeeded(responseFactory.ok()\n+                .payloadBody(from(payload((byte) 'b')), textSerializer()));\n+\n+        StreamingHttpServiceFilterFactory filterFactory = REQ_RESP_VERIFIER.apply(testEncodingScenario);\n+        return httpServerBuilder.appendServiceFilter(filterFactory)\n+                .protocols(config)\n+                .listenStreamingAndAwait(service);\n+    }\n+\n+    private HttpClient newClient() {\n+        HttpProtocolConfig config = testEncodingScenario.protocol.build(testEncodingScenario.clientSupported);\n+\n+        return HttpClients.forSingleAddress(serverHostAndPort(serverContext))\n+                .protocols(config)\n+                .build();\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(testEncodingScenario.requestEncoding);\n+        } else {\n+            assertNotSupported(testEncodingScenario.requestEncoding);\n+        }\n+    }\n+\n+    private static String payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return new String(payload, StandardCharsets.US_ASCII);\n+    }\n+\n+    private void assertSuccessful(final ContentCoding encoding) throws Exception {\n+        assertResponse(client.request(client\n+                .get(\"/\")\n+                .encoding(encoding)", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjE4NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508352184", "bodyText": "They can't as of now. My thinking was that a request isn't always a good fit for compression, eg. GET/DELETE requests, or even smaller PUTs/POSTs. It looked more fluent to enable it on-demand, rather than disable it on-demand. If you have hard objections about it, I can track it as a separate PR.", "author": "tkountis", "createdAt": "2020-10-20T09:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNzc1OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508737759", "bodyText": "Discussed offline, users can insert a simple filter if they need compression for all requests that are sent.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java b/servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\nsimilarity index 58%\nrename from servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java\nrename to servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\nindex a6aef1c7b..6475319a3 100644\n--- a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java\n+++ b/servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ContentCodingTest.java\n\n@@ -13,24 +13,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.http.netty;\n+package io.servicetalk.http.api;\n \n import io.servicetalk.concurrent.api.Single;\n import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n-import io.servicetalk.http.api.BlockingStreamingHttpClient;\n-import io.servicetalk.http.api.ContentCoding;\n-import io.servicetalk.http.api.HttpClient;\n-import io.servicetalk.http.api.HttpHeaders;\n-import io.servicetalk.http.api.HttpProtocolConfig;\n-import io.servicetalk.http.api.HttpServerBuilder;\n-import io.servicetalk.http.api.HttpServiceContext;\n-import io.servicetalk.http.api.StreamingHttpClient;\n-import io.servicetalk.http.api.StreamingHttpRequest;\n-import io.servicetalk.http.api.StreamingHttpResponse;\n-import io.servicetalk.http.api.StreamingHttpResponseFactory;\n-import io.servicetalk.http.api.StreamingHttpService;\n-import io.servicetalk.http.api.StreamingHttpServiceFilter;\n-import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n import io.servicetalk.transport.api.ServerContext;\n \n import org.junit.After;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNjM3MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508216370", "bodyText": "It's good that we know the answer how users can configure compression per-reqiest or per-response. They can specify different compression levels for different payloads. However, this is too advanced use-case. Wonder if we should start with a simple approach based on a filter and let users control it there. Let's discuss this offline.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:22:38Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,30 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n+     * If the endpoint protocol is setup with {@link HttpProtocolConfig#supportedEncodings()} the server will\n+     * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n+     * calling this method. Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#none()}.\n+     *\n+     * @param encoding The {@link ContentCoding} used for the encoding of the payload.\n+     * @return {@code this}.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n+     */\n+    HttpMetaData encoding(ContentCoding encoding);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NDAzNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508354037", "bodyText": "It is an advanced use-case indeed, and a filter would also work nicely (even though you would have to work with headers instead of using the API). The reason I kept this as part of the API is that compression/encoding is part of the vanilla HTTP spec, so it feels more natural to have an option to control that for a request/response, rather than having a proxy to do so. WDYT?", "author": "tkountis", "createdAt": "2020-10-20T09:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNjM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\nindex 90226c488..58942b2cf 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n\n@@ -48,28 +48,28 @@ public interface HttpMetaData {\n     HttpHeaders headers();\n \n     /**\n-     * The {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n      * request or a response.\n      * If the endpoint protocol is setup with {@link HttpProtocolConfig#supportedEncodings()} the server will\n      * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n      * calling this method. Any encoding passed here, takes precedence. In other words, a compressed response, can\n-     * be disabled by passing {@link ContentCodings#none()}.\n+     * be disabled by passing {@link ContentCodings#identity()}.\n      *\n-     * @param encoding The {@link ContentCoding} used for the encoding of the payload.\n+     * @param encoding The {@link StreamingContentCodec} used for the encoding of the payload.\n      * @return {@code this}.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n-    HttpMetaData encoding(ContentCoding encoding);\n+    HttpMetaData encoding(StreamingContentCodec encoding);\n \n     /**\n-     * Returns the {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n-     * request or a response.\n+     * Returns the {@link StreamingContentCodec} used to encode the payload\n+     * {@link io.servicetalk.buffer.api.Buffer} of a request or a response.\n      *\n-     * @return The {@link ContentCoding} used for the encoding of the payload.\n+     * @return The {@link StreamingContentCodec} used for the encoding of the payload.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n     @Nullable\n-    ContentCoding encoding();\n+    StreamingContentCodec encoding();\n \n     /**\n      * Adds a new header with the specified {@code name} and {@code value}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNzYyOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508217628", "bodyText": "Considere storing response.encoding() result in a local variable to avoid NPE warning for codec() method.\nYou can also move ContentCodec variable inside if.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:26:23Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -385,6 +418,30 @@ public void onComplete() {\n             }\n         }\n \n+        private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n+                                                            final Set<ContentCoding> supportedEncodings,\n+                                                            final StreamingHttpResponse response,\n+                                                            final BufferAllocator allocator) {\n+            if (supportedEncodings.isEmpty()) {\n+                return;\n+            }\n+\n+            ContentCodec codec;\n+            if (response.encoding() != null) {\n+                codec = response.encoding().codec();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\nindex b33410597..e4f3cdb87 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n\n@@ -418,30 +389,6 @@ final class NettyHttpServer {\n             }\n         }\n \n-        private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                            final Set<ContentCoding> supportedEncodings,\n-                                                            final StreamingHttpResponse response,\n-                                                            final BufferAllocator allocator) {\n-            if (supportedEncodings.isEmpty()) {\n-                return;\n-            }\n-\n-            ContentCodec codec;\n-            if (response.encoding() != null) {\n-                codec = response.encoding().codec();\n-                response.transformPayloadBody(bufferPublisher ->\n-                        codec.encode(response.headers(), bufferPublisher, allocator));\n-            } else {\n-                // Set encoding if one isn't set already and if the request Accept-Encodings match any of the server\n-                // supported ones.\n-                ContentCoding matching = negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-                if (!matching.equals(none())) {\n-                    response.transformPayloadBody(bufferPublisher ->\n-                            matching.codec().encode(response.headers(), bufferPublisher, allocator));\n-                }\n-            }\n-        }\n-\n         private StreamingHttpResponse newErrorResponse(final Throwable cause, final Executor executor,\n                                                        final HttpProtocolVersion version,\n                                                        final HttpKeepAlive keepAlive) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczOTAxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508739015", "bodyText": "This API is used only by ST, consider using CharSequence here to avoid internal conversions toString(). We have CharSequences utility class that does case-insensitive comparisons.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:14:56Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ */\n+public interface ContentCoding {\n+\n+    /**\n+     * A string representation for the content coding.\n+     *\n+     * @return a string representation for the content coding.\n+     */\n+    String name();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\nsimilarity index 57%\nrename from servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\nindex 8eb1e058b..bff3e9a60 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri.java\n\n@@ -15,22 +15,36 @@\n  */\n package io.servicetalk.http.api;\n \n-/**\n- * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n- */\n-public interface ContentCoding {\n-\n-    /**\n-     * A string representation for the content coding.\n-     *\n-     * @return a string representation for the content coding.\n-     */\n-    String name();\n-\n-    /**\n-     * The codec that supports encoding/decoding for this type of content coding.\n-     *\n-     * @return a shared instance of the codec for that content coding\n-     */\n-    ContentCodec codec();\n+import java.nio.charset.Charset;\n+import javax.annotation.Nullable;\n+\n+interface Uri {\n+    String uri();\n+\n+    @Nullable\n+    String scheme();\n+\n+    @Nullable\n+    String authority();\n+\n+    @Nullable\n+    String userInfo();\n+\n+    @Nullable\n+    String host();\n+\n+    int port();\n+\n+    String path();\n+\n+    String path(Charset charset);\n+\n+    @Nullable\n+    String query();\n+\n+    @Nullable\n+    String query(Charset charset);\n+\n+    @Nullable\n+    String fragment();\n }\n"}}, {"oid": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "url": "https://github.com/apple/servicetalk/commit/3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "message": "Rename to Codec & rebase", "committedDate": "2020-11-04T13:38:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDI3Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518430273", "bodyText": "I do not see much value in having an extended interface that adds only default methods. In this case, we can just add default methods to ContentCodec interface.\nAnother approach will be to have 2 independent interfaces: one for streamin, one for non-streaming use-case. They will have a common CharSequence name() method, which is fine to duplicate.\nEach approach has pros and cons:\n\n\nWith a single interface:\n-- users who care only about a streaming variant will also need to implement non-streaming variant. They probably can just thrown UnsupportedOperationException.\n-- users who use non-streaming implementation for streaming case may be broken (depends on compression algorithm). I do not expect it to happen with our implementations.\n\n\nWith 2 interfaces builders will need to have 2  methods: for streaming (buildStreaming()) and non-streaming (build()) variant.\n\n\nI'm fine with both approaches. If we anticipate a protocol in the future that needs both variants, having everything in a single interface will be better.\n@Scottmitch wdyt?", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:22:15Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ *\n+ * Used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface StreamingContentCodec extends ContentCodec {\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map((buffer -> encode(buffer, allocator)));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MTk1MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519071950", "bodyText": "Lets use a single interface like we do for Serializer. The assumption is impls need to support both streaming an aggregated or else they are not usable across the APIs provided by ServiceTalk.\nI would prefer to remain as consistent as possible with the Serializer and HttpSerializer interfaces/approach. They are largely doing the same thing (serializing/deserializing data), except in this case we don't need to care about the Type parameters/conversions. For example did you consider a similar split of BufferSerializer (non protocol specific) and HttpBufferSerializer (http specific)? This may also avoid the tight coupling between HttpMetaData and StreamingContentCodec if the encoding/decoding can be done at the call sites via the payload transformation methods (with helpers from the protocol specific layer).", "author": "Scottmitch", "createdAt": "2020-11-07T00:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java\ndeleted file mode 100644\nindex d6f38ac50..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java\n+++ /dev/null\n\n@@ -1,53 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.Buffer;\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Publisher;\n-\n-/**\n- * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n- *\n- * Used to encode and decode {@link Publisher} of {@link Buffer} parts.\n- * This instance is shared therefore it must provide thread safety semantics.\n- */\n-public interface StreamingContentCodec extends ContentCodec {\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the encoded contents.\n-     *\n-     * @param from the {@link Publisher} buffer to encode\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers encoded\n-     */\n-    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n-        return from.map((buffer -> encode(buffer, allocator)));\n-    }\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the decoded contents.\n-     *\n-     * @param from the {@link Publisher} to decoded\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers decoded\n-     */\n-    default Publisher<Buffer> decode(Publisher<Buffer> from, BufferAllocator allocator) {\n-        return from.map(buffer -> decode(buffer, allocator));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMzQxMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518433410", "bodyText": "Since the codec classes do not carry any http-related information it's better to avoid mentioning HTTP here. Adding this reference in encoding() methods on HttpMetaData is enough.\nWe have a potential to move them to another module outside of HTTP. Not sure if we need to do it now.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:30:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java\ndeleted file mode 100644\nindex d6f38ac50..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java\n+++ /dev/null\n\n@@ -1,53 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.Buffer;\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Publisher;\n-\n-/**\n- * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n- *\n- * Used to encode and decode {@link Publisher} of {@link Buffer} parts.\n- * This instance is shared therefore it must provide thread safety semantics.\n- */\n-public interface StreamingContentCodec extends ContentCodec {\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the encoded contents.\n-     *\n-     * @param from the {@link Publisher} buffer to encode\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers encoded\n-     */\n-    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n-        return from.map((buffer -> encode(buffer, allocator)));\n-    }\n-\n-    /**\n-     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n-     * {@link Publisher} of {@link Buffer} with the decoded contents.\n-     *\n-     * @param from the {@link Publisher} to decoded\n-     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n-     * @return {@link Publisher} the result publisher with the buffers decoded\n-     */\n-    default Publisher<Buffer> decode(Publisher<Buffer> from, BufferAllocator allocator) {\n-        return from.map(buffer -> decode(buffer, allocator));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzODUyNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518438526", "bodyText": "Use src.arrayOffset() + src.readerIndex()", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:45:40Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -153,7 +151,7 @@ public void onNext(Object next) {\n                                 output.write(src.array(), src.readerIndex(), src.readableBytes());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc3OTQ3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518779472", "bodyText": "Will do in the gRPC part, because the API changed there.", "author": "tkountis", "createdAt": "2020-11-06T14:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzODUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex c9dcb554d..9a798a5e8 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -151,14 +154,17 @@ abstract class AbstractZipContentCodec implements StreamingContentCodec {\n                                 output.write(src.array(), src.readerIndex(), src.readableBytes());\n                             } else {\n                                 while (src.readableBytes() > 0) {\n-                                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n                                     src.readBytes(onHeap);\n                                     output.write(onHeap);\n                                 }\n                             }\n \n                             output.flush();\n-                            subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+\n+                            if (dst.readableBytes() > 0) {\n+                                subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                            }\n                         } catch (IOException e) {\n                             throw new RuntimeException(e);\n                         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTExMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518441111", "bodyText": "Should we add identity to the list of header values if it's present in the collection?", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:53:46Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -656,24 +659,25 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n+                                                  final Collection<StreamingContentCodec> encodings) {\n+        final HttpHeaders headers = metaData.headers();\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (ContentCoding enc : encodings) {\n-            if (enc == none()) {\n+        for (StreamingContentCodec enc : encodings) {\n+            if (enc == identity()) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4OTgwNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518689804", "bodyText": "This is always considered acceptable, unless specifically disabled with a 'q' value. Its allowed to be skipped.\nI skipped it, to avoid having it in the headers if its the only encoding, it provides no useful info.", "author": "tkountis", "createdAt": "2020-11-06T11:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -659,25 +656,24 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request headers.\n+     * Advertise the list of supported encodings to the request/response headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param metaData the metadata headers to modify\n+     * @param headers the headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n-                                                  final Collection<StreamingContentCodec> encodings) {\n-        final HttpHeaders headers = metaData.headers();\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (StreamingContentCodec enc : encodings) {\n-            if (enc == identity()) {\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTc4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518441782", "bodyText": "Consider using builder.length() > 0 check instead of prematurely building a String. Otherwise, for non-empty use-case it will copy memory twice.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:55:48Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MjIyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518442222", "bodyText": "newAsciiString is useful when we have content as Buffer and want to give users its CharSequence representation without copying. If you already have a String, there is no need to wrap it with newAsciiString.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:57:12Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzI1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443258", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -656,24 +659,25 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -659,25 +656,24 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request headers.\n+     * Advertise the list of supported encodings to the request/response headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param metaData the metadata headers to modify\n+     * @param headers the headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n-                                                  final Collection<StreamingContentCodec> encodings) {\n-        final HttpHeaders headers = metaData.headers();\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (StreamingContentCodec enc : encodings) {\n-            if (enc == identity()) {\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n                 continue;\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzQyMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443420", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:31Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzU1Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443557", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:55Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -757,24 +753,22 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n-     * header of a request or a response.\n-     * If the name can not be matched to any of the supported encodings on this endpoint, then\n-     * a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n+     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n+     * then a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link StreamingContentCodec} that matches the name.\n+     * @return The {@link ContentCoding} that matches the name.\n      */\n-    public static StreamingContentCodec identifyContentEncodingOrNone(\n-            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n-\n+    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n+                                                              final Set<ContentCoding> allowedEncodings) {\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return identity();\n+            return none();\n         }\n \n-        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());\n+        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n         if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();\n             throw new UnsupportedContentEncodingException(lowercaseEncoding);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0NDc3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518444771", "bodyText": "None -> identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:04:37Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0NDgwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518444803", "bodyText": "None -> identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:04:43Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n-            return none();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        Set<ContentCoding> clientSupportedEncodings =\n+        List<StreamingContentCodec> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n-                                                   final Set<ContentCoding> allowedEncodings) {\n+    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n+                                                           final List<StreamingContentCodec> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518448499", "bodyText": "Note for future improvements: we can improve split to return trimmed CharSequence values instead of doing a toString() conversion and an additional trim here that makes 2 copies of data when a space char is present.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:16:05Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n-            return none();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        Set<ContentCoding> clientSupportedEncodings =\n+        List<StreamingContentCodec> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n-                                                   final Set<ContentCoding> allowedEncodings) {\n+    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n+                                                           final List<StreamingContentCodec> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n-            return none();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        for (ContentCoding encoding : allowedEncodings) {\n-            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n+        for (StreamingContentCodec encoding : allowedEncodings) {\n+            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return none();\n+        return identity();\n     }\n \n-    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n-                                                 final Set<ContentCoding> allowedEncodings) {\n+    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n+                                                          final List<StreamingContentCodec> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        Set<ContentCoding> knownEncodings = new HashSet<>();\n+        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n+            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY5MzU0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518693543", "bodyText": "Yip, split was a fast convenience, I will open an issue to improve it further outside this work.", "author": "tkountis", "createdAt": "2020-11-06T11:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2NjAyMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525266020", "bodyText": "Issue: #1216", "author": "tkountis", "createdAt": "2020-11-17T15:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -688,66 +684,66 @@ public final class HeaderUtils {\n             builder.append(enc.name());\n         }\n \n-        if (!builder.toString().isEmpty()) {\n-            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n         }\n     }\n \n     /**\n-     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * Established a commonly accepted encoding between server & client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n+     * @return The {@link ContentCoding} that satisfies both client & server needs.\n      */\n-    public static StreamingContentCodec negotiateAcceptedEncoding(\n-            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n-\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        List<StreamingContentCodec> clientSupportedEncodings =\n+        Set<ContentCoding> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n-                                                           final List<StreamingContentCodec> allowedEncodings) {\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n-            return identity();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();\n         }\n \n-        for (StreamingContentCodec encoding : allowedEncodings) {\n-            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n+        for (ContentCoding encoding : allowedEncodings) {\n+            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return identity();\n+        return none();\n     }\n \n-    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n-                                                          final List<StreamingContentCodec> allowedEncodings) {\n+    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n+                                                 final Set<ContentCoding> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n+        Set<ContentCoding> knownEncodings = new HashSet<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());\n+            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n             if (enc != null) {\n                 knownEncodings.add(enc);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MDI5Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518450293", "bodyText": "The toString() is not necessary anymore", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:21:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(\n+            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n+\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return none();\n+            return identity();\n         }\n \n-        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n+        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -757,24 +753,22 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n-     * header of a request or a response.\n-     * If the name can not be matched to any of the supported encodings on this endpoint, then\n-     * a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n+     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n+     * then a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link StreamingContentCodec} that matches the name.\n+     * @return The {@link ContentCoding} that matches the name.\n      */\n-    public static StreamingContentCodec identifyContentEncodingOrNone(\n-            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n-\n+    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n+                                                              final Set<ContentCoding> allowedEncodings) {\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return identity();\n+            return none();\n         }\n \n-        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());\n+        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n         if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();\n             throw new UnsupportedContentEncodingException(lowercaseEncoding);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MTM1Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518451352", "bodyText": "Is it necessary to do toLowerCase() for the exception message? I think it's better to keep the value as-is.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:25:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(\n+            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n+\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return none();\n+            return identity();\n         }\n \n-        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n+        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());\n         if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -757,24 +753,22 @@ public final class HeaderUtils {\n     }\n \n     /**\n-     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n-     * header of a request or a response.\n-     * If the name can not be matched to any of the supported encodings on this endpoint, then\n-     * a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n+     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n+     * then a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link StreamingContentCodec} that matches the name.\n+     * @return The {@link ContentCoding} that matches the name.\n      */\n-    public static StreamingContentCodec identifyContentEncodingOrNone(\n-            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n-\n+    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n+                                                              final Set<ContentCoding> allowedEncodings) {\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return identity();\n+            return none();\n         }\n \n-        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());\n+        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n         if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();\n             throw new UnsupportedContentEncodingException(lowercaseEncoding);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MTg3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518451879", "bodyText": "The content-coding names are case-insensitive, use contentEqualsIgnoreCase instead.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:27:10Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -15,100 +15,107 @@\n  */\n package io.servicetalk.http.api;\n \n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Default available encoding implementations.\n- * Encoding {@link #none()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n  */\n public final class ContentCodings {\n \n-    static final CharSequence GZIP_HEADER = \"gzip\";\n-    static final CharSequence DEFLATE_HEADER = \"deflate\";\n-\n-    private static final ContentCoding NONE =\n-            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final ContentCoding GZIP =\n-            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n \n-    private static final ContentCoding DEFLATE =\n-            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n-\n-    private static final Set<ContentCoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n \n     private ContentCodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link ContentCoding}.\n-     * @return the default, always supported 'identity' {@link ContentCoding}\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding none() {\n-        return NONE;\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n     }\n \n     /**\n-     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n      */\n-    public static ContentCoding gzip() {\n-        return GZIP;\n+    public static DefaultStreamingContentCodecBuilder gzip() {\n+        return new GzipStreamingContentCodecBuilder();\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding deflate() {\n-        return DEFLATE;\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n     }\n \n     /**\n-     * Returns a list of all {@link ContentCoding}s included by default.\n-     * @return a list of all {@link ContentCoding}s included by default\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n      */\n-    public static Set<ContentCoding> all() {\n-        return ALL;\n+    public static DefaultStreamingContentCodecBuilder deflate() {\n+        return new DeflateStreamingContentCodecBuilder();\n     }\n \n     /**\n-     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n      * @return an encoding from the allowed-list matching the {@code name},\n      *          otherwise {@code null} if {@code name} is {@code null} or empty\n      */\n     @Nullable\n-    public static ContentCoding encodingFor(final Collection<ContentCoding> allowedList,\n-                                            @Nullable final String name) {\n+    static StreamingContentCodec encodingFor(final Collection<StreamingContentCodec> allowedList,\n+                                             @Nullable final CharSequence name) {\n         requireNonNull(allowedList);\n-        if (name == null || name.isEmpty()) {\n+        if (name == null || isEmpty(name)) {\n             return null;\n         }\n \n         // Identity is always supported, regardless of its presence in the allowed-list\n-        if (name.equalsIgnoreCase(NONE.name())) {\n-            return NONE;\n+        if (contentEquals(name, IDENTITY.name())) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 7998eba07..806238db5 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,85 +15,78 @@\n  */\n package io.servicetalk.http.api;\n \n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n-\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.http.api.CharSequences.contentEquals;\n-import static io.servicetalk.http.api.CharSequences.isEmpty;\n-import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Common available encoding implementations.\n- * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n  */\n public final class ContentCodings {\n \n-    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n \n-    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n \n-    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n \n-    private ContentCodings() {\n-    }\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n \n-    /**\n-     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n-     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n-     */\n-    public static StreamingContentCodec identity() {\n-        return IDENTITY;\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n     }\n \n     /**\n-     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n      */\n-    public static StreamingContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n+    public static ContentCoding none() {\n+        return NONE;\n     }\n \n     /**\n-     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link StreamingContentCodec}\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static DefaultStreamingContentCodecBuilder gzip() {\n-        return new GzipStreamingContentCodecBuilder();\n+    public static ContentCoding gzip() {\n+        return GZIP;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static StreamingContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n      */\n-    public static DefaultStreamingContentCodecBuilder deflate() {\n-        return new DeflateStreamingContentCodecBuilder();\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n     }\n \n     /**\n-     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODAxOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518458019", "bodyText": "IIUC the correct name will be: DEcompressed payload", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:47:32Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultStreamingContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+abstract class DefaultStreamingContentCodecBuilder implements StreamingContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD;", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultStreamingContentCodecBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultStreamingContentCodecBuilder.java\ndeleted file mode 100644\nindex 24a09b285..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultStreamingContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-abstract class DefaultStreamingContentCodecBuilder implements StreamingContentCodecBuilder {\n-\n-    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n-\n-    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD;\n-\n-    @Override\n-    public StreamingContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n-        this.maxAllowedPayloadSize = maxAllowedPayloadSize;\n-        return this;\n-    }\n-\n-    static class GzipStreamingContentCodecBuilder extends DefaultStreamingContentCodecBuilder {\n-        @Override\n-        public StreamingContentCodec build() {\n-            return new GzipContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-\n-    static class DeflateStreamingContentCodecBuilder extends DefaultStreamingContentCodecBuilder {\n-        @Override\n-        public StreamingContentCodec build() {\n-            return new DeflateContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518460169", "bodyText": "1. Is it possible to move this filter and all associated HeaderUtils to http-netty module and make it pkg-private?\n 2. If it's not possible to make it pkg-private, it should also implement StreamingHttpConnectionFilterFactory interface.\n 3. The filter should also implement HttpExecutionStrategyInfluencer interface. See any other filters we have as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:54:47Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NTQzMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518485432", "bodyText": "Follow-up on 1: hm... it's nice that HttpServerBuilder has a protected hook. Consider adding something similar for SingleAddressHttpClientBuilder. Some method that may apply filters maybe?\n//cc @Scottmitch wdyt?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NjA0Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518486047", "bodyText": "Follow-up on 2: actually, I think it should be StreamingHttpConnectionFilterFactory only. Otherwise, if users will reserve a connection, they will lose compression/decompression.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNTQwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518805405", "bodyText": "Thanks for the feedback here, I implemented the interfaces. Regarding the attempt to move the logic in Netty pkg, what's the goal? Is that only an attempt to limit visibility, if so I can fix it with a hook (as you commented). I personally prefer to keep the logic under api, its not Netty specific.", "author": "tkountis", "createdAt": "2020-11-06T14:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNzI3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518807272", "bodyText": "On a second read, I think we are saying the same thing. Let me know if I misunderstood.", "author": "tkountis", "createdAt": "2020-11-06T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MTUxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518991515", "bodyText": "Agreed, also prefer to keep it in http-api module. Was just thinking about how can we make this filter non-public.\nLet's finish the discussion about filter ordering [1] and then decide if we will keep it public or make a hook for the builder.\n\n#1174 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex dec73e560..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map((response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        }));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2Mzg1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518463855", "bodyText": "Consider using set method instead of add for cases when this method invoked multiple times for the request object, we should not add multiple header entries.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:07:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -245,6 +244,10 @@ static void addContentEncoding(final HttpHeaders headers, CharSequence encoding)\n         headers.add(VARY, CONTENT_ENCODING);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex 3b37ea138..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -244,10 +245,6 @@ public final class HeaderUtils {\n         headers.add(VARY, CONTENT_ENCODING);\n     }\n \n-    static boolean hasContentEncoding(final HttpHeaders headers) {\n-        return headers.contains(CONTENT_ENCODING);\n-    }\n-\n     static void validateCookieNameAndValue(final CharSequence cookieName, final CharSequence cookieValue) {\n         if (cookieName == null || cookieName.length() == 0) {\n             throw new IllegalArgumentException(\"Null or empty cookie names are not allowed.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3MDMxMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518470312", "bodyText": "Not necessary to add javadoc for overriden methods.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:28:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java", "diffHunk": "@@ -141,6 +141,17 @@\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\nindex efafab6a2..44784f399 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\n\n@@ -141,17 +149,6 @@ abstract class HttpClientBuilder<U, R, SDE extends ServiceDiscovererEvent<R>> ex\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint.\n-     * The list will be advertised as part of the Accept-Encoding header\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    @Override\n-    public abstract HttpClientBuilder<U, R, SDE> supportedEncodings(StreamingContentCodec... codings);\n-\n     @Override\n     public abstract HttpClientBuilder<U, R, SDE> disableHostHeaderFallback();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3ODYyOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518478629", "bodyText": "MultiAddressHttpClientBuilder misses this override", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:57:07Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java", "diffHunk": "@@ -141,6 +141,17 @@\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    @Override\n+    public abstract HttpClientBuilder<U, R, SDE> supportedEncodings(StreamingContentCodec... codings);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\nindex efafab6a2..44784f399 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java\n\n@@ -141,17 +149,6 @@ abstract class HttpClientBuilder<U, R, SDE extends ServiceDiscovererEvent<R>> ex\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint.\n-     * The list will be advertised as part of the Accept-Encoding header\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    @Override\n-    public abstract HttpClientBuilder<U, R, SDE> supportedEncodings(StreamingContentCodec... codings);\n-\n     @Override\n     public abstract HttpClientBuilder<U, R, SDE> disableHostHeaderFallback();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3OTM5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518479391", "bodyText": "The filter should also implement HttpExecutionStrategyInfluencer interface. See any other filters we have as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:59:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex c54a6702d..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n-\n-    private final List<StreamingContentCodec> requestCodings;\n-    private final List<StreamingContentCodec> responseCodings;\n-\n-    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n-                                          final List<StreamingContentCodec> responseCodings) {\n-        this.requestCodings = requestCodings;\n-        this.responseCodings = responseCodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n-                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-\n-                return super.handle(ctx, request, responseFactory).map(response -> {\n-                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                    return response;\n-                });\n-            }\n-        };\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<StreamingContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                           final StreamingHttpResponse response,\n-                                                           final List<StreamingContentCodec> supportedEncodings) {\n-        if (response.encoding() != null) {\n-            // Enforced selection\n-            return response.encoding();\n-        }\n-\n-        // Negotiate encoding according to Accept-Encodings header and server supported ones.\n-        return negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3OTkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518479915", "bodyText": "nit: shifted indentation", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:01:03Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex c54a6702d..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n-\n-    private final List<StreamingContentCodec> requestCodings;\n-    private final List<StreamingContentCodec> responseCodings;\n-\n-    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n-                                          final List<StreamingContentCodec> responseCodings) {\n-        this.requestCodings = requestCodings;\n-        this.responseCodings = responseCodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n-                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-\n-                return super.handle(ctx, request, responseFactory).map(response -> {\n-                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                    return response;\n-                });\n-            }\n-        };\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<StreamingContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                           final StreamingHttpResponse response,\n-                                                           final List<StreamingContentCodec> supportedEncodings) {\n-        if (response.encoding() != null) {\n-            // Enforced selection\n-            return response.encoding();\n-        }\n-\n-        // Negotiate encoding according to Accept-Encodings header and server supported ones.\n-        return negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MDkzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518480936", "bodyText": "Not necessary to apply transform operations when we deal with identity().", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:04:24Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {\n+        this.requestCodings = requestCodings;\n+        this.responseCodings = responseCodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n+                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex c54a6702d..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n-\n-    private final List<StreamingContentCodec> requestCodings;\n-    private final List<StreamingContentCodec> responseCodings;\n-\n-    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n-                                          final List<StreamingContentCodec> responseCodings) {\n-        this.requestCodings = requestCodings;\n-        this.responseCodings = responseCodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n-                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-\n-                return super.handle(ctx, request, responseFactory).map(response -> {\n-                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                    return response;\n-                });\n-            }\n-        };\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<StreamingContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                           final StreamingHttpResponse response,\n-                                                           final List<StreamingContentCodec> supportedEncodings) {\n-        if (response.encoding() != null) {\n-            // Enforced selection\n-            return response.encoding();\n-        }\n-\n-        // Negotiate encoding according to Accept-Encodings header and server supported ones.\n-        return negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MTg4MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518481880", "bodyText": "coding != null and it's not identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:07:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex dec73e560..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map((response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        }));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518482922", "bodyText": "Store the result of response.encoding() in a local variable and then you can remove @Nullable.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:11:48Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {\n+        this.requestCodings = requestCodings;\n+        this.responseCodings = responseCodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n+                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+\n+                return super.handle(ctx, request, responseFactory).map(response -> {\n+                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n+                    return response;\n+                });\n+            }\n+        };\n+    }\n+\n+    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n+                                                        final List<StreamingContentCodec> supportedEncodings,\n+                                                        final StreamingHttpResponse response,\n+                                                        final BufferAllocator allocator) {\n+        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n+            return;\n+        }\n+\n+        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n+        if (coding != null && !coding.equals(identity())) {\n+            addContentEncoding(response.headers(), coding.name());\n+            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n+        }\n+    }\n+\n+    @Nullable\n+    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n+                                                           final StreamingHttpResponse response,\n+                                                           final List<StreamingContentCodec> supportedEncodings) {\n+        if (response.encoding() != null) {\n+            // Enforced selection\n+            return response.encoding();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjI4Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518722283", "bodyText": "didn't get that.", "author": "tkountis", "createdAt": "2020-11-06T12:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519007996", "bodyText": "This way method does not need @Nullable annotation:\n        final StreamingContentCodec encoding = response.encoding();\n        if (encoding != null) {\n            // Enforced selection\n            return encoding;\n        }", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex c54a6702d..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n-\n-    private final List<StreamingContentCodec> requestCodings;\n-    private final List<StreamingContentCodec> responseCodings;\n-\n-    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n-                                          final List<StreamingContentCodec> responseCodings) {\n-        this.requestCodings = requestCodings;\n-        this.responseCodings = responseCodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n-                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-\n-                return super.handle(ctx, request, responseFactory).map(response -> {\n-                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                    return response;\n-                });\n-            }\n-        };\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<StreamingContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                           final StreamingHttpResponse response,\n-                                                           final List<StreamingContentCodec> supportedEncodings) {\n-        if (response.encoding() != null) {\n-            // Enforced selection\n-            return response.encoding();\n-        }\n-\n-        // Negotiate encoding according to Accept-Encodings header and server supported ones.\n-        return negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzA1MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487051", "bodyText": "Suggested rename: supportedEncodings -> supportedResponseEncodings", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:26:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n+     * @return {@code this}\n+     */\n+    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\nindex 72e293b3b..19fedc9df 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n\n@@ -123,45 +117,32 @@ public abstract class HttpServerBuilder {\n     /**\n      * Enables wire-logging for this server.\n      * <p>\n-     * All wire events will be logged at {@link Level#TRACE TRACE} level.\n-     *\n+     * @deprecated Use {@link #enableWireLogging(String, LogLevel, BooleanSupplier)} instead.\n      * @param loggerName The name of the logger to log wire events.\n      * @return {@code this}.\n      */\n+    @Deprecated\n     public abstract HttpServerBuilder enableWireLogging(String loggerName);\n \n     /**\n-     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     * Enables wire-logging for this server.\n      *\n-     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @param loggerName The name of the logger to log wire events.\n+     * @param logLevel The level to log at.\n+     * @param logUserData {@code true} to include user data (e.g. data, headers, etc.). {@code false} to exclude user\n+     * data and log only network events.\n      * @return {@code this}.\n      */\n-    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n+    public abstract HttpServerBuilder enableWireLogging(String loggerName, LogLevel logLevel,\n+                                                        BooleanSupplier logUserData);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n-        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n      *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n-     * @return {@code this}\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n-        this.responseCodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n+    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n      * Disables automatic consumption of request {@link StreamingHttpRequest#payloadBody() payload body} when it is not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzEwNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487106", "bodyText": "Suggested rename: supportedEncodingsBiDi -> supportedEncodings", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\nindex 72e293b3b..19fedc9df 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n\n@@ -123,45 +117,32 @@ public abstract class HttpServerBuilder {\n     /**\n      * Enables wire-logging for this server.\n      * <p>\n-     * All wire events will be logged at {@link Level#TRACE TRACE} level.\n-     *\n+     * @deprecated Use {@link #enableWireLogging(String, LogLevel, BooleanSupplier)} instead.\n      * @param loggerName The name of the logger to log wire events.\n      * @return {@code this}.\n      */\n+    @Deprecated\n     public abstract HttpServerBuilder enableWireLogging(String loggerName);\n \n     /**\n-     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     * Enables wire-logging for this server.\n      *\n-     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @param loggerName The name of the logger to log wire events.\n+     * @param logLevel The level to log at.\n+     * @param logUserData {@code true} to include user data (e.g. data, headers, etc.). {@code false} to exclude user\n+     * data and log only network events.\n      * @return {@code this}.\n      */\n-    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n+    public abstract HttpServerBuilder enableWireLogging(String loggerName, LogLevel logLevel,\n+                                                        BooleanSupplier logUserData);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n-        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n      *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n-     * @return {@code this}\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n-        this.responseCodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n+    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n      * Disables automatic consumption of request {@link StreamingHttpRequest#payloadBody() payload body} when it is not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzI0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487243", "bodyText": "endpoint -> server?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:32Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\nindex 72e293b3b..19fedc9df 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n\n@@ -123,45 +117,32 @@ public abstract class HttpServerBuilder {\n     /**\n      * Enables wire-logging for this server.\n      * <p>\n-     * All wire events will be logged at {@link Level#TRACE TRACE} level.\n-     *\n+     * @deprecated Use {@link #enableWireLogging(String, LogLevel, BooleanSupplier)} instead.\n      * @param loggerName The name of the logger to log wire events.\n      * @return {@code this}.\n      */\n+    @Deprecated\n     public abstract HttpServerBuilder enableWireLogging(String loggerName);\n \n     /**\n-     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     * Enables wire-logging for this server.\n      *\n-     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @param loggerName The name of the logger to log wire events.\n+     * @param logLevel The level to log at.\n+     * @param logUserData {@code true} to include user data (e.g. data, headers, etc.). {@code false} to exclude user\n+     * data and log only network events.\n      * @return {@code this}.\n      */\n-    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n+    public abstract HttpServerBuilder enableWireLogging(String loggerName, LogLevel logLevel,\n+                                                        BooleanSupplier logUserData);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n-        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n      *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n-     * @return {@code this}\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n-        this.responseCodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n+    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n      * Disables automatic consumption of request {@link StreamingHttpRequest#payloadBody() payload body} when it is not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzMzMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487331", "bodyText": "endpoint -> server?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\nindex 72e293b3b..19fedc9df 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n\n@@ -123,45 +117,32 @@ public abstract class HttpServerBuilder {\n     /**\n      * Enables wire-logging for this server.\n      * <p>\n-     * All wire events will be logged at {@link Level#TRACE TRACE} level.\n-     *\n+     * @deprecated Use {@link #enableWireLogging(String, LogLevel, BooleanSupplier)} instead.\n      * @param loggerName The name of the logger to log wire events.\n      * @return {@code this}.\n      */\n+    @Deprecated\n     public abstract HttpServerBuilder enableWireLogging(String loggerName);\n \n     /**\n-     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     * Enables wire-logging for this server.\n      *\n-     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @param loggerName The name of the logger to log wire events.\n+     * @param logLevel The level to log at.\n+     * @param logUserData {@code true} to include user data (e.g. data, headers, etc.). {@code false} to exclude user\n+     * data and log only network events.\n      * @return {@code this}.\n      */\n-    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n+    public abstract HttpServerBuilder enableWireLogging(String loggerName, LogLevel logLevel,\n+                                                        BooleanSupplier logUserData);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n-        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n      *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n-     * @return {@code this}\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n-        this.responseCodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n+    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n      * Disables automatic consumption of request {@link StreamingHttpRequest#payloadBody() payload body} when it is not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4ODY4Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518488687", "bodyText": "Let's make this interface pkg-private for now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:32:55Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * Builder for {@link StreamingContentCodec}s.\n+ */\n+public interface StreamingContentCodecBuilder extends ContentCodecBuilder {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMzc2MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518723760", "bodyText": "Needed for gRPC, depending of course the outcome of the discussion around removing it completely.", "author": "tkountis", "createdAt": "2020-11-06T12:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4ODY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodecBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodecBuilder.java\ndeleted file mode 100644\nindex 7d34f284d..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-/**\n- * Builder for {@link StreamingContentCodec}s.\n- */\n-public interface StreamingContentCodecBuilder extends ContentCodecBuilder {\n-\n-    /**\n-     * Sets the maximum allowed compressed payload size that the codec can process.\n-     * This can help prevent malicious attempts to decompress malformed payloads that can drain resources of the\n-     * running instance.\n-     *\n-     * Default max allowed payload size is 2MiB.\n-     *\n-     * @param maxAllowedPayloadSize the maximum allowed payload size\n-     * @return {@code this}\n-     * @see <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">Zip Bomb</a>\n-     */\n-    StreamingContentCodecBuilder setMaxAllowedPayloadSize(int maxAllowedPayloadSize);\n-\n-    /**\n-     * Build and return an instance of the {@link StreamingContentCodec} with the configuration of the builder.\n-     * @return the {@link StreamingContentCodec} with the configuration of the builder\n-     */\n-    StreamingContentCodec build();\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTI0Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489247", "bodyText": "This method is invoked when the server reads a request. At that point we never have encoding. Therefore, we do not need it here.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:34:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java", "diffHunk": "@@ -70,7 +70,7 @@ public static StreamingHttpRequest newRequest(\n      */\n     public static StreamingHttpRequest newTransportRequest(\n             final HttpRequestMethod method, final String requestTarget, final HttpProtocolVersion version,\n-            final HttpHeaders headers, @Nullable final ContentCoding encoding, final BufferAllocator allocator,\n+            final HttpHeaders headers, @Nullable final StreamingContentCodec encoding, final BufferAllocator allocator,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyNTQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518725469", "bodyText": "Leftover", "author": "tkountis", "createdAt": "2020-11-06T12:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java\nindex 475d4d5c9..2952e4f24 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java\n\n@@ -70,7 +70,7 @@ public final class StreamingHttpRequests {\n      */\n     public static StreamingHttpRequest newTransportRequest(\n             final HttpRequestMethod method, final String requestTarget, final HttpProtocolVersion version,\n-            final HttpHeaders headers, @Nullable final StreamingContentCodec encoding, final BufferAllocator allocator,\n+            final HttpHeaders headers, @Nullable final ContentCoding encoding, final BufferAllocator allocator,\n             final Publisher<Object> payload, final HttpHeadersFactory headersFactory) {\n         return new DefaultStreamingHttpRequest(method, requestTarget, version, headers, encoding, allocator, payload,\n                 forTransportReceive(headers), headersFactory);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTc2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489762", "bodyText": "Can this be removed now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:36:50Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -393,12 +397,18 @@ private StreamingHttpResponse newErrorResponse(final Throwable cause, final Exec\n                 LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n                         cause);\n                 response = streamingResponseFactory().serviceUnavailable();\n+            } else if (cause instanceof UnsupportedContentEncodingException) {\n+                LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n+                        cause);\n+                // see https://tools.ietf.org/html/rfc7231#section-3.1.2.2\n+                response = streamingResponseFactory().unsupportedMediaType();\n             } else {\n                 LOGGER.error(\"Internal server error service={} connection={}\", service, this, cause);\n                 response = streamingResponseFactory().internalServerError();\n             }\n             response.version(version)\n                     .setHeader(CONTENT_LENGTH, ZERO);\n+            // advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\nindex e4f3cdb87..402c15d1e 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n\n@@ -408,7 +461,7 @@ final class NettyHttpServer {\n             }\n             response.version(version)\n                     .setHeader(CONTENT_LENGTH, ZERO);\n-            // advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);\n+            advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);\n             keepAlive.addConnectionHeaderIfNecessary(response);\n             return response;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTk0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489941", "bodyText": "The ContentCodingHttpServiceFilter is the first filter in the chain. Let's handle this exception there for now? It will give us some time to understand how people use compression codecs without prematurely making the exception type public.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:37:28Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -393,12 +397,18 @@ private StreamingHttpResponse newErrorResponse(final Throwable cause, final Exec\n                 LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n                         cause);\n                 response = streamingResponseFactory().serviceUnavailable();\n+            } else if (cause instanceof UnsupportedContentEncodingException) {\n+                LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\nindex e4f3cdb87..402c15d1e 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n\n@@ -408,7 +461,7 @@ final class NettyHttpServer {\n             }\n             response.version(version)\n                     .setHeader(CONTENT_LENGTH, ZERO);\n-            // advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);\n+            advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);\n             keepAlive.addConnectionHeaderIfNecessary(response);\n             return response;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5Mjc3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518492771", "bodyText": "1. Let's make it pkg-private for now?\n 2. Please, add serialVersionUID.\n 3. Let's remove unused ctors until we make it public?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:48:13Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * Exception thrown when a payload was encoded with an unsupported encoder.\n+ */\n+public final class UnsupportedContentEncodingException extends RuntimeException {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fadb8ccd97651b29e55616536a7097d382e2cd0e", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java\nindex 6b57aeb0c..c89ea9160 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java\n\n@@ -32,33 +32,6 @@ public final class UnsupportedContentEncodingException extends RuntimeException\n         this.encoding = encoding;\n     }\n \n-    /**\n-     * New instance.\n-     *\n-     * @param cause for this exception.\n-     * @param encoding the name of the encoding used\n-     */\n-    public UnsupportedContentEncodingException(String encoding, Throwable cause) {\n-        super(\"Compression \" + encoding + \" not supported\", cause);\n-        this.encoding = encoding;\n-    }\n-\n-    /**\n-     * New instance.\n-     *\n-     * @param message for the exception.\n-     * @param cause for this exception.\n-     * @param enableSuppression whether or not suppression is enabled or disabled.\n-     * @param writableStackTrace whether or not the stack trace should be writable.\n-     * @param encoding the name of the encoding used\n-     */\n-    public UnsupportedContentEncodingException(final String message, final Throwable cause,\n-                                               final boolean enableSuppression, final boolean writableStackTrace,\n-                                               final String encoding) {\n-        super(message, cause, enableSuppression, writableStackTrace);\n-        this.encoding = encoding;\n-    }\n-\n     /**\n      * The name of the encoding used when the Exception was thrown.\n      * @return the name of the encoding used when the Exception was thrown\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MzcxMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518493713", "bodyText": "This change can be reverted now", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:51:26Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -165,7 +167,8 @@ private NettyHttpServer() {\n                 initializer.andThen(getChannelInitializer(getByteBufAllocator(httpExecutionContext.bufferAllocator()),\n                         h1Config, closeHandler)), httpExecutionContext.executionStrategy(), HTTP_1_1, observer, false)\n                 .map(conn -> new NettyHttpServerConnection(conn, service, httpExecutionContext.executionStrategy(),\n-                        h1Config.headersFactory(), drainRequestPayloadBody)), HTTP_1_1, channel);\n+                        h1Config.headersFactory(), drainRequestPayloadBody)),\n+                        HTTP_1_1, channel);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\nindex e4f3cdb87..402c15d1e 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n\n@@ -167,7 +177,7 @@ final class NettyHttpServer {\n                 initializer.andThen(getChannelInitializer(getByteBufAllocator(httpExecutionContext.bufferAllocator()),\n                         h1Config, closeHandler)), httpExecutionContext.executionStrategy(), HTTP_1_1, observer, false)\n                 .map(conn -> new NettyHttpServerConnection(conn, service, httpExecutionContext.executionStrategy(),\n-                        h1Config.headersFactory(), drainRequestPayloadBody)),\n+                        h1Config.headersFactory(), h1Config.supportedEncodings(), drainRequestPayloadBody)),\n                         HTTP_1_1, channel);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5Mzg1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518493853", "bodyText": "The whole change here can be reverted if we remove encoding param from newTransportRequest", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:51:59Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -269,10 +272,11 @@ public String toString() {\n         void process(final boolean handleMultipleRequests) {\n             final Single<StreamingHttpRequest> requestSingle =\n                     connection.read().liftSyncToSingle(new SpliceFlatStreamToMetaSingle<>(\n-                            (HttpRequestMetaData meta, Publisher<Object> payload) ->\n-                                    newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n-                                            meta.headers(), executionContext().bufferAllocator(), payload,\n-                                            headersFactory)));\n+                            (BiFunction<HttpRequestMetaData, Publisher<Object>, StreamingHttpRequest>) (meta, payload)\n+                                    -> newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n+                                        meta.headers(), meta.encoding(),", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1758afb743527d6f8805b9ba540b826c8d7943a6", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\nindex e4f3cdb87..2caaa7bc3 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java\n\n@@ -272,11 +270,10 @@ final class NettyHttpServer {\n         void process(final boolean handleMultipleRequests) {\n             final Single<StreamingHttpRequest> requestSingle =\n                     connection.read().liftSyncToSingle(new SpliceFlatStreamToMetaSingle<>(\n-                            (BiFunction<HttpRequestMetaData, Publisher<Object>, StreamingHttpRequest>) (meta, payload)\n-                                    -> newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n-                                        meta.headers(), meta.encoding(),\n-                                        NettyHttpServerConnection.this.executionContext().bufferAllocator(),\n-                                        payload, headersFactory)));\n+                            (HttpRequestMetaData meta, Publisher<Object> payload) ->\n+                                    newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n+                                            meta.headers(), executionContext().bufferAllocator(), payload,\n+                                            headersFactory)));\n             toSource(handleRequestAndWriteResponse(requestSingle, handleMultipleRequests))\n                     .subscribe(new ErrorLoggingHttpSubscriber());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTQ2MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518495461", "bodyText": "Why this change is required? Do you have a reproducer? Trailers should already be added.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:57:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -185,7 +186,9 @@ private static void updateResponseContentLength(final int contentLength, final H\n                 for (int i = 0; i < items.size(); i++) {\n                     contentLength += calculateContentLength(items.get(i));\n                 }\n-                flatRequest = Publisher.<Object>from(metadata).concat(fromIterable(items));\n+                flatRequest = Publisher.<Object>from(metadata)\n+                        .concat(fromIterable(items))\n+                        .concat(succeeded(EmptyHttpHeaders.INSTANCE));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyNjcwMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r521426700", "bodyText": "Removed. The actual reason this was hanging was the attempt to calculate content length on non-streaming requests. A check for content-encoding was missing to skip this length-calculation and use chunking, thus this logic was anticipating a single buffer and not multiple chunks.", "author": "tkountis", "createdAt": "2020-11-11T15:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6577a1a04af84d823ceb681844ebd73795b0a4e6", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\nindex 3fd6bed8b..64ab3a689 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\n\n@@ -186,9 +186,7 @@ final class HeaderUtils {\n                 for (int i = 0; i < items.size(); i++) {\n                     contentLength += calculateContentLength(items.get(i));\n                 }\n-                flatRequest = Publisher.<Object>from(metadata)\n-                        .concat(fromIterable(items))\n-                        .concat(succeeded(EmptyHttpHeaders.INSTANCE));\n+                flatRequest = Publisher.<Object>from(metadata).concat(fromIterable(items));\n             } else if (reduction instanceof Buffer) {\n                 final Buffer buffer = (Buffer) reduction;\n                 contentLength = buffer.readableBytes();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTkzMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518495930", "bodyText": "Please, revert the original version if there are no changes", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:59:29Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java", "diffHunk": "@@ -291,7 +291,8 @@ private void childChannelActive(Future<Http2StreamChannel> future,\n                     // pipelining on a stream so we can use the non-pipelined connection which is more light weight.\n                     // https://tools.ietf.org/html/rfc7540#section-8.1\n                     responseSingle = toSource(new NonPipelinedStreamingHttpConnection(nettyConnection,\n-                            executionContext(), reqRespFactory, headersFactory).request(strategy, request));\n+                            executionContext(), reqRespFactory, headersFactory)\n+                                .request(strategy, request));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java\nindex 6c4dbf4be..6b4e55662 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java\n\n@@ -291,7 +296,7 @@ final class H2ClientParentConnectionContext extends H2ParentConnectionContext {\n                     // pipelining on a stream so we can use the non-pipelined connection which is more light weight.\n                     // https://tools.ietf.org/html/rfc7540#section-8.1\n                     responseSingle = toSource(new NonPipelinedStreamingHttpConnection(nettyConnection,\n-                            executionContext(), reqRespFactory, headersFactory)\n+                            executionContext(), reqRespFactory, headersFactory, supportedEncodings)\n                                 .request(strategy, request));\n                 } catch (Throwable cause) {\n                     if (streamChannel != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NjI1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518496255", "bodyText": "Please, revert the original version if there are no changes", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:00:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java", "diffHunk": "@@ -111,8 +111,8 @@ public final HttpConnectionContext connectionContext() {\n             addRequestTransferEncodingIfNecessary(request);\n         }\n \n-        return strategy.invokeClient(executionContext.executor(), flatRequest, determineFlushStrategyForApi(request),\n-                this);\n+        return strategy.invokeClient(executionContext.executor(), flatRequest,\n+                determineFlushStrategyForApi(request), this);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java\nindex 81f6d953d..b2acfda21 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java\n\n@@ -111,8 +125,31 @@ abstract class AbstractStreamingHttpConnection<CC extends NettyConnectionContext\n             addRequestTransferEncodingIfNecessary(request);\n         }\n \n-        return strategy.invokeClient(executionContext.executor(), flatRequest,\n-                determineFlushStrategyForApi(request), this);\n+        return decodePayloadContentIfEncoded(strategy.invokeClient(executionContext.executor(), flatRequest,\n+                determineFlushStrategyForApi(request), this));\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request) {\n+        ContentCoding encoding = request.encoding();\n+        if (encoding != null) {\n+            ContentCodec codec = encoding.codec();\n+            BufferAllocator alloc = executionContext.bufferAllocator();\n+            request.transformPayloadBody(pub -> codec.encode(request.headers(), pub, alloc));\n+        }\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle) {\n+\n+        return responseSingle.map((response -> {\n+            ContentCoding encoding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n+            ContentCodec codec = encoding.codec();\n+            if (!encoding.equals(none())) {\n+                response.transformPayloadBody(bufferPublisher ->\n+                        codec.decode(bufferPublisher, executionContext.bufferAllocator()));\n+            }\n+            return response;\n+        }));\n     }\n \n     @Nullable\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzU1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518497553", "bodyText": "HttpMetaData does not know how the payload body is represented. Consider removing reference to Buffer", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:05:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,33 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n+     * If the endpoint is setup with {@link HttpServerBuilder#supportedEncodings(StreamingContentCodec...)} ()}\n+     * or {@link HttpClientBuilder#supportedEncodings(StreamingContentCodec...)}, the server will\n+     * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n+     * calling this method.\n+     *\n+     * Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#identity()}.\n+     *\n+     * @param encoding The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @return {@code this}.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n+     */\n+    HttpMetaData encoding(StreamingContentCodec encoding);\n+\n+    /**\n+     * Returns the {@link StreamingContentCodec} used to encode the payload\n+     * {@link io.servicetalk.buffer.api.Buffer} of a request or a response.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyODk4OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518728988", "bodyText": "Good catch", "author": "tkountis", "createdAt": "2020-11-06T12:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\nindex a4e7f2ac3..90226c488 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n\n@@ -48,31 +48,28 @@ public interface HttpMetaData {\n     HttpHeaders headers();\n \n     /**\n-     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * The {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n      * request or a response.\n-     * If the endpoint is setup with {@link HttpServerBuilder#supportedEncodings(StreamingContentCodec...)} ()}\n-     * or {@link HttpClientBuilder#supportedEncodings(StreamingContentCodec...)}, the server will\n+     * If the endpoint protocol is setup with {@link HttpProtocolConfig#supportedEncodings()} the server will\n      * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n-     * calling this method.\n+     * calling this method. Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#none()}.\n      *\n-     * Any encoding passed here, takes precedence. In other words, a compressed response, can\n-     * be disabled by passing {@link ContentCodings#identity()}.\n-     *\n-     * @param encoding The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @param encoding The {@link ContentCoding} used for the encoding of the payload.\n      * @return {@code this}.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n-    HttpMetaData encoding(StreamingContentCodec encoding);\n+    HttpMetaData encoding(ContentCoding encoding);\n \n     /**\n-     * Returns the {@link StreamingContentCodec} used to encode the payload\n-     * {@link io.servicetalk.buffer.api.Buffer} of a request or a response.\n+     * Returns the {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n      *\n-     * @return The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @return The {@link ContentCoding} used for the encoding of the payload.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n     @Nullable\n-    StreamingContentCodec encoding();\n+    ContentCoding encoding();\n \n     /**\n      * Adds a new header with the specified {@code name} and {@code value}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzgxNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518497814", "bodyText": "HttpMetaData does not know how the payload body is represented. Consider removing reference to Buffer", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:06:54Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,33 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\nindex a4e7f2ac3..90226c488 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java\n\n@@ -48,31 +48,28 @@ public interface HttpMetaData {\n     HttpHeaders headers();\n \n     /**\n-     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * The {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n      * request or a response.\n-     * If the endpoint is setup with {@link HttpServerBuilder#supportedEncodings(StreamingContentCodec...)} ()}\n-     * or {@link HttpClientBuilder#supportedEncodings(StreamingContentCodec...)}, the server will\n+     * If the endpoint protocol is setup with {@link HttpProtocolConfig#supportedEncodings()} the server will\n      * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n-     * calling this method.\n+     * calling this method. Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#none()}.\n      *\n-     * Any encoding passed here, takes precedence. In other words, a compressed response, can\n-     * be disabled by passing {@link ContentCodings#identity()}.\n-     *\n-     * @param encoding The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @param encoding The {@link ContentCoding} used for the encoding of the payload.\n      * @return {@code this}.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n-    HttpMetaData encoding(StreamingContentCodec encoding);\n+    HttpMetaData encoding(ContentCoding encoding);\n \n     /**\n-     * Returns the {@link StreamingContentCodec} used to encode the payload\n-     * {@link io.servicetalk.buffer.api.Buffer} of a request or a response.\n+     * Returns the {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n      *\n-     * @return The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @return The {@link ContentCoding} used for the encoding of the payload.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n      */\n     @Nullable\n-    StreamingContentCodec encoding();\n+    ContentCoding encoding();\n \n     /**\n      * Adds a new header with the specified {@code name} and {@code value}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5OTA4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518499082", "bodyText": "These public methods returns a pkg-private class. Let's remove them for now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:11:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ */\n+public final class ContentCodings {\n+\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n+\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n+     */\n+    public static DefaultStreamingContentCodecBuilder gzip() {\n+        return new GzipStreamingContentCodecBuilder();\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     */\n+    public static DefaultStreamingContentCodecBuilder deflate() {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMDY2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518730667", "bodyText": "How is the builder accessible then?\nI am changing the signature to use the interface for now, waiting on your thoughts.", "author": "tkountis", "createdAt": "2020-11-06T12:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5OTA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 7998eba07..806238db5 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,85 +15,78 @@\n  */\n package io.servicetalk.http.api;\n \n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n-\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.http.api.CharSequences.contentEquals;\n-import static io.servicetalk.http.api.CharSequences.isEmpty;\n-import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Common available encoding implementations.\n- * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n  */\n public final class ContentCodings {\n \n-    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n \n-    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n \n-    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n \n-    private ContentCodings() {\n-    }\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n \n-    /**\n-     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n-     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n-     */\n-    public static StreamingContentCodec identity() {\n-        return IDENTITY;\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n     }\n \n     /**\n-     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n      */\n-    public static StreamingContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n+    public static ContentCoding none() {\n+        return NONE;\n     }\n \n     /**\n-     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link StreamingContentCodec}\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static DefaultStreamingContentCodecBuilder gzip() {\n-        return new GzipStreamingContentCodecBuilder();\n+    public static ContentCoding gzip() {\n+        return GZIP;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static StreamingContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n      */\n-    public static DefaultStreamingContentCodecBuilder deflate() {\n-        return new DeflateStreamingContentCodecBuilder();\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n     }\n \n     /**\n-     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMDIwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518500205", "bodyText": "Consider making IdentityContentCodec class a singleton", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:16:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ */\n+public final class ContentCodings {\n+\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 7998eba07..806238db5 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,85 +15,78 @@\n  */\n package io.servicetalk.http.api;\n \n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n-\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.http.api.CharSequences.contentEquals;\n-import static io.servicetalk.http.api.CharSequences.isEmpty;\n-import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Common available encoding implementations.\n- * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n  */\n public final class ContentCodings {\n \n-    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n \n-    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n \n-    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n \n-    private ContentCodings() {\n-    }\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n \n-    /**\n-     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n-     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n-     */\n-    public static StreamingContentCodec identity() {\n-        return IDENTITY;\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n     }\n \n     /**\n-     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n      */\n-    public static StreamingContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n+    public static ContentCoding none() {\n+        return NONE;\n     }\n \n     /**\n-     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link StreamingContentCodec}\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static DefaultStreamingContentCodecBuilder gzip() {\n-        return new GzipStreamingContentCodecBuilder();\n+    public static ContentCoding gzip() {\n+        return GZIP;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n-     *\n-     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static StreamingContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n      */\n-    public static DefaultStreamingContentCodecBuilder deflate() {\n-        return new DeflateStreamingContentCodecBuilder();\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n     }\n \n     /**\n-     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMjI4NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518502285", "bodyText": "nit: unnecessary parentheses around", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:25:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {\n+            addContentEncoding(request.headers(), coding.name());\n+            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n+        }\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map((response -> {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex dec73e560..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map((response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        }));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMjM0MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518502340", "bodyText": "This method can be static", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:25:47Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex dec73e560..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map((response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        }));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDcxMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518504713", "bodyText": "Discussion, no action needed for now:\nI see that AHC removes Content-Length and Content-Encoding headers from the response after decompression: https://github.com/apache/httpcomponents-client/blob/23af28ddaf49544ab8a7996f1a8bb508f6441828/httpclient/src/main/java/org/apache/http/client/protocol/ResponseContentEncoding.java#L124-L125\nIt has its pros and cons... Cons is that users loose visibility into original headers that were received. Pros is that they do not need to manually remove these headers when they pass through the response from the client as a server's response (proxy use-case). Thoughts?\n//cc @Scottmitch", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:35:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {\n+            addContentEncoding(request.headers(), coding.name());\n+            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n+        }\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map((response -> {\n+            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n+            if (!coding.equals(identity())) {\n+                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNDQxOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518734418", "bodyText": "Hmm, need to think about that, don't have any immediate observation.", "author": "tkountis", "createdAt": "2020-11-06T12:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex dec73e560..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map((response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        }));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDk1Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518504952", "bodyText": "It's too small for the avg payload. Let's set it to 16MiB", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:36:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java\ndeleted file mode 100644\nindex 84e76136a..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-interface ContentCodecBuilder {\n-\n-    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB\n-\n-    /**\n-     * Sets the maximum allowed compressed payload size that the codec can process.\n-     * This can help prevent malicious attempts to decompress malformed payloads that can drain resources of the\n-     * running instance.\n-     *\n-     * Default max allowed payload size is 2MiB.\n-     *\n-     * @param maxAllowedPayloadSize the maximum allowed payload size\n-     * @return {@code this}\n-     * @see <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">Zip Bomb</a>\n-     */\n-    ContentCodecBuilder setMaxAllowedPayloadSize(int maxAllowedPayloadSize);\n-\n-    /**\n-     * Build and return an instance of the {@link ContentCodec} with the configuration of the builder.\n-     * @return the {@link ContentCodec} with the configuration of the builder\n-     */\n-    ContentCodec build();\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTE2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518505164", "bodyText": "IIUC this is related to the uncompressed payload size. Bcz it's possible to generate a bomb that has tiny size but results in gigabytes.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:37:42Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB\n+\n+    /**\n+     * Sets the maximum allowed compressed payload size that the codec can process.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNTMwOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518735308", "bodyText": "yes, its the actual payload. will re-phrase it.", "author": "tkountis", "createdAt": "2020-11-06T12:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java\ndeleted file mode 100644\nindex 84e76136a..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-interface ContentCodecBuilder {\n-\n-    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB\n-\n-    /**\n-     * Sets the maximum allowed compressed payload size that the codec can process.\n-     * This can help prevent malicious attempts to decompress malformed payloads that can drain resources of the\n-     * running instance.\n-     *\n-     * Default max allowed payload size is 2MiB.\n-     *\n-     * @param maxAllowedPayloadSize the maximum allowed payload size\n-     * @return {@code this}\n-     * @see <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">Zip Bomb</a>\n-     */\n-    ContentCodecBuilder setMaxAllowedPayloadSize(int maxAllowedPayloadSize);\n-\n-    /**\n-     * Build and return an instance of the {@link ContentCodec} with the configuration of the builder.\n-     * @return the {@link ContentCodec} with the configuration of the builder\n-     */\n-    ContentCodec build();\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518505902", "bodyText": "This method is used only in one pkg-private place. Consider removing the public method.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:40:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -162,6 +162,15 @@ public static boolean contentEquals(final CharSequence a, final CharSequence b)\n         return contentEqualsUnknownTypes(a, b);\n     }\n \n+    /**\n+     * Returns {@code true} if there is no content on the {@link CharSequence} value.\n+     * @param value the {@link CharSequence} to validate for emptyness\n+     * @return {@code true} if there is no content\n+     */\n+    public static boolean isEmpty(final CharSequence value) {\n+        return value.length() == 0;", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNjU3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518736572", "bodyText": "gRPC needed", "author": "tkountis", "createdAt": "2020-11-06T13:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODM2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008364", "bodyText": "It's a trivial check, better to reduce the surface of public API we expose.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\nindex 3dc79c30d..171e9062d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n\n@@ -162,15 +162,6 @@ public final class CharSequences {\n         return contentEqualsUnknownTypes(a, b);\n     }\n \n-    /**\n-     * Returns {@code true} if there is no content on the {@link CharSequence} value.\n-     * @param value the {@link CharSequence} to validate for emptyness\n-     * @return {@code true} if there is no content\n-     */\n-    public static boolean isEmpty(final CharSequence value) {\n-        return value.length() == 0;\n-    }\n-\n     /**\n      * Find the index of {@code c} within {@code sequence} starting at index {@code fromIndex}.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNzI2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518507269", "bodyText": "Consider clarifying in the method name and javadoc that it checks the prefix case-insensitively.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:47:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -216,6 +225,19 @@ private static boolean isUpperCase(final char value) {\n         return value >= 'A' && value <= 'Z';\n     }\n \n+    /**\n+     * Tests if the string starts with the specified prefix.\n+     *\n+     * @param   string   the value to check the presence of the prefix in.\n+     * @param   prefix   the prefix.\n+     * @return  {@code true} if the character sequence represented by the\n+     *          argument is a prefix of the character sequence represented by\n+     *          the string; {@code false} otherwise.\n+     */\n+    public static boolean startsWith(final CharSequence string, final CharSequence prefix) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\nindex 3dc79c30d..171e9062d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n\n@@ -225,19 +216,6 @@ public final class CharSequences {\n         return value >= 'A' && value <= 'Z';\n     }\n \n-    /**\n-     * Tests if the string starts with the specified prefix.\n-     *\n-     * @param   string   the value to check the presence of the prefix in.\n-     * @param   prefix   the prefix.\n-     * @return  {@code true} if the character sequence represented by the\n-     *          argument is a prefix of the character sequence represented by\n-     *          the string; {@code false} otherwise.\n-     */\n-    public static boolean startsWith(final CharSequence string, final CharSequence prefix) {\n-        return regionMatches(string, false, 0, prefix, 0, prefix.length());\n-    }\n-\n     /**\n      * This methods make regionMatches operation correctly for any chars in strings.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518509775", "bodyText": "Consider allocating an Buffer of size and maxCapacity 0. This way you do not need a map operation to convert Buffer to Object.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:58:03Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0NTk0MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518745940", "bodyText": "I considered it, but none of the Buffer implementations are available without an allocator.\nI can complicate the API to have an allocator in the instance allowing me to do so, OR I can have my own no-op buffer class to use there. If I am missing something let me know.", "author": "tkountis", "createdAt": "2020-11-06T13:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODY3Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008673", "bodyText": "Let's keep it as-is, not worth spending cycles on improving if we are going to replace it.\nJust FYI: you can use the static one for this purpose: ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR. We do this in other places where we need Buffer constants. Take a look at HttpProtocolVersion as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex c9dcb554d..9a798a5e8 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -53,19 +53,19 @@ import javax.annotation.Nullable;\n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+abstract class AbstractZipContentCodec implements ContentCodec {\n \n+    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    protected final int chunkSize;\n-    private final int maxPayloadSize;\n+    private final CharSequence encoding;\n \n-    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n-        this.chunkSize = chunkSize;\n-        this.maxPayloadSize = maxPayloadSize;\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518511491", "bodyText": "The problem with readSlice here is that we keep writing new data to the original dst buffer. As the result, it will be resized multiple times and will allocate all the streaming data in memory \ud83d\ude22", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:04:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(chunkSize);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0OTc2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518749762", "bodyText": "Good catch, lets keep this out of the scope, since we are discussing about the alternative implementation with EmbeddedChannel. I will keep track of that.", "author": "tkountis", "createdAt": "2020-11-06T13:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODg2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008867", "bodyText": "Agreed that it's not worth spending cycles on fixing implementation that is going to be replaced soon. But this is an important aspect to consider before making a decision to include these implementations in the next release. Or we should clarify in the release notes that compression should not be used with streaming clients for now.\n//cc @Scottmitch", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex c9dcb554d..9a798a5e8 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -53,19 +53,19 @@ import javax.annotation.Nullable;\n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+abstract class AbstractZipContentCodec implements ContentCodec {\n \n+    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    protected final int chunkSize;\n-    private final int maxPayloadSize;\n+    private final CharSequence encoding;\n \n-    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n-        this.chunkSize = chunkSize;\n-        this.maxPayloadSize = maxPayloadSize;\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMjQ0Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518512442", "bodyText": "I suspect there is a similar issue with decompressed destination buffer.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:09:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(chunkSize);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public final Buffer decode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize, maxPayloadSize);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newInflaterInputStream(asInputStream(src));\n+\n+            int read = dst.setBytesUntilEndStream(0, input, chunkSize);\n+            dst.writerIndex(read);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(input);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> decode(final Publisher<Buffer> from, final BufferAllocator allocator) {\n+        return from.liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+\n+            @Nullable\n+            Buffer dst;\n+            @Nullable\n+            Inflater inflater;\n+            @Nullable\n+            ZLibStreamDecoder streamDecoder;\n+            @Nullable\n+            PublisherSource.Subscription subscription;\n+\n+            @Override\n+            public void onSubscribe(final PublisherSource.Subscription subscription) {\n+                dst = allocator.newBuffer(chunkSize, maxPayloadSize);\n+                inflater = newRawInflater();\n+                streamDecoder = new ZLibStreamDecoder(dst, inflater, chunkSize, supportsChecksum());\n+                this.subscription = subscription;\n+                subscriber.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Buffer src) {\n+                assert streamDecoder != null;\n+                assert subscription != null;\n+                assert src != null;\n+\n+                // onNext will produce AT-MOST N items (as received)\n+\n+                Buffer part;\n+                try {\n+                    if (streamDecoder.isFinished()) {\n+                        throw new IllegalStateException(\"Stream encoder previously closed but more input arrived \");\n+                    }\n+\n+                    part = streamDecoder.decode(src);\n+                    if (part != null) {\n+                        subscriber.onNext(part);\n+                    }\n+\n+                    // Not enough data to decompress, ask for more\n+                    subscription.request(1);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onError(t);\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onComplete();\n+            }\n+        });\n+    }\n+\n+    private void closeQuietly(@Nullable final Closeable closeable) {\n+        try {\n+            if (closeable != null) {\n+                closeable.close();\n+            }\n+        } catch (IOException e) {\n+            LOGGER.error(\"Unexpected IO exception while closing buffer streams\", e);\n+        }\n+    }\n+\n+    // Code forked from Netty's JdkZlibDecoder\n+    static class ZLibStreamDecoder {\n+        private static final int FHCRC = 0x02;\n+        private static final int FEXTRA = 0x04;\n+        private static final int FNAME = 0x08;\n+        private static final int FCOMMENT = 0x10;\n+        private static final int FRESERVED = 0xE0;\n+\n+        @Nullable\n+        private final CRC32 crc;\n+        private final Inflater inflater;\n+        private final Buffer decompressed;\n+\n+        private enum State {\n+            HEADER_START,\n+            HEADER_END,\n+            FLG_READ,\n+            XLEN_READ,\n+            SKIP_FNAME,\n+            SKIP_COMMENT,\n+            PROCESS_FHCRC,\n+            FOOTER_START,\n+        }\n+\n+        private State state = State.HEADER_START;\n+        private int flags = -1;\n+        private int xlen = -1;\n+\n+        private int chunkSize;\n+        private boolean finished;\n+\n+        ZLibStreamDecoder(Buffer destination, Inflater inflater, int chunkSize, boolean supportsChksum) {\n+            this.decompressed = destination;\n+            this.inflater = inflater;\n+            this.chunkSize = chunkSize;\n+            crc = supportsChksum ? new CRC32() : null;\n+        }\n+\n+        public boolean isFinished() {\n+            return finished;\n+        }\n+\n+        @Nullable\n+        protected Buffer decode(Buffer in) throws Exception {\n+            if (finished) {\n+                // Skip data received after finished.\n+                in.skipBytes(in.readableBytes());\n+                return null;\n+            }\n+\n+            int readableBytes = in.readableBytes();\n+            if (readableBytes == 0) {\n+                return null;\n+            }\n+\n+            if (crc != null) {\n+                switch (state) {\n+                    case FOOTER_START:\n+                        if (readGZIPFooter(in)) {\n+                            finished = true;\n+                        }\n+                        return null;\n+                    default:\n+                        if (state != State.HEADER_END && !readGZIPHeader(in)) {\n+                            return null;\n+                        }\n+                }\n+                // Some bytes may have been consumed, and so we must re-set the number of readable bytes.\n+                readableBytes = in.readableBytes();\n+            }\n+\n+            if (in.hasArray()) {\n+                inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), readableBytes);\n+            } else {\n+                byte[] array = new byte[readableBytes];\n+                in.getBytes(in.readerIndex(), array);\n+                inflater.setInput(array);\n+            }\n+\n+            try {\n+                boolean readFooter = false;\n+                while (!inflater.needsInput()) {\n+                    byte[] outArray = decompressed.array();\n+                    int writerIndex = decompressed.writerIndex();\n+                    int outIndex = decompressed.arrayOffset() + writerIndex;\n+                    int outputLength = inflater.inflate(outArray, outIndex, decompressed.writableBytes());\n+                    if (outputLength > 0) {\n+                        decompressed.writerIndex(writerIndex + outputLength);\n+                        if (crc != null) {\n+                            crc.update(outArray, outIndex, outputLength);\n+                        }\n+                    } else {\n+                        if (inflater.needsDictionary()) {\n+                            throw new IOException(\n+                                    \"decompression failure, unable to set dictionary as non was specified\");\n+                        }\n+                    }\n+\n+                    if (inflater.finished()) {\n+                        if (crc == null) {\n+                            finished = true; // Do not decode anymore.\n+                        } else {\n+                            readFooter = true;\n+                        }\n+                        break;\n+                    } else {\n+                        decompressed.ensureWritable(chunkSize);\n+                    }\n+                }\n+\n+                in.skipBytes(readableBytes - inflater.getRemaining());\n+\n+                if (readFooter) {\n+                    state = State.FOOTER_START;\n+                    if (readGZIPFooter(in)) {\n+                        finished = true;\n+                        inflater.end();\n+                    }\n+                }\n+            } catch (DataFormatException e) {\n+                throw new IOException(\"decompression failure\", e);\n+            }\n+\n+            if (decompressed.readableBytes() > 0) {\n+                return decompressed.readSlice(decompressed.readableBytes());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0OTgzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518749836", "bodyText": "Same", "author": "tkountis", "createdAt": "2020-11-06T13:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMjQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex c9dcb554d..9a798a5e8 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -53,19 +53,19 @@ import javax.annotation.Nullable;\n import static io.servicetalk.buffer.api.Buffer.asInputStream;\n import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static java.lang.Math.min;\n \n-abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+abstract class AbstractZipContentCodec implements ContentCodec {\n \n+    protected static final int ONE_KB = 1 << 10;\n     private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n     private static final Object END_OF_STREAM = new Object();\n \n-    protected final int chunkSize;\n-    private final int maxPayloadSize;\n+    private final CharSequence encoding;\n \n-    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n-        this.chunkSize = chunkSize;\n-        this.maxPayloadSize = maxPayloadSize;\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n     }\n \n     abstract boolean supportsChecksum();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518513854", "bodyText": "Can you please clarify why this filter has to be the last filter for the client (and the first for the server)?\nI worry that if we do decompression first, users have to way to intercept the original payload body size and metrics filters will show only decompressed size.\nWe may think about an alternative approach for metrics if this is a strong requirement. Otherwise, it's better to expose just a filter and let users configure it in the required order.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:15:17Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -308,6 +316,11 @@ public StreamingHttpClient buildStreaming() {\n                         ctx.builder.hostHeaderFilterFactoryFunction.apply(ctx.builder.address));\n             }\n \n+            if (ctx.builder.supportedEncodings != null) {\n+                currClientFilterFactory = appendFilter(currClientFilterFactory,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc1MjE4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518752182", "bodyText": "I consider this to be a transport layer feature, thus the ordering. I wanted to expose as less as possible as configuration to the end-user, and relax it if we have particular needs later. I can't think of any reason for users to interact with the compressed payload, if you do (//cc @Scottmitch) then happy to make the filters public and allow this to be configurable. WDYT?", "author": "tkountis", "createdAt": "2020-11-06T13:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MzcwMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518993701", "bodyText": "Use-cases I think about:\n\nMetrics filters: users likely are more interested in knowing what payload size sent on the wire vs the decompressed size.\nMetrics filter: users likely are more interested in the time it took for the HTTP exchange on the network, excluding time for post-processing.\nFilter for checksum validation of the received payload body before decompression (checksum value may come in trailers).\nFilter for adding a checksum trailer after compression.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java\nindex 50b043adf..adb0acfca 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java\n\n@@ -316,11 +310,6 @@ final class DefaultSingleAddressHttpClientBuilder<U, R> extends SingleAddressHtt\n                         ctx.builder.hostHeaderFilterFactoryFunction.apply(ctx.builder.address));\n             }\n \n-            if (ctx.builder.supportedEncodings != null) {\n-                currClientFilterFactory = appendFilter(currClientFilterFactory,\n-                        new ContentCodingHttpClientFilter(ctx.builder.supportedEncodings));\n-            }\n-\n             FilterableStreamingHttpClient lbClient = closeOnException.prepend(\n                     new LoadBalancedStreamingHttpClient(ctx.executionContext, lb, reqRespFactory));\n             if (ctx.builder.autoRetry != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTA5NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518989094", "bodyText": "The content-coding names are case-insensitive. You do contentEqualsIgnoreCase first, then we should check the startsWith prefix case-insensitively.\nBecause the startsWith method is used only in one place, let's move it as a private method in ContentCodings class for now. Better to minimize the scope of public methods we have to maintain.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:29:08Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -226,7 +225,7 @@ private static boolean isUpperCase(final char value) {\n     }\n \n     /**\n-     * Tests if the string starts with the specified prefix.\n+     * Tests if the string starts with the specified case-sensitive prefix.", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NDM2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518994362", "bodyText": "Missed that, good catch", "author": "tkountis", "createdAt": "2020-11-06T20:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\nindex 39579de6c..171e9062d 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java\n\n@@ -224,19 +216,6 @@ public final class CharSequences {\n         return value >= 'A' && value <= 'Z';\n     }\n \n-    /**\n-     * Tests if the string starts with the specified case-sensitive prefix.\n-     *\n-     * @param   string   the value to check the presence of the prefix in.\n-     * @param   prefix   the prefix.\n-     * @return  {@code true} if the character sequence represented by the\n-     *          argument is a prefix of the character sequence represented by\n-     *          the string; {@code false} otherwise.\n-     */\n-    public static boolean startsWith(final CharSequence string, final CharSequence prefix) {\n-        return regionMatches(string, false, 0, prefix, 0, prefix.length());\n-    }\n-\n     /**\n      * This methods make regionMatches operation correctly for any chars in strings.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NTgwOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518995808", "bodyText": "WDYT about making it StreamingHttpConnectionFilterFactory (or both if it's going to be public)? Then reserved connection will also have compression logic.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:44:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -23,16 +23,17 @@\n import static io.servicetalk.http.api.ContentCodings.identity;\n import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n \n /**\n  * Filter responsible for encoding/decoding content according to content-codings configured.\n  */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NzgyOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519067829", "bodyText": "agreed this is common practice for our filters.", "author": "Scottmitch", "createdAt": "2020-11-07T00:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NTgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex 8fe213549..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,83 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpClientFilter\n-        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrIdentity(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMDMzMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519000330", "bodyText": "Should we reset requestCodings when this method is invoked? For cases when users invoked supportedEncodings, built a server, then invoked supportedResponseEncodings and built another server.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:54:59Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -139,26 +139,26 @@\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     * Sets the supported {@link StreamingContentCodec}s for the server, used for both request and response handling.\n      *\n      * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n      * @return {@code this}\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n         List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n         this.requestCodings = unmodifiable;\n         this.responseCodings = unmodifiable;\n         return this;\n     }\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets the supported {@link StreamingContentCodec}s for the server, used for <b>responses only</b>.\n      *\n      * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n      * @return {@code this}\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n+    public final HttpServerBuilder supportedResponseEncodings(final StreamingContentCodec... codings) {\n         this.responseCodings = unmodifiableList(asList(codings));\n         return this;", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\nindex 445c91e39..19fedc9df 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java\n\n@@ -123,45 +117,32 @@ public abstract class HttpServerBuilder {\n     /**\n      * Enables wire-logging for this server.\n      * <p>\n-     * All wire events will be logged at {@link Level#TRACE TRACE} level.\n-     *\n+     * @deprecated Use {@link #enableWireLogging(String, LogLevel, BooleanSupplier)} instead.\n      * @param loggerName The name of the logger to log wire events.\n      * @return {@code this}.\n      */\n+    @Deprecated\n     public abstract HttpServerBuilder enableWireLogging(String loggerName);\n \n     /**\n-     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     * Enables wire-logging for this server.\n      *\n-     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @param loggerName The name of the logger to log wire events.\n+     * @param logLevel The level to log at.\n+     * @param logUserData {@code true} to include user data (e.g. data, headers, etc.). {@code false} to exclude user\n+     * data and log only network events.\n      * @return {@code this}.\n      */\n-    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n+    public abstract HttpServerBuilder enableWireLogging(String loggerName, LogLevel logLevel,\n+                                                        BooleanSupplier logUserData);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the server, used for both request and response handling.\n-     *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n-     * @return {@code this}\n-     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n-     */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n-        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the supported {@link StreamingContentCodec}s for the server, used for <b>responses only</b>.\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n      *\n-     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n-     * @return {@code this}\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n      */\n-    public final HttpServerBuilder supportedResponseEncodings(final StreamingContentCodec... codings) {\n-        this.responseCodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n+    public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n      * Disables automatic consumption of request {@link StreamingHttpRequest#payloadBody() payload body} when it is not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMzQzOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519003439", "bodyText": "We usually do not clarify default values in javadoc. Saving us some room the change them later. Consider removing it.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:01:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -51,7 +51,7 @@ public static StreamingContentCodec identity() {\n \n     /**\n      * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n+     * The max allowed payload size for this codec is 16Mib.", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\nindex 1f80b8a4b..806238db5 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java\n\n@@ -15,85 +15,78 @@\n  */\n package io.servicetalk.http.api;\n \n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n-import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n-\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.http.api.CharSequences.contentEqualsIgnoreCase;\n-import static io.servicetalk.http.api.CharSequences.isEmpty;\n-import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Common available encoding implementations.\n- * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n  */\n public final class ContentCodings {\n \n-    private static final StreamingContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n \n-    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n \n-    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n \n-    private ContentCodings() {\n-    }\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n \n-    /**\n-     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n-     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n-     */\n-    public static StreamingContentCodec identity() {\n-        return IDENTITY;\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n     }\n \n     /**\n-     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 16Mib.\n-     *\n-     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n      */\n-    public static StreamingContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n+    public static ContentCoding none() {\n+        return NONE;\n     }\n \n     /**\n-     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link StreamingContentCodec}\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static StreamingContentCodecBuilder gzip() {\n-        return new GzipStreamingContentCodecBuilder();\n+    public static ContentCoding gzip() {\n+        return GZIP;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 16Mib.\n-     *\n-     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n      */\n-    public static StreamingContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     * a customizable {@link StreamingContentCodec}.\n-     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n      */\n-    public static StreamingContentCodecBuilder deflate() {\n-        return new DeflateStreamingContentCodecBuilder();\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n     }\n \n     /**\n-     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTA1NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519061054", "bodyText": "can we cache the header value for supportedEncodings instead of recomputing on every request?", "author": "Scottmitch", "createdAt": "2020-11-06T23:57:38Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex 8fe213549..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,83 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpClientFilter\n-        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrIdentity(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTkzNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519061935", "bodyText": "can you reference the ietf publish RFC https://tools.ietf.org/html/rfc7540#section-8.1.2.2 ?", "author": "Scottmitch", "createdAt": "2020-11-07T00:01:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -226,6 +236,17 @@ static void addChunkedEncoding(final HttpHeaders headers) {\n         }\n     }\n \n+    static void addContentEncoding(final HttpHeaders headers, CharSequence encoding) {\n+        // H2 does not support TE / Transfer-Encoding, so we rely in the presentation encoding only.\n+        // https://httpwg.org/specs/rfc7540.html#n-connection-specific-header-fields", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\nindex a8f0e4e2d..2a29635fb 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java\n\n@@ -239,12 +241,8 @@ public final class HeaderUtils {\n     static void addContentEncoding(final HttpHeaders headers, CharSequence encoding) {\n         // H2 does not support TE / Transfer-Encoding, so we rely in the presentation encoding only.\n         // https://httpwg.org/specs/rfc7540.html#n-connection-specific-header-fields\n-        headers.set(CONTENT_ENCODING, encoding);\n-        headers.set(VARY, CONTENT_ENCODING);\n-    }\n-\n-    static boolean hasContentEncoding(final HttpHeaders headers) {\n-        return headers.contains(CONTENT_ENCODING);\n+        headers.add(CONTENT_ENCODING, encoding);\n+        headers.add(VARY, CONTENT_ENCODING);\n     }\n \n     static void validateCookieNameAndValue(final CharSequence cookieName, final CharSequence cookieValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2Nzg1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519067856", "bodyText": "nit: make this final?", "author": "Scottmitch", "createdAt": "2020-11-07T00:30:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex 8fe213549..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,83 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpClientFilter\n-        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrIdentity(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2OTE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519069169", "bodyText": "since we are modifying state of the request we should do this in a lazy fashion (e.g. Single.defer(() -> ...))", "author": "Scottmitch", "createdAt": "2020-11-07T00:37:52Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\ndeleted file mode 100644\nindex 8fe213549..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java\n+++ /dev/null\n\n@@ -1,83 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-\n-import java.util.List;\n-\n-import static io.servicetalk.http.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n-\n-/**\n- * Filter responsible for encoding/decoding content according to content-codings configured.\n- */\n-class ContentCodingHttpClientFilter\n-        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private final List<StreamingContentCodec> supportedEncodings;\n-\n-    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n-        this.supportedEncodings = supportedEncodings;\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n-                encodePayloadContentIfAvailable(request, alloc);\n-\n-                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            StreamingContentCodec coding = identifyContentEncodingOrIdentity(response.headers(), supportedEncodings);\n-            if (!coding.equals(identity())) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        StreamingContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            addContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MTU5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519071596", "bodyText": "#1174 (comment)\nI'm hesitant to introduce the \"terminal filter\" concept on the builder. If there may be ordering constraints (as highlighted by @idelpivnitskiy) best to let the user append the filter in their preferred order.", "author": "Scottmitch", "createdAt": "2020-11-07T00:51:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java", "diffHunk": "@@ -97,13 +105,38 @@\n     @Override\n     public abstract SingleAddressHttpClientBuilder<U, R> appendClientFilter(StreamingHttpClientFilterFactory factory);\n \n+    @Override\n+    public SingleAddressHttpClientBuilder<U, R> supportedEncodings(StreamingContentCodec... codings) {\n+        this.supportedEncodings = unmodifiableList(asList(codings));\n+        return this;\n+    }\n+\n     @Override\n     public SingleAddressHttpClientBuilder<U, R> appendClientFilter(Predicate<StreamingHttpRequest> predicate,\n                                                                    StreamingHttpClientFilterFactory factory) {\n         return (SingleAddressHttpClientBuilder<U, R>)\n                 super.appendClientFilter(predicate, factory);\n     }\n \n+    /**\n+     * Terminal filter chain amendments hook.\n+     * @param currClientFilterFactory Current filter factory to append new filters if needed.\n+     * @return {@code this}\n+     */\n+    @Nullable\n+    protected StreamingHttpClientFilterFactory terminalFilterAmendment(", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java\nindex bb782c8ff..2d97767a0 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java\n\n@@ -105,12 +105,6 @@ public abstract class SingleAddressHttpClientBuilder<U, R>\n     @Override\n     public abstract SingleAddressHttpClientBuilder<U, R> appendClientFilter(StreamingHttpClientFilterFactory factory);\n \n-    @Override\n-    public SingleAddressHttpClientBuilder<U, R> supportedEncodings(StreamingContentCodec... codings) {\n-        this.supportedEncodings = unmodifiableList(asList(codings));\n-        return this;\n-    }\n-\n     @Override\n     public SingleAddressHttpClientBuilder<U, R> appendClientFilter(Predicate<StreamingHttpRequest> predicate,\n                                                                    StreamingHttpClientFilterFactory factory) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTg0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519075841", "bodyText": "followup: I noticed in gRPC we actually encode identity on the wire. Since not including the header is equivalent to identity we should just not emit identity (for content-encoding or accept-encoding headers). encoding/decoding headers isn't free so we should avoid this when ever possible. as an implementation note we should able to simplify as treating identity() the same as null (so we don't have to check for both conditions).", "author": "Scottmitch", "createdAt": "2020-11-07T01:19:44Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -245,7 +245,7 @@ static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaDa\n                                                        final Set<GrpcMessageEncoding> allowedEncodings) {\n         final CharSequence encoding = httpMetaData.headers().get(GRPC_MESSAGE_ENCODING_KEY);\n         if (encoding == null) {\n-            return none();\n+            return identity();", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxNTA1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r521315053", "bodyText": "Will follow up on that on the gRPC PR #1198", "author": "tkountis", "createdAt": "2020-11-11T12:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTg0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java\nindex 8a29733fa..9377d8ed5 100644\n--- a/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java\n+++ b/servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java\n\n@@ -245,7 +245,7 @@ final class GrpcUtils {\n                                                        final Set<GrpcMessageEncoding> allowedEncodings) {\n         final CharSequence encoding = httpMetaData.headers().get(GRPC_MESSAGE_ENCODING_KEY);\n         if (encoding == null) {\n-            return identity();\n+            return none();\n         }\n \n         GrpcMessageEncoding enc = encodingFor(allowedEncodings, encoding.toString());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4ODk1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522788956", "bodyText": "It looks like encode(src, allocator) and decode(src, allocator) is enough for current use-cases. Wdyt if we will remove overloads with offset and length for now to reduce public API surface?", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:26:49Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMTY3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525131679", "bodyText": "Agreed, the offset part isn't needed, but the length it is in some cases to avoid creating view or slice.\nCan we keep the changes as part of this PR https://github.com/apple/servicetalk/pull/1198/files#diff-0884917fb1a61a9cdef9580cd27730bd0d9863d6c93e5138b29866276576829bR55 ?", "author": "tkountis", "createdAt": "2020-11-17T12:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4ODk1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nsimilarity index 79%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nindex 0bc21abcb..e995d2b33 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n\n@@ -13,47 +13,52 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n import io.servicetalk.concurrent.api.Publisher;\n \n /**\n- * API to support encode and decode of {@link Buffer}s.\n- * <p>\n- * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n public interface ContentCodec {\n \n-    /**\n-     * A unique textual representation for the coding.\n-     *\n-     * @return a unique textual representation for the coding.\n-     */\n-    CharSequence name();\n-\n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    default Buffer encode(Buffer src, BufferAllocator allocator) {\n-        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n+        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n     }\n \n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param offset the offset of the source to start reading from\n      * @param length the total length available for reading\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    Publisher<Buffer> encode(HttpHeaders headers, Publisher<Buffer> from, BufferAllocator allocator);\n \n     /**\n      * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzYwMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522797600", "bodyText": "Follow-up is ok: should we respond with 413 (or 400) when the size of decompressed payload body is larger than configured value?\nOn the client-side we should double check that the connection/stream will be closed if the decompressed side is larger than client allows.\nhttps://tools.ietf.org/html/rfc7231#section-6.5.11", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:34:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+    }\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings can differ for requests and responses, allowing a server that supports compressed responses,\n+     * but allows no compressed requests.\n+     * <p>\n+     * To disable support of compressed requests use an {@link Collections#emptyList()} for the\n+     * <code>supportedRequestCodings</code> param.\n+     * <p>\n+     * The order of the codecs provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedRequestCodings the codecs used to decompress client requests if compressed.\n+     * @param supportedResponseCodings the codecs used to compress server responses if client accepts them.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedRequestCodings,\n+                                          final List<ContentCodec> supportedResponseCodings) {\n+        this.requestCodings = unmodifiableList(supportedRequestCodings);\n+        this.responseCodings = unmodifiableList(supportedResponseCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                return Single.defer(() -> {\n+                    BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                    try {\n+                        ContentCodec coding =\n+                                identifyContentEncodingOrNullIfIdentity(request.headers(), requestCodings);\n+                        if (coding != null) {\n+                            request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory).map(response -> {\n+                            encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n+                            return response;\n+                        });\n+                    } catch (UnsupportedContentEncodingException cause) {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI4Njk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525286996", "bodyText": "Follow up: #1217", "author": "tkountis", "createdAt": "2020-11-17T16:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex 942c632d5..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,157 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.encoding.api.ContentCodec;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.encoding.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n-import static java.util.Collections.unmodifiableList;\n-\n-/**\n- * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n- * as these are specified by the spec\n- * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n- *\n- * <p>\n- * Append this filter before others that are expected to to see compressed content for this request/response, and after\n- * other filters that expect to see/manipulate the original payload.\n- */\n-public final class ContentCodingHttpServiceFilter\n-        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n-\n-    private final List<ContentCodec> requestCodings;\n-    private final List<ContentCodec> responseCodings;\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings will be used for both client request decompression where needed and server responses compression\n-     * where enabled and matched.\n-     * <p>\n-     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n-     * <p>\n-     * The order of the codings provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n-        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-    }\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings can differ for requests and responses, allowing a server that supports compressed responses,\n-     * but allows no compressed requests.\n-     * <p>\n-     * To disable support of compressed requests use an {@link Collections#emptyList()} for the\n-     * <code>supportedRequestCodings</code> param.\n-     * <p>\n-     * The order of the codecs provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedRequestCodings the codecs used to decompress client requests if compressed.\n-     * @param supportedResponseCodings the codecs used to compress server responses if client accepts them.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedRequestCodings,\n-                                          final List<ContentCodec> supportedResponseCodings) {\n-        this.requestCodings = unmodifiableList(supportedRequestCodings);\n-        this.responseCodings = unmodifiableList(supportedResponseCodings);\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                return Single.defer(() -> {\n-                    BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                    try {\n-                        ContentCodec coding =\n-                                identifyContentEncodingOrNullIfIdentity(request.headers(), requestCodings);\n-                        if (coding != null) {\n-                            request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-                        }\n-\n-                        return super.handle(ctx, request, responseFactory).map(response -> {\n-                            encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                            return response;\n-                        });\n-                    } catch (UnsupportedContentEncodingException cause) {\n-                        LOGGER.error(\"Request failed for service={}, connection={}\", service, this, cause);\n-                        // see https://tools.ietf.org/html/rfc7231#section-3.1.2.2\n-                        return succeeded(responseFactory.unsupportedMediaType());\n-                    }\n-                });\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence - no blocking\n-        return strategy;\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<ContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        ContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null) {\n-            setContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static ContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                  final StreamingHttpResponse response,\n-                                                  final List<ContentCodec> supportedEncodings) {\n-        // Enforced selection\n-        ContentCodec encoding = response.encoding();\n-        if (encoding == null) {\n-            // Negotiated from client headers and server config\n-            encoding = negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-        }\n-\n-        return encoding == identity() ? null : encoding;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMTI2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522801262", "bodyText": "WDYT if we will remove default implementation from streaming encode/decode methods? Our implementations always implement both. Users who do not care about streaming use-cases can decide what to do: implement the same as we have here now or throw an UnsupportedOperationException. Both ways are trivial for them to implement.\nIf we will have a strong use-case for default streaming methods later, we can add them later without breaking backward compatibility of the API.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:42:06Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    default Buffer decode(Buffer src, BufferAllocator allocator) {\n+        return decode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    Buffer decode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map((buffer -> encode(buffer, allocator)));\n+    }\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the decoded contents.\n+     *\n+     * @param from the {@link Publisher} to decoded\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers decoded\n+     */\n+    default Publisher<Buffer> decode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map(buffer -> decode(buffer, allocator));", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nsimilarity index 79%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\nindex 0bc21abcb..e995d2b33 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java\n\n@@ -13,47 +13,52 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n import io.servicetalk.concurrent.api.Publisher;\n \n /**\n- * API to support encode and decode of {@link Buffer}s.\n- * <p>\n- * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n public interface ContentCodec {\n \n-    /**\n-     * A unique textual representation for the coding.\n-     *\n-     * @return a unique textual representation for the coding.\n-     */\n-    CharSequence name();\n-\n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    default Buffer encode(Buffer src, BufferAllocator allocator) {\n-        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n+        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n     }\n \n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n      * @param src the {@link Buffer} to encode\n      * @param offset the offset of the source to start reading from\n      * @param length the total length available for reading\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    Publisher<Buffer> encode(HttpHeaders headers, Publisher<Buffer> from, BufferAllocator allocator);\n \n     /**\n      * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMjkwOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522802909", "bodyText": "We usually do not tell internal specifics or what are the default values because them may change. Consider removing information about the implementation here and for deflateDefault().", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:44:15Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n+\n+/**\n+ * Common available encoding implementations.\n+ */\n+public final class ContentCodings {\n+\n+    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n+\n+    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCodec}.\n+     * @return the default, always supported 'identity' {@link ContentCodec}\n+     */\n+    public static ContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java\ndeleted file mode 100644\nindex db4954a60..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n-import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n-\n-/**\n- * Common available encoding implementations.\n- */\n-public final class ContentCodings {\n-\n-    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n-\n-    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n-\n-    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n-\n-    private ContentCodings() {\n-    }\n-\n-    /**\n-     * Returns the default, always supported 'identity' {@link ContentCodec}.\n-     * @return the default, always supported 'identity' {@link ContentCodec}\n-     */\n-    public static ContentCodec identity() {\n-        return IDENTITY;\n-    }\n-\n-    /**\n-     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n-     */\n-    public static ContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n-    }\n-\n-    /**\n-     * Returns a GZIP based {@link DefaultContentCodecBuilder} that allows building\n-     * a customizable {@link ContentCodec}.\n-     * @return a GZIP based {@link DefaultContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link ContentCodec}\n-     */\n-    public static ContentCodecBuilder gzip() {\n-        return new GzipContentCodecBuilder();\n-    }\n-\n-    /**\n-     * Returns the default DEFLATE based {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * @return default DEFLATE based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n-     */\n-    public static ContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n-    }\n-\n-    /**\n-     * Returns a DEFLATE based {@link DefaultContentCodecBuilder} that allows building\n-     * a customizable {@link ContentCodec}.\n-     * @return a DEFLATE based {@link DefaultContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link ContentCodec}\n-     */\n-    public static ContentCodecBuilder deflate() {\n-        return new DeflateContentCodecBuilder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzg0Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522803842", "bodyText": "It returns ContentCodecBuilder interface, same for deflate().", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:45:17Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n+\n+/**\n+ * Common available encoding implementations.\n+ */\n+public final class ContentCodings {\n+\n+    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n+\n+    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCodec}.\n+     * @return the default, always supported 'identity' {@link ContentCodec}\n+     */\n+    public static ContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link DefaultContentCodecBuilder} that allows building\n+     * a customizable {@link ContentCodec}.\n+     * @return a GZIP based {@link DefaultContentCodecBuilder} that allows building", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java\ndeleted file mode 100644\nindex db4954a60..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n-import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n-\n-/**\n- * Common available encoding implementations.\n- */\n-public final class ContentCodings {\n-\n-    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n-\n-    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n-\n-    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n-\n-    private ContentCodings() {\n-    }\n-\n-    /**\n-     * Returns the default, always supported 'identity' {@link ContentCodec}.\n-     * @return the default, always supported 'identity' {@link ContentCodec}\n-     */\n-    public static ContentCodec identity() {\n-        return IDENTITY;\n-    }\n-\n-    /**\n-     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n-     */\n-    public static ContentCodec gzipDefault() {\n-        return DEFAULT_GZIP;\n-    }\n-\n-    /**\n-     * Returns a GZIP based {@link DefaultContentCodecBuilder} that allows building\n-     * a customizable {@link ContentCodec}.\n-     * @return a GZIP based {@link DefaultContentCodecBuilder} that allows building\n-     *          a customizable GZIP {@link ContentCodec}\n-     */\n-    public static ContentCodecBuilder gzip() {\n-        return new GzipContentCodecBuilder();\n-    }\n-\n-    /**\n-     * Returns the default DEFLATE based {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * @return default DEFLATE based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n-     */\n-    public static ContentCodec deflateDefault() {\n-        return DEFAULT_DEFLATE;\n-    }\n-\n-    /**\n-     * Returns a DEFLATE based {@link DefaultContentCodecBuilder} that allows building\n-     * a customizable {@link ContentCodec}.\n-     * @return a DEFLATE based {@link DefaultContentCodecBuilder} that allows building\n-     *          a customizable DEFLATE {@link ContentCodec}\n-     */\n-    public static ContentCodecBuilder deflate() {\n-        return new DeflateContentCodecBuilder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwNDQzOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522804438", "bodyText": "Can this class be pkg-private for now if we have an interface?", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:45:58Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\ndeleted file mode 100644\nindex 3dedce115..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n-\n-    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n-\n-    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n-\n-    @Override\n-    public ContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n-        this.maxAllowedPayloadSize = maxAllowedPayloadSize;\n-        return this;\n-    }\n-\n-    static final class GzipContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new GzipContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-\n-    static final class DeflateContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new DeflateContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwNzAzOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522807039", "bodyText": "Consider adding a check, follow a consistent pattern for the exception message: \n  \n    \n      servicetalk/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscovererBuilder.java\n    \n    \n        Lines 106 to 108\n      in\n      0995205\n    \n    \n    \n    \n\n        \n          \n           if (maxUdpPayloadSize <= 0) { \n        \n\n        \n          \n               throw new IllegalArgumentException(\"maxUdpPayloadSize: \" + minTTLSeconds + \" (expected > 0)\"); \n        \n\n        \n          \n           }", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:48:43Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n+\n+    @Override\n+    public ContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n+        this.maxAllowedPayloadSize = maxAllowedPayloadSize;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\ndeleted file mode 100644\nindex 3dedce115..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n-\n-    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n-\n-    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n-\n-    @Override\n-    public ContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n-        this.maxAllowedPayloadSize = maxAllowedPayloadSize;\n-        return this;\n-    }\n-\n-    static final class GzipContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new GzipContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-\n-    static final class DeflateContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new DeflateContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwODE0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522808148", "bodyText": "Consider adding a pkg-private (or protected) getter method instead of allowing subclasses to modify this value without calling a setter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:50:25Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\ndeleted file mode 100644\nindex 3dedce115..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n-\n-    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n-\n-    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n-\n-    @Override\n-    public ContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n-        this.maxAllowedPayloadSize = maxAllowedPayloadSize;\n-        return this;\n-    }\n-\n-    static final class GzipContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new GzipContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-\n-    static final class DeflateContentCodecBuilder extends DefaultContentCodecBuilder {\n-        @Override\n-        public ContentCodec build() {\n-            return new DeflateContentCodec(CHUNK_SIZE, maxAllowedPayloadSize);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwOTQzNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522809435", "bodyText": "offset -> src.arrayOffset() + offset", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:52:56Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nsimilarity index 74%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex 3a8efab7f..9a798a5e8 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -13,7 +13,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxMjAyOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522812028", "bodyText": "next.readerIndex() -> next.arrayOffset() + next.readerIndex()", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:57:48Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Buffer next) {\n+                        assert output != null;\n+                        assert stream != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    // ZIP footer is 10 bytes\n+                                    Buffer dst = allocator.newBuffer(10);\n+                                    stream.swap(dst);\n+                                    output.finish();\n+\n+                                    subscriber.onNext(dst);\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer dst;\n+                            if (headerWritten) {\n+                                dst = allocator.newBuffer(chunkSize);\n+                                stream.swap(dst);\n+                            } else {\n+                                dst = stream.buffer;\n+                            }\n+\n+                            if (next.hasArray()) {\n+                                output.write(next.array(), next.readerIndex(), next.readableBytes());", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nsimilarity index 74%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex 3a8efab7f..9a798a5e8 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -13,7 +13,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTAyNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522821024", "bodyText": "RS spec does not allow throwing from these methods. We should call onError in case of exceptions. SunscriberUtils.deliferErrorFromSource will be helpful here.\nPlease, revisit other try-catch blocks in this class.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:14:33Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nsimilarity index 74%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex 3a8efab7f..9a798a5e8 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -13,7 +13,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMjIwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522822203", "bodyText": "I think we should try-catch and deliver the error using onError instead of invoking onComplete if output.close() throws an exception.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:16:41Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Buffer next) {\n+                        assert output != null;\n+                        assert stream != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    // ZIP footer is 10 bytes\n+                                    Buffer dst = allocator.newBuffer(10);\n+                                    stream.swap(dst);\n+                                    output.finish();\n+\n+                                    subscriber.onNext(dst);\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer dst;\n+                            if (headerWritten) {\n+                                dst = allocator.newBuffer(chunkSize);\n+                                stream.swap(dst);\n+                            } else {\n+                                dst = stream.buffer;\n+                            }\n+\n+                            if (next.hasArray()) {\n+                                output.write(next.array(), next.readerIndex(), next.readableBytes());\n+                            } else {\n+                                while (next.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[Math.min(next.readableBytes(), chunkSize)];\n+                                    next.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            headerWritten = true;\n+                            subscriber.onNext(dst);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nsimilarity index 74%\nrename from servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\nrename to servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\nindex 3a8efab7f..9a798a5e8 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java\n\n@@ -13,7 +13,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package io.servicetalk.encoding.api;\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n \n import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.buffer.api.BufferAllocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NDE5Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522844193", "bodyText": "I double checked, you were right. There is a bug somewhere (need more investigation, but I have a reproducer) and we may miss trailers for some scenarios. Let's leave a TODO comment to remove this additional check when the trailers bug is resolved.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:56:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -111,7 +112,7 @@ static boolean canAddResponseTransferEncodingProtocol(final int statusCode,\n     }\n \n     private static boolean canAddContentLength(final HttpMetaData metadata) {\n-        return !hasContentHeaders(metadata.headers()) &&\n+        return !hasContentHeaders(metadata.headers()) && !hasContentEncoding(metadata.headers()) &&", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0MjUzOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525142538", "bodyText": "Opened a separate PR for this #1213\nI will leave a TODO once that is fixed.", "author": "tkountis", "createdAt": "2020-11-17T13:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NDE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\nindex 64ab3a689..1fd9dd880 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java\n\n@@ -112,7 +114,7 @@ final class HeaderUtils {\n     }\n \n     private static boolean canAddContentLength(final HttpMetaData metadata) {\n-        return !hasContentHeaders(metadata.headers()) && !hasContentEncoding(metadata.headers()) &&\n+        return !hasContentHeaders(metadata.headers()) &&\n                 isSafeToAggregate(metadata) && !mayHaveTrailers(metadata);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NjgwNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522846807", "bodyText": "nit: unnecessary extra lines", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:00:26Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java", "diffHunk": "@@ -149,9 +149,11 @@ protected void initChannel(final Http2StreamChannel streamChannel) {\n                                         parentChannelInitializer.multiplexedObserver.onNewStream();\n \n                                 // Netty To ServiceTalk type conversion\n+\n                                 streamChannel.pipeline().addLast(new H2ToStH1ServerDuplexHandler(\n                                         connection.executionContext().bufferAllocator(),\n                                         h2ServerConfig.headersFactory(),\n+", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39ec43975c626e174396f7369f163a21afe875b6", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java\nindex 83a7600d2..433f0e147 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java\n\n@@ -153,7 +153,6 @@ final class H2ServerParentConnectionContext extends H2ParentConnectionContext im\n                                 streamChannel.pipeline().addLast(new H2ToStH1ServerDuplexHandler(\n                                         connection.executionContext().bufferAllocator(),\n                                         h2ServerConfig.headersFactory(),\n-\n                                         PROTOCOL_OUTBOUND_CLOSE_HANDLER, streamObserver));\n \n                                 // ServiceTalk <-> Netty netty utilities\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522849436", "bodyText": "Just curious, why Grpc prefix was removed? :)", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:05:18Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageCodec.java", "diffHunk": "@@ -19,10 +19,21 @@\n import io.servicetalk.buffer.api.BufferAllocator;\n \n /**\n- * Codec used to encode and decode gRPC messages.\n- * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ * Codec used to encode and decode {@link Buffer} content.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n-public interface GrpcMessageCodec {\n+public interface MessageCodec {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0NzA4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525147082", "bodyText": "The gRPC PR removes them completely, #1198\nShould keep the changes there, or you would rather bring them here?", "author": "tkountis", "createdAt": "2020-11-17T13:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYyODI2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525628267", "bodyText": "Doesn't matter, let's handle it in #1198. Thanks for clarifying.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T01:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522850625", "bodyText": "Similar comment as I had for ContentCodec: it looks like only encode(src, allocator) variant is enough for now. Can we remove an overload with offset and length? Users can slice the required Bufferportion in necessary to encode only a part of theBuffer`.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:07:35Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageCodec.java", "diffHunk": "@@ -19,10 +19,21 @@\n import io.servicetalk.buffer.api.BufferAllocator;\n \n /**\n- * Codec used to encode and decode gRPC messages.\n- * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ * Codec used to encode and decode {@link Buffer} content.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n-public interface GrpcMessageCodec {\n+public interface MessageCodec {\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0ODY2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525148669", "bodyText": "It is useful for gRPC (https://github.com/apple/servicetalk/pull/1198/files#diff-04a488534a209852ed234ffe65b56d079a09bae65dede9c6366116204cf00320R162) otherwise we have to create a slice or view. IMO this is cheaper", "author": "tkountis", "createdAt": "2020-11-17T13:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYyODA2Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525628063", "bodyText": "IIUC, lengthOfData is always equal to toDeserialize.readableBytes(). Therefore, we do not need a slice. Let's handle it in #1198.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T01:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzAwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522857003", "bodyText": "Because this result will be cached in a variable and will be written multiple time, consider wrapping the retirned String with newAsciiString. It will let the HttpObjectEncoder write it faster.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:19:43Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+\n+/**\n+ * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n+ * respectively, as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to manipulate the original payload.\n+ */\n+public final class ContentCodingHttpRequesterFilter\n+        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n+                   HttpExecutionStrategyInfluencer {\n+\n+    private final List<ContentCodec> supportedCodings;\n+    @Nullable\n+    private final CharSequence acceptedEncodingsHeader;\n+\n+    /**\n+     * Enable support of the provided encodings for requests and responses.\n+     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n+     * on the receiving endpoint.\n+     *\n+     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n+     * and also used to advertise to the server.\n+     */\n+    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n+        this.supportedCodings = supportedCodings;\n+        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n+        return new StreamingHttpConnectionFilter(connection) {\n+            @Override\n+            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n+                                                         final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        // No influence since we do not block.\n+        return strategy;\n+    }\n+\n+    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n+                                                                              final HttpExecutionStrategy strategy,\n+                                                                              final StreamingHttpRequest request) {\n+        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n+        encodePayloadContentIfAvailable(request, alloc);\n+\n+        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map(response -> {\n+            ContentCodec coding = identifyContentEncodingOrNullIfIdentity(response.headers(), supportedCodings);\n+            if (coding != null) {\n+                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+            }\n+\n+            return response;\n+        });\n+    }\n+\n+    @Nullable\n+    private static CharSequence buildAcceptEncodingsHeader(final List<ContentCodec> codecs) {\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCodec enc : codecs) {\n+            if (enc == identity()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        return builder.length() > 0 ? builder.toString() : null;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java\ndeleted file mode 100644\nindex fbff04d22..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java\n+++ /dev/null\n\n@@ -1,138 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.encoding.api.ContentCodec;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.encoding.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n-import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n-\n-/**\n- * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n- * respectively, as these are specified by the spec\n- * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n- *\n- * <p>\n- * Append this filter before others that are expected to to see compressed content for this request/response, and after\n- * other filters that expect to manipulate the original payload.\n- */\n-public final class ContentCodingHttpRequesterFilter\n-        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n-                   HttpExecutionStrategyInfluencer {\n-\n-    private final List<ContentCodec> supportedCodings;\n-    @Nullable\n-    private final CharSequence acceptedEncodingsHeader;\n-\n-    /**\n-     * Enable support of the provided encodings for requests and responses.\n-     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n-     * on the receiving endpoint.\n-     *\n-     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n-     * and also used to advertise to the server.\n-     */\n-    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n-        this.supportedCodings = supportedCodings;\n-        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n-        return new StreamingHttpConnectionFilter(connection) {\n-            @Override\n-            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n-                                                         final StreamingHttpRequest request) {\n-                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n-                                                                              final HttpExecutionStrategy strategy,\n-                                                                              final StreamingHttpRequest request) {\n-        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n-        encodePayloadContentIfAvailable(request, alloc);\n-\n-        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            ContentCodec coding = identifyContentEncodingOrNullIfIdentity(response.headers(), supportedCodings);\n-            if (coding != null) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    @Nullable\n-    private static CharSequence buildAcceptEncodingsHeader(final List<ContentCodec> codecs) {\n-        StringBuilder builder = new StringBuilder();\n-        for (ContentCodec enc : codecs) {\n-            if (enc == identity()) {\n-                continue;\n-            }\n-\n-            if (builder.length() > 0) {\n-                builder.append(\", \");\n-            }\n-\n-            builder.append(enc.name());\n-        }\n-\n-        return builder.length() > 0 ? builder.toString() : null;\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        ContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            setContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1OTkwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522859905", "bodyText": "Consider moving it out of a public interface. DefaultContentCodecBuilder can be a good home for this private constant.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:24:54Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+/**\n+ * Builder for {@link ContentCodec}.\n+ */\n+public interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD = 16 << 20; //16MiB", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodecBuilder.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodecBuilder.java\ndeleted file mode 100644\nindex f358d0ce6..000000000\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodecBuilder.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.encoding.api;\n-\n-/**\n- * Builder for {@link ContentCodec}.\n- */\n-public interface ContentCodecBuilder {\n-\n-    int DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD = 16 << 20; //16MiB\n-\n-    /**\n-     * Sets the maximum allowed decompressed payload size that the codec can process.\n-     * This can help prevent malicious attempts to decode malformed payloads that can drain resources of the\n-     * running instance.\n-     *\n-     * @param maxAllowedPayloadSize the maximum allowed payload size\n-     * @return {@code this}\n-     * @see <a href=\"https://en.wikipedia.org/wiki/Zip_bomb\">Zip Bomb</a>\n-     */\n-    ContentCodecBuilder setMaxAllowedPayloadSize(int maxAllowedPayloadSize);\n-\n-    /**\n-     * Build and return an instance of the {@link ContentCodec} with the configuration of the builder.\n-     * @return the {@link ContentCodec} with the configuration of the builder\n-     */\n-    ContentCodec build();\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NTY1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522865658", "bodyText": "unmodifiableList is not helpful here, because users have a reference to the original modifyable list.We know that the internal code of this filter does not modify the list. Therefore, not necessary to add this wrapper.\nI don't think we should copy the passed list, up to you. Doesn't make much sense for users to change it later. If you will decide to copy it, please do the same for the requester filter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:36:04Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex 942c632d5..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,157 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.encoding.api.ContentCodec;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.encoding.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n-import static java.util.Collections.unmodifiableList;\n-\n-/**\n- * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n- * as these are specified by the spec\n- * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n- *\n- * <p>\n- * Append this filter before others that are expected to to see compressed content for this request/response, and after\n- * other filters that expect to see/manipulate the original payload.\n- */\n-public final class ContentCodingHttpServiceFilter\n-        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n-\n-    private final List<ContentCodec> requestCodings;\n-    private final List<ContentCodec> responseCodings;\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings will be used for both client request decompression where needed and server responses compression\n-     * where enabled and matched.\n-     * <p>\n-     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n-     * <p>\n-     * The order of the codings provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n-        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-    }\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings can differ for requests and responses, allowing a server that supports compressed responses,\n-     * but allows no compressed requests.\n-     * <p>\n-     * To disable support of compressed requests use an {@link Collections#emptyList()} for the\n-     * <code>supportedRequestCodings</code> param.\n-     * <p>\n-     * The order of the codecs provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedRequestCodings the codecs used to decompress client requests if compressed.\n-     * @param supportedResponseCodings the codecs used to compress server responses if client accepts them.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedRequestCodings,\n-                                          final List<ContentCodec> supportedResponseCodings) {\n-        this.requestCodings = unmodifiableList(supportedRequestCodings);\n-        this.responseCodings = unmodifiableList(supportedResponseCodings);\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                return Single.defer(() -> {\n-                    BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                    try {\n-                        ContentCodec coding =\n-                                identifyContentEncodingOrNullIfIdentity(request.headers(), requestCodings);\n-                        if (coding != null) {\n-                            request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-                        }\n-\n-                        return super.handle(ctx, request, responseFactory).map(response -> {\n-                            encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                            return response;\n-                        });\n-                    } catch (UnsupportedContentEncodingException cause) {\n-                        LOGGER.error(\"Request failed for service={}, connection={}\", service, this, cause);\n-                        // see https://tools.ietf.org/html/rfc7231#section-3.1.2.2\n-                        return succeeded(responseFactory.unsupportedMediaType());\n-                    }\n-                });\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence - no blocking\n-        return strategy;\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<ContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        ContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null) {\n-            setContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static ContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                  final StreamingHttpResponse response,\n-                                                  final List<ContentCodec> supportedEncodings) {\n-        // Enforced selection\n-        ContentCodec encoding = response.encoding();\n-        if (encoding == null) {\n-            // Negotiated from client headers and server config\n-            encoding = negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-        }\n-\n-        return encoding == identity() ? null : encoding;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NjY0OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522866649", "bodyText": "I think what you had on the builder was the opposite. The method that takes a single List enabled compression only for responses (the most common use-case for servers). Users who need decompression for requests are advanced users and can use a second overload.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:37:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\ndeleted file mode 100644\nindex 942c632d5..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java\n+++ /dev/null\n\n@@ -1,157 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.encoding.api.ContentCodec;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.encoding.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n-import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n-import static java.util.Collections.unmodifiableList;\n-\n-/**\n- * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n- * as these are specified by the spec\n- * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n- *\n- * <p>\n- * Append this filter before others that are expected to to see compressed content for this request/response, and after\n- * other filters that expect to see/manipulate the original payload.\n- */\n-public final class ContentCodingHttpServiceFilter\n-        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n-\n-    private final List<ContentCodec> requestCodings;\n-    private final List<ContentCodec> responseCodings;\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings will be used for both client request decompression where needed and server responses compression\n-     * where enabled and matched.\n-     * <p>\n-     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n-     * <p>\n-     * The order of the codings provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n-        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n-        this.requestCodings = unmodifiable;\n-        this.responseCodings = unmodifiable;\n-    }\n-\n-    /**\n-     * Enable support of the provided encodings for this server's requests and responses.\n-     * The encodings can differ for requests and responses, allowing a server that supports compressed responses,\n-     * but allows no compressed requests.\n-     * <p>\n-     * To disable support of compressed requests use an {@link Collections#emptyList()} for the\n-     * <code>supportedRequestCodings</code> param.\n-     * <p>\n-     * The order of the codecs provided, affect selection priority alongside the order of the incoming\n-     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n-     *\n-     * @param supportedRequestCodings the codecs used to decompress client requests if compressed.\n-     * @param supportedResponseCodings the codecs used to compress server responses if client accepts them.\n-     */\n-    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedRequestCodings,\n-                                          final List<ContentCodec> supportedResponseCodings) {\n-        this.requestCodings = unmodifiableList(supportedRequestCodings);\n-        this.responseCodings = unmodifiableList(supportedResponseCodings);\n-    }\n-\n-    @Override\n-    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n-        return new StreamingHttpServiceFilter(service) {\n-            @Override\n-            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n-                                                        final StreamingHttpRequest request,\n-                                                        final StreamingHttpResponseFactory responseFactory) {\n-\n-                return Single.defer(() -> {\n-                    BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n-                    try {\n-                        ContentCodec coding =\n-                                identifyContentEncodingOrNullIfIdentity(request.headers(), requestCodings);\n-                        if (coding != null) {\n-                            request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-                        }\n-\n-                        return super.handle(ctx, request, responseFactory).map(response -> {\n-                            encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n-                            return response;\n-                        });\n-                    } catch (UnsupportedContentEncodingException cause) {\n-                        LOGGER.error(\"Request failed for service={}, connection={}\", service, this, cause);\n-                        // see https://tools.ietf.org/html/rfc7231#section-3.1.2.2\n-                        return succeeded(responseFactory.unsupportedMediaType());\n-                    }\n-                });\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence - no blocking\n-        return strategy;\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n-                                                        final List<ContentCodec> supportedEncodings,\n-                                                        final StreamingHttpResponse response,\n-                                                        final BufferAllocator allocator) {\n-        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n-            return;\n-        }\n-\n-        ContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n-        if (coding != null) {\n-            setContentEncoding(response.headers(), coding.name());\n-            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n-        }\n-    }\n-\n-    @Nullable\n-    private static ContentCodec codingForResponse(final HttpHeaders requestHeaders,\n-                                                  final StreamingHttpResponse response,\n-                                                  final List<ContentCodec> supportedEncodings) {\n-        // Enforced selection\n-        ContentCodec encoding = response.encoding();\n-        if (encoding == null) {\n-            // Negotiated from client headers and server config\n-            encoding = negotiateAcceptedEncoding(requestHeaders, supportedEncodings);\n-        }\n-\n-        return encoding == identity() ? null : encoding;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NzE0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522867143", "bodyText": "The whole method should be wrapped with defer operator, similar to the service filter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:39:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+\n+/**\n+ * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n+ * respectively, as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to manipulate the original payload.\n+ */\n+public final class ContentCodingHttpRequesterFilter\n+        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n+                   HttpExecutionStrategyInfluencer {\n+\n+    private final List<ContentCodec> supportedCodings;\n+    @Nullable\n+    private final CharSequence acceptedEncodingsHeader;\n+\n+    /**\n+     * Enable support of the provided encodings for requests and responses.\n+     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n+     * on the receiving endpoint.\n+     *\n+     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n+     * and also used to advertise to the server.\n+     */\n+    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n+        this.supportedCodings = supportedCodings;\n+        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n+        return new StreamingHttpConnectionFilter(connection) {\n+            @Override\n+            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n+                                                         final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        // No influence since we do not block.\n+        return strategy;\n+    }\n+\n+    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n+                                                                              final HttpExecutionStrategy strategy,\n+                                                                              final StreamingHttpRequest request) {\n+        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n+        encodePayloadContentIfAvailable(request, alloc);\n+\n+        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1MDQ3MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525150470", "bodyText": "The factory methods (create) do wrap it.", "author": "tkountis", "createdAt": "2020-11-17T13:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NzE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7b06865c7197cb7266f4c9218f23970efdf41f82", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java\ndeleted file mode 100644\nindex fbff04d22..000000000\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java\n+++ /dev/null\n\n@@ -1,138 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.api;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.encoding.api.ContentCodec;\n-\n-import java.util.List;\n-import javax.annotation.Nullable;\n-\n-import static io.servicetalk.encoding.api.ContentCodings.identity;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n-import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n-import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n-\n-/**\n- * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n- * respectively, as these are specified by the spec\n- * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n- *\n- * <p>\n- * Append this filter before others that are expected to to see compressed content for this request/response, and after\n- * other filters that expect to manipulate the original payload.\n- */\n-public final class ContentCodingHttpRequesterFilter\n-        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n-                   HttpExecutionStrategyInfluencer {\n-\n-    private final List<ContentCodec> supportedCodings;\n-    @Nullable\n-    private final CharSequence acceptedEncodingsHeader;\n-\n-    /**\n-     * Enable support of the provided encodings for requests and responses.\n-     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n-     * on the receiving endpoint.\n-     *\n-     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n-     * and also used to advertise to the server.\n-     */\n-    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n-        this.supportedCodings = supportedCodings;\n-        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n-    }\n-\n-    @Override\n-    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-        return new StreamingHttpClientFilter(client) {\n-            @Override\n-            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                            final HttpExecutionStrategy strategy,\n-                                                            final StreamingHttpRequest request) {\n-                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n-        return new StreamingHttpConnectionFilter(connection) {\n-            @Override\n-            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n-                                                         final StreamingHttpRequest request) {\n-                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n-        // No influence since we do not block.\n-        return strategy;\n-    }\n-\n-    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n-                                                                              final HttpExecutionStrategy strategy,\n-                                                                              final StreamingHttpRequest request) {\n-        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n-        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n-        encodePayloadContentIfAvailable(request, alloc);\n-\n-        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);\n-    }\n-\n-    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n-            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n-\n-        return responseSingle.map(response -> {\n-            ContentCodec coding = identifyContentEncodingOrNullIfIdentity(response.headers(), supportedCodings);\n-            if (coding != null) {\n-                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n-            }\n-\n-            return response;\n-        });\n-    }\n-\n-    @Nullable\n-    private static CharSequence buildAcceptEncodingsHeader(final List<ContentCodec> codecs) {\n-        StringBuilder builder = new StringBuilder();\n-        for (ContentCodec enc : codecs) {\n-            if (enc == identity()) {\n-                continue;\n-            }\n-\n-            if (builder.length() > 0) {\n-                builder.append(\", \");\n-            }\n-\n-            builder.append(enc.name());\n-        }\n-\n-        return builder.length() > 0 ? builder.toString() : null;\n-    }\n-\n-    private static void encodePayloadContentIfAvailable(final StreamingHttpRequest request,\n-                                                        final BufferAllocator allocator) {\n-        ContentCodec coding = request.encoding();\n-        if (coding != null && !coding.equals(identity())) {\n-            setContentEncoding(request.headers(), coding.name());\n-            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n-        }\n-    }\n-}\n"}}, {"oid": "7b06865c7197cb7266f4c9218f23970efdf41f82", "url": "https://github.com/apple/servicetalk/commit/7b06865c7197cb7266f4c9218f23970efdf41f82", "message": "Introduce HTTP content encoding H1 & H2\n\nMotivation:\n\nOur HTTP clients & servers don't support any form of compression. There are many use cases that involve large payloads, that compression could make a difference on the HTTP timings.\n\nModifications:\n\nH1 & H2 protocols were altered to support a list of supported-encodings. We provide the default ones out of the box as part of the helper ContentEncodings.all() which offers, GZIP & DEFLATE.\nTo keep the behavior consistent between the two protocols, we chose to communicate the compression technique to the relevant endpoints through the 'Content-Encoding & Accept-Content-Encoding' headers, rather than on the 'Transfer-Encoding & TE' headers, which are not supported by H2.\n\nResult:\n\nOnce the client & server are configured to support different encodings through the protocol configuration, a client can encode a request by passing the encoding request.encoding(...) whereas the server will decide on the encoding based on the client advertised headers. To disable the encoding for a particular request, or enforce a specific encoding, one can call response.encoding(...) to do so. That, bypasses the auto-selection, and also ignores compatibility checks with the client.\n\nEncoding & Decoding is done in a streaming fashion.", "committedDate": "2020-11-17T12:59:30Z", "type": "commit"}, {"oid": "57bc44d84e891f2b68599e0fa40e661df4fa344a", "url": "https://github.com/apple/servicetalk/commit/57bc44d84e891f2b68599e0fa40e661df4fa344a", "message": "Fix broken pipeline when gzip footer is received onNext was not called", "committedDate": "2020-11-17T12:59:30Z", "type": "commit"}, {"oid": "a336216027fe7c0de6d2a3c268f1f8c50286f875", "url": "https://github.com/apple/servicetalk/commit/a336216027fe7c0de6d2a3c268f1f8c50286f875", "message": "Address comments", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "c464a892ff89066ed0c4cb584e8364cbe4274514", "url": "https://github.com/apple/servicetalk/commit/c464a892ff89066ed0c4cb584e8364cbe4274514", "message": "Improvements", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "a8bc7971cf60bc18b3bbbac55829a17c7ce19297", "url": "https://github.com/apple/servicetalk/commit/a8bc7971cf60bc18b3bbbac55829a17c7ce19297", "message": "Rename to Codec & rebase", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "358045f70f25ec96f518351264a064dea749c191", "url": "https://github.com/apple/servicetalk/commit/358045f70f25ec96f518351264a064dea749c191", "message": "Fix build", "committedDate": "2020-11-17T13:01:02Z", "type": "commit"}, {"oid": "6ee1909087be66c93dcce05c8b322401661d7207", "url": "https://github.com/apple/servicetalk/commit/6ee1909087be66c93dcce05c8b322401661d7207", "message": "Add ContentCodecBuilder & rename to codec", "committedDate": "2020-11-17T13:01:02Z", "type": "commit"}, {"oid": "1758afb743527d6f8805b9ba540b826c8d7943a6", "url": "https://github.com/apple/servicetalk/commit/1758afb743527d6f8805b9ba540b826c8d7943a6", "message": "Address new comments pt1", "committedDate": "2020-11-17T13:01:49Z", "type": "commit"}, {"oid": "ddc0ca9d96d7ebcae7732a3506b1caa9c49d42c0", "url": "https://github.com/apple/servicetalk/commit/ddc0ca9d96d7ebcae7732a3506b1caa9c49d42c0", "message": "Fix comments", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "fadb8ccd97651b29e55616536a7097d382e2cd0e", "url": "https://github.com/apple/servicetalk/commit/fadb8ccd97651b29e55616536a7097d382e2cd0e", "message": "Move encoding pieces to a new moduleP", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "6577a1a04af84d823ceb681844ebd73795b0a4e6", "url": "https://github.com/apple/servicetalk/commit/6577a1a04af84d823ceb681844ebd73795b0a4e6", "message": "Fix hunging issue for non-streaming requests & minor improvements", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "c7f164fbf25999ab7ddd3322406a156b8f2413d5", "url": "https://github.com/apple/servicetalk/commit/c7f164fbf25999ab7ddd3322406a156b8f2413d5", "message": "Improve max payload error message", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "39ec43975c626e174396f7369f163a21afe875b6", "url": "https://github.com/apple/servicetalk/commit/39ec43975c626e174396f7369f163a21afe875b6", "message": "Address comments", "committedDate": "2020-11-17T16:07:23Z", "type": "commit"}, {"oid": "39ec43975c626e174396f7369f163a21afe875b6", "url": "https://github.com/apple/servicetalk/commit/39ec43975c626e174396f7369f163a21afe875b6", "message": "Address comments", "committedDate": "2020-11-17T16:07:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxMzUxNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525613514", "bodyText": "We do not add \"get\" prefix for getters, we use only \"set\" prefix for setters and \"is/has\" prefix for boolean-type getters. Consider adjusting your Intellij IDEA templates for generated getters.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T00:24:13Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+    private static final int DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD = 16 << 20; //16MiB\n+\n+    private int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n+\n+    protected int getMaxAllowedPayloadSize() {", "originalCommit": "39ec43975c626e174396f7369f163a21afe875b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f134933387ac13eade5cfae1e6bfce7220422a78", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\nindex fe7ca1a06..21b509918 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\n+++ b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java\n\n@@ -22,7 +22,7 @@ abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n \n     private int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n \n-    protected int getMaxAllowedPayloadSize() {\n+    protected int maxAllowedPayloadSize() {\n         return maxAllowedPayloadSize;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxNjI0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525616248", "bodyText": "I don't think this is correct. At this level we do not need to care about internal Buffer implementation, we should just take an offset based on src.readerIndex(). The implementation of decode method also adds src.arrayOffset(). As the result, you double-counting the arrayOffset.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T00:31:36Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        int offset = src.hasArray() ? src.arrayOffset() : 0;\n+        return encode(src, offset + src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    default Buffer decode(Buffer src, BufferAllocator allocator) {\n+        int offset = src.hasArray() ? src.arrayOffset() : 0;\n+        return decode(src, offset + src.readerIndex(), src.readableBytes(), allocator);", "originalCommit": "39ec43975c626e174396f7369f163a21afe875b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTYwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525989603", "bodyText": ":(", "author": "tkountis", "createdAt": "2020-11-18T10:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxNjI0OA=="}], "type": "inlineReview", "revised_code": {"commit": "f134933387ac13eade5cfae1e6bfce7220422a78", "chunk": "diff --git a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\nindex 1f73304c1..e27d90d8d 100644\n--- a/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\n+++ b/servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java\n\n@@ -41,8 +41,7 @@ public interface ContentCodec {\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n     default Buffer encode(Buffer src, BufferAllocator allocator) {\n-        int offset = src.hasArray() ? src.arrayOffset() : 0;\n-        return encode(src, offset + src.readerIndex(), src.readableBytes(), allocator);\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n     }\n \n     /**\n"}}, {"oid": "f134933387ac13eade5cfae1e6bfce7220422a78", "url": "https://github.com/apple/servicetalk/commit/f134933387ac13eade5cfae1e6bfce7220422a78", "message": "The end", "committedDate": "2020-11-18T14:45:15Z", "type": "commit"}]}