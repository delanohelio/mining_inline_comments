{"pr_number": 1141, "pr_title": "Avoid `Connection reset by peer` error when server closes the connection", "pr_createdAt": "2020-09-04T15:53:42Z", "pr_url": "https://github.com/apple/servicetalk/pull/1141", "timeline": [{"oid": "a3ddae93f2227e4a4cdc5998874eccfb96ba6825", "url": "https://github.com/apple/servicetalk/commit/a3ddae93f2227e4a4cdc5998874eccfb96ba6825", "message": "Avoid `Connection reset by peer` error when server closes the connection\n\nMotivation:\n\nWhen users close the server gracefully or when the server adds a\n`Connection: close` header to the response, the `Channel` will be closed as\nsoon as server read the request and wrote the response. Because a client is\nnot aware that the server intends to close the connection, it may send a\nfollowing request on the same connection before it reads the response.\nIn this case, TCP stack on the server-side will respond with RST frame\n(because the `Channel` is already closed) that may erase data on the\nconnection that were delivered to the client but not acknowledged.\nSee https://tools.ietf.org/html/rfc7230#section-6.6 for more information.\n\nModifications:\n\n- When the request is read swap the `HttpRequestDecoder` with a handler\nthat discards all new incoming requests;\n- When response is written half-close the output side of the connection;\n- When the FIN is received from the client, close the `Channel`;\n- For SSL connections send `close_notify` before `shutdownOutput()`;\n- Save the original `CloseEvent` and use it later to produce more accurate\nlogs for connection closure;\n- Update `RequestResponseCloseHandlerTest` to account for a new state\nmachine;\n- Enhance `GracefulConnectionClosureHandlingTest` to test the same\nscenarios when graceful closure is initiated on the server-side;\n- Add `ServerGracefulConnectionClosureHandlingTest` that reproduces\n`Connection reset by peer` issue described in `Motivation` section;\n- Minor improvements for `ConnectionCloseHeaderHandlingTest` to align it\nwith other tests;\n\nResult:\n\nServer does to cause `Connection reset by peer` exception when it closes\ngracefully or adds `Connection: close` header.", "committedDate": "2020-09-04T03:36:11Z", "type": "commit"}, {"oid": "552f03ce079801862db091691f622721d6a3dccf", "url": "https://github.com/apple/servicetalk/commit/552f03ce079801862db091691f622721d6a3dccf", "message": "Account for the case when the server input shutdowns before output shutdown", "committedDate": "2020-09-09T00:03:12Z", "type": "commit"}, {"oid": "93c526cf271dbc3a761106d4dd5b527a7843c244", "url": "https://github.com/apple/servicetalk/commit/93c526cf271dbc3a761106d4dd5b527a7843c244", "message": "Do not half-close INBOUND (reset) on graceful server closure", "committedDate": "2020-09-09T18:07:26Z", "type": "commit"}, {"oid": "e86d5fe1bfd7d1c36018753b15512f2b127c5ed4", "url": "https://github.com/apple/servicetalk/commit/e86d5fe1bfd7d1c36018753b15512f2b127c5ed4", "message": "Merge remote-tracking branch 'upstream/main' into server-graceful-closure", "committedDate": "2020-09-09T18:08:57Z", "type": "commit"}, {"oid": "da9727cc3bc3e2897e89eb27a2b254cdd8b6db30", "url": "https://github.com/apple/servicetalk/commit/da9727cc3bc3e2897e89eb27a2b254cdd8b6db30", "message": "Use `pending == MAX_VALUE` instead of `CLOSING_SERVER_GRACEFULLY`", "committedDate": "2020-09-09T23:12:00Z", "type": "commit"}, {"oid": "f8041c0e0226a1ca53725106358f203624ab078a", "url": "https://github.com/apple/servicetalk/commit/f8041c0e0226a1ca53725106358f203624ab078a", "message": "Remove leftover Thread.dumpStack()", "committedDate": "2020-09-09T23:12:16Z", "type": "commit"}, {"oid": "72c7d110fcd833bfb3851c5d207b627c0801b310", "url": "https://github.com/apple/servicetalk/commit/72c7d110fcd833bfb3851c5d207b627c0801b310", "message": "RequestResponseCloseHandlerTest: use IS event instead of implicit invocation of h.channelClosedInbound", "committedDate": "2020-09-10T18:53:03Z", "type": "commit"}, {"oid": "7e1a5b26670c2ee4ddec82f5ed5745ce3c5fb14e", "url": "https://github.com/apple/servicetalk/commit/7e1a5b26670c2ee4ddec82f5ed5745ce3c5fb14e", "message": "Add tests to verify that read cancellation does not break graceful server shutdown", "committedDate": "2020-09-10T18:54:26Z", "type": "commit"}, {"oid": "836df80c0b28dcff25cd9c2640931ac29427645c", "url": "https://github.com/apple/servicetalk/commit/836df80c0b28dcff25cd9c2640931ac29427645c", "message": "Revert \"Use `pending == MAX_VALUE` instead of `CLOSING_SERVER_GRACEFULLY`\"\n\nThis reverts commit da9727cc3bc3e2897e89eb27a2b254cdd8b6db30.", "committedDate": "2020-09-10T20:29:11Z", "type": "commit"}, {"oid": "4b789912c8411893ee580c7e2150081ffee36815", "url": "https://github.com/apple/servicetalk/commit/4b789912c8411893ee580c7e2150081ffee36815", "message": "Fire UserEvent instead of registering a handler to discard inbound", "committedDate": "2020-09-10T22:20:29Z", "type": "commit"}, {"oid": "347624b97ca711e19ec7b19522bfe4f284e0e0cd", "url": "https://github.com/apple/servicetalk/commit/347624b97ca711e19ec7b19522bfe4f284e0e0cd", "message": "Implement toString for all `NettyUserEvent`s", "committedDate": "2020-09-14T17:06:24Z", "type": "commit"}, {"oid": "5c5b41c32b1f9dd3947bd44042f2f810e0698188", "url": "https://github.com/apple/servicetalk/commit/5c5b41c32b1f9dd3947bd44042f2f810e0698188", "message": "Do not abort server write if connection is in closing state\n\nServer may register a write after HttpRequestDecoder is already processed\nthe request with \"Connection: close\" header. As the result, server can not\nrespond if the write is aborted.", "committedDate": "2020-09-14T17:06:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5MjM5Nw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r488092397", "bodyText": "@NiteshKant upgrade to TLSv1.3 (client starts writing data earlier than server completes the handshake) helped to discover this issue, resulting in a lot of failed tests: https://ci.servicetalk.io/job/servicetalk-java11-prb/1521/\nMy fix isn't great: 5c5b41c. Open for suggestions.", "author": "idelpivnitskiy", "createdAt": "2020-09-14T17:09:53Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -470,10 +474,10 @@ private boolean failIfWriteActive(ChannelOutboundListener newChannelOutboundList\n             // It is possible that we have set the writeSubscriber, then the channel becomes inactive, and we will\n             // never notify the write writeSubscriber of the inactive event. So if the channel is inactive we notify\n             // the writeSubscriber.\n-            // It is also possible that Channel is in closing state, we should abort new writes if a closeReason was\n-            // observed:\n+            // It is also possible that Channel is in closing state, we should abort new writes from the client-side\n+            // if a closeReason was observed:\n             CloseEvent closeReason = null;\n-            if (!channel().isActive() || (closeReason = this.closeReason) != null) {\n+            if (!channel().isActive() || (isClient && (closeReason = this.closeReason) != null)) {", "originalCommit": "5c5b41c32b1f9dd3947bd44042f2f810e0698188", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "74744a3fa081d7040442e6ced07945b68dec3691", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java\nindex 2297ab5c0..4d1b0c035 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java\n\n@@ -474,10 +470,10 @@ public final class DefaultNettyConnection<Read, Write> extends NettyChannelListe\n             // It is possible that we have set the writeSubscriber, then the channel becomes inactive, and we will\n             // never notify the write writeSubscriber of the inactive event. So if the channel is inactive we notify\n             // the writeSubscriber.\n-            // It is also possible that Channel is in closing state, we should abort new writes from the client-side\n-            // if a closeReason was observed:\n+            // It is also possible that Channel is in closing state, we should abort new writes if a closeReason was\n+            // observed:\n             CloseEvent closeReason = null;\n-            if (!channel().isActive() || (isClient && (closeReason = this.closeReason) != null)) {\n+            if (!channel().isActive() || (closeReason = this.closeReason) != null) {\n                 final StacklessClosedChannelException e = StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"failIfWriteActive(...)\");\n                 newChannelOutboundListener.channelClosed(closeReason == null ? e : closeReason.wrapError(e, channel()));\n"}}, {"oid": "58f8e66af5f4e5fd10cd8a96d5b2a712b5960732", "url": "https://github.com/apple/servicetalk/commit/58f8e66af5f4e5fd10cd8a96d5b2a712b5960732", "message": "Merge remote-tracking branch 'upstream/main' into server-graceful-closure", "committedDate": "2020-09-14T18:40:11Z", "type": "commit"}, {"oid": "68818055eff2f7a23f89f5b559e4e77898a7f585", "url": "https://github.com/apple/servicetalk/commit/68818055eff2f7a23f89f5b559e4e77898a7f585", "message": "ProxyTunnel: flush all written data before closing streams", "committedDate": "2020-09-14T21:55:07Z", "type": "commit"}, {"oid": "93acb441fedbd3e99ee564e2beceb74458f01b28", "url": "https://github.com/apple/servicetalk/commit/93acb441fedbd3e99ee564e2beceb74458f01b28", "message": "Use TLSv1.2", "committedDate": "2020-09-16T01:57:07Z", "type": "commit"}, {"oid": "f042f0aac3c71776f26a44444b935d124abfde27", "url": "https://github.com/apple/servicetalk/commit/f042f0aac3c71776f26a44444b935d124abfde27", "message": "Revert \"Use TLSv1.2\"\n\nThis reverts commit 93acb441", "committedDate": "2020-09-17T22:53:00Z", "type": "commit"}, {"oid": "e7f861c71e0574c30ff438eee26fc90c474ead11", "url": "https://github.com/apple/servicetalk/commit/e7f861c71e0574c30ff438eee26fc90c474ead11", "message": "Improve test: closePipelinedAfterTwoRequestsSentBeforeAnyResponseReceived", "committedDate": "2020-09-17T22:53:43Z", "type": "commit"}, {"oid": "74744a3fa081d7040442e6ced07945b68dec3691", "url": "https://github.com/apple/servicetalk/commit/74744a3fa081d7040442e6ced07945b68dec3691", "message": "Revert \"Do not abort server write if connection is in closing state\"\n\nThis reverts commit 5c5b41c3", "committedDate": "2020-09-18T06:07:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTM0Mg==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491231342", "bodyText": "Is this really required?", "author": "NiteshKant", "createdAt": "2020-09-18T23:14:15Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -342,10 +344,18 @@ public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n         }\n     }\n \n+    private abstract static class NettyUserEvent {\n+\n+        @Override\n+        public String toString() {", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjE4NA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146184", "bodyText": "Not a strong requirement, but makes logs a bit nicer by removing random numbers at the end of these events.", "author": "idelpivnitskiy", "createdAt": "2020-09-25T17:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f0374173a8cb34134abec81b5f3f274b40d3f50b", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java\nindex 6306fbb73..613c1bbee 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java\n\n@@ -353,15 +353,15 @@ public abstract class CloseHandler {\n     }\n \n     /**\n-     * Netty UserEvent to indicate the end of a payload was observed at the transport.\n+     * Netty UserEvent to indicate the end of a outbound data was observed at the transport.\n      */\n-    static final class ProtocolPayloadEndEvent extends NettyUserEvent {\n+    static final class OutboundDataEndEvent extends NettyUserEvent {\n         /**\n-         * Netty UserEvent instance to indicate an outbound end of payload.\n+         * Netty UserEvent instance to indicate an outbound end of data.\n          */\n-        static final ProtocolPayloadEndEvent OUTBOUND = new ProtocolPayloadEndEvent();\n+        static final OutboundDataEndEvent INSTANCE = new OutboundDataEndEvent();\n \n-        private ProtocolPayloadEndEvent() {\n+        private OutboundDataEndEvent() {\n             // No instances.\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491232147", "bodyText": "I don't think we should depend on ordering between listener invocation and subscriber termination. Can you explain more what is the issue here and why was it not evident before?", "author": "NiteshKant", "createdAt": "2020-09-18T23:18:16Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -487,6 +486,9 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n                     ChannelCloseUtils.close(channel, cause);\n                 }\n             }\n+            // Notify listeners after the subscriber is terminated. Otherwise, WriteStreamSubscriber#channelClosed may", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjIxNg==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146216", "bodyText": "If we invoke listeners before the write is complete, it will trigger protocolPayloadEndOutboundSuccess that initiates connection closure before the write is complete. As the result, the pipeline will see ChannelOutputShutdownEvent and trigger WSS#channelClosed changing the terminal signal from onComplete to onError.\nCloseHandler does not know about the state of WSS to defer closure until the write is complete.", "author": "idelpivnitskiy", "createdAt": "2020-09-25T17:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4OTA5MA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496089090", "bodyText": "Netty invokes listeners after it processes the completion of the promise. I think we should do the same and first complete the subscriber, then notify listeners.", "author": "idelpivnitskiy", "createdAt": "2020-09-28T16:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491233838", "bodyText": "I am not convinced this is doing anything useful since we are following first writer-wins with events that can be concurrent and are sequenced through the event loop queue.\nIf this isn't really required for this change, i would prefer considering as a followup", "author": "NiteshKant", "createdAt": "2020-09-18T23:26:36Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -73,13 +78,21 @@\n      */\n     private int pending;\n \n+    /**\n+     * Original {@link CloseEvent} that initiated closing.\n+     */\n+    @Nullable\n+    private CloseEvent event;", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjI0OA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146248", "bodyText": "We currently have a similar problem in DefaultNettyConnection. The first close event wins.\nThis is required to understand later how should we close the connection: gracefully or not. Without storing the original reason we can not make a correct decision at the time when we are ready to close.", "author": "idelpivnitskiy", "createdAt": "2020-09-25T17:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4ODIwMQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496088201", "bodyText": "I created a diagram that tells when the state has to be updated. For this PR, it's ok to leave it as-is. In a follow-up PR, to improve understanding of the connection closure, I will add a logic that updates the event here shares it with DefaultNettyConnection.", "author": "idelpivnitskiy", "createdAt": "2020-09-28T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA=="}], "type": "inlineReview", "revised_code": {"commit": "d1398c1975da6321524d20c009a4bf65663ac3a3", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex 960113af2..b596a8b5e 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -82,17 +81,16 @@ class RequestResponseCloseHandler extends CloseHandler {\n      * Original {@link CloseEvent} that initiated closing.\n      */\n     @Nullable\n-    private CloseEvent event;\n+    private CloseEvent closeEvent;\n \n     protected interface State {\n         byte READ = 0x01;\n         byte WRITE = 0x02;\n-        byte CLOSING = 0x04;\n-        byte IN_CLOSED = 0x08;\n-        byte OUT_CLOSED = 0x10;\n-        byte CLOSED = 0x20;\n-        byte DISCARDING_SERVER_INPUT = 0x40;\n-        byte CLOSING_SERVER_GRACEFULLY = (byte) 0x80;\n+        byte DISCARDING_SERVER_INPUT = 0x04;\n+        byte CLOSING_SERVER_GRACEFULLY = 0x08;\n+        byte IN_CLOSED = 0x10;\n+        byte OUT_CLOSED = 0x20;\n+        byte CLOSED = 0x40;\n \n         byte ALL_CLOSED = CLOSED | IN_CLOSED | OUT_CLOSED;\n         byte IN_OUT_CLOSED = IN_CLOSED | OUT_CLOSED;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNTIzNw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491235237", "bodyText": "Did you mean to use evt here instead of event as the callers of this method are reading event?", "author": "NiteshKant", "createdAt": "2020-09-18T23:33:53Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d279c699920281d76a7d8b27ab0e12759b7d7d9c", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex 960113af2..a93be62fd 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -272,7 +272,7 @@ class RequestResponseCloseHandler extends CloseHandler {\n                                                      final boolean endInbound) {\n \n         if (idle(pending, state)) {\n-            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {\n+            if (isClient || has(state, IN_CLOSED) || (evt != USER_CLOSING && evt != PROTOCOL_CLOSING_OUTBOUND)) {\n                 closeChannel(channel, evt);\n             } else {\n                 serverCloseGracefully(channel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491241169", "bodyText": "I am concerned about splitting the state b/w state and event. Can we set SERVER_CLOSING_GRACEFULLY upfront so that we do not have to rely on event here?", "author": "NiteshKant", "createdAt": "2020-09-19T00:10:04Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjI3OA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146278", "bodyText": "SERVER_CLOSING_GRACEFULLY used by logic that handles shutdown events and the requirement there is to set this flag only when we shutdown outbound gracefully. I will need another flag if I can not use evt.\nHere we use the originated reason for closure to decide if we need to close gracefully or not.", "author": "idelpivnitskiy", "createdAt": "2020-09-25T17:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NzAyNA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496087024", "bodyText": "After investigating it more, I'm actually planning to do the opposite. The CLOSING state is not useful in many cases as it does not tell the reason for the closure. I plan to remove CLOSING and use event != null instead of has(state, CLOSING). In some cases, like this one, the event matters.", "author": "idelpivnitskiy", "createdAt": "2020-09-28T16:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d279c699920281d76a7d8b27ab0e12759b7d7d9c", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex 960113af2..a93be62fd 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -272,7 +272,7 @@ class RequestResponseCloseHandler extends CloseHandler {\n                                                      final boolean endInbound) {\n \n         if (idle(pending, state)) {\n-            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {\n+            if (isClient || has(state, IN_CLOSED) || (evt != USER_CLOSING && evt != PROTOCOL_CLOSING_OUTBOUND)) {\n                 closeChannel(channel, evt);\n             } else {\n                 serverCloseGracefully(channel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTQzMg==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491241432", "bodyText": "Can we move this to the receiver of the discard event?", "author": "NiteshKant", "createdAt": "2020-09-19T00:11:56Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -360,12 +406,50 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            channel.config().setAutoRead(true);", "originalCommit": "74744a3fa081d7040442e6ced07945b68dec3691", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d279c699920281d76a7d8b27ab0e12759b7d7d9c", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex 960113af2..a93be62fd 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -420,7 +420,6 @@ class RequestResponseCloseHandler extends CloseHandler {\n             LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n             channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n-            channel.config().setAutoRead(true);\n             state = set(state, DISCARDING_SERVER_INPUT);\n         }\n     }\n"}}, {"oid": "d279c699920281d76a7d8b27ab0e12759b7d7d9c", "url": "https://github.com/apple/servicetalk/commit/d279c699920281d76a7d8b27ab0e12759b7d7d9c", "message": "Address comments", "committedDate": "2020-09-25T17:58:16Z", "type": "commit"}, {"oid": "fd62e331642abd39d3ddc82d9b81a4badc19f928", "url": "https://github.com/apple/servicetalk/commit/fd62e331642abd39d3ddc82d9b81a4badc19f928", "message": "Revert changes for ConnectionCloseHeaderHandlingTest", "committedDate": "2020-09-29T21:31:08Z", "type": "commit"}, {"oid": "f8a7af41b30ca564824dec45e900cb3f74d62b76", "url": "https://github.com/apple/servicetalk/commit/f8a7af41b30ca564824dec45e900cb3f74d62b76", "message": "Use TLSv1.2 to workaround #1156", "committedDate": "2020-09-29T21:34:58Z", "type": "commit"}, {"oid": "d1398c1975da6321524d20c009a4bf65663ac3a3", "url": "https://github.com/apple/servicetalk/commit/d1398c1975da6321524d20c009a4bf65663ac3a3", "message": "Use `closeEvent` instead of `CLOSING` state", "committedDate": "2020-09-29T21:41:14Z", "type": "commit"}, {"oid": "f0374173a8cb34134abec81b5f3f274b40d3f50b", "url": "https://github.com/apple/servicetalk/commit/f0374173a8cb34134abec81b5f3f274b40d3f50b", "message": "Merge remote-tracking branch 'upstream/main' into server-graceful-closure", "committedDate": "2020-10-01T20:01:19Z", "type": "commit"}, {"oid": "5165f290564dc1097ec0baf7459c13a67a096322", "url": "https://github.com/apple/servicetalk/commit/5165f290564dc1097ec0baf7459c13a67a096322", "message": "Fix checkstyle error", "committedDate": "2020-10-02T04:53:15Z", "type": "commit"}, {"oid": "f8c89080ef4c02adff433c23aa5400d842984f9d", "url": "https://github.com/apple/servicetalk/commit/f8c89080ef4c02adff433c23aa5400d842984f9d", "message": "Support EmbeddedChannel in RequestResponseCloseHandler", "committedDate": "2020-10-02T05:00:00Z", "type": "commit"}, {"oid": "bdcbf76c73225a65bc95e2d9033e233c9df7d527", "url": "https://github.com/apple/servicetalk/commit/bdcbf76c73225a65bc95e2d9033e233c9df7d527", "message": "Revert \"Support EmbeddedChannel in RequestResponseCloseHandler\"\n\nThis reverts commit f8c89080", "committedDate": "2020-10-02T17:19:59Z", "type": "commit"}, {"oid": "7fc99310622dc52e80b54a7588629477980336dd", "url": "https://github.com/apple/servicetalk/commit/7fc99310622dc52e80b54a7588629477980336dd", "message": "Add tests for graceful closure when UDS is used", "committedDate": "2020-10-02T18:02:55Z", "type": "commit"}, {"oid": "001f052c113ed9cebcddc0ab5e1810ea74a349bd", "url": "https://github.com/apple/servicetalk/commit/001f052c113ed9cebcddc0ab5e1810ea74a349bd", "message": "Merge remote-tracking branch 'upstream/main' into server-graceful-closure", "committedDate": "2020-10-08T22:16:45Z", "type": "commit"}, {"oid": "c9f42fcf95d4e5e9fdb91bc73538f6aa8fd5c8e8", "url": "https://github.com/apple/servicetalk/commit/c9f42fcf95d4e5e9fdb91bc73538f6aa8fd5c8e8", "message": "fix import", "committedDate": "2020-10-08T22:18:34Z", "type": "commit"}, {"oid": "f1009715bb4e68bed0284499e1ce24e2caac4214", "url": "https://github.com/apple/servicetalk/commit/f1009715bb4e68bed0284499e1ce24e2caac4214", "message": "Simulate FIN from the client in ServerRespondsOnClosingTest", "committedDate": "2020-10-08T23:42:33Z", "type": "commit"}, {"oid": "44a15527b6a2e9befa64ca2c68c4f177e6cfa69e", "url": "https://github.com/apple/servicetalk/commit/44a15527b6a2e9befa64ca2c68c4f177e6cfa69e", "message": "Test that server discards further requests while it is in graceful closure state", "committedDate": "2020-10-09T00:04:56Z", "type": "commit"}, {"oid": "a0e9ec7f110853308c6cff9a2a9289ece7945fe0", "url": "https://github.com/apple/servicetalk/commit/a0e9ec7f110853308c6cff9a2a9289ece7945fe0", "message": "Merge remote-tracking branch 'upstream/main' into server-graceful-closure", "committedDate": "2020-10-09T00:28:09Z", "type": "commit"}, {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6", "url": "https://github.com/apple/servicetalk/commit/71a312d5741d1bc74214a3736893dc0d494a62b6", "message": "Ignore flushes without written objects in `OutboundWriteEventsInterceptor`", "committedDate": "2020-10-09T21:19:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502662055", "bodyText": "do we have to expose this method? ByteToMessageDecoder should clean up the cumulation when it is removed from the pipeline, not clear why we need to explicitly call this method.", "author": "Scottmitch", "createdAt": "2020-10-09T20:42:22Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "diffHunk": "@@ -242,7 +242,7 @@ protected ByteBuf swapAndCopyCumulation(final ByteBuf cumulation, final ByteBuf\n     protected void cumulationReset() {\n     }\n \n-    private void releaseCumulation() {\n+    protected final void releaseCumulation() {", "originalCommit": "a0e9ec7f110853308c6cff9a2a9289ece7945fe0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzg2OQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502727869", "bodyText": "It may have some data in the cumulation buffer. On handlerRemoved event it will fire those pending data through the pipeline. By releasing it manually, we can avoid seeing more data.", "author": "idelpivnitskiy", "createdAt": "2020-10-10T01:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4MDg2OQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503680869", "bodyText": "@Scottmitch you were right, when we do replace, netty first adds a new handler after the current one and then removes the existing handler. Therefore, even if we had something in the accumulation buffer, it will be discarded by the new handler. So, we can avoid exposing releaseCumulation() \ud83c\udf89", "author": "idelpivnitskiy", "createdAt": "2020-10-13T05:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "edb01eb2ac2de6e372c113ebef3f07aff4ff632f", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java\nindex 9844605a2..4e0fcdf47 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java\n\n@@ -242,7 +242,7 @@ public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter\n     protected void cumulationReset() {\n     }\n \n-    protected final void releaseCumulation() {\n+    private void releaseCumulation() {\n         if (cumulation != null) {\n             cumulation.release();\n             cumulation = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502683580", "bodyText": "reminder @normanmaurer: we should fix half closure in Netty so actions go through the pipeline instead of the channel bypassing handlers.", "author": "Scottmitch", "createdAt": "2020-10-09T21:43:11Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            state = set(state, DISCARDING_SERVER_INPUT);\n+        }\n+    }\n+\n+    private void serverHalfCloseOutbound(final Channel channel) {\n+        assert !isClient && idle(pending, state);\n+        if (!has(state, OUT_CLOSED)) {\n+            state = set(state, CLOSING_SERVER_GRACEFULLY);\n+            LOGGER.debug(\"{} Half-Closing OUTBOUND\", channel);\n+            halfCloseOutbound(channel, false);\n+            // Final channel.close() will happen when FIN (ChannelInputShutdownReadComplete) is received\n+        }\n+    }\n+\n+    private void halfCloseOutbound(final Channel channel, final boolean registerOnHalfClosed) {\n+        SslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+        if (sslHandler != null) {\n+            // send close_notify: https://tools.ietf.org/html/rfc5246#section-7.2.1\n+            sslHandler.closeOutbound().addListener(f -> {", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzg4NQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502727885", "bodyText": "There is also ChannelOutputShutdownEvent fired through the pipeline. Can you please clarify what event we need in addition to that?", "author": "idelpivnitskiy", "createdAt": "2020-10-10T01:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTg3MA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503585870", "bodyText": "Half closure is an example that bypasses the pipeline (due to organically added support over time). Some handlers would like to participate in state machine of channels (channel initialization/active/open/handshake/wrtiability/queuing/etc.), but in some cases the channel doesn't propagate the events through the pipeline. So for example in this case we have to reach into the pipeline and invoke a specific handler in order to cleanup \"correctly\". Ideally the events can flow through the pipeline so handlers can intercept/interpret these events as necessary.", "author": "Scottmitch", "createdAt": "2020-10-12T23:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTIzNA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503595234", "bodyText": "I see. Agreed, some other event prior the output shutdown will be useful for SslHandler to intercept it and emit close_nofity.", "author": "idelpivnitskiy", "createdAt": "2020-10-13T00:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "0e94687f1ecb43020fd922e47d4fc36023264a06", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex b6f8e62e4..a87ccc6ed 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -408,8 +409,12 @@ class RequestResponseCloseHandler extends CloseHandler {\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n         if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n-            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n-            // keep reading to receive FIN from the remote peer.\n+            // Instead of actual half-closure via DuplexChannel.shutdownInput() we request the pipeline to discard all\n+            // further inbound data until the FIN is received. Incoming FIN from the client-side\n+            // (ChannelInputShutdownReadComplete event) notifies server that client received the last response and is\n+            // also closing the connection. Therefore, we can complete graceful closure and close server's connection.\n+            // DuplexChannel.shutdownInput() silently discards all incoming data at OS level and does not notify netty\n+            // when the FIN is received.\n             LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n             channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502707194", "bodyText": "we lose the ability to apply back pressure at this point. which may lead to a surprising \"attack\" vector from the user perspective. Consider adding a comment and reference to s6.6 (client writes before it receives FIN, server responds with RST, client TCP stack doesn't deliver buffered data when RST received).\nDid you explore alternative approaches (e.g. not read at all)? Even if we don't ask to read data for the native transports Netty will read/drain if a FIN/RST is received (via RDHUP), which means we will pickup on the FIN/RST as soon as it is delivered (assuming it is delivered). However if the client has more data to send than can be queued in its sendbuf (or that can fit in the server recvbuf) then the server won't see the FIN_ACK from the client until reading/draining data. However maybe this isn't a problem as if the client continues to read (which is expected) it will eventually see the server's close and should stop trying to write.", "author": "Scottmitch", "createdAt": "2020-10-09T23:08:41Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -502,6 +505,12 @@ public final void userEventTriggered(final ChannelHandlerContext ctx, final Obje\n                 default:\n                     break;\n             }\n+        } else if (evt instanceof DiscardFurtherInboundEvent) {\n+            resetNow();\n+            releaseCumulation();\n+            ctx.pipeline().replace(HttpObjectDecoder.this, DiscardInboundHandler.INSTANCE.toString(),\n+                    DiscardInboundHandler.INSTANCE);\n+            ctx.channel().config().setAutoRead(true);", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODE4Nw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728187", "bodyText": "Hmm, interesting idea. I thought that we have to keep reading data from the channel to receive FIN in all cases, even if recvbuf is not full. What will happen on the pipeline if we do not request read() anymore but then native transport observes FIN? IIUC, AbstractEpollChannel will never fire ChannelInputShutdownReadComplete if we do not request to read, but we depend on this event in DefaultNettyConnection. Also, will the behavior change with Java NIO transport?\nThe shutdownInput() also discards all new arriving data without applying backpressure. The only difference is that we will never see FIN if we invoke shutdownInput() manually, that's why I have to implement /dev/null handler. And it looks like a safer option, without relying on native transport behavior (RDHUP).", "author": "idelpivnitskiy", "createdAt": "2020-10-10T01:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NTg3NA==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503685874", "bodyText": "Discussed offline: OS behaves in a similar way after shutdownInput(). Will keep the existing approach for now.", "author": "idelpivnitskiy", "createdAt": "2020-10-13T06:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA=="}], "type": "inlineReview", "revised_code": {"commit": "edb01eb2ac2de6e372c113ebef3f07aff4ff632f", "chunk": "diff --git a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java\nindex 57f02351a..504d7edc4 100644\n--- a/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java\n+++ b/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java\n\n@@ -507,7 +507,6 @@ abstract class HttpObjectDecoder<T extends HttpMetaData> extends ByteToMessageDe\n             }\n         } else if (evt instanceof DiscardFurtherInboundEvent) {\n             resetNow();\n-            releaseCumulation();\n             ctx.pipeline().replace(HttpObjectDecoder.this, DiscardInboundHandler.INSTANCE.toString(),\n                     DiscardInboundHandler.INSTANCE);\n             ctx.channel().config().setAutoRead(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwOTE5NQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502709195", "bodyText": "can you remove the \"keep reading\" point here in case we do something different? Consider describing the problem with shutdownInput() (e.g. client send data, server rst, client sees rst and discards read queue) and that the protocol can handle the closure more gracefully.", "author": "Scottmitch", "createdAt": "2020-10-09T23:18:07Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0e94687f1ecb43020fd922e47d4fc36023264a06", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex b6f8e62e4..a87ccc6ed 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -408,8 +409,12 @@ class RequestResponseCloseHandler extends CloseHandler {\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n         if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n-            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n-            // keep reading to receive FIN from the remote peer.\n+            // Instead of actual half-closure via DuplexChannel.shutdownInput() we request the pipeline to discard all\n+            // further inbound data until the FIN is received. Incoming FIN from the client-side\n+            // (ChannelInputShutdownReadComplete event) notifies server that client received the last response and is\n+            // also closing the connection. Therefore, we can complete graceful closure and close server's connection.\n+            // DuplexChannel.shutdownInput() silently discards all incoming data at OS level and does not notify netty\n+            // when the FIN is received.\n             LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n             channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDA3Mw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502710073", "bodyText": "USER_CLOSING -> can you plz rename this (and userClosingmethod) to include graceful? not introduced by this PR but it is confusing when the concepts are mixed together.", "author": "Scottmitch", "createdAt": "2020-10-09T23:22:32Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -235,21 +261,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (evt != USER_CLOSING && evt != PROTOCOL_CLOSING_OUTBOUND)) {", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d21abfa75b033e939995ba73de4b2084e917a15", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex b6f8e62e4..743ce9e90 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -253,10 +253,10 @@ class RequestResponseCloseHandler extends CloseHandler {\n     }\n \n     @Override\n-    void userClosing(final Channel channel) {\n+    void gracefulUserClosing(final Channel channel) {\n         assert channel.eventLoop().inEventLoop();\n-        storeCloseRequestAndEmit(USER_CLOSING);\n-        maybeCloseChannelHalfOrFullyOnClosing(channel, USER_CLOSING);\n+        storeCloseRequestAndEmit(GRACEFUL_USER_CLOSING);\n+        maybeCloseChannelHalfOrFullyOnClosing(channel, GRACEFUL_USER_CLOSING);\n     }\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjIwMw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502712203", "bodyText": "consider renaming to avoid \"discard\" because we are assuming what action will be taken as a result of this event but don't control what is being done.\nDISCARDING_SERVER_INPUT -> IN_SHUTDOWN\nDiscardFurtherInboundEvent -> GracefulInputShutdownEvent", "author": "Scottmitch", "createdAt": "2020-10-09T23:33:04Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODIwNQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728205", "bodyText": "IN_SHUTDOWN may be a bit misleading, because it actually is not shutdown. IN_CLOSED is set when the input is shutdown.\nThe discard of input happens not only for graceful closure but also for other events, like protocol closing inbound/outbound, when we are not expecting more requests. Named it DiscardFurtherInboundEvent because it's kind of a request to discard without saying how exactly it should be discarded.\nHappy to rename, just looking for better alternatives...", "author": "idelpivnitskiy", "createdAt": "2020-10-10T01:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "0e94687f1ecb43020fd922e47d4fc36023264a06", "chunk": "diff --git a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\nindex b6f8e62e4..a87ccc6ed 100644\n--- a/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n+++ b/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java\n\n@@ -408,8 +409,12 @@ class RequestResponseCloseHandler extends CloseHandler {\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n         if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n-            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n-            // keep reading to receive FIN from the remote peer.\n+            // Instead of actual half-closure via DuplexChannel.shutdownInput() we request the pipeline to discard all\n+            // further inbound data until the FIN is received. Incoming FIN from the client-side\n+            // (ChannelInputShutdownReadComplete event) notifies server that client received the last response and is\n+            // also closing the connection. Therefore, we can complete graceful closure and close server's connection.\n+            // DuplexChannel.shutdownInput() silently discards all incoming data at OS level and does not notify netty\n+            // when the FIN is received.\n             LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n             channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNzAyNw==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502717027", "bodyText": "not introduced by this PR but the control flow here is somewhat confusing. This method is called before the trailers are actually written, and eventually goes to WriteStreamSubscriber#channelOutboundClosed which calls sourceTerminated, which will complete the promise if activeWrites==0 but since we haven't written yet I assume that is never possible?", "author": "Scottmitch", "createdAt": "2020-10-10T00:00:30Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -162,7 +179,7 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n-        if (isClient || (has(state, CLOSING) && pending == 0)) {\n+        if (isClient || (closeEvent != null && pending == 0)) {\n             ctx.pipeline().fireUserEventTriggered(OutboundDataEndEvent.INSTANCE);", "originalCommit": "71a312d5741d1bc74214a3736893dc0d494a62b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODIwOQ==", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728209", "bodyText": "Agreed, the flow here is confusing. It was originally introduced in #919 and later improved (there was a bug) in #1155, according to the original logic from #919.\nIIUC this was done specifically for h2. The event is emitted before write, because netty closes the stream in write listener. But not sure if it need to be done in the same way for h1. I had an idea of how to simplify it by merging protocolPayloadEndOutbound and protocolPayloadEndOutboundSuccess together. Implementations of CloseHandler for h1 and h2 are anyway different. But did not have time to experiment. Decided to stop introducing more concurrent PRs for the same part of the codebase.", "author": "idelpivnitskiy", "createdAt": "2020-10-10T01:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNzAyNw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "4a9085749af6f47a0ec48fdb95475177355dd432", "url": "https://github.com/apple/servicetalk/commit/4a9085749af6f47a0ec48fdb95475177355dd432", "message": "Test that PROTOCOL_CLOSING_OUTBOUND closes the connection even if it's already in USER_CLOSING state and more pipelined requests pending", "committedDate": "2020-10-10T00:43:08Z", "type": "commit"}, {"oid": "6d21abfa75b033e939995ba73de4b2084e917a15", "url": "https://github.com/apple/servicetalk/commit/6d21abfa75b033e939995ba73de4b2084e917a15", "message": "Rename USER_CLOSING -> GRACEFUL_USER_CLOSING", "committedDate": "2020-10-10T01:34:27Z", "type": "commit"}, {"oid": "77b90fec4b9381f1567eaea6d096647fb13147fb", "url": "https://github.com/apple/servicetalk/commit/77b90fec4b9381f1567eaea6d096647fb13147fb", "message": "Fix compilation error after rename", "committedDate": "2020-10-12T22:10:03Z", "type": "commit"}, {"oid": "db4afd96734df734ff7ca995ab1ed070b4748510", "url": "https://github.com/apple/servicetalk/commit/db4afd96734df734ff7ca995ab1ed070b4748510", "message": "fix checkstyle", "committedDate": "2020-10-12T22:39:01Z", "type": "commit"}, {"oid": "0b5274be43f6cd317e0c04cd4863d36a56000f7c", "url": "https://github.com/apple/servicetalk/commit/0b5274be43f6cd317e0c04cd4863d36a56000f7c", "message": "Do not use offloading in ServerRespondsOnClosingTest", "committedDate": "2020-10-13T04:47:05Z", "type": "commit"}, {"oid": "24a06d1d735bd6030dfa776994e45f9319d454bc", "url": "https://github.com/apple/servicetalk/commit/24a06d1d735bd6030dfa776994e45f9319d454bc", "message": "RequestResponseCloseHandlerTest: rename UCO -> GUC", "committedDate": "2020-10-13T05:08:26Z", "type": "commit"}, {"oid": "edb01eb2ac2de6e372c113ebef3f07aff4ff632f", "url": "https://github.com/apple/servicetalk/commit/edb01eb2ac2de6e372c113ebef3f07aff4ff632f", "message": "Do not expose ByteToMessageDecoder#releaseCumulation()", "committedDate": "2020-10-13T05:43:11Z", "type": "commit"}, {"oid": "3d5bfdc24a80a6c7558cb587b4f05ba4c72a77bb", "url": "https://github.com/apple/servicetalk/commit/3d5bfdc24a80a6c7558cb587b4f05ba4c72a77bb", "message": "fix checkstyle", "committedDate": "2020-10-13T05:44:39Z", "type": "commit"}, {"oid": "0e94687f1ecb43020fd922e47d4fc36023264a06", "url": "https://github.com/apple/servicetalk/commit/0e94687f1ecb43020fd922e47d4fc36023264a06", "message": "Clarify comment for RequestResponseCloseHandler#serverHalfCloseInbound", "committedDate": "2020-10-13T05:59:57Z", "type": "commit"}]}