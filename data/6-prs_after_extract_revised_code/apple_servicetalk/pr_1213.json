{"pr_number": 1213, "pr_title": "Fix transformed aggregated requests with missing trailers", "pr_createdAt": "2020-11-16T17:04:31Z", "pr_url": "https://github.com/apple/servicetalk/pull/1213", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMDgyMA==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r524430820", "bodyText": "Append trailers when the result of the reduction is a list of items.\nTrailers should not be here, reasoning:\n\nWhen trailers exist according to spec, the transfer encoding should be chunked\nWhen the payload 'mayHaveTrailers==true' this flow is avoided\nThe calculateContentLength(item) method already checks instance type and throws exception if not buffer.", "author": "tkountis", "createdAt": "2020-11-16T17:08:48Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -182,10 +183,12 @@ private static void updateResponseContentLength(final int contentLength, final H\n                 flatRequest = from(metadata, EmptyHttpHeaders.INSTANCE);\n             } else if (reduction instanceof List) {\n                 final List<?> items = (List<?>) reduction;\n-                for (int i = 0; i < items.size(); i++) {\n-                    contentLength += calculateContentLength(items.get(i));\n+                for (Object item : items) {\n+                    contentLength += calculateContentLength(item);\n                 }\n-                flatRequest = Publisher.<Object>from(metadata).concat(fromIterable(items));\n+                flatRequest = Publisher.<Object>from(metadata)\n+                        .concat(fromIterable(items))\n+                        .concat(succeeded(EmptyHttpHeaders.INSTANCE));", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMjQyMg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r524432422", "bodyText": "When a request/response is transformed then we have no info of the new payload, thus we revert safe-to-aggregate back to false.", "author": "tkountis", "createdAt": "2020-11-16T17:10:14Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java", "diffHunk": "@@ -222,6 +223,9 @@ private void updatePayloadBody(Publisher<Buffer> newPayload, boolean isTransform\n                 // payloadBody() will split trailers if not yet split\n                 newPayload.liftSync(new BridgeFlowControlAndDiscardOperator(payloadBody()));\n         payloadInfo.setOnlyEmitsBuffer(true);\n+        if (isTransform) {\n+            payloadInfo.setSafeToAggregate(false);", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTY3Mw==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525535673", "bodyText": "Discussed offline: users of aggregated API usually assume that the payload body always fits in memory. Transform functions are usually used for logging/metrics/decoration. If they have a use-case when transformation changes the size significantly, they have to handle it using streaming API.", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzMjQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "chunk": "diff --git a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java\nindex 9df2ccad9..375a5d98f 100644\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpPayloadHolder.java\n\n@@ -223,9 +222,6 @@ final class StreamingHttpPayloadHolder implements PayloadInfo {\n                 // payloadBody() will split trailers if not yet split\n                 newPayload.liftSync(new BridgeFlowControlAndDiscardOperator(payloadBody()));\n         payloadInfo.setOnlyEmitsBuffer(true);\n-        if (isTransform) {\n-            payloadInfo.setSafeToAggregate(false);\n-        }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDIyMg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525534222", "bodyText": "Instead of adding a new test class, consider enhancing the existing one:\nIndex: servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(revision a2c12893734841eea9c18d033884cccf944f7624)\n+++ servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentLengthTest.java\t(date 1605648191399)\n@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,10 +15,13 @@\n  */\n package io.servicetalk.http.netty;\n \n+import io.servicetalk.buffer.api.Buffer;\n import io.servicetalk.concurrent.api.Publisher;\n import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.HttpHeaders;\n import io.servicetalk.http.api.HttpMetaData;\n import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpRequestMethod;\n import io.servicetalk.http.api.HttpResponse;\n import io.servicetalk.http.api.StreamingHttpRequest;\n import io.servicetalk.http.api.StreamingHttpRequests;\n@@ -28,23 +31,34 @@\n import org.junit.Test;\n \n import java.util.Collection;\n+import java.util.Iterator;\n \n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.CONNECT;\n+import static io.servicetalk.http.api.HttpRequestMethod.DELETE;\n import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpRequestMethod.HEAD;\n+import static io.servicetalk.http.api.HttpRequestMethod.OPTIONS;\n+import static io.servicetalk.http.api.HttpRequestMethod.PATCH;\n+import static io.servicetalk.http.api.HttpRequestMethod.POST;\n+import static io.servicetalk.http.api.HttpRequestMethod.PUT;\n+import static io.servicetalk.http.api.HttpRequestMethod.TRACE;\n import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n import static io.servicetalk.http.api.StreamingHttpResponses.newResponse;\n import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\n import static io.servicetalk.http.netty.HeaderUtils.setRequestContentLength;\n import static io.servicetalk.http.netty.HeaderUtils.setResponseContentLength;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.Assert.assertThat;\n \n public class ContentLengthTest extends AbstractNettyHttpServerTest {\n \n@@ -55,12 +69,36 @@\n     }\n \n     @Test\n-    public void shouldCalculateRequestContentLengthFromEmptyPublisher() throws Exception {\n-        StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n+    public void shouldNotCalculateRequestContentLengthFromEmptyPublisherForGetRequest() throws Exception {\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(GET);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(HEAD);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(DELETE);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(CONNECT);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(OPTIONS);\n+        shouldNotCalculateRequestContentLengthFromEmptyPublisher(TRACE);\n+    }\n+\n+    private static void shouldNotCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n                 .payloadBody(Publisher.empty());\n         setRequestContentLengthAndVerify(request, nullValue(CharSequence.class));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromEmptyPublisherForPostRequest() throws Exception {\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(POST);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PUT);\n+        shouldCalculateRequestContentLengthFromEmptyPublisher(PATCH);\n+    }\n+\n+    private static void shouldCalculateRequestContentLengthFromEmptyPublisher(HttpRequestMethod method)\n+            throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest(method).toStreamingRequest()\n+                .payloadBody(Publisher.empty());\n+        setRequestContentLengthAndVerify(request, is(\"0\"));\n+    }\n+\n     @Test\n     public void shouldCalculateRequestContentLengthFromSingleItemPublisher() throws Exception {\n         StreamingHttpRequest request = newAggregatedRequest().toStreamingRequest()\n@@ -82,6 +120,22 @@\n         setRequestContentLengthAndVerify(request, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateRequestContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpRequest request = newAggregatedRequest().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingRequest().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setRequestContentLengthAndVerify(request, is(\"12\"));\n+    }\n+\n     @Test\n     public void shouldCalculateResponseContentLengthFromEmptyPublisher() throws Exception {\n         StreamingHttpResponse response = newAggregatedResponse().toStreamingResponse()\n@@ -110,8 +164,28 @@\n         setResponseContentLengthAndVerify(response, is(\"12\"));\n     }\n \n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformPayloadBody(payload -> payload.concat(Publisher.from(\" \", \"World\", \"!\")),\n+                        textDeserializer(), textSerializer());\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n+    @Test\n+    public void shouldCalculateResponseContentLengthFromTransformedRawMultipleItemPublisher() throws Exception {\n+        StreamingHttpResponse response = newAggregatedResponse().payloadBody(\"Hello\", textSerializer())\n+                .toStreamingResponse().transformRawPayloadBody(payload -> payload.map(obj -> (Buffer) obj)\n+                        .concat(Publisher.from(\" \", \"World\", \"!\").map(DEFAULT_RO_ALLOCATOR::fromAscii)));\n+        setResponseContentLengthAndVerify(response, is(\"12\"));\n+    }\n+\n     private static HttpRequest newAggregatedRequest() {\n-        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(GET, \"/\", HTTP_1_1,\n+        return newAggregatedRequest(GET);\n+    }\n+\n+    private static HttpRequest newAggregatedRequest(HttpRequestMethod method) {\n+        return awaitSingleIndefinitelyNonNull(StreamingHttpRequests.newRequest(method, \"/\", HTTP_1_1,\n                 headersFactory.newHeaders(), DEFAULT_ALLOCATOR, headersFactory).toRequest());\n     }\n \n@@ -124,17 +198,29 @@\n                                                          final Matcher<CharSequence> matcher) throws Exception {\n         Collection<Object> flattened = setRequestContentLength(request).toFuture().get();\n         assertThat(\"Unexpected items in the flattened request.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator<Object> iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened request.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n     }\n \n     private static void setResponseContentLengthAndVerify(final StreamingHttpResponse response,\n                                                           final Matcher<CharSequence> matcher) throws Exception {\n         Collection<Object> flattened = setResponseContentLength(response).toFuture().get();\n         assertThat(\"Unexpected items in the flattened response.\", flattened, hasSize(greaterThanOrEqualTo(2)));\n-        Object firstItem = flattened.iterator().next();\n+        Iterator<Object> iterator = flattened.iterator();\n+        Object firstItem = iterator.next();\n         assertThat(\"Unexpected items in the flattened response.\", firstItem, is(instanceOf(HttpMetaData.class)));\n         assertThat(((HttpMetaData) firstItem).headers().get(CONTENT_LENGTH), matcher);\n+        assertLastItem(iterator);\n+    }\n+\n+    private static void assertLastItem(Iterator<Object> iterator) {\n+        Object item = null;\n+        while (iterator.hasNext()) {\n+            item = iterator.next();\n+        }\n+        assertThat(\"Unexpected last item in the flattened stream.\", item, is(instanceOf(HttpHeaders.class)));\n     }\n }\n\nFeel free to add more test cases there if I missed something.", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:24:57Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.FilterableStreamingHttpClient;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpHeadersFactory;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpClientFilter;\n+import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpRequester;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n+import static io.servicetalk.http.netty.HttpServers.forPort;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class AggregatedRequestsFilterTest {", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMjkzNg==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r530032936", "bodyText": "thx \ud83d\ude80", "author": "tkountis", "createdAt": "2020-11-25T00:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNDIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "chunk": "diff --git a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java b/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java\ndeleted file mode 100644\nindex 265ed4d86..000000000\n--- a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java\n+++ /dev/null\n\n@@ -1,213 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.netty;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n-import io.servicetalk.http.api.FilterableStreamingHttpClient;\n-import io.servicetalk.http.api.HttpClient;\n-import io.servicetalk.http.api.HttpExecutionStrategy;\n-import io.servicetalk.http.api.HttpHeadersFactory;\n-import io.servicetalk.http.api.HttpRequest;\n-import io.servicetalk.http.api.StreamingHttpClient;\n-import io.servicetalk.http.api.StreamingHttpClientFilter;\n-import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n-import io.servicetalk.http.api.StreamingHttpRequest;\n-import io.servicetalk.http.api.StreamingHttpRequester;\n-import io.servicetalk.http.api.StreamingHttpResponse;\n-import io.servicetalk.transport.api.ServerContext;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n-import static io.servicetalk.concurrent.api.Publisher.from;\n-import static io.servicetalk.concurrent.api.Single.failed;\n-import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n-import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n-import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n-import static io.servicetalk.http.api.HttpRequestMethod.GET;\n-import static io.servicetalk.http.api.HttpResponseStatus.OK;\n-import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n-import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n-import static io.servicetalk.http.netty.HttpServers.forPort;\n-import static java.util.Objects.requireNonNull;\n-import static org.junit.Assert.assertEquals;\n-\n-public class AggregatedRequestsFilterTest {\n-\n-    private static final StreamingHttpClientFilterFactory BODY_TRANSFORMER_FILTER =\n-            new StreamingHttpClientFilterFactory() {\n-        @Override\n-        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-            return new StreamingHttpClientFilter(client) {\n-                @Override\n-                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                                final HttpExecutionStrategy strategy,\n-                                                                final StreamingHttpRequest request) {\n-                    BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n-                    request.transformPayloadBody(b -> b.concat(succeeded(allocator.fromAscii(\"red-pill\"))));\n-                    return super.request(delegate, strategy, request);\n-                }\n-            };\n-        }\n-    };\n-\n-    private static final StreamingHttpClientFilterFactory RAW_TRANSFORMER_FILTER =\n-            new StreamingHttpClientFilterFactory() {\n-                @Override\n-                public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-                    return new StreamingHttpClientFilter(client) {\n-                        @Override\n-                        protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                                        final HttpExecutionStrategy strategy,\n-                                                                        final StreamingHttpRequest request) {\n-                            BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n-                            HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-\n-                            request.transformRawPayloadBody(b -> from(allocator.fromAscii(\"red-pill\"),\n-                                    headersFactory.newTrailers().add(\"fooA\", \"barA\")));\n-                            return super.request(delegate, strategy, request);\n-                        }\n-                    };\n-                }\n-            };\n-\n-    private ServerContext bodyOnlyServerCtx;\n-    private ServerContext bodyWithTrailersServerCtx;\n-    private HttpClient clientWithBodyTransformer;\n-    private HttpClient clientWithRawTransformer;\n-\n-    @Before\n-    public void setup() throws Exception {\n-        bodyOnlyServerCtx = forPort(0).listenStreamingAndAwait((ctx, request, responseFactory) ->\n-            succeeded(responseFactory.ok().payloadBody(from(\"reply\"), textSerializer())));\n-\n-        bodyWithTrailersServerCtx = forPort(0).listenStreamingAndAwait((ctx, request, responseFactory) -> {\n-            try {\n-                HttpRequest aggr = request.toRequest().toFuture().get();\n-                if (aggr.trailers().get(\"fooA\") == null) {\n-                    return failed(new IllegalStateException(\"Expected trailers\"));\n-                }\n-            } catch (Exception e) {\n-                return Single.failed(e);\n-            }\n-            return succeeded(responseFactory.ok().payloadBody(from(\"reply\"), textSerializer()));\n-        });\n-\n-        clientWithBodyTransformer = HttpClients\n-                .forResolvedAddress(bodyOnlyServerCtx.listenAddress())\n-                .appendClientFilter(BODY_TRANSFORMER_FILTER)\n-                .build();\n-\n-        clientWithRawTransformer = HttpClients\n-                .forResolvedAddress(bodyWithTrailersServerCtx.listenAddress())\n-                .appendClientFilter(RAW_TRANSFORMER_FILTER)\n-                .build();\n-    }\n-\n-    @After\n-    public void tearDown() throws Exception {\n-        clientWithBodyTransformer.close();\n-        bodyOnlyServerCtx.close();\n-        bodyWithTrailersServerCtx.close();\n-    }\n-\n-    @Test\n-    public void clientWithStreamingRequest() {\n-        final StreamingHttpClient streamingClient = clientWithBodyTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithBodyTransformer, request);\n-    }\n-\n-    @Test\n-    public void clientWithStreamingRequestAndTrailers() {\n-        BufferAllocator allocator = clientWithBodyTransformer.executionContext().bufferAllocator();\n-        HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-        final StreamingHttpRequest request = newTransportRequest(GET, \"/\", HTTP_1_1,\n-                headersFactory.newHeaders(), allocator, from(EMPTY_BUFFER, EMPTY_BUFFER, headersFactory.newTrailers()),\n-                headersFactory);\n-\n-        assertValidResponse(clientWithBodyTransformer, request);\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequestAndTrailers() {\n-        BufferAllocator allocator = clientWithBodyTransformer.executionContext().bufferAllocator();\n-        HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-        final StreamingHttpRequest request = newTransportRequest(GET, \"/\", HTTP_1_1,\n-                headersFactory.newHeaders().add(TRANSFER_ENCODING, CHUNKED), allocator,\n-                from(EMPTY_BUFFER, EMPTY_BUFFER, headersFactory.newTrailers().add(\"foo\", \"bar\")),\n-                headersFactory);\n-\n-        assertValidResponse(clientWithBodyTransformer, aggregate(request));\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequest() {\n-        final StreamingHttpClient streamingClient = clientWithBodyTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithBodyTransformer, aggregate(request));\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequestAndRawTransformerFilter() {\n-        final StreamingHttpClient streamingClient = clientWithRawTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithRawTransformer, aggregate(request));\n-    }\n-\n-    private HttpRequest aggregate(StreamingHttpRequest request) {\n-        return awaitSingleIndefinitelyNonNull(request.toRequest());\n-    }\n-\n-    private void assertValidResponse(HttpClient client, HttpRequest request) {\n-        try {\n-            // Two requests to make sure the HttpEncoder is left in the right state (eg. not awaiting for trailers)\n-            assertEquals(OK, client.request(request).toFuture().get().status());\n-            assertEquals(OK, client.request(request).toFuture().get().status());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    private void assertValidResponse(HttpClient client, StreamingHttpRequest request) {\n-        try {\n-            // Two requests to make sure the HttpEncoder is left in the right state (eg. not awaiting for trailers)\n-            assertEquals(OK, client.asStreamingClient().request(request).toFuture().get().status());\n-            assertEquals(OK, client.asStreamingClient().request(request).toFuture().get().status());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    static <T> T awaitSingleIndefinitelyNonNull(Single<T> single) {\n-        try {\n-            return requireNonNull(single.toFuture().get());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNjM1Mw==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r525536353", "bodyText": "Discussed offline: transformRawPayloadBody should not add trailers. For trailers, transform/transformRaw methods should be used. Also, users are responsible for consuming the original publisher when they apply transformations.", "author": "idelpivnitskiy", "createdAt": "2020-11-17T21:28:56Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n+import io.servicetalk.http.api.FilterableStreamingHttpClient;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpHeadersFactory;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpClientFilter;\n+import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpRequester;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpRequestMethod.GET;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n+import static io.servicetalk.http.netty.HttpServers.forPort;\n+import static java.util.Objects.requireNonNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class AggregatedRequestsFilterTest {\n+\n+    private static final StreamingHttpClientFilterFactory BODY_TRANSFORMER_FILTER =\n+            new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n+                    request.transformPayloadBody(b -> b.concat(succeeded(allocator.fromAscii(\"red-pill\"))));\n+                    return super.request(delegate, strategy, request);\n+                }\n+            };\n+        }\n+    };\n+\n+    private static final StreamingHttpClientFilterFactory RAW_TRANSFORMER_FILTER =\n+            new StreamingHttpClientFilterFactory() {\n+                @Override\n+                public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+                    return new StreamingHttpClientFilter(client) {\n+                        @Override\n+                        protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                        final HttpExecutionStrategy strategy,\n+                                                                        final StreamingHttpRequest request) {\n+                            BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n+                            HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n+\n+                            request.transformRawPayloadBody(b -> from(allocator.fromAscii(\"red-pill\"),\n+                                    headersFactory.newTrailers().add(\"fooA\", \"barA\")));", "originalCommit": "a2c12893734841eea9c18d033884cccf944f7624", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "chunk": "diff --git a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java b/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java\ndeleted file mode 100644\nindex 265ed4d86..000000000\n--- a/servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/AggregatedRequestsFilterTest.java\n+++ /dev/null\n\n@@ -1,213 +0,0 @@\n-/*\n- * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.netty;\n-\n-import io.servicetalk.buffer.api.BufferAllocator;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.http.api.DefaultHttpHeadersFactory;\n-import io.servicetalk.http.api.FilterableStreamingHttpClient;\n-import io.servicetalk.http.api.HttpClient;\n-import io.servicetalk.http.api.HttpExecutionStrategy;\n-import io.servicetalk.http.api.HttpHeadersFactory;\n-import io.servicetalk.http.api.HttpRequest;\n-import io.servicetalk.http.api.StreamingHttpClient;\n-import io.servicetalk.http.api.StreamingHttpClientFilter;\n-import io.servicetalk.http.api.StreamingHttpClientFilterFactory;\n-import io.servicetalk.http.api.StreamingHttpRequest;\n-import io.servicetalk.http.api.StreamingHttpRequester;\n-import io.servicetalk.http.api.StreamingHttpResponse;\n-import io.servicetalk.transport.api.ServerContext;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n-import static io.servicetalk.concurrent.api.Publisher.from;\n-import static io.servicetalk.concurrent.api.Single.failed;\n-import static io.servicetalk.concurrent.api.Single.succeeded;\n-import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n-import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n-import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n-import static io.servicetalk.http.api.HttpRequestMethod.GET;\n-import static io.servicetalk.http.api.HttpResponseStatus.OK;\n-import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n-import static io.servicetalk.http.api.StreamingHttpRequests.newTransportRequest;\n-import static io.servicetalk.http.netty.HttpServers.forPort;\n-import static java.util.Objects.requireNonNull;\n-import static org.junit.Assert.assertEquals;\n-\n-public class AggregatedRequestsFilterTest {\n-\n-    private static final StreamingHttpClientFilterFactory BODY_TRANSFORMER_FILTER =\n-            new StreamingHttpClientFilterFactory() {\n-        @Override\n-        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-            return new StreamingHttpClientFilter(client) {\n-                @Override\n-                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                                final HttpExecutionStrategy strategy,\n-                                                                final StreamingHttpRequest request) {\n-                    BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n-                    request.transformPayloadBody(b -> b.concat(succeeded(allocator.fromAscii(\"red-pill\"))));\n-                    return super.request(delegate, strategy, request);\n-                }\n-            };\n-        }\n-    };\n-\n-    private static final StreamingHttpClientFilterFactory RAW_TRANSFORMER_FILTER =\n-            new StreamingHttpClientFilterFactory() {\n-                @Override\n-                public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n-                    return new StreamingHttpClientFilter(client) {\n-                        @Override\n-                        protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n-                                                                        final HttpExecutionStrategy strategy,\n-                                                                        final StreamingHttpRequest request) {\n-                            BufferAllocator allocator = delegate.executionContext().bufferAllocator();\n-                            HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-\n-                            request.transformRawPayloadBody(b -> from(allocator.fromAscii(\"red-pill\"),\n-                                    headersFactory.newTrailers().add(\"fooA\", \"barA\")));\n-                            return super.request(delegate, strategy, request);\n-                        }\n-                    };\n-                }\n-            };\n-\n-    private ServerContext bodyOnlyServerCtx;\n-    private ServerContext bodyWithTrailersServerCtx;\n-    private HttpClient clientWithBodyTransformer;\n-    private HttpClient clientWithRawTransformer;\n-\n-    @Before\n-    public void setup() throws Exception {\n-        bodyOnlyServerCtx = forPort(0).listenStreamingAndAwait((ctx, request, responseFactory) ->\n-            succeeded(responseFactory.ok().payloadBody(from(\"reply\"), textSerializer())));\n-\n-        bodyWithTrailersServerCtx = forPort(0).listenStreamingAndAwait((ctx, request, responseFactory) -> {\n-            try {\n-                HttpRequest aggr = request.toRequest().toFuture().get();\n-                if (aggr.trailers().get(\"fooA\") == null) {\n-                    return failed(new IllegalStateException(\"Expected trailers\"));\n-                }\n-            } catch (Exception e) {\n-                return Single.failed(e);\n-            }\n-            return succeeded(responseFactory.ok().payloadBody(from(\"reply\"), textSerializer()));\n-        });\n-\n-        clientWithBodyTransformer = HttpClients\n-                .forResolvedAddress(bodyOnlyServerCtx.listenAddress())\n-                .appendClientFilter(BODY_TRANSFORMER_FILTER)\n-                .build();\n-\n-        clientWithRawTransformer = HttpClients\n-                .forResolvedAddress(bodyWithTrailersServerCtx.listenAddress())\n-                .appendClientFilter(RAW_TRANSFORMER_FILTER)\n-                .build();\n-    }\n-\n-    @After\n-    public void tearDown() throws Exception {\n-        clientWithBodyTransformer.close();\n-        bodyOnlyServerCtx.close();\n-        bodyWithTrailersServerCtx.close();\n-    }\n-\n-    @Test\n-    public void clientWithStreamingRequest() {\n-        final StreamingHttpClient streamingClient = clientWithBodyTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithBodyTransformer, request);\n-    }\n-\n-    @Test\n-    public void clientWithStreamingRequestAndTrailers() {\n-        BufferAllocator allocator = clientWithBodyTransformer.executionContext().bufferAllocator();\n-        HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-        final StreamingHttpRequest request = newTransportRequest(GET, \"/\", HTTP_1_1,\n-                headersFactory.newHeaders(), allocator, from(EMPTY_BUFFER, EMPTY_BUFFER, headersFactory.newTrailers()),\n-                headersFactory);\n-\n-        assertValidResponse(clientWithBodyTransformer, request);\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequestAndTrailers() {\n-        BufferAllocator allocator = clientWithBodyTransformer.executionContext().bufferAllocator();\n-        HttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false, false);\n-        final StreamingHttpRequest request = newTransportRequest(GET, \"/\", HTTP_1_1,\n-                headersFactory.newHeaders().add(TRANSFER_ENCODING, CHUNKED), allocator,\n-                from(EMPTY_BUFFER, EMPTY_BUFFER, headersFactory.newTrailers().add(\"foo\", \"bar\")),\n-                headersFactory);\n-\n-        assertValidResponse(clientWithBodyTransformer, aggregate(request));\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequest() {\n-        final StreamingHttpClient streamingClient = clientWithBodyTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithBodyTransformer, aggregate(request));\n-    }\n-\n-    @Test\n-    public void clientWithAggregatedStreamingRequestAndRawTransformerFilter() {\n-        final StreamingHttpClient streamingClient = clientWithRawTransformer.asStreamingClient();\n-        final StreamingHttpRequest request = streamingClient.get(\"/\")\n-                .payloadBody(from(\"A\", \"B\"), textSerializer());\n-\n-        assertValidResponse(clientWithRawTransformer, aggregate(request));\n-    }\n-\n-    private HttpRequest aggregate(StreamingHttpRequest request) {\n-        return awaitSingleIndefinitelyNonNull(request.toRequest());\n-    }\n-\n-    private void assertValidResponse(HttpClient client, HttpRequest request) {\n-        try {\n-            // Two requests to make sure the HttpEncoder is left in the right state (eg. not awaiting for trailers)\n-            assertEquals(OK, client.request(request).toFuture().get().status());\n-            assertEquals(OK, client.request(request).toFuture().get().status());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    private void assertValidResponse(HttpClient client, StreamingHttpRequest request) {\n-        try {\n-            // Two requests to make sure the HttpEncoder is left in the right state (eg. not awaiting for trailers)\n-            assertEquals(OK, client.asStreamingClient().request(request).toFuture().get().status());\n-            assertEquals(OK, client.asStreamingClient().request(request).toFuture().get().status());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    static <T> T awaitSingleIndefinitelyNonNull(Single<T> single) {\n-        try {\n-            return requireNonNull(single.toFuture().get());\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-}\n"}}, {"oid": "2b3a1eb2bcd276fc3e64a3860fc4f2ace93499d8", "url": "https://github.com/apple/servicetalk/commit/2b3a1eb2bcd276fc3e64a3860fc4f2ace93499d8", "message": "Fix transformed aggregated requests with missing trailers", "committedDate": "2020-11-25T00:20:27Z", "type": "commit"}, {"oid": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "url": "https://github.com/apple/servicetalk/commit/3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "message": "Fix comments", "committedDate": "2020-11-25T00:33:22Z", "type": "commit"}, {"oid": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "url": "https://github.com/apple/servicetalk/commit/3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "message": "Fix comments", "committedDate": "2020-11-25T00:33:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMTMzMA==", "url": "https://github.com/apple/servicetalk/pull/1213#discussion_r532901330", "bodyText": "Consider upgrading the copyright year for this file to 2018-2020", "author": "idelpivnitskiy", "createdAt": "2020-11-30T21:02:23Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -34,6 +34,7 @@\n \n import static io.servicetalk.concurrent.api.Publisher.from;\n import static io.servicetalk.concurrent.api.Publisher.fromIterable;\n+import static io.servicetalk.concurrent.api.Single.succeeded;", "originalCommit": "3460b0a3ea9782e6a3ed0963d840cd10f27c901a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "50471f208355ada215414c63809ba8e700ea6868", "url": "https://github.com/apple/servicetalk/commit/50471f208355ada215414c63809ba8e700ea6868", "message": "Fix checkstyle", "committedDate": "2020-12-03T18:59:19Z", "type": "commit"}]}