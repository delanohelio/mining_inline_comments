{"pr_number": 1544, "pr_title": "Issue #1404: Implemented tests for DockerRegistryApiService", "pr_createdAt": "2020-11-05T13:41:13Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1544", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwOTI4Nw==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r520609287", "bodyText": "Apparently, we should use the dockerRegistryApiService here, not the mockDockerRegistryManager. And also in the test below.", "author": "YouKofan", "createdAt": "2020-11-10T14:35:40Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistry dockerRegistryWithOwner = DockerCreatorUtils.getDockerRegistry(SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final Tool tool = ToolCreatorUtils.getTool();\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistryWithOwner, AclPermission.WRITE);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        final DockerRegistry resultRegistry = dockerRegistryApiService.updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(resultRegistry).isEqualTo(dockerRegistryWithOwner);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+        initAclEntity(dockerRegistryWithOwner);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithOwner));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(mockDockerRegistryManager.delete(ID, true)).isEqualTo(dockerRegistry);", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\nindex c8afd2143..511b4f925 100644\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n\n@@ -17,26 +17,30 @@\n package com.epam.pipeline.acl.docker;\n \n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.JwtRawToken;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.security.AuthManager;\n import com.epam.pipeline.security.acl.AclPermission;\n import com.epam.pipeline.test.acl.AbstractAclTest;\n import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.access.AccessDeniedException;\n import org.springframework.security.test.context.support.WithMockUser;\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n import static org.assertj.core.api.Assertions.assertThat;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDIwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244200", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "author": "ekazachkova", "createdAt": "2020-11-11T09:58:27Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.entity.pipeline.Tool;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class ToolCreatorUtils {\n+\n+    private ToolCreatorUtils() {\n+\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();\n+        tool.setId(ID);\n+        tool.setName(TEST_STRING);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        tool.setRegistryId(ID);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java\ndeleted file mode 100644\nindex ba34a6684..000000000\n--- a/api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java\n+++ /dev/null\n\n@@ -1,52 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.test.creator.docker;\n-\n-import com.epam.pipeline.entity.pipeline.Tool;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-\n-public final class ToolCreatorUtils {\n-\n-    private ToolCreatorUtils() {\n-\n-    }\n-\n-    public static Tool getTool() {\n-        final Tool tool = new Tool();\n-        tool.setId(ID);\n-        tool.setName(TEST_STRING);\n-        tool.setCpu(TEST_STRING);\n-        tool.setDefaultCommand(TEST_STRING);\n-        tool.setToolGroupId(ID);\n-        tool.setRegistry(TEST_STRING);\n-        tool.setRegistryId(ID);\n-        return tool;\n-    }\n-\n-    public static Tool getTool(String owner) {\n-        final Tool tool = new Tool();\n-        tool.setOwner(owner);\n-        tool.setId(ID);\n-        tool.setCpu(TEST_STRING);\n-        tool.setDefaultCommand(TEST_STRING);\n-        tool.setToolGroupId(ID);\n-        tool.setRegistry(TEST_STRING);\n-        return tool;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDY4MQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244681", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "author": "ekazachkova", "createdAt": "2020-11-11T09:59:17Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\nindex 5844e7913..cb01add4a 100644\n--- a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n+++ b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n\n@@ -16,39 +16,130 @@\n \n package com.epam.pipeline.test.creator.docker;\n \n+import com.epam.pipeline.controller.Result;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n \n import java.util.Collections;\n import java.util.List;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n \n public final class DockerCreatorUtils {\n \n+    public static final TypeReference<Result<ImageDescription>> IMAGE_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ImageDescription>>() {};\n+    public static final TypeReference<Result<ToolDescription>> TOOL_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolDescription>>() {};\n+    public static final TypeReference<Result<ToolVersion>> TOOL_VERSION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersion>>() {};\n+    public static final TypeReference<Result<List<ImageHistoryLayer>>> IMAGE_HISTORY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ImageHistoryLayer>>>() {};\n+    public static final TypeReference<Result<List<ToolVersion>>> TOOL_VERSION_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ToolVersion>>>() {};\n+    public static final TypeReference<Result<ToolVersionScanResult>> TOOL_VERSION_SCAN_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersionScanResult>>() {};\n+    public static final TypeReference<Result<ToolScanResultView>> SCAN_RESULT_VIEW_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanResultView>>() {};\n+    public static final TypeReference<Result<ToolScanPolicy>> TOOL_SCAN_POLICY_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanPolicy>>() {};\n+    public static final TypeReference<Result<Tool>> TOOL_INSTANCE_TYPE = new TypeReference<Result<Tool>>() {};\n+    public static final TypeReference<Result<List<String>>> LIST_STRING_INSTANCE_TYPE =\n+            new TypeReference<Result<List<String>>>() {};\n+    public static final TypeReference<Result<ToolGroup>> TOOL_GROUP_TYPE =\n+            new TypeReference<Result<ToolGroup>>() {};\n+    public static final TypeReference<Result<ToolGroupWithIssues>> TOOL_GROUP_WITH_ISSUES_TYPE =\n+            new TypeReference<Result<ToolGroupWithIssues>>() {};\n+    public static final TypeReference<Result<List<ToolGroup>>> TOOL_GROUP_LIST_TYPE =\n+            new TypeReference<Result<List<ToolGroup>>>() {};\n+    public static final TypeReference<Result<DockerRegistry>> DOCKER_REGISTRY_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistry>>() {};\n+    public static final TypeReference<Result<DockerRegistryList>> DOCKER_REGISTRY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistryList>>() {};\n+    public static final TypeReference<Result<List<Tool>>> TOOL_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<Tool>>>() {};\n+\n     private DockerCreatorUtils() {\n \n     }\n \n+    public static ImageDescription getImageDescription() {\n+        return new ImageDescription();\n+    }\n+\n+    public static ImageHistoryLayer getImageHistoryLayer() {\n+        return new ImageHistoryLayer();\n+    }\n+\n+    public static ToolDescription getToolDescription() {\n+        return new ToolDescription();\n+    }\n+\n+    public static ToolVersion getToolVersion() {\n+        return new ToolVersion();\n+    }\n+\n+    public static ToolVersionScanResult getToolVersionScanResult() {\n+        final ToolVersionScanResult toolVersionScanResult = new ToolVersionScanResult();\n+        toolVersionScanResult.setToolId(ID);\n+        toolVersionScanResult.setVersion(TEST_STRING);\n+        toolVersionScanResult.setFromWhiteList(true);\n+        return toolVersionScanResult;\n+    }\n+\n+    public static ToolScanResultView getToolScanResultView() {\n+        return new ToolScanResultView(ID, Collections.singletonMap(TEST_STRING, getToolVersionScanResultView()));\n+    }\n+\n+    public static ToolVersionScanResultView getToolVersionScanResultView() {\n+        return ToolVersionScanResultView.builder().build();\n+    }\n+\n+    public static ToolScanPolicy getToolScanPolicy() {\n+        return new ToolScanPolicy();\n+    }\n+\n+    public static ToolSymlinkRequest getToolSymlinkRequest() {\n+        return new ToolSymlinkRequest(ID, ID);\n+    }\n+\n+    public static ToolGroupWithIssues getToolGroupWithIssues() {\n+        return new ToolGroupWithIssues();\n+    }\n+\n     public static DockerRegistry getDockerRegistry() {\n         final DockerRegistry dockerRegistry = new DockerRegistry();\n-        dockerRegistry.setCaCert(TEST_STRING);\n-        dockerRegistry.setId(ID);\n+        dockerRegistry.setPath(TEST_STRING);\n         dockerRegistry.setDescription(TEST_STRING);\n-        dockerRegistry.setExternalUrl(TEST_STRING);\n-        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setSecretName(TEST_STRING);\n+        dockerRegistry.setUserName(TEST_STRING);\n         dockerRegistry.setPassword(TEST_STRING);\n+        dockerRegistry.setCaCert(TEST_STRING);\n         return dockerRegistry;\n     }\n \n-    public static DockerRegistry getDockerRegistry(String owner) {\n+    public static DockerRegistry getDockerRegistry(final Long id, final String owner) {\n         final DockerRegistry dockerRegistry = new DockerRegistry();\n         dockerRegistry.setOwner(owner);\n         dockerRegistry.setCaCert(TEST_STRING);\n-        dockerRegistry.setId(ID);\n+        dockerRegistry.setId(id);\n         dockerRegistry.setDescription(TEST_STRING);\n         dockerRegistry.setExternalUrl(TEST_STRING);\n         dockerRegistry.setHasMetadata(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NjM1NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521246354", "bodyText": "Do not forget to add final\nDo we really need this method?", "author": "ekazachkova", "createdAt": "2020-11-11T10:02:08Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setOwner(owner);\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistryVO getDockerRegistryVO() {\n+        final DockerRegistryVO dockerRegistryVO = new DockerRegistryVO();\n+        dockerRegistryVO.setCaCert(TEST_STRING);\n+        dockerRegistryVO.setId(ID);\n+        dockerRegistryVO.setDescription(TEST_STRING);\n+        dockerRegistryVO.setExternalUrl(TEST_STRING);\n+        dockerRegistryVO.setPassword(TEST_STRING);\n+        return dockerRegistryVO;\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList() {\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\nindex 5844e7913..cb01add4a 100644\n--- a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n+++ b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n\n@@ -16,39 +16,130 @@\n \n package com.epam.pipeline.test.creator.docker;\n \n+import com.epam.pipeline.controller.Result;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n \n import java.util.Collections;\n import java.util.List;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n \n public final class DockerCreatorUtils {\n \n+    public static final TypeReference<Result<ImageDescription>> IMAGE_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ImageDescription>>() {};\n+    public static final TypeReference<Result<ToolDescription>> TOOL_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolDescription>>() {};\n+    public static final TypeReference<Result<ToolVersion>> TOOL_VERSION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersion>>() {};\n+    public static final TypeReference<Result<List<ImageHistoryLayer>>> IMAGE_HISTORY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ImageHistoryLayer>>>() {};\n+    public static final TypeReference<Result<List<ToolVersion>>> TOOL_VERSION_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ToolVersion>>>() {};\n+    public static final TypeReference<Result<ToolVersionScanResult>> TOOL_VERSION_SCAN_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersionScanResult>>() {};\n+    public static final TypeReference<Result<ToolScanResultView>> SCAN_RESULT_VIEW_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanResultView>>() {};\n+    public static final TypeReference<Result<ToolScanPolicy>> TOOL_SCAN_POLICY_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanPolicy>>() {};\n+    public static final TypeReference<Result<Tool>> TOOL_INSTANCE_TYPE = new TypeReference<Result<Tool>>() {};\n+    public static final TypeReference<Result<List<String>>> LIST_STRING_INSTANCE_TYPE =\n+            new TypeReference<Result<List<String>>>() {};\n+    public static final TypeReference<Result<ToolGroup>> TOOL_GROUP_TYPE =\n+            new TypeReference<Result<ToolGroup>>() {};\n+    public static final TypeReference<Result<ToolGroupWithIssues>> TOOL_GROUP_WITH_ISSUES_TYPE =\n+            new TypeReference<Result<ToolGroupWithIssues>>() {};\n+    public static final TypeReference<Result<List<ToolGroup>>> TOOL_GROUP_LIST_TYPE =\n+            new TypeReference<Result<List<ToolGroup>>>() {};\n+    public static final TypeReference<Result<DockerRegistry>> DOCKER_REGISTRY_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistry>>() {};\n+    public static final TypeReference<Result<DockerRegistryList>> DOCKER_REGISTRY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistryList>>() {};\n+    public static final TypeReference<Result<List<Tool>>> TOOL_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<Tool>>>() {};\n+\n     private DockerCreatorUtils() {\n \n     }\n \n+    public static ImageDescription getImageDescription() {\n+        return new ImageDescription();\n+    }\n+\n+    public static ImageHistoryLayer getImageHistoryLayer() {\n+        return new ImageHistoryLayer();\n+    }\n+\n+    public static ToolDescription getToolDescription() {\n+        return new ToolDescription();\n+    }\n+\n+    public static ToolVersion getToolVersion() {\n+        return new ToolVersion();\n+    }\n+\n+    public static ToolVersionScanResult getToolVersionScanResult() {\n+        final ToolVersionScanResult toolVersionScanResult = new ToolVersionScanResult();\n+        toolVersionScanResult.setToolId(ID);\n+        toolVersionScanResult.setVersion(TEST_STRING);\n+        toolVersionScanResult.setFromWhiteList(true);\n+        return toolVersionScanResult;\n+    }\n+\n+    public static ToolScanResultView getToolScanResultView() {\n+        return new ToolScanResultView(ID, Collections.singletonMap(TEST_STRING, getToolVersionScanResultView()));\n+    }\n+\n+    public static ToolVersionScanResultView getToolVersionScanResultView() {\n+        return ToolVersionScanResultView.builder().build();\n+    }\n+\n+    public static ToolScanPolicy getToolScanPolicy() {\n+        return new ToolScanPolicy();\n+    }\n+\n+    public static ToolSymlinkRequest getToolSymlinkRequest() {\n+        return new ToolSymlinkRequest(ID, ID);\n+    }\n+\n+    public static ToolGroupWithIssues getToolGroupWithIssues() {\n+        return new ToolGroupWithIssues();\n+    }\n+\n     public static DockerRegistry getDockerRegistry() {\n         final DockerRegistry dockerRegistry = new DockerRegistry();\n-        dockerRegistry.setCaCert(TEST_STRING);\n-        dockerRegistry.setId(ID);\n+        dockerRegistry.setPath(TEST_STRING);\n         dockerRegistry.setDescription(TEST_STRING);\n-        dockerRegistry.setExternalUrl(TEST_STRING);\n-        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setSecretName(TEST_STRING);\n+        dockerRegistry.setUserName(TEST_STRING);\n         dockerRegistry.setPassword(TEST_STRING);\n+        dockerRegistry.setCaCert(TEST_STRING);\n         return dockerRegistry;\n     }\n \n-    public static DockerRegistry getDockerRegistry(String owner) {\n+    public static DockerRegistry getDockerRegistry(final Long id, final String owner) {\n         final DockerRegistry dockerRegistry = new DockerRegistry();\n         dockerRegistry.setOwner(owner);\n         dockerRegistry.setCaCert(TEST_STRING);\n-        dockerRegistry.setId(ID);\n+        dockerRegistry.setId(id);\n         dockerRegistry.setDescription(TEST_STRING);\n         dockerRegistry.setExternalUrl(TEST_STRING);\n         dockerRegistry.setHasMetadata(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2OTAyOQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521269029", "bodyText": "Could you add a simple tests for methods with AclTree annotation?", "author": "ekazachkova", "createdAt": "2020-11-11T10:42:02Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\nindex c8afd2143..511b4f925 100644\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n\n@@ -17,26 +17,30 @@\n package com.epam.pipeline.acl.docker;\n \n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.JwtRawToken;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.security.AuthManager;\n import com.epam.pipeline.security.acl.AclPermission;\n import com.epam.pipeline.test.acl.AbstractAclTest;\n import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n import org.junit.Test;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.security.access.AccessDeniedException;\n import org.springframework.security.test.context.support.WithMockUser;\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n import static org.assertj.core.api.Assertions.assertThat;\n"}}, {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "url": "https://github.com/epam/cloud-pipeline/commit/c3103f3f4623dae614b7ca813920a21f643d8c0a", "message": "Issue #1404: Added tests for AclTree annotation", "committedDate": "2020-11-18T07:46:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzNjk4NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525936985", "bodyText": "Could it be realized like:\nreturn getTool(null, null)\n\n?", "author": "ekazachkova", "createdAt": "2020-11-18T09:30:03Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -165,10 +166,56 @@ public static DockerRegistryVO getDockerRegistryVO() {\n     }\n \n     public static DockerRegistryList getDockerRegistryList() {\n-        return new DockerRegistryList(Collections.singletonList(getDockerRegistry()));\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(final DockerRegistry dockerRegistry) {\n+        return new DockerRegistryList(Collections.singletonList(dockerRegistry));\n     }\n \n     public static DockerRegistryEventEnvelope getDockerRegistryEventEnvelope() {\n         return new DockerRegistryEventEnvelope();\n     }\n+\n+    public static Tool getTool(final Long id, final String owner) {\n+        final Tool tool = new Tool();\n+        tool.setOwner(owner);\n+        tool.setId(id);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(final String owner) {\n+        return getTool(ID, owner);\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\nindex cb01add4a..81c0bf349 100644\n--- a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n+++ b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n\n@@ -166,56 +189,20 @@ public final class DockerCreatorUtils {\n     }\n \n     public static DockerRegistryList getDockerRegistryList() {\n-        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n-        return new DockerRegistryList(dockerRegistries);\n-    }\n-\n-    public static DockerRegistryList getDockerRegistryList(final DockerRegistry dockerRegistry) {\n-        return new DockerRegistryList(Collections.singletonList(dockerRegistry));\n+        return new DockerRegistryList(Collections.singletonList(getDockerRegistry()));\n     }\n \n     public static DockerRegistryEventEnvelope getDockerRegistryEventEnvelope() {\n         return new DockerRegistryEventEnvelope();\n     }\n \n-    public static Tool getTool(final Long id, final String owner) {\n-        final Tool tool = new Tool();\n-        tool.setOwner(owner);\n-        tool.setId(id);\n-        tool.setCpu(TEST_STRING);\n-        tool.setDefaultCommand(TEST_STRING);\n-        tool.setToolGroupId(ID);\n-        tool.setRegistry(TEST_STRING);\n-        return tool;\n-    }\n-\n-    public static Tool getTool(final String owner) {\n-        return getTool(ID, owner);\n-    }\n-\n-    public static Tool getTool() {\n-        final Tool tool = new Tool();\n-        tool.setId(ID);\n-        tool.setImage(TEST_STRING);\n-        tool.setCpu(TEST_STRING);\n-        tool.setRam(TEST_STRING);\n-        tool.setInstanceType(TEST_STRING);\n-        tool.setDisk(TEST_INT);\n-        return tool;\n-    }\n-\n-    public static ToolGroup getToolGroup(final long id, final String owner) {\n-        final ToolGroup toolGroup = new ToolGroup();\n-        toolGroup.setId(id);\n-        toolGroup.setOwner(owner);\n-        return toolGroup;\n-    }\n-\n-    public static ToolGroup getToolGroup(final String owner) {\n-        return getToolGroup(ID, owner);\n-    }\n-\n-    public static ToolGroup getToolGroup() {\n-        return getToolGroup(ID, TEST_STRING);\n+    public static ToolScanResult getToolScanResult() {\n+        final ToolScanResult toolScanResult = new ToolScanResult();\n+        final ToolVersionScanResult toolVersionScanResult = new ToolVersionScanResult();\n+        toolVersionScanResult.setVersion(TEST_STRING);\n+        final Map<String, ToolVersionScanResult> map = Collections.singletonMap(TEST_STRING, toolVersionScanResult);\n+        toolScanResult.setToolId(ID);\n+        toolScanResult.setToolVersionScanResults(map);\n+        return toolScanResult;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTY4MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525939680", "bodyText": "Could you please remove empty line?", "author": "ekazachkova", "createdAt": "2020-11-18T09:34:03Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2ODQ2Mg==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525968462", "bodyText": "It looks a bit confusing: you are granting permission to object with name *WithoutPermission", "author": "ekazachkova", "createdAt": "2020-11-18T10:16:25Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NzQ0NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525987445", "bodyText": "Class fields mutation makes code confusing. To my mind it would more clearly to refactor this lines:\ntoolGroup.setTools(toolList);\ntoolGroupWithoutPermission.setTools(toolList);\ndockerRegistryWithTools.setGroups(toolGroups);\n\nI would suggest two options:\n\ncreate a new objects into the test\ninitialize this fields at the tests class beginning", "author": "ekazachkova", "createdAt": "2020-11-18T10:45:19Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525996198", "bodyText": "Maybe assertThat(dockerRegistryChildren).containsAll(toolGroups); would be enough?", "author": "ekazachkova", "createdAt": "2020-11-18T10:59:03Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n+        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n+\n+        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDIxNQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000215", "bodyText": "If so, could you please check it for other places? (and think about common method)", "author": "ekazachkova", "createdAt": "2020-11-18T11:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000511", "bodyText": "Could we use hasSize here?", "author": "ekazachkova", "createdAt": "2020-11-18T11:05:47Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMzM5NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526003395", "bodyText": "If so, could you please fix it for other methods?", "author": "ekazachkova", "createdAt": "2020-11-18T11:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwNzM1MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526007350", "bodyText": "Could we store dockerRegistryApiService.loadAllRegistriesContent().getChildren() into the local field?", "author": "ekazachkova", "createdAt": "2020-11-18T11:17:01Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxMDM2NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526010364", "bodyText": "Is it possible to rename this method to more clear?", "author": "ekazachkova", "createdAt": "2020-11-18T11:21:59Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzAxMQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526017011", "bodyText": "Could we refactor this logic somehow: list.get(index) is not clear? (Maybe pick methods for each requested entity? by Id?)", "author": "ekazachkova", "createdAt": "2020-11-18T11:33:15Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java b/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\ndeleted file mode 100644\nindex 511b4f925..000000000\n--- a/api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java\n+++ /dev/null\n\n@@ -1,363 +0,0 @@\n-/*\n- * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.epam.pipeline.acl.docker;\n-\n-import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n-import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n-import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.docker.DockerRegistryList;\n-import com.epam.pipeline.entity.pipeline.DockerRegistry;\n-import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n-import com.epam.pipeline.entity.pipeline.Tool;\n-import com.epam.pipeline.entity.pipeline.ToolGroup;\n-import com.epam.pipeline.entity.security.JwtRawToken;\n-import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.security.acl.AclPermission;\n-import com.epam.pipeline.test.acl.AbstractAclTest;\n-import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n-import org.junit.Test;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.security.access.AccessDeniedException;\n-import org.springframework.security.test.context.support.WithMockUser;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n-import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n-import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n-\n-public class DockerRegistryApiServiceTest extends AbstractAclTest {\n-\n-    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n-    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n-    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final List<Tool> tools = Collections.singletonList(tool);\n-    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n-    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n-    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n-    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n-    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n-    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n-    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n-    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n-    private final List<ToolGroup> toolGroups =\n-            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n-\n-\n-    @Autowired\n-    private DockerRegistryApiService dockerRegistryApiService;\n-\n-    @Autowired\n-    private DockerRegistryManager mockDockerRegistryManager;\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldCreateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n-        initDockerRegistryAclTree();\n-        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n-                .isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n-                .updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n-\n-        assertWholeDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldListDockerRegistriesWithCerts() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldListDockerRegistryHierarchyWithCerts() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .listDockerRegistriesWithCerts().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadAllRegistriesContent() {\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadAllRegistriesHierarchyContent() {\n-        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n-        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n-        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n-\n-        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n-                .loadAllRegistriesContent().getChildren().get(0);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldLoadDockerRegistry() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n-\n-        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldLoadDockerRegistryHierarchy() {\n-        initDockerRegistryAclTree();\n-        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n-\n-        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n-\n-        assertPartialDockerRegistryAclTree(returnedDr);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldDeleteDockerRegistryForAdmin() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n-        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n-        initAclEntity(dockerRegistry, AclPermission.WRITE);\n-\n-        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldNotifyDockerRegistryEventsForAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n-    }\n-\n-    @Test\n-    @WithMockUser\n-    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n-        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n-\n-        assertThrows(AccessDeniedException.class,\n-            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n-    }\n-\n-    @Test\n-    public void shouldIssueTokenForDockerRegistry() {\n-        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n-\n-        assertThat(dockerRegistryApiService\n-                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n-                .isEqualTo(jwtRawToken);\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetCertificateContentForAdmin() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n-    }\n-\n-    @Test\n-    @WithMockUser(roles = ADMIN_ROLE)\n-    public void shouldGetConfigScript() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(SIMPLE_USER)\n-    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n-        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n-        initAclEntity(dockerRegistry, AclPermission.READ);\n-\n-        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = SIMPLE_USER)\n-    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n-        initAclEntity(dockerRegistry);\n-\n-        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n-    }\n-\n-    private void initDockerRegistryAclTree() {\n-        toolGroup.setTools(toolList);\n-        toolGroupWithoutPermission.setTools(toolList);\n-        dockerRegistryWithTools.setGroups(toolGroups);\n-        initAclEntity(toolRead, AclPermission.READ);\n-        initAclEntity(toolWithoutPermission);\n-        initAclEntity(toolGroup, AclPermission.READ);\n-        initAclEntity(toolGroupWithoutPermission);\n-        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n-    }\n-\n-    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n-        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n-    }\n-\n-    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n-        assertDockerRegistryAclHierarchy(registry);\n-        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n-                registry.getChildren().get(1).getLeaves();\n-\n-        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n-    }\n-\n-    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n-        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n-        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n-        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n-\n-        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());\n-        assertThat(dockerRegistryChildren).isEqualTo(toolGroups);\n-        assertThat(toolGroupLeaves.size()).isEqualTo(toolList.size());\n-        assertThat(toolGroupLeaves).isEqualTo(toolList);\n-        assertThat(emptyToolGroupLeaves).isEmpty();\n-    }\n-}\n"}}, {"oid": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "url": "https://github.com/epam/cloud-pipeline/commit/0827d96f72a94d9c78b9c6ea29339eba98ff906d", "message": "Issue #1404: Classes moved to acl package", "committedDate": "2020-11-18T14:07:30Z", "type": "commit"}, {"oid": "fe94dc764f316c003773190714b9c9e35b32ee9f", "url": "https://github.com/epam/cloud-pipeline/commit/fe94dc764f316c003773190714b9c9e35b32ee9f", "message": "Issue #1404: Implemented tests for DockerRegistryApiService", "committedDate": "2020-11-18T14:07:31Z", "type": "commit"}, {"oid": "841645292a31b3af2e2ceca233256cfbcd95d8d1", "url": "https://github.com/epam/cloud-pipeline/commit/841645292a31b3af2e2ceca233256cfbcd95d8d1", "message": "Issue #1404: Added tests for AclTree annotation", "committedDate": "2020-11-18T14:33:10Z", "type": "commit"}, {"oid": "efb35955d01c6b006d93061421daa1529e6f228a", "url": "https://github.com/epam/cloud-pipeline/commit/efb35955d01c6b006d93061421daa1529e6f228a", "message": "Issue #1404: AclTree tests refactoring", "committedDate": "2020-11-19T12:45:38Z", "type": "commit"}, {"oid": "efb35955d01c6b006d93061421daa1529e6f228a", "url": "https://github.com/epam/cloud-pipeline/commit/efb35955d01c6b006d93061421daa1529e6f228a", "message": "Issue #1404: AclTree tests refactoring", "committedDate": "2020-11-19T12:45:38Z", "type": "forcePushed"}, {"oid": "d980bcdc57c70e9904ba8bd347fffb67c97b57ad", "url": "https://github.com/epam/cloud-pipeline/commit/d980bcdc57c70e9904ba8bd347fffb67c97b57ad", "message": "Issue #1404: added childrenById map for AclTree assertions", "committedDate": "2020-11-20T08:50:45Z", "type": "commit"}, {"oid": "1e455fcf504bd2da113b5a72e09f95fad57e7343", "url": "https://github.com/epam/cloud-pipeline/commit/1e455fcf504bd2da113b5a72e09f95fad57e7343", "message": "Issue #1404: Applied proposed refactoring to AclTree tests", "committedDate": "2020-11-27T15:27:20Z", "type": "commit"}, {"oid": "cd73dceefe7eb11454c128d83cf46ed8488dd779", "url": "https://github.com/epam/cloud-pipeline/commit/cd73dceefe7eb11454c128d83cf46ed8488dd779", "message": "Issue #1404: Added more test object to fix permission merging, improved the way returned data accessed from collections", "committedDate": "2020-11-30T15:05:51Z", "type": "commit"}]}