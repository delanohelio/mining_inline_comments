{"pr_number": 1546, "pr_title": "Issue #1405: Tests  for docker registry controller layer", "pr_createdAt": "2020-11-06T07:36:38Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1546", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5ODEwNQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519598105", "bodyText": "Let's add final here just in order to be consistent with all the new code.", "author": "tcibinan", "createdAt": "2020-11-09T07:25:08Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.tool;\n+\n+import com.epam.pipeline.entity.pipeline.Tool;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class ToolCreatorUtils {\n+\n+    private ToolCreatorUtils() {\n+\n+    }\n+\n+    public static Tool getTool() {\n+        Tool tool = new Tool();", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e409cb035fef4335817091948fb45020243c5b06", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java\nindex 7131b8ab8..f1762fcb1 100644\n--- a/api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java\n+++ b/api/src/test/java/com/epam/pipeline/test/creator/tool/ToolCreatorUtils.java\n\n@@ -16,7 +16,11 @@\n \n package com.epam.pipeline.test.creator.tool;\n \n+import com.epam.pipeline.controller.Result;\n import com.epam.pipeline.entity.pipeline.Tool;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import java.util.List;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MzgwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519653800", "bodyText": "I suppose we can move such type reference to common constants utils class.", "author": "tcibinan", "createdAt": "2020-11-09T09:12:07Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.Result;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    public static final TypeReference<Result<DockerRegistry>> DOCKER_REGISTRY_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistry>>() {};\n+    public static final TypeReference<Result<DockerRegistryList>> DOCKER_REGISTRY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<DockerRegistryList>>() {};\n+    public static final TypeReference<Result<Map<String, String>>> STRING_MAP_INSTANCE_TYPE =", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\nindex 6147cf969..6c574e475 100644\n--- a/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n+++ b/api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java\n\n@@ -17,37 +17,154 @@\n package com.epam.pipeline.test.creator.docker;\n \n import com.epam.pipeline.controller.Result;\n+<<<<<<< HEAD\n+import com.epam.pipeline.entity.docker.ImageDescription;\n+import com.epam.pipeline.entity.docker.ImageHistoryLayer;\n+import com.epam.pipeline.entity.docker.ToolDescription;\n+import com.epam.pipeline.entity.docker.ToolVersion;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.pipeline.ToolGroupWithIssues;\n+import com.epam.pipeline.entity.scan.ToolScanPolicy;\n+import com.epam.pipeline.entity.scan.ToolScanResultView;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResult;\n+import com.epam.pipeline.entity.scan.ToolVersionScanResultView;\n+import com.epam.pipeline.entity.tool.ToolSymlinkRequest;\n+=======\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+>>>>>>> Issue #1405: Implemented tests (except one) for docker registry controller layer\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import java.util.Collections;\n import java.util.List;\n+<<<<<<< HEAD\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+=======\n import java.util.Map;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+>>>>>>> Issue #1405: Implemented tests (except one) for docker registry controller layer\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n \n public final class DockerCreatorUtils {\n \n+<<<<<<< HEAD\n+    public static final TypeReference<Result<ImageDescription>> IMAGE_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ImageDescription>>() {};\n+    public static final TypeReference<Result<ToolDescription>> TOOL_DESCRIPTION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolDescription>>() {};\n+    public static final TypeReference<Result<ToolVersion>> TOOL_VERSION_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersion>>() {};\n+    public static final TypeReference<Result<List<ImageHistoryLayer>>> IMAGE_HISTORY_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ImageHistoryLayer>>>() {};\n+    public static final TypeReference<Result<List<ToolVersion>>> TOOL_VERSION_LIST_INSTANCE_TYPE =\n+            new TypeReference<Result<List<ToolVersion>>>() {};\n+    public static final TypeReference<Result<ToolVersionScanResult>> TOOL_VERSION_SCAN_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolVersionScanResult>>() {};\n+    public static final TypeReference<Result<ToolScanResultView>> SCAN_RESULT_VIEW_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanResultView>>() {};\n+    public static final TypeReference<Result<ToolScanPolicy>> TOOL_SCAN_POLICY_INSTANCE_TYPE =\n+            new TypeReference<Result<ToolScanPolicy>>() {};\n+    public static final TypeReference<Result<Tool>> TOOL_INSTANCE_TYPE = new TypeReference<Result<Tool>>() {};\n+    public static final TypeReference<Result<List<String>>> LIST_STRING_INSTANCE_TYPE =\n+            new TypeReference<Result<List<String>>>() {};\n+    public static final TypeReference<Result<ToolGroup>> TOOL_GROUP_TYPE =\n+            new TypeReference<Result<ToolGroup>>() {};\n+    public static final TypeReference<Result<ToolGroupWithIssues>> TOOL_GROUP_WITH_ISSUES_TYPE =\n+            new TypeReference<Result<ToolGroupWithIssues>>() {};\n+    public static final TypeReference<Result<List<ToolGroup>>> TOOL_GROUP_LIST_TYPE =\n+            new TypeReference<Result<List<ToolGroup>>>() {};\n+=======\n     public static final TypeReference<Result<DockerRegistry>> DOCKER_REGISTRY_INSTANCE_TYPE =\n-            new TypeReference<Result<DockerRegistry>>() {};\n+            new TypeReference<Result<DockerRegistry>>() {  };\n+    public static final TypeReference<Result<JwtRawToken>> JWT_RAW_TOKEN_INSTANCE_TYPE =\n+            new TypeReference<Result<JwtRawToken>>() {  };\n     public static final TypeReference<Result<DockerRegistryList>> DOCKER_REGISTRY_LIST_INSTANCE_TYPE =\n-            new TypeReference<Result<DockerRegistryList>>() {};\n+            new TypeReference<Result<DockerRegistryList>>() {  };\n     public static final TypeReference<Result<Map<String, String>>> STRING_MAP_INSTANCE_TYPE =\n-            new TypeReference<Result<Map<String, String>>>() {};\n+            new TypeReference<Result<Map<String, String>>>() {  };\n     public static final TypeReference<Result<List<Tool>>> TOOL_LIST_INSTANCE_TYPE =\n-            new TypeReference<Result<List<Tool>>>() {};\n+            new TypeReference<Result<List<Tool>>>() {  };\n+>>>>>>> Issue #1405: Implemented tests (except one) for docker registry controller layer\n \n     private DockerCreatorUtils() {\n \n     }\n \n+<<<<<<< HEAD\n+    public static ImageDescription getImageDescription() {\n+        return new ImageDescription();\n+    }\n+\n+    public static ImageHistoryLayer getImageHistoryLayer() {\n+        return new ImageHistoryLayer();\n+    }\n+\n+    public static ToolDescription getToolDescription() {\n+        return new ToolDescription();\n+    }\n+\n+    public static ToolVersion getToolVersion() {\n+        return new ToolVersion();\n+    }\n+\n+    public static ToolVersionScanResult getToolVersionScanResult() {\n+        final ToolVersionScanResult toolVersionScanResult = new ToolVersionScanResult();\n+        toolVersionScanResult.setToolId(ID);\n+        toolVersionScanResult.setVersion(TEST_STRING);\n+        toolVersionScanResult.setFromWhiteList(true);\n+        return toolVersionScanResult;\n+    }\n+\n+    public static ToolScanResultView getToolScanResultView() {\n+        return new ToolScanResultView(ID, Collections.singletonMap(TEST_STRING, getToolVersionScanResultView()));\n+    }\n+\n+    public static ToolVersionScanResultView getToolVersionScanResultView() {\n+        final ToolVersionScanResultView scanResultView = ToolVersionScanResultView.builder().build();\n+        return scanResultView;\n+    }\n+\n+    public static ToolScanPolicy getToolScanPolicy() {\n+        return new ToolScanPolicy();\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();\n+        tool.setId(ID);\n+        tool.setImage(TEST_STRING);\n+        tool.setCpu(TEST_STRING);\n+        tool.setRam(TEST_STRING);\n+        tool.setInstanceType(TEST_STRING);\n+        tool.setDisk(TEST_INT);\n+        return tool;\n+    }\n+\n+    public static ToolSymlinkRequest getToolSymlinkRequest() {\n+        return new ToolSymlinkRequest(ID, ID);\n+    }\n+\n+    public static ToolGroup getToolGroup() {\n+        return new ToolGroup();\n+    }\n+\n+    public static ToolGroupWithIssues getToolGroupWithIssues() {\n+        return new ToolGroupWithIssues();\n+=======\n+    public static DockerRegistry getDefaultDockerRegistry() {\n+        return new DockerRegistry();\n+\n+    }\n+\n     public static DockerRegistry getDockerRegistry() {\n-        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        DockerRegistry dockerRegistry = new DockerRegistry();\n         dockerRegistry.setPath(TEST_STRING);\n         dockerRegistry.setDescription(TEST_STRING);\n         dockerRegistry.setSecretName(TEST_STRING);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2ODUwOA==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519668508", "bodyText": "The type could be extracted to the existing security creator utils class.", "author": "tcibinan", "createdAt": "2020-11-09T09:35:13Z", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\nindex 7c1fe3fd5..579f3df5e 100644\n--- a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n+++ b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n\n@@ -16,7 +16,6 @@\n \n package com.epam.pipeline.controller.docker;\n \n-import com.epam.pipeline.config.JsonMapper;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3MDkwOQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519670909", "bodyText": "It could be extracted even if there is only a single call now because it can be reused later.", "author": "tcibinan", "createdAt": "2020-11-09T09:38:52Z", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\nindex 7c1fe3fd5..579f3df5e 100644\n--- a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n+++ b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n\n@@ -16,7 +16,6 @@\n \n package com.epam.pipeline.controller.docker;\n \n-import com.epam.pipeline.config.JsonMapper;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3NDA0NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519674045", "bodyText": "Probably we can use more accurate test name such as shouldDownloadRegistryCertificate.", "author": "tcibinan", "createdAt": "2020-11-09T09:43:52Z", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, DockerCreatorUtils.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, DockerCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadPipelineFile() throws Exception {", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\nindex 7c1fe3fd5..579f3df5e 100644\n--- a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n+++ b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n\n@@ -16,7 +16,6 @@\n \n package com.epam.pipeline.controller.docker;\n \n-import com.epam.pipeline.config.JsonMapper;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3NTU3NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r519675574", "bodyText": "Let's extract this downloading file parameters assertion to the abstract class. It definitely has a potential to be reused in other tests.", "author": "tcibinan", "createdAt": "2020-11-09T09:46:11Z", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.CERTIFICATE_NAME;\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                new TypeReference<JwtRawToken>() {});\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, DockerCreatorUtils.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, DockerCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadPipelineFile() throws Exception {\n+        doReturn(bytes).when(mockDockerRegistryApiService).getCertificateContent(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(CERT_REGISTRY_URL, ID)),\n+                OCTET_STREAM_CONTENT_TYPE);\n+\n+        verify(mockDockerRegistryApiService).getCertificateContent(ID);\n+        final byte[] actualByteArray = mvcResult.getResponse().getContentAsByteArray();\n+        final String contentDispositionHeader = mvcResult.getResponse().getHeader(CONTENT_DISPOSITION_HEADER);\n+        assertThat(actualByteArray).isEqualTo(bytes);\n+        assertThat(contentDispositionHeader).contains(CERTIFICATE_NAME);", "originalCommit": "4f3035559809c14069eb04f6f19c00838736a249", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\nindex 7c1fe3fd5..579f3df5e 100644\n--- a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n+++ b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n\n@@ -16,7 +16,6 @@\n \n package com.epam.pipeline.controller.docker;\n \n-import com.epam.pipeline.config.JsonMapper;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMTc1Mw==", "url": "https://github.com/epam/cloud-pipeline/pull/1546#discussion_r521221753", "bodyText": "Let's now extract both assertions into a single one like the following.\nassertFileResponse(mvcResult, fileName, fileContent);\nAlso let's use the added method in shouldDownloadConfigScript test as well.", "author": "tcibinan", "createdAt": "2020-11-11T09:20:17Z", "path": "api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.docker;\n+\n+import com.epam.pipeline.config.JsonMapper;\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryApiService;\n+import com.epam.pipeline.security.UserAccessService;\n+import com.epam.pipeline.security.UserContext;\n+import com.epam.pipeline.test.creator.CommonCreatorConstants;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.security.SecurityCreatorUtils;\n+import com.epam.pipeline.test.creator.tool.ToolCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.epam.pipeline.controller.docker.DockerRegistryController.DOCKER_LOGIN_SCRIPT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.refEq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = DockerRegistryController.class)\n+public class DockerRegistryControllerTest extends AbstractControllerTest {\n+\n+    private static final String DOCKER_REGISTRY_URL = SERVLET_PATH + \"/dockerRegistry\";\n+    private static final String REGISTER_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/register\";\n+    private static final String UPDATE_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/update\";\n+    private static final String UPDATE_DOCKER_REGISTRY_CREDS_URL = DOCKER_REGISTRY_URL + \"/updateCredentials\";\n+    private static final String OAUTH_DOCKER_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/oauth\";\n+    private static final String LOAD_TREE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadTree\";\n+    private static final String LOAD_CERTS_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/loadCerts\";\n+    private static final String LOAD_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%s/load\";\n+    private static final String DELETE_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/delete\";\n+    private static final String CERT_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/cert\";\n+    private static final String LOGIN_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/%d/login\";\n+    private static final String NOTIFY_REGISTRY_URL = DOCKER_REGISTRY_URL + \"/notify\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+\n+    private static final String CONTENT_DISPOSITION_HEADER = \"Content-Disposition\";\n+    private static final String FORCE = \"force\";\n+    private static final String TRUE_AS_STRING = String.valueOf(true);\n+    private static final String REGISTRY_PATH = \"Registry-Path\";\n+    private static final String SERVICE = \"service\";\n+    private static final String SCOPE = \"scope\";\n+    private final byte[] bytes = {1, 1, 1};\n+\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final JwtRawToken jwtRawToken = SecurityCreatorUtils.getJwtRawToken();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final UserContext userContext = SecurityCreatorUtils.getUserContext();\n+\n+    @Autowired\n+    private DockerRegistryApiService mockDockerRegistryApiService;\n+\n+    @Autowired\n+    private UserAccessService mockAccessService;\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldCreateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(REGISTER_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).create(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailCreateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(REGISTER_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistry() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistry);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistry(dockerRegistry);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldUpdateDockerRegistryCredentials() throws Exception {\n+        final String content = getObjectMapper().writeValueAsString(dockerRegistryVO);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService)\n+                .updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+\n+        final MvcResult mvcResult = performRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL).content(content));\n+\n+        verify(mockDockerRegistryApiService).updateDockerRegistryCredentials(refEq(dockerRegistryVO));\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailUpdateDockerRegistryCredentials() throws Exception {\n+        performUnauthorizedRequest(post(UPDATE_DOCKER_REGISTRY_CREDS_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        final String testNameAndPass = TEST_STRING + \":\" + TEST_STRING;\n+        final String encodedNameAndPass = new String(Base64.getEncoder()\n+                .encode(testNameAndPass.getBytes(StandardCharsets.UTF_8)));\n+        doReturn(userContext).when(mockAccessService).getJwtUser(any(), any());\n+        doReturn(jwtRawToken).when(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        final MvcResult mvcResult = performRequest(get(OAUTH_DOCKER_REGISTRY_URL)\n+                .header(\"Authorization\", \"Basic\" + encodedNameAndPass).params(params));\n+\n+        verify(mockDockerRegistryApiService)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+        final JwtRawToken actualResult = JsonMapper.parseData(mvcResult.getResponse().getContentAsString(),\n+                SecurityCreatorUtils.JWT_RAW_TOKEN_INSTANCE_TYPE);\n+        Assert.assertEquals(jwtRawToken, actualResult);\n+    }\n+\n+    @Test\n+    public void shouldFailOauthEndpoint() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(SERVICE, TEST_STRING);\n+        params.add(SCOPE, TEST_STRING);\n+        performUnauthorizedRequest(get(OAUTH_DOCKER_REGISTRY_URL).params(params));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistryContent() throws Exception {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).loadAllRegistriesContent();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_TREE_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).loadAllRegistriesContent();\n+        assertResponse(mvcResult, dockerRegistryList, DockerCreatorUtils.DOCKER_REGISTRY_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllRegistryContent() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_TREE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadRegistryCertificates() throws Exception {\n+        final Map<String, String> loadedCerts = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        doReturn(dockerRegistryList).when(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_CERTS_REGISTRY_URL));\n+\n+        verify(mockDockerRegistryApiService).listDockerRegistriesWithCerts();\n+        assertResponse(mvcResult, loadedCerts, CommonCreatorConstants.STRING_MAP_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadRegistryCertificates() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_CERTS_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() throws Exception {\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).load(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_REGISTRY_URL, ID)));\n+\n+        verify(mockDockerRegistryApiService).load(ID);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDeleteDockerRegistry() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(FORCE, TRUE_AS_STRING);\n+        doReturn(dockerRegistry).when(mockDockerRegistryApiService).delete(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(DELETE_REGISTRY_URL, ID)).params(params));\n+\n+        verify(mockDockerRegistryApiService).delete(ID, true);\n+        assertResponse(mvcResult, dockerRegistry, DockerCreatorUtils.DOCKER_REGISTRY_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDeleteDockerRegistry() throws Exception {\n+        performUnauthorizedRequest(delete(DELETE_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldNotifyRegistryEvents() throws Exception {\n+        final Tool tool = ToolCreatorUtils.getTool();\n+        final List<Tool> tools = Collections.singletonList(tool);\n+        final String content = getObjectMapper().writeValueAsString(eventEnvelope);\n+        doReturn(tools).when(mockDockerRegistryApiService)\n+                .notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+\n+        final MvcResult mvcResult = performRequest(\n+                post(NOTIFY_REGISTRY_URL).header(REGISTRY_PATH, TEST_STRING).content(content));\n+\n+        verify(mockDockerRegistryApiService).notifyDockerRegistryEvents(eq(TEST_STRING), refEq(eventEnvelope));\n+        assertResponse(mvcResult, tools, ToolCreatorUtils.TOOL_LIST_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailNotifyRegistryEvents() throws Exception {\n+        performUnauthorizedRequest(get(NOTIFY_REGISTRY_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadRegistryCertificate() throws Exception {\n+        doReturn(bytes).when(mockDockerRegistryApiService).getCertificateContent(ID);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(CERT_REGISTRY_URL, ID)),\n+                OCTET_STREAM_CONTENT_TYPE);\n+\n+        verify(mockDockerRegistryApiService).getCertificateContent(ID);\n+        final byte[] actualByteArray = mvcResult.getResponse().getContentAsByteArray();\n+        assertThat(actualByteArray).isEqualTo(bytes);\n+        assertResponseHeader(mvcResult, CONTENT_DISPOSITION_HEADER, CERTIFICATE_NAME);", "originalCommit": "bddab1c9c769bde63cf36fca027ab8fbfeb12ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "chunk": "diff --git a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\nindex c55572117..579f3df5e 100644\n--- a/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n+++ b/api/src/test/java/com/epam/pipeline/controller/docker/DockerRegistryControllerTest.java\n\n@@ -16,7 +16,6 @@\n \n package com.epam.pipeline.controller.docker;\n \n-import com.epam.pipeline.config.JsonMapper;\n import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n"}}, {"oid": "d71ba9ea05dce1aaa382def626a41682ef8097b0", "url": "https://github.com/epam/cloud-pipeline/commit/d71ba9ea05dce1aaa382def626a41682ef8097b0", "message": "Issue #1405: Implemented tests (except one) for docker registry controller layer\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:36:32Z", "type": "commit"}, {"oid": "cc13ae7783e9f255c479b3b2dda5446fc6dc68d8", "url": "https://github.com/epam/cloud-pipeline/commit/cc13ae7783e9f255c479b3b2dda5446fc6dc68d8", "message": "Issue #1405: Implemented tests for docker registry controller layer\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:36:53Z", "type": "commit"}, {"oid": "e409cb035fef4335817091948fb45020243c5b06", "url": "https://github.com/epam/cloud-pipeline/commit/e409cb035fef4335817091948fb45020243c5b06", "message": "Issue #1405: Improvements and fixes in accordance with comments\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:37:59Z", "type": "commit"}, {"oid": "a6db09c64d7220fdd588a62566c1934322bd2b73", "url": "https://github.com/epam/cloud-pipeline/commit/a6db09c64d7220fdd588a62566c1934322bd2b73", "message": "Issue #1405: Extracting headers assertion to the abstract class\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:38:17Z", "type": "commit"}, {"oid": "fe3c2b2991609a1c855df1d1d8847bd7f07173e9", "url": "https://github.com/epam/cloud-pipeline/commit/fe3c2b2991609a1c855df1d1d8847bd7f07173e9", "message": "Issue #1405: Added assertion method to the abstract class\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:38:45Z", "type": "commit"}, {"oid": "d542db4e2796805e7c15f543c4d16f7cc35348a6", "url": "https://github.com/epam/cloud-pipeline/commit/d542db4e2796805e7c15f543c4d16f7cc35348a6", "message": "Issue #1405: Fix assertion method\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T13:40:47Z", "type": "commit"}, {"oid": "fd0cf27c15eb5b41ed3c8e5860704560850c8c2f", "url": "https://github.com/epam/cloud-pipeline/commit/fd0cf27c15eb5b41ed3c8e5860704560850c8c2f", "message": "Issue #1405: Branch rebased, merge conflicts resolved\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T14:09:09Z", "type": "commit"}, {"oid": "fd0cf27c15eb5b41ed3c8e5860704560850c8c2f", "url": "https://github.com/epam/cloud-pipeline/commit/fd0cf27c15eb5b41ed3c8e5860704560850c8c2f", "message": "Issue #1405: Branch rebased, merge conflicts resolved\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-11-16T14:09:09Z", "type": "forcePushed"}]}