{"pr_number": 6867, "pr_title": "tackled some class<?> newInstance depeated, and some code refactor", "pr_createdAt": "2020-11-03T08:30:46Z", "pr_url": "https://github.com/apache/dubbo/pull/6867", "timeline": [{"oid": "0fd0a0d8e2d85ed327440e78101f5e65191ad8f5", "url": "https://github.com/apache/dubbo/commit/0fd0a0d8e2d85ed327440e78101f5e65191ad8f5", "message": "refactor: class<?> newInstance depeated tackled, and some code refactor\n\nSigned-off-by: licho <lecho.sun@gmail.com>", "committedDate": "2020-11-03T02:34:06Z", "type": "commit"}, {"oid": "bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "url": "https://github.com/apache/dubbo/commit/bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "message": "Merge branch 'master' into master", "committedDate": "2021-03-20T06:28:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM3MDU4Nw==", "url": "https://github.com/apache/dubbo/pull/6867#discussion_r598370587", "bodyText": "Pls recover end-line format of this file", "author": "AlbumenJ", "createdAt": "2021-03-22T01:03:32Z", "path": "dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java", "diffHunk": "@@ -1,445 +1,445 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package org.apache.dubbo.common.compiler.support;\r\n-\r\n-import org.apache.dubbo.common.utils.StringUtils;\r\n-\r\n-import java.io.PrintWriter;\r\n-import java.io.StringWriter;\r\n-import java.lang.reflect.Array;\r\n-import java.lang.reflect.GenericArrayType;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.ParameterizedType;\r\n-import java.lang.reflect.Type;\r\n-import java.lang.reflect.TypeVariable;\r\n-import java.net.URI;\r\n-import java.net.URISyntaxException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * ClassUtils. (Tool, Static, ThreadSafe)\r\n- */\r\n-public class ClassUtils {\r\n-\r\n-    public static final String CLASS_EXTENSION = \".class\";\r\n-\r\n-    public static final String JAVA_EXTENSION = \".java\";\r\n-    private static final int JIT_LIMIT = 5 * 1024;\r\n-\r\n-    private ClassUtils() {\r\n-    }\r\n-\r\n-    public static Object newInstance(String name) {\r\n-        try {\r\n-            return forName(name).newInstance();\r\n-        } catch (InstantiationException | IllegalAccessException e) {\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> forName(String[] packages, String className) {\r\n-        try {\r\n-            return classForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            if (packages != null && packages.length > 0) {\r\n-                for (String pkg : packages) {\r\n-                    try {\r\n-                        return classForName(pkg + \".\" + className);\r\n-                    } catch (ClassNotFoundException e2) {\r\n-                    }\r\n-                }\r\n-            }\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> forName(String className) {\r\n-        try {\r\n-            return classForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new IllegalStateException(e.getMessage(), e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> classForName(String className) throws ClassNotFoundException {\r\n-        switch (className) {\r\n-            case \"boolean\":\r\n-                return boolean.class;\r\n-            case \"byte\":\r\n-                return byte.class;\r\n-            case \"char\":\r\n-                return char.class;\r\n-            case \"short\":\r\n-                return short.class;\r\n-            case \"int\":\r\n-                return int.class;\r\n-            case \"long\":\r\n-                return long.class;\r\n-            case \"float\":\r\n-                return float.class;\r\n-            case \"double\":\r\n-                return double.class;\r\n-            case \"boolean[]\":\r\n-                return boolean[].class;\r\n-            case \"byte[]\":\r\n-                return byte[].class;\r\n-            case \"char[]\":\r\n-                return char[].class;\r\n-            case \"short[]\":\r\n-                return short[].class;\r\n-            case \"int[]\":\r\n-                return int[].class;\r\n-            case \"long[]\":\r\n-                return long[].class;\r\n-            case \"float[]\":\r\n-                return float[].class;\r\n-            case \"double[]\":\r\n-                return double[].class;\r\n-            default:\r\n-        }\r\n-        try {\r\n-            return arrayForName(className);\r\n-        } catch (ClassNotFoundException e) {\r\n-            // try to load from java.lang package\r\n-            if (className.indexOf('.') == -1) {\r\n-                try {\r\n-                    return arrayForName(\"java.lang.\" + className);\r\n-                } catch (ClassNotFoundException e2) {\r\n-                    // ignore, let the original exception be thrown\r\n-                }\r\n-            }\r\n-            throw e;\r\n-        }\r\n-    }\r\n-\r\n-    private static Class<?> arrayForName(String className) throws ClassNotFoundException {\r\n-        return Class.forName(className.endsWith(\"[]\")\r\n-                ? \"[L\" + className.substring(0, className.length() - 2) + \";\"\r\n-                : className, true, Thread.currentThread().getContextClassLoader());\r\n-    }\r\n-\r\n-    public static Class<?> getBoxedClass(Class<?> type) {\r\n-        if (type == boolean.class) {\r\n-            return Boolean.class;\r\n-        } else if (type == char.class) {\r\n-            return Character.class;\r\n-        } else if (type == byte.class) {\r\n-            return Byte.class;\r\n-        } else if (type == short.class) {\r\n-            return Short.class;\r\n-        } else if (type == int.class) {\r\n-            return Integer.class;\r\n-        } else if (type == long.class) {\r\n-            return Long.class;\r\n-        } else if (type == float.class) {\r\n-            return Float.class;\r\n-        } else if (type == double.class) {\r\n-            return Double.class;\r\n-        } else {\r\n-            return type;\r\n-        }\r\n-    }\r\n-\r\n-    public static Boolean boxed(boolean v) {\r\n-        return Boolean.valueOf(v);\r\n-    }\r\n-\r\n-    public static Character boxed(char v) {\r\n-        return Character.valueOf(v);\r\n-    }\r\n-\r\n-    public static Byte boxed(byte v) {\r\n-        return Byte.valueOf(v);\r\n-    }\r\n-\r\n-    public static Short boxed(short v) {\r\n-        return Short.valueOf(v);\r\n-    }\r\n-\r\n-    public static Integer boxed(int v) {\r\n-        return Integer.valueOf(v);\r\n-    }\r\n-\r\n-    public static Long boxed(long v) {\r\n-        return Long.valueOf(v);\r\n-    }\r\n-\r\n-    public static Float boxed(float v) {\r\n-        return Float.valueOf(v);\r\n-    }\r\n-\r\n-    public static Double boxed(double v) {\r\n-        return Double.valueOf(v);\r\n-    }\r\n-\r\n-    public static Object boxed(Object v) {\r\n-        return v;\r\n-    }\r\n-\r\n-    public static boolean unboxed(Boolean v) {\r\n-        return v == null ? false : v.booleanValue();\r\n-    }\r\n-\r\n-    public static char unboxed(Character v) {\r\n-        return v == null ? '\\0' : v.charValue();\r\n-    }\r\n-\r\n-    public static byte unboxed(Byte v) {\r\n-        return v == null ? 0 : v.byteValue();\r\n-    }\r\n-\r\n-    public static short unboxed(Short v) {\r\n-        return v == null ? 0 : v.shortValue();\r\n-    }\r\n-\r\n-    public static int unboxed(Integer v) {\r\n-        return v == null ? 0 : v.intValue();\r\n-    }\r\n-\r\n-    public static long unboxed(Long v) {\r\n-        return v == null ? 0 : v.longValue();\r\n-    }\r\n-\r\n-    public static float unboxed(Float v) {\r\n-        return v == null ? 0 : v.floatValue();\r\n-    }\r\n-\r\n-    public static double unboxed(Double v) {\r\n-        return v == null ? 0 : v.doubleValue();\r\n-    }\r\n-\r\n-    public static Object unboxed(Object v) {\r\n-        return v;\r\n-    }\r\n-\r\n-    public static boolean isNotEmpty(Object object) {\r\n-        return getSize(object) > 0;\r\n-    }\r\n-\r\n-    public static int getSize(Object object) {\r\n-        if (object == null) {\r\n-            return 0;\r\n-        }\r\n-        if (object instanceof Collection<?>) {\r\n-            return ((Collection<?>) object).size();\r\n-        } else if (object instanceof Map<?, ?>) {\r\n-            return ((Map<?, ?>) object).size();\r\n-        } else if (object.getClass().isArray()) {\r\n-            return Array.getLength(object);\r\n-        } else {\r\n-            return -1;\r\n-        }\r\n-    }\r\n-\r\n-    public static URI toURI(String name) {\r\n-        try {\r\n-            return new URI(name);\r\n-        } catch (URISyntaxException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-    }\r\n-\r\n-    public static Class<?> getGenericClass(Class<?> cls) {\r\n-        return getGenericClass(cls, 0);\r\n-    }\r\n-\r\n-    public static Class<?> getGenericClass(Class<?> cls, int i) {\r\n-        try {\r\n-            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\r\n-            Object genericClass = parameterizedType.getActualTypeArguments()[i];\r\n-            if (genericClass instanceof ParameterizedType) {\r\n-                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\r\n-            } else if (genericClass instanceof GenericArrayType) {\r\n-                Type type = ((GenericArrayType) genericClass).getGenericComponentType();\r\n-                if (type instanceof TypeVariable) {\r\n-                    return type.getClass();\r\n-                }\r\n-                return (((GenericArrayType) genericClass).getGenericComponentType() instanceof Class<?>)\r\n-                        ? (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType()\r\n-                        : ((GenericArrayType) genericClass).getGenericComponentType().getClass();\r\n-            } else if (genericClass != null) {\r\n-                if (genericClass instanceof TypeVariable) {\r\n-                    return genericClass.getClass();\r\n-                }\r\n-                return (Class<?>) genericClass;\r\n-            }\r\n-        } catch (Throwable e) {\r\n-\r\n-        }\r\n-        if (cls.getSuperclass() != null) {\r\n-            return getGenericClass(cls.getSuperclass(), i);\r\n-        } else {\r\n-            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\");\r\n-        }\r\n-    }\r\n-\r\n-    public static boolean isBeforeJava5(String javaVersion) {\r\n-        return (StringUtils.isEmpty(javaVersion) || \"1.0\".equals(javaVersion)\r\n-                || \"1.1\".equals(javaVersion) || \"1.2\".equals(javaVersion)\r\n-                || \"1.3\".equals(javaVersion) || \"1.4\".equals(javaVersion));\r\n-    }\r\n-\r\n-    public static boolean isBeforeJava6(String javaVersion) {\r\n-        return isBeforeJava5(javaVersion) || \"1.5\".equals(javaVersion);\r\n-    }\r\n-\r\n-    public static String toString(Throwable e) {\r\n-        StringWriter w = new StringWriter();\r\n-        PrintWriter p = new PrintWriter(w);\r\n-        p.print(e.getClass().getName() + \": \");\r\n-        if (e.getMessage() != null) {\r\n-            p.print(e.getMessage() + \"\\n\");\r\n-        }\r\n-        p.println();\r\n-        try {\r\n-            e.printStackTrace(p);\r\n-            return w.toString();\r\n-        } finally {\r\n-            p.close();\r\n-        }\r\n-    }\r\n-\r\n-    public static void checkBytecode(String name, byte[] bytecode) {\r\n-        if (bytecode.length > JIT_LIMIT) {\r\n-            System.err.println(\"The template bytecode too long, may be affect the JIT compiler. template class: \" + name);\r\n-        }\r\n-    }\r\n-\r\n-    public static String getSizeMethod(Class<?> cls) {\r\n-        try {\r\n-            return cls.getMethod(\"size\", new Class<?>[0]).getName() + \"()\";\r\n-        } catch (NoSuchMethodException e) {\r\n-            try {\r\n-                return cls.getMethod(\"length\", new Class<?>[0]).getName() + \"()\";\r\n-            } catch (NoSuchMethodException e2) {\r\n-                try {\r\n-                    return cls.getMethod(\"getSize\", new Class<?>[0]).getName() + \"()\";\r\n-                } catch (NoSuchMethodException e3) {\r\n-                    try {\r\n-                        return cls.getMethod(\"getLength\", new Class<?>[0]).getName() + \"()\";\r\n-                    } catch (NoSuchMethodException e4) {\r\n-                        return null;\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {\r\n-        if (method.getParameterTypes().length > parameterClasses.length) {\r\n-            Class<?>[] types = method.getParameterTypes();\r\n-            StringBuilder buf = new StringBuilder(rightCode);\r\n-            for (int i = parameterClasses.length; i < types.length; i++) {\r\n-                if (buf.length() > 0) {\r\n-                    buf.append(\",\");\r\n-                }\r\n-                Class<?> type = types[i];\r\n-                String def;\r\n-                if (type == boolean.class) {\r\n-                    def = \"false\";\r\n-                } else if (type == char.class) {\r\n-                    def = \"\\'\\\\0\\'\";\r\n-                } else if (type == byte.class\r\n-                        || type == short.class\r\n-                        || type == int.class\r\n-                        || type == long.class\r\n-                        || type == float.class\r\n-                        || type == double.class) {\r\n-                    def = \"0\";\r\n-                } else {\r\n-                    def = \"null\";\r\n-                }\r\n-                buf.append(def);\r\n-            }\r\n-        }\r\n-        return method.getName() + \"(\" + rightCode + \")\";\r\n-    }\r\n-\r\n-    public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {\r\n-        if (currentClass == null) {\r\n-            throw new NoSuchMethodException(\"class == null\");\r\n-        }\r\n-        try {\r\n-            return currentClass.getMethod(name, parameterTypes);\r\n-        } catch (NoSuchMethodException e) {\r\n-            for (Method method : currentClass.getMethods()) {\r\n-                if (method.getName().equals(name)\r\n-                        && parameterTypes.length == method.getParameterTypes().length\r\n-                        && Modifier.isPublic(method.getModifiers())) {\r\n-                    if (parameterTypes.length > 0) {\r\n-                        Class<?>[] types = method.getParameterTypes();\r\n-                        boolean match = true;\r\n-                        for (int i = 0; i < parameterTypes.length; i++) {\r\n-                            if (!types[i].isAssignableFrom(parameterTypes[i])) {\r\n-                                match = false;\r\n-                                break;\r\n-                            }\r\n-                        }\r\n-                        if (!match) {\r\n-                            continue;\r\n-                        }\r\n-                    }\r\n-                    return method;\r\n-                }\r\n-            }\r\n-            throw e;\r\n-        }\r\n-    }\r\n-\r\n-    public static String getInitCode(Class<?> type) {\r\n-        if (byte.class.equals(type)\r\n-                || short.class.equals(type)\r\n-                || int.class.equals(type)\r\n-                || long.class.equals(type)\r\n-                || float.class.equals(type)\r\n-                || double.class.equals(type)) {\r\n-            return \"0\";\r\n-        } else if (char.class.equals(type)) {\r\n-            return \"'\\\\0'\";\r\n-        } else if (boolean.class.equals(type)) {\r\n-            return \"false\";\r\n-        } else {\r\n-            return \"null\";\r\n-        }\r\n-    }\r\n-\r\n-    public static <K, V> Map<K, V> toMap(Map.Entry<K, V>[] entries) {\r\n-        Map<K, V> map = new HashMap<K, V>();\r\n-        if (entries != null && entries.length > 0) {\r\n-            for (Map.Entry<K, V> entry : entries) {\r\n-                map.put(entry.getKey(), entry.getValue());\r\n-            }\r\n-        }\r\n-        return map;\r\n-    }\r\n-    \r\n-    /**\r\n-     * get simple class name from qualified class name\r\n-     */\r\n-    public static String getSimpleClassName(String qualifiedName) {\r\n-        if (null == qualifiedName) {\r\n-            return null;\r\n-        }\r\n-        \r\n-        int i = qualifiedName.lastIndexOf('.');\r\n-        return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);\r\n-    }\r\n-\r\n-}\r\n+/*", "originalCommit": "bf9b55d55aea25f20d8f7c3a4e877b22f06b718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM5MDQ2Mw==", "url": "https://github.com/apache/dubbo/pull/6867#discussion_r598390463", "bodyText": "it's CRLF to LF problem. recover it already.", "author": "leechor", "createdAt": "2021-03-22T02:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODM3MDU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5540ddd216148cc6d65c8929aa660b780b925578", "chunk": "diff --git a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\nindex f0ecf6799..d09afadcc 100644\n--- a/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\n+++ b/dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/ClassUtils.java\n\n@@ -1,445 +1,445 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.dubbo.common.compiler.support;\n-\n-import org.apache.dubbo.common.utils.StringUtils;\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * ClassUtils. (Tool, Static, ThreadSafe)\n- */\n-public class ClassUtils {\n-\n-    public static final String CLASS_EXTENSION = \".class\";\n-\n-    public static final String JAVA_EXTENSION = \".java\";\n-    private static final int JIT_LIMIT = 5 * 1024;\n-\n-    private ClassUtils() {\n-    }\n-\n-    public static Object newInstance(String name) {\n-        try {\n-            return forName(name).getDeclaredConstructor().newInstance();\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n-            throw new IllegalStateException(e.getMessage(), e);\n-        }\n-    }\n-\n-    public static Class<?> forName(String[] packages, String className) {\n-        try {\n-            return classForName(className);\n-        } catch (ClassNotFoundException e) {\n-            if (packages != null && packages.length > 0) {\n-                for (String pkg : packages) {\n-                    try {\n-                        return classForName(pkg + \".\" + className);\n-                    } catch (ClassNotFoundException ignore) {\n-                    }\n-                }\n-            }\n-            throw new IllegalStateException(e.getMessage(), e);\n-        }\n-    }\n-\n-    public static Class<?> forName(String className) {\n-        try {\n-            return classForName(className);\n-        } catch (ClassNotFoundException e) {\n-            throw new IllegalStateException(e.getMessage(), e);\n-        }\n-    }\n-\n-    public static Class<?> classForName(String className) throws ClassNotFoundException {\n-        switch (className) {\n-            case \"boolean\":\n-                return boolean.class;\n-            case \"byte\":\n-                return byte.class;\n-            case \"char\":\n-                return char.class;\n-            case \"short\":\n-                return short.class;\n-            case \"int\":\n-                return int.class;\n-            case \"long\":\n-                return long.class;\n-            case \"float\":\n-                return float.class;\n-            case \"double\":\n-                return double.class;\n-            case \"boolean[]\":\n-                return boolean[].class;\n-            case \"byte[]\":\n-                return byte[].class;\n-            case \"char[]\":\n-                return char[].class;\n-            case \"short[]\":\n-                return short[].class;\n-            case \"int[]\":\n-                return int[].class;\n-            case \"long[]\":\n-                return long[].class;\n-            case \"float[]\":\n-                return float[].class;\n-            case \"double[]\":\n-                return double[].class;\n-            default:\n-        }\n-        try {\n-            return arrayForName(className);\n-        } catch (ClassNotFoundException e) {\n-            // try to load from java.lang package\n-            if (className.indexOf('.') == -1) {\n-                try {\n-                    return arrayForName(\"java.lang.\" + className);\n-                } catch (ClassNotFoundException ignore) {\n-                    // ignore, let the original exception be thrown\n-                }\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    private static Class<?> arrayForName(String className) throws ClassNotFoundException {\n-        return Class.forName(className.endsWith(\"[]\")\n-                ? \"[L\" + className.substring(0, className.length() - 2) + \";\"\n-                : className, true, Thread.currentThread().getContextClassLoader());\n-    }\n-\n-    public static Class<?> getBoxedClass(Class<?> type) {\n-        if (type == boolean.class) {\n-            return Boolean.class;\n-        } else if (type == char.class) {\n-            return Character.class;\n-        } else if (type == byte.class) {\n-            return Byte.class;\n-        } else if (type == short.class) {\n-            return Short.class;\n-        } else if (type == int.class) {\n-            return Integer.class;\n-        } else if (type == long.class) {\n-            return Long.class;\n-        } else if (type == float.class) {\n-            return Float.class;\n-        } else if (type == double.class) {\n-            return Double.class;\n-        } else {\n-            return type;\n-        }\n-    }\n-\n-    public static Boolean boxed(boolean v) {\n-        return Boolean.valueOf(v);\n-    }\n-\n-    public static Character boxed(char v) {\n-        return Character.valueOf(v);\n-    }\n-\n-    public static Byte boxed(byte v) {\n-        return Byte.valueOf(v);\n-    }\n-\n-    public static Short boxed(short v) {\n-        return Short.valueOf(v);\n-    }\n-\n-    public static Integer boxed(int v) {\n-        return Integer.valueOf(v);\n-    }\n-\n-    public static Long boxed(long v) {\n-        return Long.valueOf(v);\n-    }\n-\n-    public static Float boxed(float v) {\n-        return Float.valueOf(v);\n-    }\n-\n-    public static Double boxed(double v) {\n-        return Double.valueOf(v);\n-    }\n-\n-    public static Object boxed(Object v) {\n-        return v;\n-    }\n-\n-    public static boolean unboxed(Boolean v) {\n-        return v == null ? false : v.booleanValue();\n-    }\n-\n-    public static char unboxed(Character v) {\n-        return v == null ? '\\0' : v.charValue();\n-    }\n-\n-    public static byte unboxed(Byte v) {\n-        return v == null ? 0 : v.byteValue();\n-    }\n-\n-    public static short unboxed(Short v) {\n-        return v == null ? 0 : v.shortValue();\n-    }\n-\n-    public static int unboxed(Integer v) {\n-        return v == null ? 0 : v.intValue();\n-    }\n-\n-    public static long unboxed(Long v) {\n-        return v == null ? 0 : v.longValue();\n-    }\n-\n-    public static float unboxed(Float v) {\n-        return v == null ? 0 : v.floatValue();\n-    }\n-\n-    public static double unboxed(Double v) {\n-        return v == null ? 0 : v.doubleValue();\n-    }\n-\n-    public static Object unboxed(Object v) {\n-        return v;\n-    }\n-\n-    public static boolean isNotEmpty(Object object) {\n-        return getSize(object) > 0;\n-    }\n-\n-    public static int getSize(Object object) {\n-        if (object == null) {\n-            return 0;\n-        }\n-        if (object instanceof Collection<?>) {\n-            return ((Collection<?>) object).size();\n-        } else if (object instanceof Map<?, ?>) {\n-            return ((Map<?, ?>) object).size();\n-        } else if (object.getClass().isArray()) {\n-            return Array.getLength(object);\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    public static URI toURI(String name) {\n-        try {\n-            return new URI(name);\n-        } catch (URISyntaxException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static Class<?> getGenericClass(Class<?> cls) {\n-        return getGenericClass(cls, 0);\n-    }\n-\n-    public static Class<?> getGenericClass(Class<?> cls, int i) {\n-        try {\n-            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\n-            Object genericClass = parameterizedType.getActualTypeArguments()[i];\n-            if (genericClass instanceof ParameterizedType) {\n-                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\n-            } else if (genericClass instanceof GenericArrayType) {\n-                Type type = ((GenericArrayType) genericClass).getGenericComponentType();\n-                if (type instanceof TypeVariable) {\n-                    return type.getClass();\n-                }\n-                return (((GenericArrayType) genericClass).getGenericComponentType() instanceof Class<?>)\n-                        ? (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType()\n-                        : ((GenericArrayType) genericClass).getGenericComponentType().getClass();\n-            } else if (genericClass != null) {\n-                if (genericClass instanceof TypeVariable) {\n-                    return genericClass.getClass();\n-                }\n-                return (Class<?>) genericClass;\n-            }\n-        } catch (Throwable e) {\n-\n-        }\n-        if (cls.getSuperclass() != null) {\n-            return getGenericClass(cls.getSuperclass(), i);\n-        } else {\n-            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\");\n-        }\n-    }\n-\n-    public static boolean isBeforeJava5(String javaVersion) {\n-        return (StringUtils.isEmpty(javaVersion) || \"1.0\".equals(javaVersion)\n-                || \"1.1\".equals(javaVersion) || \"1.2\".equals(javaVersion)\n-                || \"1.3\".equals(javaVersion) || \"1.4\".equals(javaVersion));\n-    }\n-\n-    public static boolean isBeforeJava6(String javaVersion) {\n-        return isBeforeJava5(javaVersion) || \"1.5\".equals(javaVersion);\n-    }\n-\n-    public static String toString(Throwable e) {\n-        StringWriter w = new StringWriter();\n-        PrintWriter p = new PrintWriter(w);\n-        p.print(e.getClass().getName() + \": \");\n-        if (e.getMessage() != null) {\n-            p.print(e.getMessage() + \"\\n\");\n-        }\n-        p.println();\n-        try {\n-            e.printStackTrace(p);\n-            return w.toString();\n-        } finally {\n-            p.close();\n-        }\n-    }\n-\n-    public static void checkBytecode(String name, byte[] bytecode) {\n-        if (bytecode.length > JIT_LIMIT) {\n-            System.err.println(\"The template bytecode too long, may be affect the JIT compiler. template class: \" + name);\n-        }\n-    }\n-\n-    public static String getSizeMethod(Class<?> cls) {\n-        try {\n-            return cls.getMethod(\"size\", new Class<?>[0]).getName() + \"()\";\n-        } catch (NoSuchMethodException e) {\n-            try {\n-                return cls.getMethod(\"length\", new Class<?>[0]).getName() + \"()\";\n-            } catch (NoSuchMethodException e2) {\n-                try {\n-                    return cls.getMethod(\"getSize\", new Class<?>[0]).getName() + \"()\";\n-                } catch (NoSuchMethodException e3) {\n-                    try {\n-                        return cls.getMethod(\"getLength\", new Class<?>[0]).getName() + \"()\";\n-                    } catch (NoSuchMethodException e4) {\n-                        return null;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {\n-        if (method.getParameterTypes().length > parameterClasses.length) {\n-            Class<?>[] types = method.getParameterTypes();\n-            StringBuilder buf = new StringBuilder(rightCode);\n-            for (int i = parameterClasses.length; i < types.length; i++) {\n-                if (buf.length() > 0) {\n-                    buf.append(\",\");\n-                }\n-                Class<?> type = types[i];\n-                String def;\n-                if (type == boolean.class) {\n-                    def = \"false\";\n-                } else if (type == char.class) {\n-                    def = \"\\'\\\\0\\'\";\n-                } else if (type == byte.class\n-                        || type == short.class\n-                        || type == int.class\n-                        || type == long.class\n-                        || type == float.class\n-                        || type == double.class) {\n-                    def = \"0\";\n-                } else {\n-                    def = \"null\";\n-                }\n-                buf.append(def);\n-            }\n-        }\n-        return method.getName() + \"(\" + rightCode + \")\";\n-    }\n-\n-    public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {\n-        if (currentClass == null) {\n-            throw new NoSuchMethodException(\"class == null\");\n-        }\n-        try {\n-            return currentClass.getMethod(name, parameterTypes);\n-        } catch (NoSuchMethodException e) {\n-            for (Method method : currentClass.getMethods()) {\n-                if (method.getName().equals(name)\n-                        && parameterTypes.length == method.getParameterTypes().length\n-                        && Modifier.isPublic(method.getModifiers())) {\n-                    if (parameterTypes.length > 0) {\n-                        Class<?>[] types = method.getParameterTypes();\n-                        boolean match = true;\n-                        for (int i = 0; i < parameterTypes.length; i++) {\n-                            if (!types[i].isAssignableFrom(parameterTypes[i])) {\n-                                match = false;\n-                                break;\n-                            }\n-                        }\n-                        if (!match) {\n-                            continue;\n-                        }\n-                    }\n-                    return method;\n-                }\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    public static String getInitCode(Class<?> type) {\n-        if (byte.class.equals(type)\n-                || short.class.equals(type)\n-                || int.class.equals(type)\n-                || long.class.equals(type)\n-                || float.class.equals(type)\n-                || double.class.equals(type)) {\n-            return \"0\";\n-        } else if (char.class.equals(type)) {\n-            return \"'\\\\0'\";\n-        } else if (boolean.class.equals(type)) {\n-            return \"false\";\n-        } else {\n-            return \"null\";\n-        }\n-    }\n-\n-    public static <K, V> Map<K, V> toMap(Map.Entry<K, V>[] entries) {\n-        Map<K, V> map = new HashMap<K, V>();\n-        if (entries != null && entries.length > 0) {\n-            for (Map.Entry<K, V> entry : entries) {\n-                map.put(entry.getKey(), entry.getValue());\n-            }\n-        }\n-        return map;\n-    }\n-\n-    /**\n-     * get simple class name from qualified class name\n-     */\n-    public static String getSimpleClassName(String qualifiedName) {\n-        if (null == qualifiedName) {\n-            return null;\n-        }\n-        int i = qualifiedName.lastIndexOf('.');\n-        return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.dubbo.common.compiler.support;\n+\n+import org.apache.dubbo.common.utils.StringUtils;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * ClassUtils. (Tool, Static, ThreadSafe)\n+ */\n+public class ClassUtils {\n+\n+    public static final String CLASS_EXTENSION = \".class\";\n+\n+    public static final String JAVA_EXTENSION = \".java\";\n+    private static final int JIT_LIMIT = 5 * 1024;\n+\n+    private ClassUtils() {\n+    }\n+\n+    public static Object newInstance(String name) {\n+        try {\n+            return forName(name).getDeclaredConstructor().newInstance();\n+        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+            throw new IllegalStateException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static Class<?> forName(String[] packages, String className) {\n+        try {\n+            return classForName(className);\n+        } catch (ClassNotFoundException e) {\n+            if (packages != null && packages.length > 0) {\n+                for (String pkg : packages) {\n+                    try {\n+                        return classForName(pkg + \".\" + className);\n+                    } catch (ClassNotFoundException ignore) {\n+                    }\n+                }\n+            }\n+            throw new IllegalStateException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static Class<?> forName(String className) {\n+        try {\n+            return classForName(className);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static Class<?> classForName(String className) throws ClassNotFoundException {\n+        switch (className) {\n+            case \"boolean\":\n+                return boolean.class;\n+            case \"byte\":\n+                return byte.class;\n+            case \"char\":\n+                return char.class;\n+            case \"short\":\n+                return short.class;\n+            case \"int\":\n+                return int.class;\n+            case \"long\":\n+                return long.class;\n+            case \"float\":\n+                return float.class;\n+            case \"double\":\n+                return double.class;\n+            case \"boolean[]\":\n+                return boolean[].class;\n+            case \"byte[]\":\n+                return byte[].class;\n+            case \"char[]\":\n+                return char[].class;\n+            case \"short[]\":\n+                return short[].class;\n+            case \"int[]\":\n+                return int[].class;\n+            case \"long[]\":\n+                return long[].class;\n+            case \"float[]\":\n+                return float[].class;\n+            case \"double[]\":\n+                return double[].class;\n+            default:\n+        }\n+        try {\n+            return arrayForName(className);\n+        } catch (ClassNotFoundException e) {\n+            // try to load from java.lang package\n+            if (className.indexOf('.') == -1) {\n+                try {\n+                    return arrayForName(\"java.lang.\" + className);\n+                } catch (ClassNotFoundException ignore) {\n+                    // ignore, let the original exception be thrown\n+                }\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    private static Class<?> arrayForName(String className) throws ClassNotFoundException {\n+        return Class.forName(className.endsWith(\"[]\")\n+                ? \"[L\" + className.substring(0, className.length() - 2) + \";\"\n+                : className, true, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    public static Class<?> getBoxedClass(Class<?> type) {\n+        if (type == boolean.class) {\n+            return Boolean.class;\n+        } else if (type == char.class) {\n+            return Character.class;\n+        } else if (type == byte.class) {\n+            return Byte.class;\n+        } else if (type == short.class) {\n+            return Short.class;\n+        } else if (type == int.class) {\n+            return Integer.class;\n+        } else if (type == long.class) {\n+            return Long.class;\n+        } else if (type == float.class) {\n+            return Float.class;\n+        } else if (type == double.class) {\n+            return Double.class;\n+        } else {\n+            return type;\n+        }\n+    }\n+\n+    public static Boolean boxed(boolean v) {\n+        return Boolean.valueOf(v);\n+    }\n+\n+    public static Character boxed(char v) {\n+        return Character.valueOf(v);\n+    }\n+\n+    public static Byte boxed(byte v) {\n+        return Byte.valueOf(v);\n+    }\n+\n+    public static Short boxed(short v) {\n+        return Short.valueOf(v);\n+    }\n+\n+    public static Integer boxed(int v) {\n+        return Integer.valueOf(v);\n+    }\n+\n+    public static Long boxed(long v) {\n+        return Long.valueOf(v);\n+    }\n+\n+    public static Float boxed(float v) {\n+        return Float.valueOf(v);\n+    }\n+\n+    public static Double boxed(double v) {\n+        return Double.valueOf(v);\n+    }\n+\n+    public static Object boxed(Object v) {\n+        return v;\n+    }\n+\n+    public static boolean unboxed(Boolean v) {\n+        return v == null ? false : v.booleanValue();\n+    }\n+\n+    public static char unboxed(Character v) {\n+        return v == null ? '\\0' : v.charValue();\n+    }\n+\n+    public static byte unboxed(Byte v) {\n+        return v == null ? 0 : v.byteValue();\n+    }\n+\n+    public static short unboxed(Short v) {\n+        return v == null ? 0 : v.shortValue();\n+    }\n+\n+    public static int unboxed(Integer v) {\n+        return v == null ? 0 : v.intValue();\n+    }\n+\n+    public static long unboxed(Long v) {\n+        return v == null ? 0 : v.longValue();\n+    }\n+\n+    public static float unboxed(Float v) {\n+        return v == null ? 0 : v.floatValue();\n+    }\n+\n+    public static double unboxed(Double v) {\n+        return v == null ? 0 : v.doubleValue();\n+    }\n+\n+    public static Object unboxed(Object v) {\n+        return v;\n+    }\n+\n+    public static boolean isNotEmpty(Object object) {\n+        return getSize(object) > 0;\n+    }\n+\n+    public static int getSize(Object object) {\n+        if (object == null) {\n+            return 0;\n+        }\n+        if (object instanceof Collection<?>) {\n+            return ((Collection<?>) object).size();\n+        } else if (object instanceof Map<?, ?>) {\n+            return ((Map<?, ?>) object).size();\n+        } else if (object.getClass().isArray()) {\n+            return Array.getLength(object);\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    public static URI toURI(String name) {\n+        try {\n+            return new URI(name);\n+        } catch (URISyntaxException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static Class<?> getGenericClass(Class<?> cls) {\n+        return getGenericClass(cls, 0);\n+    }\n+\n+    public static Class<?> getGenericClass(Class<?> cls, int i) {\n+        try {\n+            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\n+            Object genericClass = parameterizedType.getActualTypeArguments()[i];\n+            if (genericClass instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\n+            } else if (genericClass instanceof GenericArrayType) {\n+                Type type = ((GenericArrayType) genericClass).getGenericComponentType();\n+                if (type instanceof TypeVariable) {\n+                    return type.getClass();\n+                }\n+                return (((GenericArrayType) genericClass).getGenericComponentType() instanceof Class<?>)\n+                        ? (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType()\n+                        : ((GenericArrayType) genericClass).getGenericComponentType().getClass();\n+            } else if (genericClass != null) {\n+                if (genericClass instanceof TypeVariable) {\n+                    return genericClass.getClass();\n+                }\n+                return (Class<?>) genericClass;\n+            }\n+        } catch (Throwable e) {\n+\n+        }\n+        if (cls.getSuperclass() != null) {\n+            return getGenericClass(cls.getSuperclass(), i);\n+        } else {\n+            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\");\n+        }\n+    }\n+\n+    public static boolean isBeforeJava5(String javaVersion) {\n+        return (StringUtils.isEmpty(javaVersion) || \"1.0\".equals(javaVersion)\n+                || \"1.1\".equals(javaVersion) || \"1.2\".equals(javaVersion)\n+                || \"1.3\".equals(javaVersion) || \"1.4\".equals(javaVersion));\n+    }\n+\n+    public static boolean isBeforeJava6(String javaVersion) {\n+        return isBeforeJava5(javaVersion) || \"1.5\".equals(javaVersion);\n+    }\n+\n+    public static String toString(Throwable e) {\n+        StringWriter w = new StringWriter();\n+        PrintWriter p = new PrintWriter(w);\n+        p.print(e.getClass().getName() + \": \");\n+        if (e.getMessage() != null) {\n+            p.print(e.getMessage() + \"\\n\");\n+        }\n+        p.println();\n+        try {\n+            e.printStackTrace(p);\n+            return w.toString();\n+        } finally {\n+            p.close();\n+        }\n+    }\n+\n+    public static void checkBytecode(String name, byte[] bytecode) {\n+        if (bytecode.length > JIT_LIMIT) {\n+            System.err.println(\"The template bytecode too long, may be affect the JIT compiler. template class: \" + name);\n+        }\n+    }\n+\n+    public static String getSizeMethod(Class<?> cls) {\n+        try {\n+            return cls.getMethod(\"size\", new Class<?>[0]).getName() + \"()\";\n+        } catch (NoSuchMethodException e) {\n+            try {\n+                return cls.getMethod(\"length\", new Class<?>[0]).getName() + \"()\";\n+            } catch (NoSuchMethodException e2) {\n+                try {\n+                    return cls.getMethod(\"getSize\", new Class<?>[0]).getName() + \"()\";\n+                } catch (NoSuchMethodException e3) {\n+                    try {\n+                        return cls.getMethod(\"getLength\", new Class<?>[0]).getName() + \"()\";\n+                    } catch (NoSuchMethodException e4) {\n+                        return null;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static String getMethodName(Method method, Class<?>[] parameterClasses, String rightCode) {\n+        if (method.getParameterTypes().length > parameterClasses.length) {\n+            Class<?>[] types = method.getParameterTypes();\n+            StringBuilder buf = new StringBuilder(rightCode);\n+            for (int i = parameterClasses.length; i < types.length; i++) {\n+                if (buf.length() > 0) {\n+                    buf.append(\",\");\n+                }\n+                Class<?> type = types[i];\n+                String def;\n+                if (type == boolean.class) {\n+                    def = \"false\";\n+                } else if (type == char.class) {\n+                    def = \"\\'\\\\0\\'\";\n+                } else if (type == byte.class\n+                        || type == short.class\n+                        || type == int.class\n+                        || type == long.class\n+                        || type == float.class\n+                        || type == double.class) {\n+                    def = \"0\";\n+                } else {\n+                    def = \"null\";\n+                }\n+                buf.append(def);\n+            }\n+        }\n+        return method.getName() + \"(\" + rightCode + \")\";\n+    }\n+\n+    public static Method searchMethod(Class<?> currentClass, String name, Class<?>[] parameterTypes) throws NoSuchMethodException {\n+        if (currentClass == null) {\n+            throw new NoSuchMethodException(\"class == null\");\n+        }\n+        try {\n+            return currentClass.getMethod(name, parameterTypes);\n+        } catch (NoSuchMethodException e) {\n+            for (Method method : currentClass.getMethods()) {\n+                if (method.getName().equals(name)\n+                        && parameterTypes.length == method.getParameterTypes().length\n+                        && Modifier.isPublic(method.getModifiers())) {\n+                    if (parameterTypes.length > 0) {\n+                        Class<?>[] types = method.getParameterTypes();\n+                        boolean match = true;\n+                        for (int i = 0; i < parameterTypes.length; i++) {\n+                            if (!types[i].isAssignableFrom(parameterTypes[i])) {\n+                                match = false;\n+                                break;\n+                            }\n+                        }\n+                        if (!match) {\n+                            continue;\n+                        }\n+                    }\n+                    return method;\n+                }\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    public static String getInitCode(Class<?> type) {\n+        if (byte.class.equals(type)\n+                || short.class.equals(type)\n+                || int.class.equals(type)\n+                || long.class.equals(type)\n+                || float.class.equals(type)\n+                || double.class.equals(type)) {\n+            return \"0\";\n+        } else if (char.class.equals(type)) {\n+            return \"'\\\\0'\";\n+        } else if (boolean.class.equals(type)) {\n+            return \"false\";\n+        } else {\n+            return \"null\";\n+        }\n+    }\n+\n+    public static <K, V> Map<K, V> toMap(Map.Entry<K, V>[] entries) {\n+        Map<K, V> map = new HashMap<K, V>();\n+        if (entries != null && entries.length > 0) {\n+            for (Map.Entry<K, V> entry : entries) {\n+                map.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * get simple class name from qualified class name\n+     */\n+    public static String getSimpleClassName(String qualifiedName) {\n+        if (null == qualifiedName) {\n+            return null;\n+        }\n+        int i = qualifiedName.lastIndexOf('.');\n+        return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);\n+    }\n+\n+}\n"}}, {"oid": "5540ddd216148cc6d65c8929aa660b780b925578", "url": "https://github.com/apache/dubbo/commit/5540ddd216148cc6d65c8929aa660b780b925578", "message": "fix: ClassUtils.java LF to CRLF\n\nSigned-off-by: licho <lecho.sun@gmail.com>", "committedDate": "2021-03-22T02:07:19Z", "type": "commit"}]}