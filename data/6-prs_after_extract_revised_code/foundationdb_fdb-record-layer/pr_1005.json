{"pr_number": 1005, "pr_title": "Resolves #1004: Better to scan with OR filter than to Union \u2026", "pr_createdAt": "2020-07-28T21:50:41Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1005", "timeline": [{"oid": "f82f5a276cc782bc944826e4e0f9ba985a5cc145", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f82f5a276cc782bc944826e4e0f9ba985a5cc145", "message": "Resolves #1004: Better to scan with OR filter than to Union multiple identical scans with individual filters", "committedDate": "2020-07-28T21:57:30Z", "type": "forcePushed"}, {"oid": "6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1", "message": "Resolves #1004: Better to scan with OR filter than to Union multiple identical scans with individual filters", "committedDate": "2020-07-30T20:22:32Z", "type": "commit"}, {"oid": "6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1", "message": "Resolves #1004: Better to scan with OR filter than to Union multiple identical scans with individual filters", "committedDate": "2020-07-30T20:22:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MTM5Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1005#discussion_r463251396", "bodyText": "Specifically, for FDBInQueryTest.testInQueryIndexSortedDifferently, the old alternative plan was\nIndex(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 1 \u222a[Field { 'str_value_indexed' None}, Field { 'rec_no' None}] Index(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 4 \u222a[Field { 'str_value_indexed' None}, Field { 'rec_no' None}] Index(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed EQUALS 2\n\nand the new one is\nIndex(MySimpleRecord$str_value_indexed <,>) | Or([num_value_3_indexed EQUALS 1, num_value_3_indexed EQUALS 4, num_value_3_indexed EQUALS 2])\n\nbut the winner still is\nIndex(MySimpleRecord$str_value_indexed <,>) | num_value_3_indexed IN [1, 4, 2]\n\nHence no change in that test.", "author": "MMcM", "createdAt": "2020-07-30T20:26:39Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -1186,8 +1188,33 @@ private ScoredPlan planOr(@Nonnull PlanContext planContext, @Nonnull OrComponent\n             if (subplan.planOrderingKey == null) {\n                 allHaveOrderingKey = false;\n             }\n+            RecordQueryPlan filteredBasePlan;\n+            if (subplan.plan instanceof RecordQueryFilterPlan) {\n+                filteredBasePlan = ((RecordQueryFilterPlan)subplan.plan).getInner();\n+            } else {\n+                filteredBasePlan = null;\n+            }\n+            if (subplans.isEmpty()) {\n+                commonFilteredBasePlan = filteredBasePlan;\n+                allHaveSameBasePlan = filteredBasePlan != null;\n+            } else if (allHaveSameBasePlan && !Objects.equals(filteredBasePlan, commonFilteredBasePlan)) {\n+                allHaveSameBasePlan = false;\n+            }\n             subplans.add(subplan);\n         }\n+        // If the child plans only differ in their filters, then there is no point in repeating the base\n+        // scan only to evaluate each of the filters. Just evaluate the scan with an OR filter.\n+        // Note that this also improves the _second-best_ plan for planFilterWithInJoin, but an IN filter wins\n+        // out there over the equivalent OR(EQUALS) filters.", "originalCommit": "6706ba2a8be6c8eecbb5e557dcb1ac2f02e98fd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}