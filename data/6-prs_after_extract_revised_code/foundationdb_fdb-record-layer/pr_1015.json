{"pr_number": 1015, "pr_title": "Resolves #1019: Avoid repeating index endpoints conflicts", "pr_createdAt": "2020-08-14T22:17:26Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015", "timeline": [{"oid": "d093083a32ac1a54872e9a542240a3824f038041", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d093083a32ac1a54872e9a542240a3824f038041", "message": "While setting endpoints for indexer, repeating conflicts with other transaction could prevent the job from running\n\n   resolution: Since the store is marked WRITE_ONLY while determining endpoints and reading the records,\n   is seems safe to ignore conflicts caused by insertion of new records - as the inseration should already\n   imply valid index entries.", "committedDate": "2020-08-14T22:26:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODUzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470918539", "bodyText": "Hm, what is this line trying to accomplish?", "author": "alecgrieser", "createdAt": "2020-08-15T01:04:17Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java", "diffHunk": "@@ -103,6 +103,9 @@ public void run() {\n                 try (FDBRecordContext context = openContext()) {\n                     long sum = recordStore.evaluateAggregateFunction(Collections.singletonList(\"MySimpleRecord\"), aggregateFunction, TupleRange.ALL, IsolationLevel.SNAPSHOT).join().getLong(0);\n                     long expected = updatedRecords.stream().mapToInt(msg -> msg.hasNumValue2() ? msg.getNumValue2() : 0).sum();\n+                    for (int i = 0; sum != expected && i < 20; i ++) {\n+                        Thread.yield();", "originalCommit": "d093083a32ac1a54872e9a542240a3824f038041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3OTcwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470979705", "bodyText": "This meaningless code made the sum test pass, I do not understand why.\nAfter distinguishing between idempotent and accumulative indexes, the sum test passes without this ghost hunting.", "author": "jjezra", "createdAt": "2020-08-15T13:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java\nindex b6c19cb9..d919435e 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerBuildSumIndexTest.java\n\n@@ -103,9 +103,6 @@ public abstract class OnlineIndexerBuildSumIndexTest extends OnlineIndexerBuildI\n                 try (FDBRecordContext context = openContext()) {\n                     long sum = recordStore.evaluateAggregateFunction(Collections.singletonList(\"MySimpleRecord\"), aggregateFunction, TupleRange.ALL, IsolationLevel.SNAPSHOT).join().getLong(0);\n                     long expected = updatedRecords.stream().mapToInt(msg -> msg.hasNumValue2() ? msg.getNumValue2() : 0).sum();\n-                    for (int i = 0; sum != expected && i < 20; i ++) {\n-                        Thread.yield();\n-                    }\n                     assertEquals(expected, sum);\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODc2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470918767", "bodyText": "Hm, perhaps this is a sign with our tests if it's not catching a bug here, but I think this needs to validate that the index is idempotent before it sets the isolation level to SNAPSHOT. Otherwise, there's not a guarantee that the concurrently written record will be indexed.\nWe should probably have a comment here explaining why SNAPSHOT is used, and then another explaining why we need to add the read conflict range at the place we do.", "author": "alecgrieser", "createdAt": "2020-08-15T01:06:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -539,7 +539,7 @@ private void increaseLimit() {\n         }\n         final IndexMaintainer maintainer = store.getIndexMaintainer(index);\n         final ExecuteProperties.Builder executeProperties = ExecuteProperties.newBuilder()\n-                .setIsolationLevel(IsolationLevel.SERIALIZABLE);\n+                .setIsolationLevel(IsolationLevel.SNAPSHOT);", "originalCommit": "d093083a32ac1a54872e9a542240a3824f038041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk4MjU2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r470982567", "bodyText": "The sum index test did fail, do not lose hope :)\nYou did mention before that the SNAPSHOT approach must be limited to idempotent indexes only, but I failed to assimilate (sorry). I'll fix it now.", "author": "jjezra", "createdAt": "2020-08-15T13:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxODc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "chunk": "diff --git a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\nindex 4f3c4cf9..395d0284 100644\n--- a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n+++ b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n\n@@ -538,8 +538,12 @@ public class OnlineIndexer implements AutoCloseable {\n             throw new MetaDataException(\"Store does not have the same metadata\");\n         }\n         final IndexMaintainer maintainer = store.getIndexMaintainer(index);\n+        final boolean isIdempotent = maintainer.isIdempotent();\n         final ExecuteProperties.Builder executeProperties = ExecuteProperties.newBuilder()\n-                .setIsolationLevel(IsolationLevel.SNAPSHOT);\n+                .setIsolationLevel(\n+                        isIdempotent ?\n+                        IsolationLevel.SNAPSHOT :\n+                        IsolationLevel.SERIALIZABLE);\n         if (respectLimit) {\n             executeProperties.setReturnedRowLimit(limit);\n         }\n"}}, {"oid": "cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/cc5a22bf9cfe0674a4aae5ab0835bb9a4d5681df", "message": "While setting endpoints for indexer, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Since the store is marked WRITE_ONLY while determining endpoints and\n   reading the records,is seems safe to ignore conflicts caused by insertion of new records - as the inseration\n   should already imply valid index entries.\n   TODO: add tests.", "committedDate": "2020-08-17T14:03:27Z", "type": "forcePushed"}, {"oid": "f707d2d05801980019b89bc63fe5ce27c3d49a65", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/f707d2d05801980019b89bc63fe5ce27c3d49a65", "message": "Resolves #1015: Avoid repeating index endpoints conflicts\n\n     Add utests.", "committedDate": "2020-08-19T13:30:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473304057", "bodyText": "Hmm. IIUC from offline conversations, this was needed to make future commits down the line not fail with a conflict, but this call seems suspicious to me. It essentially marks the index as already built, so the index build won't do much of anything, so it seems more likely to me that this is either masking some other problem, or there is some issue or is a sign that there is some other kind of misconfiguration going on with these tests.", "author": "alecgrieser", "createdAt": "2020-08-19T20:37:45Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * OnlineIndexerConflictsTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.IndexState;\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ */\n+\n+@Tag(Tags.RequiresFDB)\n+public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n+\n+    @Test\n+    public void testOnlineIndexerIdempotent() throws Exception {\n+\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                                                 ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());", "originalCommit": "acdd84b077ab54cfa4c32895dca8602cbd99e734", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMzk5OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473313999", "bodyText": "I agree. This line was copied from the tests in OnlineIndexerSimpleTest. Would you have any idea why the indexer commit was failing without this line?", "author": "jjezra", "createdAt": "2020-08-19T20:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxOTU2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473319569", "bodyText": "I believe all of the instances of that method being used in OnlineIndexerSimpleTest, it does so so that it can then scan the index without either (1) being told that the index isn't readable (which is what happens if you scan an unbuilt index normally) or (2) building the index and therefore disturbing it. It also looks like in all of the instances (that I could find) in OnlinIndexerSimpleTest, the transaction that calls uncheckedMarkIndexReadable isn't committed (and indeed, there are comments saying // do NOT commit instead of calls to commit()).\nI'm not sure why it's currently failing without that change, though. I had some theories, but most of the theories ended up being falsified by further experiments that you did. It's possible this needs more investigation, which might mean turning on detailed FDB client trace logging, or possibly investing in #1002 (or something temporary along those lines) to see what the conflict is.", "author": "alecgrieser", "createdAt": "2020-08-19T21:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ2NTc5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473465795", "bodyText": "I've added the test you've suggested above. Here I could mark the index as write only.", "author": "jjezra", "createdAt": "2020-08-20T00:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNDA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 561e919f..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,186 +20,179 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n+\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n+    }\n \n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n-            }\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n+            context.commit();\n         }\n+        openSimpleMetaData(hookAdd);\n+        try (FDBRecordContext context = openContext()) {\n+            context.commit();\n+        }\n+\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n \n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        int[] inserts = {10, 4, 16};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        context2.commit();\n                     }\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n-        }\n \n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n-\n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3MjMzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473472331", "bodyText": "I don't think this comment applies to this test any more", "author": "alecgrieser", "createdAt": "2020-08-20T00:28:29Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473476169", "bodyText": "I don't think this test needs quite as many records now. I think...three would suffice? The main tests have lots of records in order to make sure that during the random operations, we get lots of different combinations. That shouldn't be necessary with this test, though, as it's more about testing specific concurrent operations.", "author": "alecgrieser", "createdAt": "2020-08-20T00:34:33Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MDk0OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473490949", "bodyText": "Sure. Shall I keep the other two (random) tests?", "author": "jjezra", "createdAt": "2020-08-20T00:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5NTkwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473495903", "bodyText": "I don't think so, really. I think the tests in OnlineIndexerBuildValueIndexTest and OnlineIndexerBuildSumIndexTest are essentially trying to test the same thing, and so I think we'd want to stick with those (or add more tests there if we think they are insufficient).\nI'd also think we'd want to track down the weird conflict if we kept them in.", "author": "alecgrieser", "createdAt": "2020-08-20T01:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwMDcwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473500703", "bodyText": "Ok.", "author": "jjezra", "createdAt": "2020-08-20T01:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjY4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473476680", "bodyText": "Hm, it's weird that you need to mark the index as write only.... It should be marking the index as write only when the record store is opened, I think, unless I'm misunderstanding how this all works.", "author": "alecgrieser", "createdAt": "2020-08-20T00:35:18Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MjAwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473492007", "bodyText": "Removing the writeOnly but keeping the commit works!", "author": "jjezra", "createdAt": "2020-08-20T00:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NjY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473477207", "bodyText": "I don't think doing this in a loop really adds much. Probably sufficient to just have the one insert. As written, this also builds the full index repeatedly within the loop, which probably isn't quite what we want.", "author": "alecgrieser", "createdAt": "2020-08-20T00:36:11Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5MDEzNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473490134", "bodyText": "Actually that is intentional, I was trying to add a single record each time outside the range (from both sides), next the the first/last items, and in the middle of it. The result is repeatedly adding a record while repeatedly indexing.", "author": "jjezra", "createdAt": "2020-08-20T00:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5NDgwMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473494800", "bodyText": "I believe that the way that OnlineIndexer.buildRange works, it'll build the whole range, so I think what this test is currently doing is:\n\nThe first iteration, building the index and inserting a record in separate transactions and asserting that they both succeed\nAll subsequent iterations, inserting a record and then validating that the index doesn't need to be built because it already has\n\nSo, I'm not quite sure it's testing what's desired, unless I'm misunderstanding the goal here.", "author": "alecgrieser", "createdAt": "2020-08-20T01:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwMTcyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473501720", "bodyText": "Is there an easy way to delete the index?", "author": "jjezra", "createdAt": "2020-08-20T01:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwNTM4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473505388", "bodyText": "If you create a new record store and call clearAndMarkIndexWriteOnly, that will delete all of the index's data, if that's what you want to do.", "author": "alecgrieser", "createdAt": "2020-08-20T01:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwNTYxOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473505619", "bodyText": "Got it:\nFDBRecordStoreTestBase.RecordMetaDataHook hookDel = metaDataBuilder -> metaDataBuilder.removeIndex(index.getName());", "author": "jjezra", "createdAt": "2020-08-20T01:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxNjEyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473516122", "bodyText": "Sorry I didn't see your reply before submitting (my browser, as it seems, does not refresh frequently enough). Shall I change the removeIndex to clearAndMarkIndexWriteOnly?", "author": "jjezra", "createdAt": "2020-08-20T01:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxNzIxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473517218", "bodyText": "It depends on what you are trying to accomplish. The removeIndex method will...remove the index from the meta-data (so it will require adding it back to then build the index, if that's the idea). Whereas the method I gave simply \"clears out\" the index. I think you just want to clear it out here, but I could be misunderstanding the desired effect.", "author": "alecgrieser", "createdAt": "2020-08-20T01:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxOTI0Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473519246", "bodyText": "Either one will work for my desired effect (which is to add a record in different locations while indexing). Would you be willing to review it as is?", "author": "jjezra", "createdAt": "2020-08-20T01:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3NzIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODAzNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473478035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.info(\"newIndex thread run\");\n          \n      \n    \n    \n  \n\nNow that it's not its own thread", "author": "alecgrieser", "createdAt": "2020-08-20T00:37:29Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            final FDBStoreTimer timer = new FDBStoreTimer();\n+            LOGGER.info(\"newIndex thread run\");", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ5Mzc2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473493762", "bodyText": "", "author": "jjezra", "createdAt": "2020-08-20T01:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3ODQwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473478409", "bodyText": "But...a conflict shouldn't happen?", "author": "alecgrieser", "createdAt": "2020-08-20T00:38:04Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ3OTkyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473479922", "bodyText": "This assert isn't hurting anything, I suppose, but it's also already covered by the two contexts committing successfully above. It may be worth adding a comment on context1.commit() about how a record is being added in the range added by the indexer, but the transaction still commits because it's value isn't needed by the indexer.", "author": "alecgrieser", "createdAt": "2020-08-20T00:40:32Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {\n+        // If a conflict happens, this test should succeed by retries\n+        Random rand = new Random();\n+        final long seed = rand.nextInt();\n+        LOGGER.info(\"Random seed is \" + seed);\n+        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 50; i <= 150; i++) {\n+                // even numbers 100-300 (that's 101 values)\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+\n+        openSimpleMetaData(hook);\n+        try (FDBRecordContext context = openContext()) {\n+            recordStore.markIndexWriteOnly(index.getName()).join();\n+            context.commit();\n+        }\n+\n+        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            final FDBStoreTimer timer = new FDBStoreTimer();\n+            LOGGER.info(\"newIndex thread run\");\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .setTimer(timer)\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ4MjQwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r473482404", "bodyText": "Hm, maybe something more like testAddRecordToRangeWhileIndexedIdempotent? Or something with those words?\nI don't think we want \"nested\" in the title. We typically use that to refer to nested key expressions (i.e., indexes defined on elements of nested messages), and having it here might cause confusion.", "author": "alecgrieser", "createdAt": "2020-08-20T00:44:24Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -201,5 +201,60 @@ public void run() {\n         assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n         assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n+\n+    @Test\n+    public void testOnlineIndexerIdempotentNested() throws Exception {", "originalCommit": "57772c69d76d3d8951d9bf34b0854b580021d12f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d54d963231c6b06b25169fd81607f50d05b9d45", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex 0f340fc4..a7b76608 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -20,240 +20,178 @@\n \n package com.apple.foundationdb.record.provider.foundationdb;\n \n-import com.apple.foundationdb.record.IndexState;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import java.util.List;\n-import java.util.Random;\n import java.util.stream.Collectors;\n import java.util.stream.LongStream;\n \n import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests for {@link OnlineIndexer}. Checking different db manipulations the indexing process.\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n  */\n \n @Tag(Tags.RequiresFDB)\n public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(OnlineIndexerConflictsTest.class);\n-\n     @Test\n-    public void testOnlineIndexerIdempotent() throws Exception {\n-\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n-                                                 ).collect(Collectors.toList());\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(11);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = rand.nextInt(400);\n-            if (100 <= i && i <= 300) {\n-                i = i | 1; // make it odd\n-            }\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n         }\n-\n-        indexerThread.join();\n-        assertTrue(recordStore.getIndexState(index.getName()) == IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n     }\n \n     @Test\n-    public void testOnlineIndexerAggregate() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n                 ).collect(Collectors.toList());\n \n-        Index index = new Index(\"newIndex\", field(\"num_value_2\").ungrouped(), IndexTypes.SUM);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n-                recordStore.saveRecord(records.get(i * 2));\n-            }\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            assertTrue(recordStore.uncheckedMarkIndexReadable(index.getName()).join());\n-            recordStore.checkVersion(null, FDBRecordStoreBase.StoreExistenceCheck.ERROR_IF_NOT_EXISTS).join();\n             context.commit();\n         }\n \n-        final FDBStoreTimer timer = new FDBStoreTimer();\n-        final int sleepTime = rand.nextInt(6);\n-        class IndexerThread extends Thread  {\n-            public void run() {\n-                LOGGER.info(\"newIndex thread run\");\n-                try (FDBRecordContext context1 = openContext()) {\n-                    try (OnlineIndexer indexer =\n-                                 OnlineIndexer.newBuilder()\n-                                         .setRecordStore(recordStore)\n-                                         .setIndex(\"newIndex\")\n-                                         .setTimer(timer)\n-                                         .build()) {\n-                        LOGGER.info(\"newIndex thread start. SleepTIme = \" + sleepTime);\n-                        // Build in this transaction.\n-                        Thread.sleep(sleepTime / 2);\n-                        indexer.buildIndex(true);\n-                        Thread.sleep(sleepTime);\n-                        // how can I ensure it run without conflicts & retries?\n-                        context1.commit();\n-                        LOGGER.info(\"newIndex thread done\");\n-                    } catch (InterruptedException e) {\n-                        e.printStackTrace();\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n                     }\n+                    context1.commit();\n                 }\n             }\n-        }\n-\n-        IndexerThread indexerThread = new IndexerThread();\n-        indexerThread.start();\n \n-        for (int count = 20; count > 0; --count) { // could have been nice to have a \"repeat(100)\" syntax..\n-            int i = count == 19 ? 10 :\n-                    count == 15 ? 310 :\n-                    rand.nextInt(400);\n-            LOGGER.debug(\"insert records item \" + i);\n-            try (FDBRecordContext context2 = openContext()) {\n-                recordStore.saveRecord(records.get(i));\n-                context2.commit();\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n             }\n-        }\n-\n-        indexerThread.join();\n-        assertSame(recordStore.getIndexState(index.getName()), IndexState.READABLE);\n-        assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+        });\n     }\n \n     @Test\n-    public void testOnlineIndexerIdempotentNested() throws Exception {\n-        // If a conflict happens, this test should succeed by retries\n-        Random rand = new Random();\n-        final long seed = rand.nextInt();\n-        LOGGER.info(\"Random seed is \" + seed);\n-        rand = new Random(seed); // make rand repeatable (note that multi threading behaviour is not fully repeatable in this test)\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n \n         List<TestRecords1Proto.MySimpleRecord> records =\n-                LongStream.range(0, 400).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n                 ).collect(Collectors.toList());\n \n         Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n-        FDBRecordStoreTestBase.RecordMetaDataHook hook = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n         openSimpleMetaData();\n         try (FDBRecordContext context = openContext()) {\n-            for (int i = 50; i <= 150; i++) {\n-                // even numbers 100-300 (that's 101 values)\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n                 recordStore.saveRecord(records.get(i * 2));\n             }\n             context.commit();\n         }\n-\n-        openSimpleMetaData(hook);\n+        openSimpleMetaData(hookAdd);\n         try (FDBRecordContext context = openContext()) {\n-            recordStore.markIndexWriteOnly(index.getName()).join();\n             context.commit();\n         }\n \n-        int[] inserts = {99, 101, 133, 201, 350, 299, 301};\n+        int[] inserts = {10, 4, 16};\n         for (int i = 0; i < inserts.length; i++) {\n             int record_i = inserts[i];\n \n-            final FDBStoreTimer timer = new FDBStoreTimer();\n-            LOGGER.info(\"newIndex thread run\");\n             try (FDBRecordContext context1 = openContext()) {\n                 try (OnlineIndexer indexer =\n                              OnlineIndexer.newBuilder()\n                                      .setRecordStore(recordStore)\n                                      .setIndex(\"newIndex\")\n-                                     .setTimer(timer)\n                                      .build()) {\n                     indexer.buildRange(recordStore, null, null).join();\n                     try (FDBRecordContext context2 = openContext()) {\n                         recordStore.saveRecord(records.get(record_i));\n                         context2.commit();\n                     }\n-                    context1.commit();\n+                    assertThrows(FDBExceptions.FDBStoreTransactionConflictException.class, context1::commit);\n                 }\n             }\n \n-            assertEquals(0, timer.getCount(FDBStoreTimer.Events.COMMIT_FAILURE));\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474412217", "bodyText": "It's a good place to illustrate on \"range conflict protection\": allow records being added to the range (so they may be or may not be seen by indexer) while scanning.", "author": "nblintao", "createdAt": "2020-08-21T05:12:14Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1015,11 +1022,19 @@ public void rebuildIndex(@Nonnull FDBRecordStore store) {\n     @Nonnull\n     private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n                                                          @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,", "originalCommit": "779aef648d481dbf55b3b1135a6b263ffb0f3897", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyNDA1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474724058", "bodyText": "I'm not sure I understand this action item. Are you suggesting to add a test to do it?\n(Alec said that this scenario is already covered in other tests)", "author": "jjezra", "createdAt": "2020-08-21T14:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjMxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474812318", "bodyText": "I meant it should help to explain \"range conflict protection\" in more detail in this comment.", "author": "nblintao", "createdAt": "2020-08-21T16:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzAwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474823009", "bodyText": "Sure. NP!", "author": "jjezra", "createdAt": "2020-08-21T17:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMjIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "chunk": "diff --git a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\nindex 395d0284..366bcd4b 100644\n--- a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n+++ b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n\n@@ -1025,8 +1025,10 @@ public class OnlineIndexer implements AutoCloseable {\n         boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n         final IsolationLevel isolationLevel =\n                 isIdempotent ?\n-                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,\n-                // some records will be re-indexed.\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of\n+                // a range conflict one - which means that new records, added to the range while indexing the SNAPSHOT,\n+                // will not cause a conflict during the commit. At worse, few records (if added after marking WRITE_ONLY but\n+                // before this method's query) will be re-indexed.\n                 IsolationLevel.SNAPSHOT :\n                 IsolationLevel.SERIALIZABLE;\n         final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474413666", "bodyText": "Even though only one record is scanned, I think that record should be added to read conflict.\nI wouldn't worry about reproducing it from tests though.", "author": "nblintao", "createdAt": "2020-08-21T05:18:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java", "diffHunk": "@@ -1015,11 +1022,19 @@ public void rebuildIndex(@Nonnull FDBRecordStore store) {\n     @Nonnull\n     private CompletableFuture<TupleRange> buildEndpoints(@Nonnull FDBRecordStore store, @Nonnull RangeSet rangeSet,\n                                                          @Nullable AtomicLong recordsScanned) {\n+        boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n+        final IsolationLevel isolationLevel =\n+                isIdempotent ?\n+                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,\n+                // some records will be re-indexed.\n+                IsolationLevel.SNAPSHOT :\n+                IsolationLevel.SERIALIZABLE;\n         final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n                 .setReturnedRowLimit(1)\n-                .setIsolationLevel(IsolationLevel.SERIALIZABLE)\n+                .setIsolationLevel(isolationLevel)", "originalCommit": "779aef648d481dbf55b3b1135a6b263ffb0f3897", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyODA1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474728056", "bodyText": "If I understand it correctly:\nWhen idempotent - the endpoints will always be added to the conflicts list during the full scan, because the data doesn't change in a SNAPSHOT mode. And if an endpoint is not being indexed (other type), why should we care if it changes?\nWhen accumulative - we use the range protection, which includes the endpoints.\nWhat am I missing?", "author": "jjezra", "createdAt": "2020-08-21T14:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxODgyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474818826", "bodyText": "After taking close look, I think the implementation is correct. We don't need to add the endpoints to read conflict list because this method will call buildRange which will do it.", "author": "nblintao", "createdAt": "2020-08-21T17:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMzY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "chunk": "diff --git a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\nindex 395d0284..366bcd4b 100644\n--- a/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n+++ b/fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexer.java\n\n@@ -1025,8 +1025,10 @@ public class OnlineIndexer implements AutoCloseable {\n         boolean isIdempotent = store.getIndexMaintainer(index).isIdempotent();\n         final IsolationLevel isolationLevel =\n                 isIdempotent ?\n-                // if idempotent: since double indexing is harmless, we can skip the range conflict protection. At worse,\n-                // some records will be re-indexed.\n+                // If idempotent: since double indexing is harmless, we can use individual records protection instead of\n+                // a range conflict one - which means that new records, added to the range while indexing the SNAPSHOT,\n+                // will not cause a conflict during the commit. At worse, few records (if added after marking WRITE_ONLY but\n+                // before this method's query) will be re-indexed.\n                 IsolationLevel.SNAPSHOT :\n                 IsolationLevel.SERIALIZABLE;\n         final ExecuteProperties limit1 = ExecuteProperties.newBuilder()\n"}}, {"oid": "1d54d963231c6b06b25169fd81607f50d05b9d45", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d54d963231c6b06b25169fd81607f50d05b9d45", "message": "Resolves #1019: Avoid repeating index endpoints conflicts\n\n   While setting the indexer's range, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Set the endpoints and read the records in a non-conflicting SNAPSHOT isolation,\n   and add each indexed record to a conflict list. Having the index in WRITE_ONLY mode, new records within the range will be\n   indexed while inserted and shall not cause a rejection.", "committedDate": "2020-08-21T14:51:26Z", "type": "commit"}, {"oid": "1d54d963231c6b06b25169fd81607f50d05b9d45", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d54d963231c6b06b25169fd81607f50d05b9d45", "message": "Resolves #1019: Avoid repeating index endpoints conflicts\n\n   While setting the indexer's range, repeating conflicts with other transaction could prevent the job from running\n\n   resolution (for idempotent indexes only): Set the endpoints and read the records in a non-conflicting SNAPSHOT isolation,\n   and add each indexed record to a conflict list. Having the index in WRITE_ONLY mode, new records within the range will be\n   indexed while inserted and shall not cause a rejection.", "committedDate": "2020-08-21T14:51:26Z", "type": "forcePushed"}, {"oid": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "message": "Implement Tao's change request", "committedDate": "2020-08-21T17:24:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMTc1MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1015#discussion_r474831751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testAddRecordToRangeWhileIndexedIdempotentFailure() {\n          \n          \n            \n                public void testModifyRecordInRangeWhileIndexedIdempotentFailure() {\n          \n      \n    \n    \n  \n\nI think that's probably a more accurate description", "author": "alecgrieser", "createdAt": "2020-08-21T17:28:45Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * OnlineIndexerConflictsTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.metadata.Index;\n+import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import static com.apple.foundationdb.record.metadata.Key.Expressions.field;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * Tests for {@link OnlineIndexer}. Checking different db manipulations during the indexing process.\n+ */\n+\n+@Tag(Tags.RequiresFDB)\n+public class OnlineIndexerConflictsTest extends OnlineIndexerTest {\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedIdempotent() {\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 20).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            for (int i = 2; i <= 8; i++) {\n+                // even numbers from 4 to 16\n+                recordStore.saveRecord(records.get(i * 2));\n+            }\n+            context.commit();\n+        }\n+        openSimpleMetaData(hookAdd);\n+        try (FDBRecordContext context = openContext()) {\n+            context.commit();\n+        }\n+\n+        int[] inserts = {2, 5, 11, 17, 15};\n+        for (int i = 0; i < inserts.length; i++) {\n+            int record_i = inserts[i];\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(records.get(record_i));\n+                        // This record might be added in the indexer's range, but the transaction still commits because it doesn't\n+                        // change any existing records.\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedOtherType() {\n+\n+        List<TestRecords1Proto.MySimpleRecord> records =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(val * 2).setNumValue2((int)val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecords =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 1).build()\n+                ).collect(Collectors.toList());\n+\n+        List<TestRecords1Proto.MyOtherRecord> otherRecordsOverwrite =\n+                LongStream.range(0, 7).mapToObj(val -> TestRecords1Proto.MyOtherRecord.newBuilder().setRecNo(val * 2 + 1).setNumValue2((int) val + 101).build()\n+                ).collect(Collectors.toList());\n+\n+        Index index = new Index(\"newIndex\", field(\"num_value_2\"), IndexTypes.VALUE);\n+        FDBRecordStoreTestBase.RecordMetaDataHook hookAdd = metaDataBuilder -> metaDataBuilder.addIndex(\"MySimpleRecord\", index);\n+\n+        openSimpleMetaData();\n+        try (FDBRecordContext context = openContext()) {\n+            records.forEach(recordStore::saveRecord);\n+            otherRecords.forEach(recordStore::saveRecord);\n+            context.commit();\n+        }\n+        openSimpleMetaData(hookAdd);\n+        try (FDBRecordContext context = openContext()) {\n+            context.commit();\n+        }\n+\n+        otherRecordsOverwrite.forEach(rec -> {\n+\n+            try (FDBRecordContext context1 = openContext()) {\n+                try (OnlineIndexer indexer =\n+                             OnlineIndexer.newBuilder()\n+                                     .setRecordStore(recordStore)\n+                                     .setIndex(\"newIndex\")\n+                                     .build()) {\n+                    indexer.buildRange(recordStore, null, null).join();\n+                    try (FDBRecordContext context2 = openContext()) {\n+                        recordStore.saveRecord(rec);\n+                        // This record's type is different than the indexer's, so both commits should succeed\n+                        context2.commit();\n+                    }\n+                    context1.commit();\n+                }\n+            }\n+\n+            try (FDBRecordContext context = openContext()) {\n+                recordStore.clearAndMarkIndexWriteOnly(index).join();\n+                context.commit();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testAddRecordToRangeWhileIndexedIdempotentFailure() {", "originalCommit": "9a857ec3666b81d75ce21ae79cd67f318ec77bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "12b07955f26082a418f529c0b44c2571b9718b16", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\nindex a7b76608..d1fad3de 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/OnlineIndexerConflictsTest.java\n\n@@ -23,6 +23,7 @@ package com.apple.foundationdb.record.provider.foundationdb;\n import com.apple.foundationdb.record.TestRecords1Proto;\n import com.apple.foundationdb.record.metadata.Index;\n import com.apple.foundationdb.record.metadata.IndexTypes;\n+import com.apple.foundationdb.record.metadata.Key;\n import com.apple.test.Tags;\n import org.junit.jupiter.api.Tag;\n import org.junit.jupiter.api.Test;\n"}}, {"oid": "12b07955f26082a418f529c0b44c2571b9718b16", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/12b07955f26082a418f529c0b44c2571b9718b16", "message": "implement changes requested by Alec", "committedDate": "2020-08-22T01:35:28Z", "type": "commit"}]}