{"pr_number": 904, "pr_title": "Resolves #903 Reorganize tests", "pr_createdAt": "2020-04-14T19:50:09Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/904", "timeline": [{"oid": "835ea4f082175b9b167245f86ffd540dc19f9e7f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/835ea4f082175b9b167245f86ffd540dc19f9e7f", "message": "Fix FDBRecordStoreStateCacheTest parameterized names", "committedDate": "2020-04-14T19:30:14Z", "type": "commit"}, {"oid": "3925af3ca001b7399fb35d713b5ffe6a5a10d353", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/3925af3ca001b7399fb35d713b5ffe6a5a10d353", "message": "Test: Remove unnecessary reopening of stores", "committedDate": "2020-04-14T19:30:14Z", "type": "commit"}, {"oid": "a376cc2d229dc6169d77048cba87d600f67fef30", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/a376cc2d229dc6169d77048cba87d600f67fef30", "message": "Test: Don't use openStore helpers just to open something else\n\nThere's a bunch of test code that calls openStore, and then converts\nit to a builder, to change something and then re-open. Inline those,\nin part to deal with the upcoming fix to #489, and in part because\nit makes the code cleaner.\nAlso, one of the tests did not have a try around the contexts.", "committedDate": "2020-04-14T21:28:38Z", "type": "commit"}, {"oid": "bf404a80df2212963bc0f96ee91006942a871a1a", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/bf404a80df2212963bc0f96ee91006942a871a1a", "message": "Cleanup a bunch of intelliJ warnings in test files", "committedDate": "2020-04-14T21:45:51Z", "type": "forcePushed"}, {"oid": "d6552084e235bd57aa5725c3045d462695cbd602", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/d6552084e235bd57aa5725c3045d462695cbd602", "message": "Resolves #903 Creating a bunch more fixtures\n\nThis probably isn't perfect, but better, I hope.\nThere were no code changes to any of the methods as part of this\nchange, just moving them between classes.", "committedDate": "2020-04-15T14:57:35Z", "type": "commit"}, {"oid": "c2dec708e1b858a3d4f6bb6e0ee11e73b301d6bf", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/c2dec708e1b858a3d4f6bb6e0ee11e73b301d6bf", "message": "Cleanup a bunch of intelliJ warnings in test files", "committedDate": "2020-04-15T14:59:05Z", "type": "commit"}, {"oid": "c2dec708e1b858a3d4f6bb6e0ee11e73b301d6bf", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/c2dec708e1b858a3d4f6bb6e0ee11e73b301d6bf", "message": "Cleanup a bunch of intelliJ warnings in test files", "committedDate": "2020-04-15T14:59:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5MTAyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/904#discussion_r408991022", "bodyText": "This is maybe a different change, but I believe this is using uncheckedOpen in order to avoid conflicting on the store header create. I suspect we could make this a \"real\" open if we opened the store in a separate, initial transaction before all of this. Then the other operations would just read the store header rather than change it.", "author": "alecgrieser", "createdAt": "2020-04-15T16:54:01Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java", "diffHunk": "@@ -2459,55 +2461,56 @@ public void testSubspaceWriteConflict() throws Exception {\n     @Test\n     public void testSubspaceReadWriteConflict() throws Exception {\n         // Double check that it works to have two contexts on same space writing different records without conflict.\n-        FDBRecordContext context1 = openContext();\n-        uncheckedOpenSimpleRecordStore(context1);\n-        FDBRecordStore recordStore1 = recordStore;\n-        recordStore1.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(1).build());\n-        try (FDBRecordContext context2 = openContext()) {\n-            uncheckedOpenSimpleRecordStore(context2);\n-            recordStore.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(2).build());\n-            commit(context2);\n+        try (FDBRecordContext context1 = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context1);", "originalCommit": "a376cc2d229dc6169d77048cba87d600f67fef30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3b0c27c4885b781a905dba8fb371ad480f2fc86", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\nindex f09cab1e..d67307a0 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\n\n@@ -2491,195 +729,59 @@ public class FDBRecordStoreTest extends FDBRecordStoreTestBase {\n         }\n     }\n \n-    @Test\n-    public void testFormatVersionUpgrade() throws Exception {\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1)\n-                    .create();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION)\n-                    .open();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1)\n-                    .open();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-    }\n-\n     /**\n      * Test that the user field can be set.\n      */\n     @Test\n     public void testAccessUserField() throws Exception {\n         try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertNull(recordStore.getHeaderUserField(\"foo\"));\n-            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertEquals(\"bar\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(1, storeHeader.getUserFieldCount());\n-\n-            // Validate that one can overwrite an existing value\n-            recordStore.setHeaderUserField(\"foo\", \"\u00b5s\".getBytes(Charsets.UTF_8));\n-            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(1, storeHeader.getUserFieldCount());\n-\n-            // Validate that one can add a new value\n-            recordStore.setHeaderUserField(\"baz\", field(\"baz\").toKeyExpression().toByteString());\n-            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(2, storeHeader.getUserFieldCount());\n-\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            // Read back the stored values\n-            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            ByteString bazValue = recordStore.getHeaderUserField(\"baz\");\n-            assertNotNull(bazValue);\n-            KeyExpression expr = KeyExpression.fromProto(RecordMetaDataProto.KeyExpression.parseFrom(bazValue));\n-            assertEquals(field(\"baz\"), expr);\n-\n-            // Add in a new field\n-            recordStore.setHeaderUserField(\"qwop\", Tuple.from(1066L).pack());\n-\n-            // Delete the middle field\n-            recordStore.clearHeaderUserField(\"baz\");\n-            assertNull(recordStore.getHeaderUserField(\"baz\"));\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            assertNull(recordStore.getHeaderUserField(\"baz\"));\n-            assertEquals(Tuple.from(1066L), Tuple.fromBytes(recordStore.getHeaderUserField(\"qwop\").toByteArray()));\n-            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(2, storeHeader.getUserFieldCount());\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * Test that if a header user field is set that it's value can be read in the same transaction (i.e., that it\n-     * supports read-your-writes).\n-     */\n-    @Test\n-    public void testReadYourWritesWithHeaderUserField() throws Exception {\n-        final String userField = \"my_key\";\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            recordStore.setHeaderUserField(userField, ByteString.copyFromUtf8(\"my_value\"));\n-            assertEquals(\"my_value\", recordStore.getHeaderUserField(userField).toStringUtf8());\n-            // do not commit to make sure it is *only* updated at commit time\n-        }\n-\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertNull(recordStore.getHeaderUserField(\"my_key\"));\n-            recordStore.setHeaderUserField(userField, ByteString.copyFromUtf8(\"my_other_value\"));\n-            assertEquals(\"my_other_value\", recordStore.getHeaderUserField(userField).toStringUtf8());\n-\n-            // Create a new record store to validate that a new record store in the same transaction also sees the value\n-            // when opened after the value has been changed\n-            FDBRecordStore secondStore = recordStore.asBuilder().open();\n-            assertEquals(\"my_other_value\", secondStore.getHeaderUserField(userField).toStringUtf8());\n-\n-            secondStore.clearHeaderUserField(userField);\n-            assertNull(secondStore.getHeaderUserField(userField));\n-\n-            FDBRecordStore thirdStore = recordStore.asBuilder().open();\n-            assertNull(secondStore.getHeaderUserField(userField));\n-\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * This is essentially a bug, but this test exhibits the behavior. Essentially, if you have a two record store\n-     * objects opened on the same subspace in the same transaction, and then you update a header user field\n-     * in one, then it isn't updated in the other. There might be a solution that involves all of this \"shared state\"\n-     * living in some shared place for all record stores (as the same problem affects, say, index state information),\n-     * but that is not what the code does right now. See:\n-     * <a href=\"https://github.com/FoundationDB/fdb-record-layer/issues/489\">Issue #489</a>.\n-     */\n-    @Test\n-    public void testHeaderUserFieldNotUpdatedInRecordStoreOnSameSubspace() throws Exception {\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            recordStore.setHeaderUserField(\"user_field\", new byte[]{0x42});\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertArrayEquals(new byte[]{0x42}, recordStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            FDBRecordStore secondStore = recordStore.asBuilder().open();\n-            assertArrayEquals(new byte[]{0x42}, secondStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            recordStore.setHeaderUserField(\"user_field\", new byte[]{0x10, 0x66});\n-            assertArrayEquals(new byte[]{0x10, 0x66}, recordStore.getHeaderUserField(\"user_field\").toByteArray());\n-            assertArrayEquals(new byte[]{0x42}, secondStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * Test that accessing the header user fields at earlier format versions is disallowed.\n-     */\n-    @Test\n-    public void testAccessUserFieldAtOldFormatVersion() {\n-        final String expectedErrMsg = \"cannot access header user fields at current format version\";\n-        final RecordMetaData metaData = RecordMetaData.build(TestRecords1Proto.getDescriptor());\n-        FDBRecordStore.Builder storeBuilder = FDBRecordStore.newBuilder()\n-                .setKeySpacePath(path).setMetaDataProvider(metaData)\n-                .setFormatVersion(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION - 1);\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setContext(context).create();\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.getHeaderUserField(\"foo\"));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            assertNull(recordStore.getHeaderUserField(\"foo\"));\n+            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n             commit(context);\n         }\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setContext(context).open();\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8)));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            assertEquals(\"bar\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(1, storeHeader.getUserFieldCount());\n+\n+            // Validate that one can overwrite an existing value\n+            recordStore.setHeaderUserField(\"foo\", \"\u00b5s\".getBytes(Charsets.UTF_8));\n+            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(1, storeHeader.getUserFieldCount());\n+\n+            // Validate that one can add a new value\n+            recordStore.setHeaderUserField(\"baz\", field(\"baz\").toKeyExpression().toByteString());\n+            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(2, storeHeader.getUserFieldCount());\n+\n             commit(context);\n         }\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setFormatVersion(FDBRecordStore.INFO_ADDED_FORMAT_VERSION).setContext(context).open();\n-            assertEquals(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION - 1, recordStore.getFormatVersion());\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.clearHeaderUserField(\"foo\"));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            // Read back the stored values\n+            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            ByteString bazValue = recordStore.getHeaderUserField(\"baz\");\n+            assertNotNull(bazValue);\n+            KeyExpression expr = KeyExpression.fromProto(RecordMetaDataProto.KeyExpression.parseFrom(bazValue));\n+            assertEquals(field(\"baz\"), expr);\n+\n+            // Add in a new field\n+            recordStore.setHeaderUserField(\"qwop\", Tuple.from(1066L).pack());\n+\n+            // Delete the middle field\n+            recordStore.clearHeaderUserField(\"baz\");\n+            assertNull(recordStore.getHeaderUserField(\"baz\"));\n             commit(context);\n         }\n-        // Now try upgrading the format version and validate that the fields can be read\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setFormatVersion(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION)\n-                    .setContext(context).open();\n-            assertEquals(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION, recordStore.getFormatVersion());\n-            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n-            String val = recordStore.getHeaderUserField(\"foo\").toStringUtf8();\n-            assertEquals(\"bar\", val);\n-            recordStore.clearHeaderUserField(\"foo\");\n-            assertNull(recordStore.getHeaderUserField(\"foo\"));\n+            openSimpleRecordStore(context);\n+            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            assertNull(recordStore.getHeaderUserField(\"baz\"));\n+            assertEquals(Tuple.from(1066L), Tuple.fromBytes(recordStore.getHeaderUserField(\"qwop\").toByteArray()));\n+            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(2, storeHeader.getUserFieldCount());\n             commit(context);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk5MTk1OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/904#discussion_r408991958", "bodyText": "I guess this change here is logic preserving, but we could probably also achieve more or less the same check by asserting that the exception is of type FDBStoreTransactionConflictException (or whatever it's called) instead of FDBStoreRetriableException.", "author": "alecgrieser", "createdAt": "2020-04-15T16:55:37Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java", "diffHunk": "@@ -2459,55 +2461,56 @@ public void testSubspaceWriteConflict() throws Exception {\n     @Test\n     public void testSubspaceReadWriteConflict() throws Exception {\n         // Double check that it works to have two contexts on same space writing different records without conflict.\n-        FDBRecordContext context1 = openContext();\n-        uncheckedOpenSimpleRecordStore(context1);\n-        FDBRecordStore recordStore1 = recordStore;\n-        recordStore1.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(1).build());\n-        try (FDBRecordContext context2 = openContext()) {\n-            uncheckedOpenSimpleRecordStore(context2);\n-            recordStore.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(2).build());\n-            commit(context2);\n+        try (FDBRecordContext context1 = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context1);\n+            FDBRecordStore recordStore1 = recordStore;\n+            recordStore1.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(1).build());\n+            try (FDBRecordContext context2 = openContext()) {\n+                uncheckedOpenSimpleRecordStore(context2);\n+                recordStore.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(2).build());\n+                commit(context2);\n+            }\n+            commit(context1);\n         }\n-        commit(context1);\n \n         // Again with requested conflict.\n-        FDBRecordContext context3 = openContext();\n-        uncheckedOpenSimpleRecordStore(context3);\n-        FDBRecordStore recordStore3 = recordStore;\n-        recordStore3.addConflictForSubspace(false);\n-        recordStore3.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(3).build());\n-        try (FDBRecordContext context4 = openContext()) {\n-            uncheckedOpenSimpleRecordStore(context4);\n-            recordStore.addConflictForSubspace(false);\n-            recordStore.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(4).build());\n-            commit(context4);\n-        }\n-        try {\n-            commit(context3);\n-            fail(\"should have gotten failure\");\n-        } catch (FDBExceptions.FDBStoreRetriableException ex) {\n-            assertTrue(ex.getCause() instanceof FDBException);\n-            assertThat(((FDBException)ex.getCause()).getCode(), equalTo(1020)); // not_committed\n+        try (FDBRecordContext context3 = openContext()) {\n+            uncheckedOpenSimpleRecordStore(context3);\n+            FDBRecordStore recordStore3 = recordStore;\n+            recordStore3.addConflictForSubspace(false);\n+            recordStore3.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(3).build());\n+            try (FDBRecordContext context4 = openContext()) {\n+                uncheckedOpenSimpleRecordStore(context4);\n+                recordStore.addConflictForSubspace(false);\n+                recordStore.saveRecord(TestRecords1Proto.MySimpleRecord.newBuilder().setRecNo(4).build());\n+                commit(context4);\n+            }\n+            final FDBExceptions.FDBStoreRetriableException exception = assertThrows(FDBExceptions.FDBStoreRetriableException.class,\n+                    () -> commit(context3));\n+            assertThat(((FDBException)exception.getCause()).getCode(), equalTo(1020)); // not_committed", "originalCommit": "a376cc2d229dc6169d77048cba87d600f67fef30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3b0c27c4885b781a905dba8fb371ad480f2fc86", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\nindex f09cab1e..d67307a0 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreTest.java\n\n@@ -2491,195 +729,59 @@ public class FDBRecordStoreTest extends FDBRecordStoreTestBase {\n         }\n     }\n \n-    @Test\n-    public void testFormatVersionUpgrade() throws Exception {\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1)\n-                    .create();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION)\n-                    .open();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = getStoreBuilder(context, simpleMetaData(NO_HOOK))\n-                    .setFormatVersion(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION - 1)\n-                    .open();\n-            assertEquals(FDBRecordStore.MAX_SUPPORTED_FORMAT_VERSION, recordStore.getFormatVersion());\n-            commit(context);\n-        }\n-    }\n-\n     /**\n      * Test that the user field can be set.\n      */\n     @Test\n     public void testAccessUserField() throws Exception {\n         try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertNull(recordStore.getHeaderUserField(\"foo\"));\n-            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertEquals(\"bar\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(1, storeHeader.getUserFieldCount());\n-\n-            // Validate that one can overwrite an existing value\n-            recordStore.setHeaderUserField(\"foo\", \"\u00b5s\".getBytes(Charsets.UTF_8));\n-            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(1, storeHeader.getUserFieldCount());\n-\n-            // Validate that one can add a new value\n-            recordStore.setHeaderUserField(\"baz\", field(\"baz\").toKeyExpression().toByteString());\n-            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(2, storeHeader.getUserFieldCount());\n-\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            // Read back the stored values\n-            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            ByteString bazValue = recordStore.getHeaderUserField(\"baz\");\n-            assertNotNull(bazValue);\n-            KeyExpression expr = KeyExpression.fromProto(RecordMetaDataProto.KeyExpression.parseFrom(bazValue));\n-            assertEquals(field(\"baz\"), expr);\n-\n-            // Add in a new field\n-            recordStore.setHeaderUserField(\"qwop\", Tuple.from(1066L).pack());\n-\n-            // Delete the middle field\n-            recordStore.clearHeaderUserField(\"baz\");\n-            assertNull(recordStore.getHeaderUserField(\"baz\"));\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n-            assertNull(recordStore.getHeaderUserField(\"baz\"));\n-            assertEquals(Tuple.from(1066L), Tuple.fromBytes(recordStore.getHeaderUserField(\"qwop\").toByteArray()));\n-            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n-            assertEquals(2, storeHeader.getUserFieldCount());\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * Test that if a header user field is set that it's value can be read in the same transaction (i.e., that it\n-     * supports read-your-writes).\n-     */\n-    @Test\n-    public void testReadYourWritesWithHeaderUserField() throws Exception {\n-        final String userField = \"my_key\";\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            recordStore.setHeaderUserField(userField, ByteString.copyFromUtf8(\"my_value\"));\n-            assertEquals(\"my_value\", recordStore.getHeaderUserField(userField).toStringUtf8());\n-            // do not commit to make sure it is *only* updated at commit time\n-        }\n-\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertNull(recordStore.getHeaderUserField(\"my_key\"));\n-            recordStore.setHeaderUserField(userField, ByteString.copyFromUtf8(\"my_other_value\"));\n-            assertEquals(\"my_other_value\", recordStore.getHeaderUserField(userField).toStringUtf8());\n-\n-            // Create a new record store to validate that a new record store in the same transaction also sees the value\n-            // when opened after the value has been changed\n-            FDBRecordStore secondStore = recordStore.asBuilder().open();\n-            assertEquals(\"my_other_value\", secondStore.getHeaderUserField(userField).toStringUtf8());\n-\n-            secondStore.clearHeaderUserField(userField);\n-            assertNull(secondStore.getHeaderUserField(userField));\n-\n-            FDBRecordStore thirdStore = recordStore.asBuilder().open();\n-            assertNull(secondStore.getHeaderUserField(userField));\n-\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * This is essentially a bug, but this test exhibits the behavior. Essentially, if you have a two record store\n-     * objects opened on the same subspace in the same transaction, and then you update a header user field\n-     * in one, then it isn't updated in the other. There might be a solution that involves all of this \"shared state\"\n-     * living in some shared place for all record stores (as the same problem affects, say, index state information),\n-     * but that is not what the code does right now. See:\n-     * <a href=\"https://github.com/FoundationDB/fdb-record-layer/issues/489\">Issue #489</a>.\n-     */\n-    @Test\n-    public void testHeaderUserFieldNotUpdatedInRecordStoreOnSameSubspace() throws Exception {\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            recordStore.setHeaderUserField(\"user_field\", new byte[]{0x42});\n-            commit(context);\n-        }\n-        try (FDBRecordContext context = openContext()) {\n-            openSimpleRecordStore(context);\n-            assertArrayEquals(new byte[]{0x42}, recordStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            FDBRecordStore secondStore = recordStore.asBuilder().open();\n-            assertArrayEquals(new byte[]{0x42}, secondStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            recordStore.setHeaderUserField(\"user_field\", new byte[]{0x10, 0x66});\n-            assertArrayEquals(new byte[]{0x10, 0x66}, recordStore.getHeaderUserField(\"user_field\").toByteArray());\n-            assertArrayEquals(new byte[]{0x42}, secondStore.getHeaderUserField(\"user_field\").toByteArray());\n-\n-            commit(context);\n-        }\n-    }\n-\n-    /**\n-     * Test that accessing the header user fields at earlier format versions is disallowed.\n-     */\n-    @Test\n-    public void testAccessUserFieldAtOldFormatVersion() {\n-        final String expectedErrMsg = \"cannot access header user fields at current format version\";\n-        final RecordMetaData metaData = RecordMetaData.build(TestRecords1Proto.getDescriptor());\n-        FDBRecordStore.Builder storeBuilder = FDBRecordStore.newBuilder()\n-                .setKeySpacePath(path).setMetaDataProvider(metaData)\n-                .setFormatVersion(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION - 1);\n-        try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setContext(context).create();\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.getHeaderUserField(\"foo\"));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            assertNull(recordStore.getHeaderUserField(\"foo\"));\n+            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n             commit(context);\n         }\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setContext(context).open();\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8)));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            assertEquals(\"bar\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(1, storeHeader.getUserFieldCount());\n+\n+            // Validate that one can overwrite an existing value\n+            recordStore.setHeaderUserField(\"foo\", \"\u00b5s\".getBytes(Charsets.UTF_8));\n+            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(1, storeHeader.getUserFieldCount());\n+\n+            // Validate that one can add a new value\n+            recordStore.setHeaderUserField(\"baz\", field(\"baz\").toKeyExpression().toByteString());\n+            storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(2, storeHeader.getUserFieldCount());\n+\n             commit(context);\n         }\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setFormatVersion(FDBRecordStore.INFO_ADDED_FORMAT_VERSION).setContext(context).open();\n-            assertEquals(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION - 1, recordStore.getFormatVersion());\n-            RecordCoreException err = assertThrows(RecordCoreException.class,\n-                    () -> recordStore.clearHeaderUserField(\"foo\"));\n-            assertEquals(expectedErrMsg, err.getMessage());\n+            openSimpleRecordStore(context);\n+            // Read back the stored values\n+            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            ByteString bazValue = recordStore.getHeaderUserField(\"baz\");\n+            assertNotNull(bazValue);\n+            KeyExpression expr = KeyExpression.fromProto(RecordMetaDataProto.KeyExpression.parseFrom(bazValue));\n+            assertEquals(field(\"baz\"), expr);\n+\n+            // Add in a new field\n+            recordStore.setHeaderUserField(\"qwop\", Tuple.from(1066L).pack());\n+\n+            // Delete the middle field\n+            recordStore.clearHeaderUserField(\"baz\");\n+            assertNull(recordStore.getHeaderUserField(\"baz\"));\n             commit(context);\n         }\n-        // Now try upgrading the format version and validate that the fields can be read\n         try (FDBRecordContext context = openContext()) {\n-            recordStore = storeBuilder.setFormatVersion(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION)\n-                    .setContext(context).open();\n-            assertEquals(FDBRecordStore.HEADER_USER_FIELDS_FORMAT_VERSION, recordStore.getFormatVersion());\n-            recordStore.setHeaderUserField(\"foo\", \"bar\".getBytes(Charsets.UTF_8));\n-            String val = recordStore.getHeaderUserField(\"foo\").toStringUtf8();\n-            assertEquals(\"bar\", val);\n-            recordStore.clearHeaderUserField(\"foo\");\n-            assertNull(recordStore.getHeaderUserField(\"foo\"));\n+            openSimpleRecordStore(context);\n+            assertEquals(\"\u00b5s\", recordStore.getHeaderUserField(\"foo\").toStringUtf8());\n+            assertNull(recordStore.getHeaderUserField(\"baz\"));\n+            assertEquals(Tuple.from(1066L), Tuple.fromBytes(recordStore.getHeaderUserField(\"qwop\").toByteArray()));\n+            RecordMetaDataProto.DataStoreInfo storeHeader = recordStore.getRecordStoreState().getStoreHeader();\n+            assertEquals(2, storeHeader.getUserFieldCount());\n             commit(context);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTEzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/904#discussion_r410455138", "bodyText": "This kind of feels like it should be, like, an \"index\" test rather than a uniqueness test, in that it's really testing that behavior rather than the store's. But probably a rename that could happen later.", "author": "alecgrieser", "createdAt": "2020-04-17T20:31:03Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniquenessTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * FDBRecordStoreUniquenessTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.RecordIndexUniquenessViolation;\n+import com.apple.foundationdb.record.TestRecords1Proto;\n+import com.apple.foundationdb.record.TestRecordsBytesProto;\n+import com.apple.foundationdb.tuple.Tuple;\n+import com.apple.test.Tags;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * Tests of uniqueness checks.\n+ */\n+@Tag(Tags.RequiresFDB)\n+public class FDBRecordStoreUniquenessTest extends FDBRecordStoreTestBase {", "originalCommit": "d6552084e235bd57aa5725c3045d462695cbd602", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3b0c27c4885b781a905dba8fb371ad480f2fc86", "chunk": "diff --git a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniquenessTest.java b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniqueIndexTest.java\nsimilarity index 98%\nrename from fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniquenessTest.java\nrename to fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniqueIndexTest.java\nindex d59774de..4f93981c 100644\n--- a/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniquenessTest.java\n+++ b/fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/FDBRecordStoreUniqueIndexTest.java\n\n@@ -40,7 +40,7 @@ import static org.junit.jupiter.api.Assertions.assertThrows;\n  * Tests of uniqueness checks.\n  */\n @Tag(Tags.RequiresFDB)\n-public class FDBRecordStoreUniquenessTest extends FDBRecordStoreTestBase {\n+public class FDBRecordStoreUniqueIndexTest extends FDBRecordStoreTestBase {\n \n     @Test\n     public void writeUniqueByteString() throws Exception {\n"}}, {"oid": "b3b0c27c4885b781a905dba8fb371ad480f2fc86", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/b3b0c27c4885b781a905dba8fb371ad480f2fc86", "message": "Rename FDBRecordStoreUniquenessTest -> FDBRecordStoreUniqueIndexTest", "committedDate": "2020-04-17T20:38:25Z", "type": "commit"}, {"oid": "624c5446ed7ce2e30c634890a08ac7c8b423f126", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/624c5446ed7ce2e30c634890a08ac7c8b423f126", "message": "Use open instead of uncheckedOpen in conflict test\n\nFDBRecordStoreTest.testSubspaceReadWriteConflict was calling\nuncheckedOpen, but only to avoid conflicting on the store creation.\nCreating the store in a separate transaction before is better.", "committedDate": "2020-04-17T20:42:42Z", "type": "commit"}, {"oid": "746c82edf2e87f419d3c9dda681e7d1658a37a67", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/746c82edf2e87f419d3c9dda681e7d1658a37a67", "message": "Catch specific exception, rather than examining fdb error code", "committedDate": "2020-04-17T20:44:11Z", "type": "commit"}]}