{"pr_number": 3149, "pr_title": "Added a reroute call when updating the maxLatency flow field.", "pr_createdAt": "2020-01-28T12:20:45Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3149", "timeline": [{"oid": "d1e8ae7680a707a64051ddc634f12f8bd25f0d94", "url": "https://github.com/telstra/open-kilda/commit/d1e8ae7680a707a64051ddc634f12f8bd25f0d94", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-01-28T12:25:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NzYwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r371777601", "bodyText": "strategyIsLMaxLatency", "author": "niksv", "createdAt": "2020-01-28T12:40:01Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -279,9 +288,43 @@ public UnidirectionalFlow updateFlow(FlowDto flow) throws FlowNotFoundException\n \n             flowRepository.createOrUpdate(currentFlow);\n \n-            return Optional.of(forwardFlow);\n+            return Optional.of(result.updatedFlow(forwardFlow).build());\n \n         }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+\n+        if (updateFlowResult.isNeedRerouteFlow()) {\n+            Flow updatedFlow = updateFlowResult.getUpdatedFlow().getFlow();\n+            Set<PathId> pathIds = new HashSet<>(updatedFlow.getFlowPathIds());\n+            carrier.sendRerouteRequest(Collections.singletonMap(updatedFlow.getFlowId(), pathIds),\n+                    updateFlowResult.getRerouteReason());\n+        }\n+\n+        return updateFlowResult.getUpdatedFlow();\n+    }\n+\n+    @VisibleForTesting\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n+        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n+                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n+                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency = flowDto.getPathComputationStrategy() != null", "originalCommit": "d1e8ae7680a707a64051ddc634f12f8bd25f0d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxMDg1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r371810857", "bodyText": "noooooooo", "author": "rtretyak", "createdAt": "2020-01-28T13:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0NTU4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r371845586", "bodyText": "oh. my bad. your name is correct", "author": "niksv", "createdAt": "2020-01-28T14:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NzYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\nindex 8158e365b..e68fbf47d 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n\n@@ -308,10 +308,9 @@ public class FlowOperationsService {\n                 && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n         boolean changedMaxLatency = flowDto.getMaxLatency() != null\n                 && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = flowDto.getPathComputationStrategy() != null\n-                && flowDto.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY)\n-                || flowDto.getPathComputationStrategy() == null && flow.getPathComputationStrategy() != null\n-                && flow.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY);\n+        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n+                || flowDto.getPathComputationStrategy() == null\n+                && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n         String reason = null;\n         if (changedStrategy) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NDQ1NA==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r371784454", "bodyText": "it could be simplified\n boolean strategyIsMaxLatency = \n    PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n    || flowDto.getPathComputationStrategy() == null \n    && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy())", "author": "niksv", "createdAt": "2020-01-28T12:55:10Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -279,9 +288,43 @@ public UnidirectionalFlow updateFlow(FlowDto flow) throws FlowNotFoundException\n \n             flowRepository.createOrUpdate(currentFlow);\n \n-            return Optional.of(forwardFlow);\n+            return Optional.of(result.updatedFlow(forwardFlow).build());\n \n         }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+\n+        if (updateFlowResult.isNeedRerouteFlow()) {\n+            Flow updatedFlow = updateFlowResult.getUpdatedFlow().getFlow();\n+            Set<PathId> pathIds = new HashSet<>(updatedFlow.getFlowPathIds());\n+            carrier.sendRerouteRequest(Collections.singletonMap(updatedFlow.getFlowId(), pathIds),\n+                    updateFlowResult.getRerouteReason());\n+        }\n+\n+        return updateFlowResult.getUpdatedFlow();\n+    }\n+\n+    @VisibleForTesting\n+    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n+        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n+                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n+        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n+                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n+        boolean strategyIsMaxLatency = flowDto.getPathComputationStrategy() != null\n+                && flowDto.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY)\n+                || flowDto.getPathComputationStrategy() == null && flow.getPathComputationStrategy() != null\n+                && flow.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY);", "originalCommit": "d1e8ae7680a707a64051ddc634f12f8bd25f0d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMjg2MA==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r372212860", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-01-29T06:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4NDQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\nindex 8158e365b..e68fbf47d 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n\n@@ -308,10 +308,9 @@ public class FlowOperationsService {\n                 && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n         boolean changedMaxLatency = flowDto.getMaxLatency() != null\n                 && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = flowDto.getPathComputationStrategy() != null\n-                && flowDto.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY)\n-                || flowDto.getPathComputationStrategy() == null && flow.getPathComputationStrategy() != null\n-                && flow.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY);\n+        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n+                || flowDto.getPathComputationStrategy() == null\n+                && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n         String reason = null;\n         if (changedStrategy) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc5MjI1NA==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r371792254", "bodyText": "I'm not sure about pathIds. I guess we must get pathIds for reroute from original flow.", "author": "niksv", "createdAt": "2020-01-28T13:11:38Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -279,9 +288,43 @@ public UnidirectionalFlow updateFlow(FlowDto flow) throws FlowNotFoundException\n \n             flowRepository.createOrUpdate(currentFlow);\n \n-            return Optional.of(forwardFlow);\n+            return Optional.of(result.updatedFlow(forwardFlow).build());\n \n         }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n+\n+        if (updateFlowResult.isNeedRerouteFlow()) {\n+            Flow updatedFlow = updateFlowResult.getUpdatedFlow().getFlow();\n+            Set<PathId> pathIds = new HashSet<>(updatedFlow.getFlowPathIds());", "originalCommit": "d1e8ae7680a707a64051ddc634f12f8bd25f0d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5NTIwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r372195205", "bodyText": "This flow update does not affect the flow paths at this point.", "author": "dpoltavets", "createdAt": "2020-01-29T05:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc5MjI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\nindex 8158e365b..e68fbf47d 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n\n@@ -308,10 +308,9 @@ public class FlowOperationsService {\n                 && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n         boolean changedMaxLatency = flowDto.getMaxLatency() != null\n                 && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = flowDto.getPathComputationStrategy() != null\n-                && flowDto.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY)\n-                || flowDto.getPathComputationStrategy() == null && flow.getPathComputationStrategy() != null\n-                && flow.getPathComputationStrategy().equals(PathComputationStrategy.MAX_LATENCY);\n+        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n+                || flowDto.getPathComputationStrategy() == null\n+                && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n \n         String reason = null;\n         if (changedStrategy) {\n"}}, {"oid": "b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "url": "https://github.com/telstra/open-kilda/commit/b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-01-29T06:42:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDc4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r373934785", "bodyText": "I think you need to add saving of getPathComputationStrategy() into currentFlow. like in lines 20 and 283", "author": "niksv", "createdAt": "2020-02-03T06:11:13Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -279,9 +288,42 @@ public UnidirectionalFlow updateFlow(FlowDto flow) throws FlowNotFoundException\n \n             flowRepository.createOrUpdate(currentFlow);\n \n-            return Optional.of(forwardFlow);\n+            return Optional.of(result.updatedFlow(forwardFlow).build());", "originalCommit": "b95ad6d4dc28b6a768c7700bcece82efc59c59ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNjE1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3149#discussion_r373936153", "bodyText": "Saving of getPathComputationStrategy() is added here: #3036", "author": "dpoltavets", "createdAt": "2020-02-03T06:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d72513da4a6f363bf24031c75b6cf5ef86d08261", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\ndeleted file mode 100644\nindex e68fbf47d..000000000\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n+++ /dev/null\n\n@@ -1,352 +0,0 @@\n-/* Copyright 2019 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.wfm.topology.nbworker.services;\n-\n-import static java.lang.String.format;\n-import static org.apache.commons.collections4.ListUtils.union;\n-\n-import org.openkilda.messaging.model.FlowDto;\n-import org.openkilda.messaging.model.FlowPathDto;\n-import org.openkilda.messaging.model.FlowPathDto.FlowPathDtoBuilder;\n-import org.openkilda.messaging.model.FlowPathDto.FlowProtectedPathDto;\n-import org.openkilda.messaging.payload.flow.PathNodePayload;\n-import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowPair;\n-import org.openkilda.model.FlowPath;\n-import org.openkilda.model.PathComputationStrategy;\n-import org.openkilda.model.PathId;\n-import org.openkilda.model.SwitchConnectedDevice;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.model.UnidirectionalFlow;\n-import org.openkilda.persistence.TransactionManager;\n-import org.openkilda.persistence.repositories.FlowPairRepository;\n-import org.openkilda.persistence.repositories.FlowPathRepository;\n-import org.openkilda.persistence.repositories.FlowRepository;\n-import org.openkilda.persistence.repositories.IslRepository;\n-import org.openkilda.persistence.repositories.RepositoryFactory;\n-import org.openkilda.persistence.repositories.SwitchConnectedDeviceRepository;\n-import org.openkilda.persistence.repositories.SwitchRepository;\n-import org.openkilda.wfm.error.FlowNotFoundException;\n-import org.openkilda.wfm.error.IslNotFoundException;\n-import org.openkilda.wfm.error.SwitchNotFoundException;\n-import org.openkilda.wfm.share.logger.FlowOperationsDashboardLogger;\n-import org.openkilda.wfm.share.mappers.FlowPathMapper;\n-import org.openkilda.wfm.share.service.IntersectionComputer;\n-import org.openkilda.wfm.topology.nbworker.bolts.FlowOperationBoltCarrier;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import lombok.Builder;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-@Slf4j\n-public class FlowOperationsService {\n-    private final FlowOperationsDashboardLogger flowDashboardLogger = new FlowOperationsDashboardLogger(log);\n-    private TransactionManager transactionManager;\n-    private IslRepository islRepository;\n-    private SwitchRepository switchRepository;\n-    private FlowRepository flowRepository;\n-    private FlowPairRepository flowPairRepository;\n-    private FlowPathRepository flowPathRepository;\n-    private SwitchConnectedDeviceRepository switchConnectedDeviceRepository;\n-\n-    public FlowOperationsService(RepositoryFactory repositoryFactory, TransactionManager transactionManager) {\n-        this.islRepository = repositoryFactory.createIslRepository();\n-        this.switchRepository = repositoryFactory.createSwitchRepository();\n-        this.flowRepository = repositoryFactory.createFlowRepository();\n-        this.flowPairRepository = repositoryFactory.createFlowPairRepository();\n-        this.flowPathRepository = repositoryFactory.createFlowPathRepository();\n-        this.switchConnectedDeviceRepository = repositoryFactory.createSwitchConnectedDeviceRepository();\n-        this.transactionManager = transactionManager;\n-    }\n-\n-    /**\n-     * Return flow by flow id.\n-     */\n-    public Flow getFlow(String flowId) throws FlowNotFoundException {\n-        return flowRepository.findById(flowId).orElseThrow(() -> new FlowNotFoundException(flowId));\n-    }\n-\n-    /**\n-     * Return all paths for a particular link.\n-     *\n-     * @param srcSwitchId source switch id.\n-     * @param srcPort     source port.\n-     * @param dstSwitchId destination switch id.\n-     * @param dstPort     destination port.\n-     * @return all paths for a particular link.\n-     * @throws IslNotFoundException if there is no link with these parameters.\n-     */\n-    public Collection<FlowPath> getFlowPathsForLink(SwitchId srcSwitchId, Integer srcPort,\n-                                                    SwitchId dstSwitchId, Integer dstPort)\n-            throws IslNotFoundException {\n-\n-        flowDashboardLogger.onFlowPathsDumpByLink(srcSwitchId, srcPort, dstSwitchId, dstPort);\n-\n-        if (!islRepository.findByEndpoints(srcSwitchId, srcPort, dstSwitchId, dstPort).isPresent()) {\n-            throw new IslNotFoundException(srcSwitchId, srcPort, dstSwitchId, dstPort);\n-        }\n-\n-        return flowPathRepository.findWithPathSegment(srcSwitchId, srcPort, dstSwitchId, dstPort);\n-    }\n-\n-    /**\n-     * Return all paths for a particular endpoint or for a particular switch if port is null.\n-     *\n-     * @param switchId switch id.\n-     * @param port     port.\n-     * @return all paths for a particular endpoint.\n-     * @throws SwitchNotFoundException if there is no switch with this switch id.\n-     */\n-    public Collection<FlowPath> getFlowPathsForEndpoint(SwitchId switchId, Integer port)\n-            throws SwitchNotFoundException {\n-\n-        flowDashboardLogger.onFlowPathsDumpByEndpoint(switchId, port);\n-\n-        if (!switchRepository.findById(switchId).isPresent()) {\n-            throw new SwitchNotFoundException(switchId);\n-        }\n-\n-        if (port != null) {\n-            List<FlowPath> flowPaths = new ArrayList<>(flowPathRepository.findBySegmentEndpoint(switchId, port));\n-            flowRepository.findByEndpoint(switchId, port).stream().findAny()\n-                    .ifPresent(flow -> flowPaths.add(flow.getForwardPath()));\n-            return flowPaths;\n-        } else {\n-            List<FlowPath> flowPaths = new ArrayList<>(flowPathRepository.findBySegmentSwitch(switchId));\n-            flowRepository.findByEndpointSwitch(switchId).stream().findAny()\n-                    .ifPresent(flow -> flowPaths.add(flow.getForwardPath()));\n-            return flowPaths;\n-        }\n-\n-    }\n-\n-    /**\n-     * Groups passed flow paths by flow id.\n-     *\n-     * @param paths the flow paths for grouping.\n-     * @return map with grouped grouped flow paths.\n-     */\n-    public Map<String, Set<PathId>> groupFlowIdWithPathIdsForRerouting(Collection<FlowPath> paths) {\n-        return paths.stream()\n-                .collect(Collectors.groupingBy(path -> path.getFlow().getFlowId(),\n-                        Collectors.mapping(FlowPath::getPathId, Collectors.toSet())));\n-    }\n-\n-    public Optional<FlowPair> getFlowPairById(String flowId) {\n-        return flowPairRepository.findById(flowId);\n-    }\n-\n-    /**\n-     * Return flow paths for a switch.\n-     *\n-     * @param switchId switch id.\n-     * @return all flow paths for a switch.\n-     */\n-    public Collection<FlowPath> getFlowPathsForSwitch(SwitchId switchId) {\n-        flowDashboardLogger.onFlowPathsDumpBySwitch(switchId);\n-\n-        return flowPathRepository.findBySegmentSwitch(switchId);\n-    }\n-\n-    /**\n-     * Returns flow path. If flow has group, returns also path for each flow in group.\n-     *\n-     * @param flowId the flow to get a path.\n-     */\n-    public List<FlowPathDto> getFlowPath(String flowId) throws FlowNotFoundException {\n-        flowDashboardLogger.onFlowPathsRead(flowId);\n-\n-        Flow flow = flowRepository.findById(flowId)\n-                .orElseThrow(() -> new FlowNotFoundException(flowId));\n-\n-        String groupId = flow.getGroupId();\n-        if (groupId == null) {\n-            return Collections.singletonList(\n-                    toFlowPathDtoBuilder(flow).build());\n-        } else {\n-            Collection<Flow> flowsInGroup = flowRepository.findByGroupId(groupId);\n-            Collection<FlowPath> flowPathsInGroup = flowPathRepository.findByFlowGroupId(groupId);\n-\n-            IntersectionComputer primaryIntersectionComputer = new IntersectionComputer(\n-                    flow.getFlowId(), flow.getForwardPathId(), flow.getReversePathId(), flowPathsInGroup);\n-\n-            // target flow primary path\n-            FlowPathDtoBuilder targetFlowDtoBuilder = this.toFlowPathDtoBuilder(flow)\n-                    .segmentsStats(primaryIntersectionComputer.getOverlappingStats());\n-\n-            // other flows in the the group\n-            List<FlowPathDto> payloads = flowsInGroup.stream()\n-                    .filter(e -> !e.getFlowId().equals(flowId))\n-                    .map(e -> this.mapGroupPathFlowDto(e, true, primaryIntersectionComputer))\n-                    .collect(Collectors.toList());\n-\n-            if (flow.isAllocateProtectedPath()) {\n-                IntersectionComputer protectedIntersectionComputer = new IntersectionComputer(\n-                        flow.getFlowId(), flow.getProtectedForwardPathId(), flow.getProtectedReversePathId(),\n-                        flowPathsInGroup);\n-\n-                // target flow protected path\n-                targetFlowDtoBuilder.protectedPath(FlowProtectedPathDto.builder()\n-                        .forwardPath(buildPathFromFlow(flow, flow.getProtectedForwardPath()))\n-                        .reversePath(buildPathFromFlow(flow, flow.getProtectedReversePath()))\n-                        .segmentsStats(\n-                                protectedIntersectionComputer.getOverlappingStats())\n-                        .build());\n-\n-                // other flows in the the group\n-                List<FlowPathDto> protectedPathPayloads = flowsInGroup.stream()\n-                        .filter(e -> !e.getFlowId().equals(flowId))\n-                        .map(e -> this.mapGroupPathFlowDto(e, false, protectedIntersectionComputer))\n-                        .collect(Collectors.toList());\n-                payloads = union(payloads, protectedPathPayloads);\n-            }\n-\n-            payloads.add(targetFlowDtoBuilder.build());\n-\n-            return payloads;\n-        }\n-    }\n-\n-    private FlowPathDto mapGroupPathFlowDto(Flow flow, boolean primaryPathCorrespondStat,\n-                                            IntersectionComputer intersectionComputer) {\n-        FlowPathDtoBuilder builder = this.toFlowPathDtoBuilder(flow)\n-                .primaryPathCorrespondStat(primaryPathCorrespondStat)\n-                .segmentsStats(\n-                        intersectionComputer.getOverlappingStats(flow.getForwardPathId(), flow.getReversePathId()));\n-        if (flow.isAllocateProtectedPath()) {\n-            builder.protectedPath(FlowProtectedPathDto.builder()\n-                    .forwardPath(buildPathFromFlow(flow, flow.getProtectedForwardPath()))\n-                    .reversePath(buildPathFromFlow(flow, flow.getProtectedReversePath()))\n-                    .segmentsStats(\n-                            intersectionComputer.getOverlappingStats(\n-                                    flow.getProtectedForwardPathId(), flow.getProtectedReversePathId()))\n-                    .build());\n-        }\n-        return builder.build();\n-    }\n-\n-    private FlowPathDtoBuilder toFlowPathDtoBuilder(Flow flow) {\n-        return FlowPathDto.builder()\n-                .id(flow.getFlowId())\n-                .forwardPath(buildPathFromFlow(flow, flow.getForwardPath()))\n-                .reversePath(buildPathFromFlow(flow, flow.getReversePath()));\n-    }\n-\n-    private List<PathNodePayload> buildPathFromFlow(Flow flow, FlowPath flowPath) {\n-        return flowPath != null ? FlowPathMapper.INSTANCE.mapToPathNodes(flow, flowPath) : Collections.emptyList();\n-    }\n-\n-    /**\n-     * Update flow.\n-     *\n-     * @param flow flow.\n-     * @return updated flow.\n-     */\n-    public UnidirectionalFlow updateFlow(FlowDto flow, FlowOperationBoltCarrier carrier) throws FlowNotFoundException {\n-        UpdateFlowResult updateFlowResult = transactionManager.doInTransaction(() -> {\n-            Optional<FlowPair> foundFlow = flowPairRepository.findById(flow.getFlowId());\n-            if (!foundFlow.isPresent()) {\n-                return Optional.<UpdateFlowResult>empty();\n-            }\n-            UnidirectionalFlow forwardFlow = foundFlow.get().getForward();\n-            Flow currentFlow = forwardFlow.getFlow();\n-\n-            final UpdateFlowResult.UpdateFlowResultBuilder result = prepareFlowUpdateResult(flow, currentFlow);\n-\n-            if (flow.getMaxLatency() != null) {\n-                currentFlow.setMaxLatency(flow.getMaxLatency());\n-            }\n-            if (flow.getPriority() != null) {\n-                currentFlow.setPriority(flow.getPriority());\n-            }\n-\n-            flowDashboardLogger.onFlowPatchUpdate(currentFlow);\n-\n-            flowRepository.createOrUpdate(currentFlow);\n-\n-            return Optional.of(result.updatedFlow(forwardFlow).build());\n-\n-        }).orElseThrow(() -> new FlowNotFoundException(flow.getFlowId()));\n-\n-        if (updateFlowResult.isNeedRerouteFlow()) {\n-            Flow updatedFlow = updateFlowResult.getUpdatedFlow().getFlow();\n-            Set<PathId> pathIds = new HashSet<>(updatedFlow.getFlowPathIds());\n-            carrier.sendRerouteRequest(Collections.singletonMap(updatedFlow.getFlowId(), pathIds),\n-                    updateFlowResult.getRerouteReason());\n-        }\n-\n-        return updateFlowResult.getUpdatedFlow();\n-    }\n-\n-    @VisibleForTesting\n-    UpdateFlowResult.UpdateFlowResultBuilder prepareFlowUpdateResult(FlowDto flowDto, Flow flow) {\n-        boolean changedStrategy = flowDto.getPathComputationStrategy() != null\n-                && !flowDto.getPathComputationStrategy().equals(flow.getPathComputationStrategy());\n-        boolean changedMaxLatency = flowDto.getMaxLatency() != null\n-                && !flowDto.getMaxLatency().equals(flow.getMaxLatency());\n-        boolean strategyIsMaxLatency = PathComputationStrategy.MAX_LATENCY.equals(flowDto.getPathComputationStrategy())\n-                || flowDto.getPathComputationStrategy() == null\n-                && PathComputationStrategy.MAX_LATENCY.equals(flow.getPathComputationStrategy());\n-\n-        String reason = null;\n-        if (changedStrategy) {\n-            reason = format(\"initiated via Northbound, path computation strategy was changed from %s to %s\",\n-                    flow.getPathComputationStrategy(), flowDto.getPathComputationStrategy());\n-        } else if (changedMaxLatency && strategyIsMaxLatency) {\n-            reason = format(\"initiated via Northbound, max latency was changed from %d to %d\",\n-                    flow.getMaxLatency(), flowDto.getMaxLatency());\n-        }\n-\n-        return UpdateFlowResult.builder()\n-                .needRerouteFlow(changedStrategy || changedMaxLatency && strategyIsMaxLatency)\n-                .rerouteReason(reason);\n-    }\n-\n-    /**\n-     * Get connected devices for Flow.\n-     *\n-     * @param flowId flow ID\n-     * @return connected devices for flow\n-     */\n-    public Collection<SwitchConnectedDevice> getFlowConnectedDevice(String flowId) throws FlowNotFoundException {\n-        return transactionManager.doInTransaction(() -> {\n-            if (!flowRepository.exists(flowId)) {\n-                throw new FlowNotFoundException(flowId);\n-            }\n-\n-            return switchConnectedDeviceRepository.findByFlowId(flowId);\n-        });\n-    }\n-\n-    @Data\n-    @Builder\n-    static class UpdateFlowResult {\n-        private UnidirectionalFlow updatedFlow;\n-        private boolean needRerouteFlow;\n-        private String rerouteReason;\n-    }\n-}\n"}}, {"oid": "d72513da4a6f363bf24031c75b6cf5ef86d08261", "url": "https://github.com/telstra/open-kilda/commit/d72513da4a6f363bf24031c75b6cf5ef86d08261", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-02-10T11:02:43Z", "type": "forcePushed"}, {"oid": "1585a0754ece5dca5fa0246a7d762f8416707508", "url": "https://github.com/telstra/open-kilda/commit/1585a0754ece5dca5fa0246a7d762f8416707508", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-02-10T12:38:46Z", "type": "forcePushed"}, {"oid": "8a4754256b4253bb2ad7c0c7e2015d112e65d3a0", "url": "https://github.com/telstra/open-kilda/commit/8a4754256b4253bb2ad7c0c7e2015d112e65d3a0", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-02-18T11:27:55Z", "type": "forcePushed"}, {"oid": "6b8cb181f2ab7b3110af33ad96a8daa3e82ab101", "url": "https://github.com/telstra/open-kilda/commit/6b8cb181f2ab7b3110af33ad96a8daa3e82ab101", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-03-02T06:20:40Z", "type": "commit"}, {"oid": "6b8cb181f2ab7b3110af33ad96a8daa3e82ab101", "url": "https://github.com/telstra/open-kilda/commit/6b8cb181f2ab7b3110af33ad96a8daa3e82ab101", "message": "Added a reroute call when updating the maxLatency flow field.", "committedDate": "2020-03-02T06:20:40Z", "type": "forcePushed"}]}