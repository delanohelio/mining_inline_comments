{"pr_number": 3787, "pr_title": "Flow loop feature implementation", "pr_createdAt": "2020-10-16T10:21:18Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3787", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTY2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r506469660", "bodyText": "Why do you use the plural form (getFlowLoopS)? A flow can't have more than one loop\nProbably would be better to use the singular form (getFlowLoopS -> getFlowLoop)", "author": "andriidovhan", "createdAt": "2020-10-16T14:11:27Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -160,6 +162,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loop\")\n+    @ResponseStatus(HttpStatus.OK)\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI2NjIyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r509266225", "bodyText": "This method allows you to get all looped flows in the system by combining filters. You can skip optional flow_id param and get looped flows by switch_id or all of them.", "author": "rozdy", "createdAt": "2020-10-21T13:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\nindex 3f623a383..15c61d34e 100644\n--- a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\n+++ b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\n\n@@ -170,7 +168,7 @@ public class FlowControllerV2 extends BaseController {\n      * @return list of flow loops\n      */\n     @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n-    @GetMapping(value = \"/loop\")\n+    @GetMapping(value = \"/loops\")\n     @ResponseStatus(HttpStatus.OK)\n     public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(\n             @RequestParam(value = \"flow_id\", required = false) String flowId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508436746", "bodyText": "Please log or throw an exception for an unhandled request.", "author": "dpoltavets", "createdAt": "2020-10-20T11:52:39Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java", "diffHunk": "@@ -93,8 +95,17 @@ protected void init() {\n     @Override\n     protected void onRequest(Tuple input) throws PipelineException {\n         currentKey = input.getStringByField(MessageKafkaTranslator.FIELD_ID_KEY);\n-        FlowRequest payload = (FlowRequest) input.getValueByField(FIELD_ID_PAYLOAD);\n-        service.handleRequest(currentKey, pullContext(input), payload);\n+        Object payload = input.getValueByField(FIELD_ID_PAYLOAD);\n+        if (payload instanceof FlowRequest) {\n+            FlowRequest flowRequest = (FlowRequest) payload;\n+            service.handleUpdateRequest(currentKey, pullContext(input), flowRequest);\n+        } else if (payload instanceof CreateFlowLoopRequest) {\n+            CreateFlowLoopRequest flowLoopRequest = (CreateFlowLoopRequest) payload;\n+            service.handleCreateFlowLoopRequest(currentKey, pullContext(input), flowLoopRequest);\n+        } else if (payload instanceof DeleteFlowLoopRequest) {\n+            DeleteFlowLoopRequest flowLoopRequest = (DeleteFlowLoopRequest) payload;\n+            service.handleDeleteFlowLoopRequest(currentKey, pullContext(input), flowLoopRequest);\n+        }", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1NDI5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511054295", "bodyText": "+1", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTMxMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609312", "bodyText": "fixed", "author": "rozdy", "createdAt": "2020-10-28T16:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java\nindex a45c7c473..98e042289 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java\n\n@@ -105,6 +105,8 @@ public class FlowUpdateHubBolt extends HubBolt implements FlowUpdateHubCarrier {\n         } else if (payload instanceof DeleteFlowLoopRequest) {\n             DeleteFlowLoopRequest flowLoopRequest = (DeleteFlowLoopRequest) payload;\n             service.handleDeleteFlowLoopRequest(currentKey, pullContext(input), flowLoopRequest);\n+        } else {\n+            unhandledInput(input);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODAzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508438039", "bodyText": "You can use the getFlow method defined in FlowProcessingAction.", "author": "dpoltavets", "createdAt": "2020-10-20T11:55:06Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java", "diffHunk": "@@ -81,9 +84,11 @@ public ValidateFlowAction(PersistenceManager persistenceManager, FlowOperationsD\n         stateMachine.setTargetFlow(targetFlow);\n         stateMachine.setBulkUpdateFlowIds(context.getBulkUpdateFlowIds());\n         stateMachine.setDoNotRevert(context.isDoNotRevert());\n+        Flow flow = flowRepository.findById(flowId)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTQxNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609416", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T16:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java\nindex a2e54aae0..1b8704abd 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java\n\n@@ -84,8 +84,7 @@ public class ValidateFlowAction extends NbTrackableAction<FlowUpdateFsm, State,\n         stateMachine.setTargetFlow(targetFlow);\n         stateMachine.setBulkUpdateFlowIds(context.getBulkUpdateFlowIds());\n         stateMachine.setDoNotRevert(context.isDoNotRevert());\n-        Flow flow = flowRepository.findById(flowId)\n-                .orElseThrow(() -> new FlowProcessingException(ErrorType.NOT_FOUND, \"Flow not found\"));\n+        Flow flow = getFlow(flowId);\n \n         try {\n             flowValidator.validate(flow, targetFlow, stateMachine.getBulkUpdateFlowIds());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MTM4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508441385", "bodyText": "Please remove this merge artifact.", "author": "dpoltavets", "createdAt": "2020-10-20T12:00:54Z", "path": "src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/* Copyright 2018 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.persistence.repositories.impl;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singleton;\n+\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.FlowFilter;\n+import org.openkilda.model.FlowPath;\n+import org.openkilda.model.FlowStatus;\n+import org.openkilda.model.PathSegment;\n+import org.openkilda.model.Switch;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.FetchStrategy;\n+import org.openkilda.persistence.TransactionManager;\n+import org.openkilda.persistence.converters.FlowStatusConverter;\n+import org.openkilda.persistence.converters.SwitchIdConverter;\n+import org.openkilda.persistence.exceptions.PersistenceException;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+import org.neo4j.ogm.cypher.ComparisonOperator;\n+import org.neo4j.ogm.cypher.Filter;\n+import org.neo4j.ogm.cypher.Filters;\n+import org.neo4j.ogm.session.Neo4jSession;\n+import org.neo4j.ogm.session.Session;\n+import org.neo4j.ogm.typeconversion.InstantStringConverter;\n+\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Neo4j OGM implementation of {@link FlowRepository}.\n+ */\n+@Slf4j\n+public class Neo4jFlowRepository extends Neo4jGenericRepository<Flow> implements FlowRepository {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTUxNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609514", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MTM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java b/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java\ndeleted file mode 100644\nindex 3bbb7a132..000000000\n--- a/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java\n+++ /dev/null\n\n@@ -1,673 +0,0 @@\n-/* Copyright 2018 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.persistence.repositories.impl;\n-\n-import static java.lang.String.format;\n-import static java.util.Collections.emptyList;\n-import static java.util.Collections.singleton;\n-\n-import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowFilter;\n-import org.openkilda.model.FlowPath;\n-import org.openkilda.model.FlowStatus;\n-import org.openkilda.model.PathSegment;\n-import org.openkilda.model.Switch;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.persistence.FetchStrategy;\n-import org.openkilda.persistence.TransactionManager;\n-import org.openkilda.persistence.converters.FlowStatusConverter;\n-import org.openkilda.persistence.converters.SwitchIdConverter;\n-import org.openkilda.persistence.exceptions.PersistenceException;\n-import org.openkilda.persistence.repositories.FlowRepository;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Lists;\n-import lombok.NonNull;\n-import lombok.extern.slf4j.Slf4j;\n-import org.neo4j.ogm.cypher.ComparisonOperator;\n-import org.neo4j.ogm.cypher.Filter;\n-import org.neo4j.ogm.cypher.Filters;\n-import org.neo4j.ogm.session.Neo4jSession;\n-import org.neo4j.ogm.session.Session;\n-import org.neo4j.ogm.typeconversion.InstantStringConverter;\n-\n-import java.time.Instant;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-/**\n- * Neo4j OGM implementation of {@link FlowRepository}.\n- */\n-@Slf4j\n-public class Neo4jFlowRepository extends Neo4jGenericRepository<Flow> implements FlowRepository {\n-    static final String FLOW_ID_PROPERTY_NAME = \"flow_id\";\n-    static final String GROUP_ID_PROPERTY_NAME = \"group_id\";\n-    static final String SRC_PORT_PROPERTY_NAME = \"src_port\";\n-    static final String DST_PORT_PROPERTY_NAME = \"dst_port\";\n-    static final String SRC_MULTI_TABLE_PROPERTY_NAME = \"src_with_multi_table\";\n-    static final String DST_MULTI_TABLE_PROPERTY_NAME = \"dst_with_multi_table\";\n-    static final String PERIODIC_PINGS_PROPERTY_NAME = \"periodic_pings\";\n-    static final String STATUS_PROPERTY_NAME = \"status\";\n-    static final String SRC_LLDP_PROPERTY_NAME = \"detect_src_lldp_connected_devices\";\n-    static final String DST_LLDP_PROPERTY_NAME = \"detect_dst_lldp_connected_devices\";\n-    static final String SRC_ARP_PROPERTY_NAME = \"detect_src_arp_connected_devices\";\n-    static final String DST_ARP_PROPERTY_NAME = \"detect_dst_arp_connected_devices\";\n-    static final String LOOPED_PROPERTY_NAME = \"looped\";\n-    static final String LOOP_SWITCH_ID_PROPERTY_NAME = \"loop_switch_id\";\n-    private static final String SRC_SWITCH_ALIAS = \"src_switch\";\n-    private static final String DST_SWITCH_ALIAS = \"dst_switch\";\n-    private static final String FLOW_ALIAS = \"flow\";\n-\n-    private final FlowStatusConverter flowStatusConverter = new FlowStatusConverter();\n-    private final InstantStringConverter instantStringConverter = new InstantStringConverter();\n-    private final SwitchIdConverter switchIdConverter = new SwitchIdConverter();\n-\n-    private final Neo4jFlowPathRepository flowPathRepository;\n-\n-    public Neo4jFlowRepository(Neo4jSessionFactory sessionFactory, TransactionManager transactionManager) {\n-        super(sessionFactory, transactionManager);\n-\n-        flowPathRepository = new Neo4jFlowPathRepository(sessionFactory, transactionManager);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findAll() {\n-        return findAll(FetchStrategy.DIRECT_RELATIONS);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findAll(FetchStrategy fetchStrategy) {\n-        return loadAll(EMPTY_FILTERS, fetchStrategy);\n-    }\n-\n-    @Override\n-    public long countFlows() {\n-        return getSession().countEntitiesOfType(getEntityType());\n-    }\n-\n-    @Override\n-    public boolean exists(String flowId) {\n-        Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-\n-        return getSession().count(getEntityType(), singleton(flowIdFilter)) > 0;\n-    }\n-\n-    @Override\n-    public Optional<Flow> findById(String flowId) {\n-        return findById(flowId, getDefaultFetchStrategy());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findById(String flowId, FetchStrategy fetchStrategy) {\n-        Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-\n-        Collection<Flow> flows = loadAll(flowIdFilter, fetchStrategy);\n-        if (flows.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by %s as flowId\", flowId));\n-        } else if (flows.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        return Optional.of(flows.iterator().next());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findByIdWithEndpoints(String flowId) {\n-        Map<String, Object> parameters = ImmutableMap.of(\"flow_id\", flowId);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE f.flow_id = $flow_id \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by flowId '%s'. Found flows: %s\",\n-                    flowId, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByGroupId(String flowGroupId) {\n-        Filter groupIdFilter = new Filter(GROUP_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowGroupId);\n-\n-        return loadAll(groupIdFilter);\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowsIdByGroupId(String flowGroupId) {\n-        Map<String, Object> flowParameters = ImmutableMap.of(\"flow_group_id\", flowGroupId);\n-\n-        return queryForStrings(\n-                \"MATCH (f:flow {group_id: $flow_group_id}) RETURN f.flow_id as flow_id\", flowParameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<Flow> findWithPeriodicPingsEnabled() {\n-        Filter periodicPingsFilter = new Filter(PERIODIC_PINGS_PROPERTY_NAME, ComparisonOperator.EQUALS, true);\n-\n-        return loadAll(periodicPingsFilter);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpoint(SwitchId switchId, int port) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcPortFilter = new Filter(SRC_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstPortFilter = new Filter(DST_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcPortFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstPortFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findByEndpointAndVlan(SwitchId switchId, int port, int vlan) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchId,\n-                \"port\", port,\n-                \"vlan\", vlan);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE (s.name = $switch_id AND f.src_port = $port AND f.src_vlan = $vlan) \"\n-                + \"OR (d.name = $switch_id AND f.dst_port = $port AND f.dst_vlan = $vlan) \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by SwitchId %s, port %d and vlan %d. \"\n-                    + \"Found Flows: %s\", switchId, port, vlan, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Optional<Flow> findOneSwitchFlowBySwitchIdInPortAndOutVlan(SwitchId switchId, int inPort, int outVlan) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchId,\n-                \"in_port\", inPort,\n-                \"out_vlan\", outVlan);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE s.name = $switch_id AND d.name = $switch_id \"\n-                + \"AND ((f.src_port = $in_port AND f.dst_vlan = $out_vlan) \"\n-                + \"OR (f.dst_port = $in_port AND f.src_vlan = $out_vlan)) \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by SwitchId %s, InPort %d and \"\n-                    + \"OutVlan %d. Found Flows %s\", switchId, inPort, outVlan, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointWithMultiTableSupport(SwitchId switchId, int port) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcPortFilter = new Filter(SRC_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter srcMultiTableFilter = new Filter(SRC_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstPortFilter = new Filter(DST_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter dstMultiTableFilter = new Filter(DST_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcPortFilter).and(srcMultiTableFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstPortFilter).and(dstMultiTableFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowsIdsByEndpointWithMultiTableSupport(SwitchId switchId, int port) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchIdConverter.toGraphProperty(switchId),\n-                \"port\", port,\n-                \"multi_table\", true);\n-\n-        return queryForStrings(\"MATCH (src:switch)-[:source]-(f:flow)-[:destination]-(dst:switch) \"\n-                + \"WHERE src.name=$switch_id AND f.src_port=$port AND f.src_with_multi_table=$multi_table \"\n-                + \"OR dst.name=$switch_id AND f.dst_port=$port AND f.dst_with_multi_table=$multi_table \"\n-                + \"RETURN f.flow_id as flow_id\", parameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowIdsForMultiSwitchFlowsByEndpointWithMultiTableSupport(\n-            SwitchId switchId, int port) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchIdConverter.toGraphProperty(switchId),\n-                \"port\", port,\n-                \"multi_table\", true);\n-\n-        return queryForStrings(\"MATCH (src:switch)-[:source]-(f:flow)-[:destination]-(dst:switch) \"\n-                + \"WHERE src.name <> dst.name \"\n-                + \"AND (src.name=$switch_id AND f.src_port=$port AND f.src_with_multi_table=$multi_table \"\n-                + \"OR dst.name=$switch_id AND f.dst_port=$port AND f.dst_with_multi_table=$multi_table) \"\n-                + \"RETURN f.flow_id as flow_id\", parameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitch(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-\n-        return Stream.concat(loadAll(srcSwitchFilter).stream(), loadAll(dstSwitchFilter).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithMultiTableSupport(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcMultiTableFilter = new Filter(SRC_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstMultiTableFilter = new Filter(DST_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcMultiTableFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstMultiTableFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithEnabledLldp(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcLldpFilter = new Filter(SRC_LLDP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstLldpFilter = new Filter(DST_LLDP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcLldpFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstLldpFilter)).stream())\n-                .collect(Collectors.toSet()); // to do not return one flow twice (one switch flow with LLDP)\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithEnabledArp(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcArpFilter = new Filter(SRC_ARP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstArpFilter = new Filter(DST_ARP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcArpFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstArpFilter)).stream())\n-                .collect(Collectors.toSet()); // to do not return one flow twice (one switch flow with ARP)\n-    }\n-\n-    @Override\n-    public Collection<Flow> findOneSwitchFlows(SwitchId switchId) {\n-        Filters filters = new Filters();\n-        filters.and(createSrcSwitchFilter(switchId));\n-        filters.and(createDstSwitchFilter(switchId));\n-        return loadAll(filters);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findDownFlows() {\n-        Filter flowStatusDown = new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, FlowStatus.DOWN);\n-        Filter flowStatusDegraded = new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, FlowStatus.DEGRADED);\n-\n-        return loadAll(flowStatusDown.or(flowStatusDegraded));\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByFlowFilter(FlowFilter flowFilter) {\n-        Filters filters = new Filters();\n-        Optional.ofNullable(flowFilter.getFlowStatus()).ifPresent(flowStatus ->\n-                filters.and(new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, flowStatus)));\n-        return loadAll(filters, FetchStrategy.DIRECT_RELATIONS);\n-    }\n-\n-    @Override\n-    public void createOrUpdate(Flow flow) {\n-        validateFlow(flow);\n-\n-        if (flow.getTimeCreate() == null) {\n-            flow.setTimeCreate(Instant.now());\n-        } else {\n-            flow.setTimeModify(Instant.now());\n-        }\n-\n-        transactionManager.doInTransaction(() -> {\n-            Session session = getSession();\n-            // To avoid Neo4j deadlocks, we perform locking of switch nodes in the case of new flow, path or segments.\n-            boolean isNewFlow = session.resolveGraphIdFor(flow) == null;\n-            if (isNewFlow || hasUnmanagedEntity(flow)) {\n-                // No need to fetch current paths for a new flow.\n-                Collection<FlowPath> currentPaths = isNewFlow ? emptyList()\n-                        : flowPathRepository.findByFlowId(flow.getFlowId());\n-\n-                flowPathRepository.lockInvolvedSwitches(Stream.concat(currentPaths.stream(), flow.getPaths().stream())\n-                        .toArray(FlowPath[]::new));\n-\n-                if (!isNewFlow) {\n-                    deleteOrphanPaths(flow, currentPaths);\n-                }\n-            } else {\n-                deleteOrphanPaths(flow);\n-            }\n-\n-            super.createOrUpdate(flow);\n-        });\n-    }\n-\n-    private String extractFlowsAsString(List<Map<String, Object>> results) {\n-        return results.stream()\n-                .map(result -> result.get(FLOW_ALIAS))\n-                .map(Flow.class::cast)\n-                .map(Flow::toString)\n-                .collect(Collectors.joining(\", \"));\n-    }\n-\n-    private Optional<Flow> extractFlowWithEndpoints(List<Map<String, Object>> results) {\n-        if (results.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        Map<String, Object> result = results.iterator().next();\n-\n-        Flow flow = (Flow) result.get(FLOW_ALIAS);\n-        flow.setSrcSwitch((Switch) result.get(SRC_SWITCH_ALIAS));\n-        flow.setDestSwitch((Switch) result.get(DST_SWITCH_ALIAS));\n-        return Optional.of(flow);\n-    }\n-\n-    /**\n-     * Validate the flow relations and flow path to be managed by Neo4j OGM.\n-     */\n-    private void validateFlow(Flow flow) {\n-        // The flow must reference a managed switches to avoid creation of duplicated ones.\n-        // Check for nulls as the entity may be read not completely.\n-        if (flow.getSrcSwitch() != null) {\n-            requireManagedEntity(flow.getSrcSwitch());\n-        }\n-        if (flow.getDestSwitch() != null) {\n-            requireManagedEntity(flow.getDestSwitch());\n-        }\n-\n-        for (FlowPath path : flow.getPaths()) {\n-            flowPathRepository.validateFlowPath(path);\n-        }\n-    }\n-\n-    private boolean hasUnmanagedEntity(Flow flow) {\n-        Session session = getSession();\n-        for (FlowPath path : flow.getPaths()) {\n-            if (session.resolveGraphIdFor(path) == null) {\n-                return true;\n-            }\n-            for (PathSegment segment : path.getSegments()) {\n-                if (session.resolveGraphIdFor(segment) == null) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private void deleteOrphanPaths(Flow flow, Collection<FlowPath> currentPaths) {\n-        Session session = getSession();\n-        Set<Long> updatedFlowPaths = flow.getPaths().stream()\n-                .map(session::resolveGraphIdFor)\n-                .filter(Objects::nonNull)\n-                .collect(Collectors.toSet());\n-\n-        FlowPath[] pathsToDelete = currentPaths.stream()\n-                .filter(path -> !updatedFlowPaths.contains(session.resolveGraphIdFor(path)))\n-                .toArray(FlowPath[]::new);\n-        if (pathsToDelete.length > 0) {\n-            flowPathRepository.lockInvolvedSwitches(pathsToDelete);\n-\n-            for (FlowPath path : pathsToDelete) {\n-                flowPathRepository.delete(path);\n-            }\n-        }\n-    }\n-\n-    private void deleteOrphanPaths(Flow flow) {\n-        Session session = getSession();\n-        Set<Long> currentPathIds = findPathEntityIdsByFlowId(flow.getFlowId());\n-        flow.getPaths().stream()\n-                .map(session::resolveGraphIdFor)\n-                .filter(Objects::nonNull)\n-                .forEach(currentPathIds::remove);\n-\n-        if (!currentPathIds.isEmpty()) {\n-            FlowPath[] pathsToDelete = currentPathIds.stream()\n-                    .map(pathEntityId -> session.load(FlowPath.class, pathEntityId))\n-                    .filter(Objects::nonNull)\n-                    .toArray(FlowPath[]::new);\n-\n-            if (pathsToDelete.length > 0) {\n-                flowPathRepository.lockInvolvedSwitches(pathsToDelete);\n-\n-                for (FlowPath path : pathsToDelete) {\n-                    flowPathRepository.delete(path);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Set<Long> findPathEntityIdsByFlowId(String flowId) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"flow_id\", flowId);\n-\n-        Set<Long> pathEntityIds = new HashSet<>();\n-        queryForLongs(\"MATCH (flow {flow_id: $flow_id})-[:owns]-(fp:flow_path) RETURN id(fp) as id\",\n-                parameters, \"id\").forEach(pathEntityIds::add);\n-        return pathEntityIds;\n-    }\n-\n-    @Override\n-    public void delete(Flow flow) {\n-        transactionManager.doInTransaction(() -> {\n-            Collection<FlowPath> flowPaths = flowPathRepository.findByFlowId(flow.getFlowId());\n-            flowPathRepository.lockInvolvedSwitches(flowPaths.toArray(new FlowPath[0]));\n-\n-            flowPaths.forEach(flowPathRepository::delete);\n-\n-            super.delete(flow);\n-        });\n-    }\n-\n-    @Override\n-    public Optional<String> getOrCreateFlowGroupId(String flowId) {\n-        return transactionManager.doInTransaction(() -> findById(flowId, FetchStrategy.NO_RELATIONS)\n-                .map(diverseFlow -> {\n-                    if (diverseFlow.getGroupId() == null) {\n-                        String groupId = UUID.randomUUID().toString();\n-\n-                        diverseFlow.setGroupId(groupId);\n-                        super.createOrUpdate(diverseFlow);\n-                    }\n-                    return diverseFlow.getGroupId();\n-                }));\n-    }\n-\n-    @Override\n-    public void updateStatus(String flowId, FlowStatus flowStatus) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"flow_id\", flowId,\n-                \"status\", flowStatusConverter.toGraphProperty(flowStatus),\n-                \"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id}) \"\n-                        + \"SET f.status=$status, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id\", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusUpdate(flowStatus, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatus(@NonNull String flowId, @NonNull FlowStatus flowStatus, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status\", flowStatusConverter.toGraphProperty(flowStatus));\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id})  \"\n-                        + \"SET f.status=$status, f.status_info=$status_info, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id \", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusUpdate(flowStatus, flowStatusInfo, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatusInfo(@NonNull String flowId, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id})   \"\n-                        + \"SET f.status_info=$status_info, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id  \", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusInfoUpdate(flowStatusInfo, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatusSafe(@NonNull String flowId, @NonNull FlowStatus flowStatus, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status\", flowStatusConverter.toGraphProperty(flowStatus));\n-        parameters.put(\"keep_status\", flowStatusConverter.toGraphProperty(FlowStatus.IN_PROGRESS));\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-\n-        String query = \"MATCH (f:flow {flow_id: $flow_id}) \"\n-                + \"WHERE f.status<>$keep_status \"\n-                + \"SET f.status=$status, f.status_info=$status_info, f.time_modify=$time_modify \"\n-                + \"RETURN id(f) as id\";\n-        Optional<Long> entityId = queryForLong(query, parameters, \"id\");\n-        entityId.ifPresent(id -> postStatusUpdate(flowStatus, flowStatusInfo, timestamp, id));\n-    }\n-\n-    @Override\n-    public long computeFlowsBandwidthSum(Set<String> flowIds) {\n-        Map<String, Object> parameters = ImmutableMap.of(\"flow_ids\", flowIds);\n-        return queryForLong(\"MATCH (f:flow) WHERE f.flow_id IN $flow_ids \"\n-                + \"RETURN sum(f.bandwidth) as bandwidth\", parameters, \"bandwidth\").orElse(0L);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findLoopedByFlowIdAndLoopSwitchId(String flowId, String switchId) {\n-        Filter loopedFilter = new Filter(LOOPED_PROPERTY_NAME, ComparisonOperator.EQUALS, true);\n-        Filters filters = new Filters(loopedFilter);\n-        if (flowId != null) {\n-            Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-            filters.and(flowIdFilter);\n-        }\n-        if (switchId != null) {\n-            Filter switchIdFilter = new Filter(LOOP_SWITCH_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, switchId);\n-            filters.and(switchIdFilter);\n-        }\n-\n-        return loadAll(filters);\n-    }\n-\n-    @Override\n-    protected Class<Flow> getEntityType() {\n-        return Flow.class;\n-    }\n-\n-    @Override\n-    protected FetchStrategy getDefaultFetchStrategy() {\n-        return FetchStrategy.ALL_RELATIONS;\n-    }\n-\n-    @Override\n-    protected int getDepthLoadEntity(FetchStrategy fetchStrategy) {\n-        switch (fetchStrategy) {\n-            case ALL_RELATIONS:\n-                // depth 3 is needed to load switches in PathSegment entity.\n-                return 3;\n-            default:\n-                return super.getDepthLoadEntity(fetchStrategy);\n-        }\n-    }\n-\n-    @Override\n-    protected int getDepthCreateUpdateEntity() {\n-        // depth 3 is needed to create/update relations to switches, flow paths,\n-        // path segments and switches of path segments.\n-        return 3;\n-    }\n-\n-    private void postStatusUpdate(FlowStatus flowStatus, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatus(flowStatus);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-\n-    private void postStatusUpdate(FlowStatus flowStatus, String flowStatusInfo, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatus(flowStatus);\n-            updatedFlow.setStatusInfo(flowStatusInfo);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-\n-    private void postStatusInfoUpdate(String flowStatusInfo, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatusInfo(flowStatusInfo);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508443819", "bodyText": "Why did you remove @NonNull?", "author": "dpoltavets", "createdAt": "2020-10-20T12:05:21Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java", "diffHunk": "@@ -38,7 +37,7 @@\n     IngressFlowSegmentCommand(\n             MessageContext messageContext, UUID commandId, FlowSegmentMetadata metadata,\n             FlowEndpoint endpoint, MeterConfig meterConfig, SwitchId egressSwitchId, int islPort,\n-            @NonNull FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {\n+            FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0OTMyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508649325", "bodyText": "I know \"why?\" and I don't agree with this.", "author": "surabujin", "createdAt": "2020-10-20T16:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTY2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609669", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T16:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java\nindex 66984a53a..8d2f24850 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java\n\n@@ -37,7 +38,7 @@ public abstract class IngressFlowSegmentCommand extends IngressFlowSegmentBase {\n     IngressFlowSegmentCommand(\n             MessageContext messageContext, UUID commandId, FlowSegmentMetadata metadata,\n             FlowEndpoint endpoint, MeterConfig meterConfig, SwitchId egressSwitchId, int islPort,\n-            FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {\n+            @NonNull FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {\n         super(\n                 messageContext, endpoint.getSwitchId(), commandId, metadata, endpoint, meterConfig,\n                 egressSwitchId, rulesContext);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508445588", "bodyText": "Why do flow loop rules have this priority?", "author": "dpoltavets", "createdAt": "2020-10-20T12:08:25Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java", "diffHunk": "@@ -216,6 +216,7 @@\n     public static final int CATCH_BFD_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int ROUND_TRIP_LATENCY_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int FLOW_PRIORITY = FlowModUtils.PRIORITY_HIGH;\n+    public static final int FLOW_LOOP_PRIORITY = FLOW_PRIORITY + 10;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1OTAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508659032", "bodyText": "+10 is not enough, it will intersect with QinQ rules. Need at least 11, but better 50 or 100 (so you can use -10 as priority step for default-port rules).", "author": "surabujin", "createdAt": "2020-10-20T16:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDI2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610269", "bodyText": "changed to +100", "author": "rozdy", "createdAt": "2020-10-28T16:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java\nindex fe3db925a..52dc453a6 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java\n\n@@ -216,7 +216,7 @@ public class SwitchManager implements IFloodlightModule, IFloodlightService, ISw\n     public static final int CATCH_BFD_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int ROUND_TRIP_LATENCY_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int FLOW_PRIORITY = FlowModUtils.PRIORITY_HIGH;\n-    public static final int FLOW_LOOP_PRIORITY = FLOW_PRIORITY + 10;\n+    public static final int FLOW_LOOP_PRIORITY = FLOW_PRIORITY + 100;\n     public static final int ISL_EGRESS_VXLAN_RULE_PRIORITY_MULTITABLE = FLOW_PRIORITY - 2;\n     public static final int ISL_TRANSIT_VXLAN_RULE_PRIORITY_MULTITABLE = FLOW_PRIORITY - 3;\n     public static final int INGRESS_CUSTOMER_PORT_RULE_PRIORITY_MULTITABLE = FLOW_PRIORITY - 2;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODUwMjIyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508502229", "bodyText": "Do we really need both looped and loopSwitchId fields? I propose to treat loopSwitchId != null as a looped marker.", "author": "surabujin", "createdAt": "2020-10-20T13:28:52Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java", "diffHunk": "@@ -183,6 +183,12 @@\n     @JsonProperty(\"diverse_with\")\n     private Set<String> diverseWith;\n \n+    @JsonProperty(\"looped\")\n+    private boolean looped;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDQ1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610452", "bodyText": "removed looped field", "author": "rozdy", "createdAt": "2020-10-28T16:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODUwMjIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java b/src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java\nindex 9af78d9fe..1d14f6868 100644\n--- a/src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java\n+++ b/src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java\n\n@@ -183,9 +183,6 @@ public class FlowDto implements Serializable {\n     @JsonProperty(\"diverse_with\")\n     private Set<String> diverseWith;\n \n-    @JsonProperty(\"looped\")\n-    private boolean looped;\n-\n     @JsonProperty(\"loop_switch_id\")\n     private SwitchId loopSwitchId;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NTE3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508575177", "bodyText": "Use FlowSideAdapter instead of PathSegment is it much more clear - at least you don't need to know is the ingress switch included in the first path segment or not.\nAnd avoid extraction of dependent objects segment.getPath() there was a huge amount of errors created by such coding approach.", "author": "surabujin", "createdAt": "2020-10-20T14:49:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDYxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610611", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T16:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NTE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex bf21b99ff..9f93c1738 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -292,19 +293,20 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n                 .build();\n     }\n \n-    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n-        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n-                && !segment.getPath().isProtected();\n+    private boolean ingressLoopRuleRequired(Flow flow, FlowSideAdapter flowSideAdapter, boolean isProtected) {\n+        return flow.isLooped() && flowSideAdapter.getEndpoint().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !isProtected;\n     }\n \n     private FlowSegmentRequestFactory makeIngressLoopRequest(\n             CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            FlowSideAdapter flowSide, PathSegment segment) {\n+            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egress) {\n         PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n \n         UUID commandId = commandIdGenerator.generate();\n         MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        Cookie cookie = path.getCookie().toBuilder().type(CookieType.FLOW_LOOP).build();\n+        Cookie cookie = path.getCookie().toBuilder().looped(true).build();\n+\n         return IngressFlowLoopSegmentRequestFactory.builder()\n                 .messageContext(messageContext)\n                 .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NjU5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508576597", "bodyText": "Should it be egressLoopRuleRequired()?", "author": "surabujin", "createdAt": "2020-10-20T14:50:40Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -243,10 +252,16 @@ private RulesContext createRulesContext(PathContext pathContext) {\n         if (lastSegment != null) {\n             if (doEgress) {\n                 requests.add(makeEgressRequest(context, path, encapsulation, lastSegment, egressSide, ingressSide));\n+                if (transitLoopRuleRequired(flow, lastSegment)) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMTc2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513611760", "bodyText": "according to current naming loop rules are called ingress and transit.", "author": "rozdy", "createdAt": "2020-10-28T17:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NjU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex bf21b99ff..9f93c1738 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -251,9 +251,10 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n \n         if (lastSegment != null) {\n             if (doEgress) {\n-                requests.add(makeEgressRequest(context, path, encapsulation, lastSegment, egressSide, ingressSide));\n-                if (transitLoopRuleRequired(flow, lastSegment)) {\n-                    requests.add(makeTransitLoopRequest(context, path, encapsulation, lastSegment));\n+                requests.add(makeEgressSegmentRequest(context, path, encapsulation, lastSegment, egressSide,\n+                        ingressSide));\n+                if (transitLoopRuleRequired(flow, egressSide, path.isProtected())) {\n+                    requests.add(makeTransitLoopRequest(context, path, encapsulation, lastSegment, egressSide));\n                 }\n             }\n         } else if (doIngress) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjI0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508596247", "bodyText": "??? Why it is here? I mean why it is into metadata? Is the corresponding IngressFlowLoopSegmentRequestFactory not informative enough to define these requirements?\nPS Don't see the usage of these fields.", "author": "surabujin", "createdAt": "2020-10-20T15:14:44Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -370,9 +451,15 @@ private PathSegmentSide makePathSegmentDestSide(PathSegment segment) {\n                 segment.isDestWithMultiTable());\n     }\n \n+    private FlowSegmentMetadata makeMetadata(String flowId, Cookie cookie, boolean isMultitable,\n+                                             boolean ingressLoopRuleRequired,\n+                                             boolean transitLoopRuleRequired) {\n+        return new FlowSegmentMetadata(flowId, cookie, isMultitable,\n+                ingressLoopRuleRequired, transitLoopRuleRequired);", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMTg5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513611891", "bodyText": "Removed", "author": "rozdy", "createdAt": "2020-10-28T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex bf21b99ff..9f93c1738 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -451,15 +453,12 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n                 segment.isDestWithMultiTable());\n     }\n \n-    private FlowSegmentMetadata makeMetadata(String flowId, Cookie cookie, boolean isMultitable,\n-                                             boolean ingressLoopRuleRequired,\n-                                             boolean transitLoopRuleRequired) {\n-        return new FlowSegmentMetadata(flowId, cookie, isMultitable,\n-                ingressLoopRuleRequired, transitLoopRuleRequired);\n+    private FlowSegmentMetadata makeMetadata(String flowId, Cookie cookie, boolean isMultitable) {\n+        return new FlowSegmentMetadata(flowId, cookie, isMultitable);\n     }\n \n     private FlowSegmentMetadata makeMetadata(FlowPath path, boolean isMultitable) {\n-        return makeMetadata(path.getFlow().getFlowId(), path.getCookie(), isMultitable, false, false);\n+        return makeMetadata(path.getFlow().getFlowId(), path.getCookie(), isMultitable);\n     }\n \n     @Value\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYyMDA4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508620089", "bodyText": "I would like to use OfAdapter.INSTANCE.makeVlanReplaceActions() here as a reference approach to calculate vlan's stack update.", "author": "surabujin", "createdAt": "2020-10-20T15:36:44Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java", "diffHunk": "@@ -61,6 +63,21 @@ public IngressInstallFlowModFactory(\n         return instructions;\n     }\n \n+    @Override\n+    protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n+        List<OFAction> actions = new ArrayList<>();\n+        if (endpoint.getInnerVlanId() != 0) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMjAyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513612020", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYyMDA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\nindex 40e6a3ce2..fc3aca87b 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\n\n@@ -67,8 +67,8 @@ public abstract class IngressInstallFlowModFactory extends IngressFlowModFactory\n     protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n         List<OFAction> actions = new ArrayList<>();\n         if (endpoint.getInnerVlanId() != 0) {\n-            actions.add(of.actions().pushVlan(EthType.VLAN_FRAME));\n-            actions.add(OfAdapter.INSTANCE.setVlanIdAction(of, endpoint.getOuterVlanId()));\n+            OfAdapter.INSTANCE.makeVlanReplaceActions(of, Collections.singletonList(endpoint.getOuterVlanId()),\n+                    endpoint.getVlanStack());\n         }\n         actions.add(of.actions().buildOutput()\n                 .setPort(OFPort.of(endpoint.getPortNumber()))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508636620", "bodyText": "I would like to suggest other terminology... because we don't have the egress loop, I would not use the ingress term here. Let's name it endpoint loop i.e. in this case it will makeEndpointLoopRequest and EndpointLoopSegmentRequestFactory (can't say should we include flow anywhere in this name).\nPS I don't have a better name for transit loop segment.", "author": "surabujin", "createdAt": "2020-10-20T15:50:29Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzU0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617542", "bodyText": "I prefer naming ingress/transit loop. From flow perspective loop rules either forward traffic input to output (just like single switch ingress rule) or forward traffic to next switch in a looped path (just like transit rule).", "author": "rozdy", "createdAt": "2020-10-28T17:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwODcwNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516008704", "bodyText": "It looks weird when we make makeTransitLoopRequest call to create a rule for the egress switch. :(\nCan we make method makeEgressLoopRequest() and put makeTransitLookRequest call inside it? It will be less confusing, at least for me. And similar wrapper for transitLoopRuleRequired too.", "author": "surabujin", "createdAt": "2020-11-02T14:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex bf21b99ff..9f93c1738 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -292,19 +293,20 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n                 .build();\n     }\n \n-    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n-        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n-                && !segment.getPath().isProtected();\n+    private boolean ingressLoopRuleRequired(Flow flow, FlowSideAdapter flowSideAdapter, boolean isProtected) {\n+        return flow.isLooped() && flowSideAdapter.getEndpoint().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !isProtected;\n     }\n \n     private FlowSegmentRequestFactory makeIngressLoopRequest(\n             CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            FlowSideAdapter flowSide, PathSegment segment) {\n+            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egress) {\n         PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n \n         UUID commandId = commandIdGenerator.generate();\n         MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        Cookie cookie = path.getCookie().toBuilder().type(CookieType.FLOW_LOOP).build();\n+        Cookie cookie = path.getCookie().toBuilder().looped(true).build();\n+\n         return IngressFlowLoopSegmentRequestFactory.builder()\n                 .messageContext(messageContext)\n                 .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MTE5OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508641198", "bodyText": "Now when we have 2 kind' of requests, we should rename existing makeIngressRequest, makeTransitRequest and makeEgressRequest into makeIngressSegmentRequest, makeTransitSegmentRequest and makeEgressSegmentRequest.", "author": "surabujin", "createdAt": "2020-10-20T15:54:24Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(\n+            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n+            FlowSideAdapter flowSide, PathSegment segment) {\n+        PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n+\n+        UUID commandId = commandIdGenerator.generate();\n+        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n+        Cookie cookie = path.getCookie().toBuilder().type(CookieType.FLOW_LOOP).build();\n+        return IngressFlowLoopSegmentRequestFactory.builder()\n+                .messageContext(messageContext)\n+                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n+                        flowSide.isMultiTableSegment(), segmentSide.isMultiTable(),\n+                        String.format(\"First flow(id:%s, path:%s) segment and flow level multi-table flag values are \"\n+                                              + \"incompatible to each other - flow(%s) != segment(%s)\",\n+                                      path.getFlow().getFlowId(), path.getPathId(),\n+                                      flowSide.isMultiTableSegment(), segmentSide.isMultiTable())),\n+                        true, false))\n+                .endpoint(flowSide.getEndpoint())\n+                .islPort(segmentSide.getEndpoint().getPortNumber())\n+                .encapsulation(encapsulation)\n+                .build();\n+    }\n+\n+    private boolean transitLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getDestSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeTransitLoopRequest(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzcwMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617700", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MTE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex bf21b99ff..9f93c1738 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -292,19 +293,20 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n                 .build();\n     }\n \n-    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n-        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n-                && !segment.getPath().isProtected();\n+    private boolean ingressLoopRuleRequired(Flow flow, FlowSideAdapter flowSideAdapter, boolean isProtected) {\n+        return flow.isLooped() && flowSideAdapter.getEndpoint().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !isProtected;\n     }\n \n     private FlowSegmentRequestFactory makeIngressLoopRequest(\n             CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            FlowSideAdapter flowSide, PathSegment segment) {\n+            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egress) {\n         PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n \n         UUID commandId = commandIdGenerator.generate();\n         MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        Cookie cookie = path.getCookie().toBuilder().type(CookieType.FLOW_LOOP).build();\n+        Cookie cookie = path.getCookie().toBuilder().looped(true).build();\n+\n         return IngressFlowLoopSegmentRequestFactory.builder()\n                 .messageContext(messageContext)\n                 .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NDc2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508644767", "bodyText": "No. You must not allow this. Search for other solution.", "author": "surabujin", "createdAt": "2020-10-20T15:57:25Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java", "diffHunk": "@@ -48,7 +48,7 @@\n \n     IngressFlowSegmentBase(\n             MessageContext context, UUID commandId, FlowSegmentMetadata metadata, @NonNull FlowEndpoint endpoint,\n-            MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzg4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617882", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java\nindex c13f55a70..802dc23bf 100644\n--- a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java\n+++ b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java\n\n@@ -48,7 +48,7 @@ abstract class IngressFlowSegmentBase extends FlowSegmentRequest {\n \n     IngressFlowSegmentBase(\n             MessageContext context, UUID commandId, FlowSegmentMetadata metadata, @NonNull FlowEndpoint endpoint,\n-            MeterConfig meterConfig, SwitchId egressSwitchId,\n+            MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,\n             RulesContext rulesContext) {\n         super(context, endpoint.getSwitchId(), commandId, metadata);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NzAxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508647015", "bodyText": "One more time - why for you need it here?", "author": "surabujin", "createdAt": "2020-10-20T15:59:51Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java", "diffHunk": "@@ -35,13 +35,31 @@\n     @JsonProperty(\"multi_table\")\n     private final boolean multiTable;\n \n+    @JsonProperty(\"ingress_loop_rule\")\n+    private final boolean ingressLoopRule;\n+\n+    @JsonProperty(\"transit_loop_rule\")\n+    private final boolean transitLoopRule;\n+\n     @JsonCreator\n     public FlowSegmentMetadata(\n             @JsonProperty(\"flowid\") @NonNull String flowId,\n             @JsonProperty(\"cookie\") @NonNull Cookie cookie,\n-            @JsonProperty(\"multi_table\") boolean multiTable) {\n+            @JsonProperty(\"multi_table\") boolean multiTable,\n+            @JsonProperty(\"ingress_loop_rule\") boolean ingressLoopRule,\n+            @JsonProperty(\"transit_loop_rule\") boolean transitLoopRule) {\n+        this.flowId = flowId;\n+        this.cookie = cookie;\n+        this.multiTable = multiTable;\n+        this.ingressLoopRule = ingressLoopRule;\n+        this.transitLoopRule = transitLoopRule;\n+    }\n+\n+    public FlowSegmentMetadata(String flowId, Cookie cookie, boolean multiTable) {\n         this.flowId = flowId;\n         this.cookie = cookie;\n         this.multiTable = multiTable;\n+        this.ingressLoopRule = false;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODAzOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618038", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T17:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NzAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java\nindex 07e5bd797..e8d8714cc 100644\n--- a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java\n+++ b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java\n\n@@ -35,31 +35,13 @@ public class FlowSegmentMetadata implements Serializable {\n     @JsonProperty(\"multi_table\")\n     private final boolean multiTable;\n \n-    @JsonProperty(\"ingress_loop_rule\")\n-    private final boolean ingressLoopRule;\n-\n-    @JsonProperty(\"transit_loop_rule\")\n-    private final boolean transitLoopRule;\n-\n     @JsonCreator\n     public FlowSegmentMetadata(\n             @JsonProperty(\"flowid\") @NonNull String flowId,\n             @JsonProperty(\"cookie\") @NonNull Cookie cookie,\n-            @JsonProperty(\"multi_table\") boolean multiTable,\n-            @JsonProperty(\"ingress_loop_rule\") boolean ingressLoopRule,\n-            @JsonProperty(\"transit_loop_rule\") boolean transitLoopRule) {\n-        this.flowId = flowId;\n-        this.cookie = cookie;\n-        this.multiTable = multiTable;\n-        this.ingressLoopRule = ingressLoopRule;\n-        this.transitLoopRule = transitLoopRule;\n-    }\n-\n-    public FlowSegmentMetadata(String flowId, Cookie cookie, boolean multiTable) {\n+            @JsonProperty(\"multi_table\") boolean multiTable) {\n         this.flowId = flowId;\n         this.cookie = cookie;\n         this.multiTable = multiTable;\n-        this.ingressLoopRule = false;\n-        this.transitLoopRule = false;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0Nzk5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508647997", "bodyText": "And here too - don't do it.", "author": "surabujin", "createdAt": "2020-10-20T16:00:53Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java", "diffHunk": "@@ -71,7 +71,7 @@\n \n     IngressFlowSegmentBase(\n             MessageContext messageContext, SwitchId switchId, UUID commandId, FlowSegmentMetadata metadata,\n-            @NonNull FlowEndpoint endpoint, MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODI1NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618254", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0Nzk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java\nindex 2f243b916..c587e49c5 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java\n\n@@ -71,7 +71,7 @@ public abstract class IngressFlowSegmentBase extends FlowSegmentCommand {\n \n     IngressFlowSegmentBase(\n             MessageContext messageContext, SwitchId switchId, UUID commandId, FlowSegmentMetadata metadata,\n-            @NonNull FlowEndpoint endpoint, MeterConfig meterConfig, SwitchId egressSwitchId,\n+            @NonNull FlowEndpoint endpoint, MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,\n             RulesContext rulesContext) {\n         super(messageContext, switchId, commandId, metadata);\n         this.endpoint = endpoint;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1MzYwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508653609", "bodyText": "-1 in flow segments was used to match already existing priorities. \"normal\" priorities step should be +-10.", "author": "surabujin", "createdAt": "2020-10-20T16:06:46Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "diffHunk": "@@ -297,6 +297,83 @@ public OFFlowMod makeArpInputCustomerFlowMessage() {\n                 .build());\n     }\n \n+    /**\n+     * Make ingress flow loop rule to match all port traffic and route it back to port from where it came.\n+     */\n+    public OFFlowMod makeDefaultPortIngressFlowLoopMessage() {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        return flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -1)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODQ4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618486", "bodyText": "changed", "author": "rozdy", "createdAt": "2020-10-28T17:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1MzYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\nindex 077a62973..493e0ed5d 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\n\n@@ -303,7 +303,7 @@ public abstract class IngressFlowModFactory {\n     public OFFlowMod makeDefaultPortIngressFlowLoopMessage() {\n         FlowEndpoint endpoint = command.getEndpoint();\n         return flowModBuilderFactory\n-                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -1)\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -10)\n                 .setMatch(of.buildMatch()\n                         .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n                         .build())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NTA2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508665069", "bodyText": "better one level of if {} else if {} else {} that this 2 level detection.", "author": "surabujin", "createdAt": "2020-10-20T16:18:24Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java", "diffHunk": "@@ -98,6 +100,12 @@ protected void handleInput(Tuple input) {\n         } else if (data instanceof SwapFlowEndpointRequest) {\n             log.debug(\"Received a swap flow endpoints request with key {}. MessageId {}\", key, input.getMessageId());\n             emitWithContext(ROUTER_TO_FLOW_SWAP_ENDPOINTS_HUB.name(), input, new Values(key, data));\n+        } else if (data instanceof FlowLoopRequest) {\n+            String type = data instanceof CreateFlowLoopRequest ? \"create\" : \"delete\";", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODY1OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618658", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NTA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java\nindex 8d3e75fa9..70f9a552a 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java\n\n@@ -100,11 +100,13 @@ public class RouterBolt extends AbstractBolt {\n         } else if (data instanceof SwapFlowEndpointRequest) {\n             log.debug(\"Received a swap flow endpoints request with key {}. MessageId {}\", key, input.getMessageId());\n             emitWithContext(ROUTER_TO_FLOW_SWAP_ENDPOINTS_HUB.name(), input, new Values(key, data));\n-        } else if (data instanceof FlowLoopRequest) {\n-            String type = data instanceof CreateFlowLoopRequest ? \"create\" : \"delete\";\n-            log.debug(\"Received a flow loop {} request with key {}. MessageId {}\",\n-                    type, key, input.getMessageId());\n-            FlowLoopRequest request = (FlowLoopRequest) data;\n+        } else if (data instanceof CreateFlowLoopRequest) {\n+            log.debug(\"Received a create flow loop request with key {}. MessageId {}\", key, input.getMessageId());\n+            CreateFlowLoopRequest request = (CreateFlowLoopRequest) data;\n+            emitWithContext(ROUTER_TO_FLOW_UPDATE_HUB.name(), input, new Values(key, request.getFlowId(), data));\n+        } else if (data instanceof DeleteFlowLoopRequest) {\n+            log.debug(\"Received a delete flow loop request with key {}. MessageId {}\", key, input.getMessageId());\n+            DeleteFlowLoopRequest request = (DeleteFlowLoopRequest) data;\n             emitWithContext(ROUTER_TO_FLOW_UPDATE_HUB.name(), input, new Values(key, request.getFlowId(), data));\n         } else {\n             unhandledInput(input);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjYyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508666620", "bodyText": "brrr... move it into some method.", "author": "surabujin", "createdAt": "2020-10-20T16:20:31Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java", "diffHunk": "@@ -62,21 +65,57 @@ protected void perform(State from, State to, Event event, FlowUpdateContext cont\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                        stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                        speakerContext.getForward()));\n+                switch (stateMachine.getFlowLoopOperation()) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODc1NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618754", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\nindex ee11bb804..ba61acdf4 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\n\n@@ -65,44 +66,13 @@ public class InstallIngressRulesAction extends FlowProcessingAction<FlowUpdateFs\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                                speakerContext.getForward()));\n-                        break;\n-                    case CREATE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                                speakerContext.getForward()).stream()\n-                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList()));\n-                        break;\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                }\n+                commands.addAll(getCommandsForSourceUpdate(commandBuilder, stateMachine, flow,\n+                        newPrimaryForward, newPrimaryReverse, speakerContext));\n                 break;\n             case DESTINATION:\n                 speakerContext.getReverse().setUpdateMeter(false);\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryReverse, newPrimaryForward,\n-                                speakerContext.getReverse()));\n-                        break;\n-                    case CREATE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryReverse, newPrimaryForward,\n-                                speakerContext.getReverse()).stream()\n-                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList()));\n-                        break;\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                        break;\n-                }\n+                commands.addAll(getCommandsForDestinationUpdate(commandBuilder, stateMachine, flow,\n+                        newPrimaryForward, newPrimaryReverse, speakerContext));\n                 break;\n             case BOTH:\n                 speakerContext.getForward().setUpdateMeter(false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODA2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508668060", "bodyText": "... :(", "author": "surabujin", "createdAt": "2020-10-20T16:22:34Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java", "diffHunk": "@@ -62,21 +65,57 @@ protected void perform(State from, State to, Event event, FlowUpdateContext cont\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                        stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                        speakerContext.getForward()));\n+                switch (stateMachine.getFlowLoopOperation()) {\n+                    case NONE:\n+                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n+                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n+                                speakerContext.getForward()));\n+                        break;\n+                    case CREATE:\n+                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n+                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n+                                speakerContext.getForward()).stream()\n+                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTIyNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619224", "bodyText": "Unfortunately I don't have better solution", "author": "rozdy", "createdAt": "2020-10-28T17:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODA2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\nindex ee11bb804..ba61acdf4 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java\n\n@@ -65,44 +66,13 @@ public class InstallIngressRulesAction extends FlowProcessingAction<FlowUpdateFs\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                                speakerContext.getForward()));\n-                        break;\n-                    case CREATE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                                speakerContext.getForward()).stream()\n-                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList()));\n-                        break;\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                }\n+                commands.addAll(getCommandsForSourceUpdate(commandBuilder, stateMachine, flow,\n+                        newPrimaryForward, newPrimaryReverse, speakerContext));\n                 break;\n             case DESTINATION:\n                 speakerContext.getReverse().setUpdateMeter(false);\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryReverse, newPrimaryForward,\n-                                speakerContext.getReverse()));\n-                        break;\n-                    case CREATE:\n-                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                                stateMachine.getCommandContext(), flow, newPrimaryReverse, newPrimaryForward,\n-                                speakerContext.getReverse()).stream()\n-                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList()));\n-                        break;\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                        break;\n-                }\n+                commands.addAll(getCommandsForDestinationUpdate(commandBuilder, stateMachine, flow,\n+                        newPrimaryForward, newPrimaryReverse, speakerContext));\n                 break;\n             case BOTH:\n                 speakerContext.getForward().setUpdateMeter(false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjgzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508672832", "bodyText": "Do not introduce new cookie types, add a new flag into FlowSegmentCookie.", "author": "surabujin", "createdAt": "2020-10-20T16:29:44Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java", "diffHunk": "@@ -155,6 +155,7 @@ protected static String formatIllegalTypeError(CookieType illegalType, Set<Cooki\n         APPLICATION_MIRROR_FLOW(0x00A),\n         EXCLUSION_FLOW(0x0B),\n         SERVER_42_INGRESS(0x00C),\n+        FLOW_LOOP(0x00D),", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTMzNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619334", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java b/src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java\nindex 454e30c23..b4d5e2f5e 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java\n\n@@ -155,7 +155,6 @@ public abstract class CookieBase implements Serializable {\n         APPLICATION_MIRROR_FLOW(0x00A),\n         EXCLUSION_FLOW(0x0B),\n         SERVER_42_INGRESS(0x00C),\n-        FLOW_LOOP(0x00D),\n \n         // This do not consume any value from allowed address space - you can define another field with -1 value.\n         // (must be last entry)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508673772", "bodyText": "Do we still need it?", "author": "surabujin", "createdAt": "2020-10-20T16:31:01Z", "path": "src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/* Copyright 2018 Telstra Open Source", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1OTYyNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511059624", "bodyText": "Right, it must be removed.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTQ2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619469", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T17:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java b/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java\ndeleted file mode 100644\nindex 3bbb7a132..000000000\n--- a/src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java\n+++ /dev/null\n\n@@ -1,673 +0,0 @@\n-/* Copyright 2018 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.persistence.repositories.impl;\n-\n-import static java.lang.String.format;\n-import static java.util.Collections.emptyList;\n-import static java.util.Collections.singleton;\n-\n-import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowFilter;\n-import org.openkilda.model.FlowPath;\n-import org.openkilda.model.FlowStatus;\n-import org.openkilda.model.PathSegment;\n-import org.openkilda.model.Switch;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.persistence.FetchStrategy;\n-import org.openkilda.persistence.TransactionManager;\n-import org.openkilda.persistence.converters.FlowStatusConverter;\n-import org.openkilda.persistence.converters.SwitchIdConverter;\n-import org.openkilda.persistence.exceptions.PersistenceException;\n-import org.openkilda.persistence.repositories.FlowRepository;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Lists;\n-import lombok.NonNull;\n-import lombok.extern.slf4j.Slf4j;\n-import org.neo4j.ogm.cypher.ComparisonOperator;\n-import org.neo4j.ogm.cypher.Filter;\n-import org.neo4j.ogm.cypher.Filters;\n-import org.neo4j.ogm.session.Neo4jSession;\n-import org.neo4j.ogm.session.Session;\n-import org.neo4j.ogm.typeconversion.InstantStringConverter;\n-\n-import java.time.Instant;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-/**\n- * Neo4j OGM implementation of {@link FlowRepository}.\n- */\n-@Slf4j\n-public class Neo4jFlowRepository extends Neo4jGenericRepository<Flow> implements FlowRepository {\n-    static final String FLOW_ID_PROPERTY_NAME = \"flow_id\";\n-    static final String GROUP_ID_PROPERTY_NAME = \"group_id\";\n-    static final String SRC_PORT_PROPERTY_NAME = \"src_port\";\n-    static final String DST_PORT_PROPERTY_NAME = \"dst_port\";\n-    static final String SRC_MULTI_TABLE_PROPERTY_NAME = \"src_with_multi_table\";\n-    static final String DST_MULTI_TABLE_PROPERTY_NAME = \"dst_with_multi_table\";\n-    static final String PERIODIC_PINGS_PROPERTY_NAME = \"periodic_pings\";\n-    static final String STATUS_PROPERTY_NAME = \"status\";\n-    static final String SRC_LLDP_PROPERTY_NAME = \"detect_src_lldp_connected_devices\";\n-    static final String DST_LLDP_PROPERTY_NAME = \"detect_dst_lldp_connected_devices\";\n-    static final String SRC_ARP_PROPERTY_NAME = \"detect_src_arp_connected_devices\";\n-    static final String DST_ARP_PROPERTY_NAME = \"detect_dst_arp_connected_devices\";\n-    static final String LOOPED_PROPERTY_NAME = \"looped\";\n-    static final String LOOP_SWITCH_ID_PROPERTY_NAME = \"loop_switch_id\";\n-    private static final String SRC_SWITCH_ALIAS = \"src_switch\";\n-    private static final String DST_SWITCH_ALIAS = \"dst_switch\";\n-    private static final String FLOW_ALIAS = \"flow\";\n-\n-    private final FlowStatusConverter flowStatusConverter = new FlowStatusConverter();\n-    private final InstantStringConverter instantStringConverter = new InstantStringConverter();\n-    private final SwitchIdConverter switchIdConverter = new SwitchIdConverter();\n-\n-    private final Neo4jFlowPathRepository flowPathRepository;\n-\n-    public Neo4jFlowRepository(Neo4jSessionFactory sessionFactory, TransactionManager transactionManager) {\n-        super(sessionFactory, transactionManager);\n-\n-        flowPathRepository = new Neo4jFlowPathRepository(sessionFactory, transactionManager);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findAll() {\n-        return findAll(FetchStrategy.DIRECT_RELATIONS);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findAll(FetchStrategy fetchStrategy) {\n-        return loadAll(EMPTY_FILTERS, fetchStrategy);\n-    }\n-\n-    @Override\n-    public long countFlows() {\n-        return getSession().countEntitiesOfType(getEntityType());\n-    }\n-\n-    @Override\n-    public boolean exists(String flowId) {\n-        Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-\n-        return getSession().count(getEntityType(), singleton(flowIdFilter)) > 0;\n-    }\n-\n-    @Override\n-    public Optional<Flow> findById(String flowId) {\n-        return findById(flowId, getDefaultFetchStrategy());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findById(String flowId, FetchStrategy fetchStrategy) {\n-        Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-\n-        Collection<Flow> flows = loadAll(flowIdFilter, fetchStrategy);\n-        if (flows.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by %s as flowId\", flowId));\n-        } else if (flows.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        return Optional.of(flows.iterator().next());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findByIdWithEndpoints(String flowId) {\n-        Map<String, Object> parameters = ImmutableMap.of(\"flow_id\", flowId);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE f.flow_id = $flow_id \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by flowId '%s'. Found flows: %s\",\n-                    flowId, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByGroupId(String flowGroupId) {\n-        Filter groupIdFilter = new Filter(GROUP_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowGroupId);\n-\n-        return loadAll(groupIdFilter);\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowsIdByGroupId(String flowGroupId) {\n-        Map<String, Object> flowParameters = ImmutableMap.of(\"flow_group_id\", flowGroupId);\n-\n-        return queryForStrings(\n-                \"MATCH (f:flow {group_id: $flow_group_id}) RETURN f.flow_id as flow_id\", flowParameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<Flow> findWithPeriodicPingsEnabled() {\n-        Filter periodicPingsFilter = new Filter(PERIODIC_PINGS_PROPERTY_NAME, ComparisonOperator.EQUALS, true);\n-\n-        return loadAll(periodicPingsFilter);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpoint(SwitchId switchId, int port) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcPortFilter = new Filter(SRC_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstPortFilter = new Filter(DST_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcPortFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstPortFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Optional<Flow> findByEndpointAndVlan(SwitchId switchId, int port, int vlan) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchId,\n-                \"port\", port,\n-                \"vlan\", vlan);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE (s.name = $switch_id AND f.src_port = $port AND f.src_vlan = $vlan) \"\n-                + \"OR (d.name = $switch_id AND f.dst_port = $port AND f.dst_vlan = $vlan) \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by SwitchId %s, port %d and vlan %d. \"\n-                    + \"Found Flows: %s\", switchId, port, vlan, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Optional<Flow> findOneSwitchFlowBySwitchIdInPortAndOutVlan(SwitchId switchId, int inPort, int outVlan) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchId,\n-                \"in_port\", inPort,\n-                \"out_vlan\", outVlan);\n-\n-        String query = format(\"MATCH (s:switch)<-[:source]-(f:flow)-[:destination]->(d:switch) \"\n-                + \"WHERE s.name = $switch_id AND d.name = $switch_id \"\n-                + \"AND ((f.src_port = $in_port AND f.dst_vlan = $out_vlan) \"\n-                + \"OR (f.dst_port = $in_port AND f.src_vlan = $out_vlan)) \"\n-                + \"RETURN s as %s, f as %s, d as %s\", SRC_SWITCH_ALIAS, FLOW_ALIAS, DST_SWITCH_ALIAS);\n-\n-        List<Map<String, Object>> results = Lists.newArrayList(getSession().query(query, parameters).queryResults());\n-\n-        if (results.size() > 1) {\n-            throw new PersistenceException(format(\"Found more that 1 Flow entity by SwitchId %s, InPort %d and \"\n-                    + \"OutVlan %d. Found Flows %s\", switchId, inPort, outVlan, extractFlowsAsString(results)));\n-        }\n-\n-        return extractFlowWithEndpoints(results);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointWithMultiTableSupport(SwitchId switchId, int port) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcPortFilter = new Filter(SRC_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter srcMultiTableFilter = new Filter(SRC_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstPortFilter = new Filter(DST_PORT_PROPERTY_NAME, ComparisonOperator.EQUALS, port);\n-        Filter dstMultiTableFilter = new Filter(DST_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcPortFilter).and(srcMultiTableFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstPortFilter).and(dstMultiTableFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowsIdsByEndpointWithMultiTableSupport(SwitchId switchId, int port) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchIdConverter.toGraphProperty(switchId),\n-                \"port\", port,\n-                \"multi_table\", true);\n-\n-        return queryForStrings(\"MATCH (src:switch)-[:source]-(f:flow)-[:destination]-(dst:switch) \"\n-                + \"WHERE src.name=$switch_id AND f.src_port=$port AND f.src_with_multi_table=$multi_table \"\n-                + \"OR dst.name=$switch_id AND f.dst_port=$port AND f.dst_with_multi_table=$multi_table \"\n-                + \"RETURN f.flow_id as flow_id\", parameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<String> findFlowIdsForMultiSwitchFlowsByEndpointWithMultiTableSupport(\n-            SwitchId switchId, int port) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"switch_id\", switchIdConverter.toGraphProperty(switchId),\n-                \"port\", port,\n-                \"multi_table\", true);\n-\n-        return queryForStrings(\"MATCH (src:switch)-[:source]-(f:flow)-[:destination]-(dst:switch) \"\n-                + \"WHERE src.name <> dst.name \"\n-                + \"AND (src.name=$switch_id AND f.src_port=$port AND f.src_with_multi_table=$multi_table \"\n-                + \"OR dst.name=$switch_id AND f.dst_port=$port AND f.dst_with_multi_table=$multi_table) \"\n-                + \"RETURN f.flow_id as flow_id\", parameters, \"flow_id\");\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitch(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-\n-        return Stream.concat(loadAll(srcSwitchFilter).stream(), loadAll(dstSwitchFilter).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithMultiTableSupport(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcMultiTableFilter = new Filter(SRC_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstMultiTableFilter = new Filter(DST_MULTI_TABLE_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcMultiTableFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstMultiTableFilter)).stream())\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithEnabledLldp(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcLldpFilter = new Filter(SRC_LLDP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstLldpFilter = new Filter(DST_LLDP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcLldpFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstLldpFilter)).stream())\n-                .collect(Collectors.toSet()); // to do not return one flow twice (one switch flow with LLDP)\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByEndpointSwitchWithEnabledArp(SwitchId switchId) {\n-        Filter srcSwitchFilter = createSrcSwitchFilter(switchId);\n-        Filter srcArpFilter = new Filter(SRC_ARP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-        Filter dstSwitchFilter = createDstSwitchFilter(switchId);\n-        Filter dstArpFilter = new Filter(DST_ARP_PROPERTY_NAME, ComparisonOperator.IS_TRUE);\n-\n-        return Stream.concat(\n-                loadAll(srcSwitchFilter.and(srcArpFilter)).stream(),\n-                loadAll(dstSwitchFilter.and(dstArpFilter)).stream())\n-                .collect(Collectors.toSet()); // to do not return one flow twice (one switch flow with ARP)\n-    }\n-\n-    @Override\n-    public Collection<Flow> findOneSwitchFlows(SwitchId switchId) {\n-        Filters filters = new Filters();\n-        filters.and(createSrcSwitchFilter(switchId));\n-        filters.and(createDstSwitchFilter(switchId));\n-        return loadAll(filters);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findDownFlows() {\n-        Filter flowStatusDown = new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, FlowStatus.DOWN);\n-        Filter flowStatusDegraded = new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, FlowStatus.DEGRADED);\n-\n-        return loadAll(flowStatusDown.or(flowStatusDegraded));\n-    }\n-\n-    @Override\n-    public Collection<Flow> findByFlowFilter(FlowFilter flowFilter) {\n-        Filters filters = new Filters();\n-        Optional.ofNullable(flowFilter.getFlowStatus()).ifPresent(flowStatus ->\n-                filters.and(new Filter(STATUS_PROPERTY_NAME, ComparisonOperator.EQUALS, flowStatus)));\n-        return loadAll(filters, FetchStrategy.DIRECT_RELATIONS);\n-    }\n-\n-    @Override\n-    public void createOrUpdate(Flow flow) {\n-        validateFlow(flow);\n-\n-        if (flow.getTimeCreate() == null) {\n-            flow.setTimeCreate(Instant.now());\n-        } else {\n-            flow.setTimeModify(Instant.now());\n-        }\n-\n-        transactionManager.doInTransaction(() -> {\n-            Session session = getSession();\n-            // To avoid Neo4j deadlocks, we perform locking of switch nodes in the case of new flow, path or segments.\n-            boolean isNewFlow = session.resolveGraphIdFor(flow) == null;\n-            if (isNewFlow || hasUnmanagedEntity(flow)) {\n-                // No need to fetch current paths for a new flow.\n-                Collection<FlowPath> currentPaths = isNewFlow ? emptyList()\n-                        : flowPathRepository.findByFlowId(flow.getFlowId());\n-\n-                flowPathRepository.lockInvolvedSwitches(Stream.concat(currentPaths.stream(), flow.getPaths().stream())\n-                        .toArray(FlowPath[]::new));\n-\n-                if (!isNewFlow) {\n-                    deleteOrphanPaths(flow, currentPaths);\n-                }\n-            } else {\n-                deleteOrphanPaths(flow);\n-            }\n-\n-            super.createOrUpdate(flow);\n-        });\n-    }\n-\n-    private String extractFlowsAsString(List<Map<String, Object>> results) {\n-        return results.stream()\n-                .map(result -> result.get(FLOW_ALIAS))\n-                .map(Flow.class::cast)\n-                .map(Flow::toString)\n-                .collect(Collectors.joining(\", \"));\n-    }\n-\n-    private Optional<Flow> extractFlowWithEndpoints(List<Map<String, Object>> results) {\n-        if (results.isEmpty()) {\n-            return Optional.empty();\n-        }\n-\n-        Map<String, Object> result = results.iterator().next();\n-\n-        Flow flow = (Flow) result.get(FLOW_ALIAS);\n-        flow.setSrcSwitch((Switch) result.get(SRC_SWITCH_ALIAS));\n-        flow.setDestSwitch((Switch) result.get(DST_SWITCH_ALIAS));\n-        return Optional.of(flow);\n-    }\n-\n-    /**\n-     * Validate the flow relations and flow path to be managed by Neo4j OGM.\n-     */\n-    private void validateFlow(Flow flow) {\n-        // The flow must reference a managed switches to avoid creation of duplicated ones.\n-        // Check for nulls as the entity may be read not completely.\n-        if (flow.getSrcSwitch() != null) {\n-            requireManagedEntity(flow.getSrcSwitch());\n-        }\n-        if (flow.getDestSwitch() != null) {\n-            requireManagedEntity(flow.getDestSwitch());\n-        }\n-\n-        for (FlowPath path : flow.getPaths()) {\n-            flowPathRepository.validateFlowPath(path);\n-        }\n-    }\n-\n-    private boolean hasUnmanagedEntity(Flow flow) {\n-        Session session = getSession();\n-        for (FlowPath path : flow.getPaths()) {\n-            if (session.resolveGraphIdFor(path) == null) {\n-                return true;\n-            }\n-            for (PathSegment segment : path.getSegments()) {\n-                if (session.resolveGraphIdFor(segment) == null) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private void deleteOrphanPaths(Flow flow, Collection<FlowPath> currentPaths) {\n-        Session session = getSession();\n-        Set<Long> updatedFlowPaths = flow.getPaths().stream()\n-                .map(session::resolveGraphIdFor)\n-                .filter(Objects::nonNull)\n-                .collect(Collectors.toSet());\n-\n-        FlowPath[] pathsToDelete = currentPaths.stream()\n-                .filter(path -> !updatedFlowPaths.contains(session.resolveGraphIdFor(path)))\n-                .toArray(FlowPath[]::new);\n-        if (pathsToDelete.length > 0) {\n-            flowPathRepository.lockInvolvedSwitches(pathsToDelete);\n-\n-            for (FlowPath path : pathsToDelete) {\n-                flowPathRepository.delete(path);\n-            }\n-        }\n-    }\n-\n-    private void deleteOrphanPaths(Flow flow) {\n-        Session session = getSession();\n-        Set<Long> currentPathIds = findPathEntityIdsByFlowId(flow.getFlowId());\n-        flow.getPaths().stream()\n-                .map(session::resolveGraphIdFor)\n-                .filter(Objects::nonNull)\n-                .forEach(currentPathIds::remove);\n-\n-        if (!currentPathIds.isEmpty()) {\n-            FlowPath[] pathsToDelete = currentPathIds.stream()\n-                    .map(pathEntityId -> session.load(FlowPath.class, pathEntityId))\n-                    .filter(Objects::nonNull)\n-                    .toArray(FlowPath[]::new);\n-\n-            if (pathsToDelete.length > 0) {\n-                flowPathRepository.lockInvolvedSwitches(pathsToDelete);\n-\n-                for (FlowPath path : pathsToDelete) {\n-                    flowPathRepository.delete(path);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Set<Long> findPathEntityIdsByFlowId(String flowId) {\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"flow_id\", flowId);\n-\n-        Set<Long> pathEntityIds = new HashSet<>();\n-        queryForLongs(\"MATCH (flow {flow_id: $flow_id})-[:owns]-(fp:flow_path) RETURN id(fp) as id\",\n-                parameters, \"id\").forEach(pathEntityIds::add);\n-        return pathEntityIds;\n-    }\n-\n-    @Override\n-    public void delete(Flow flow) {\n-        transactionManager.doInTransaction(() -> {\n-            Collection<FlowPath> flowPaths = flowPathRepository.findByFlowId(flow.getFlowId());\n-            flowPathRepository.lockInvolvedSwitches(flowPaths.toArray(new FlowPath[0]));\n-\n-            flowPaths.forEach(flowPathRepository::delete);\n-\n-            super.delete(flow);\n-        });\n-    }\n-\n-    @Override\n-    public Optional<String> getOrCreateFlowGroupId(String flowId) {\n-        return transactionManager.doInTransaction(() -> findById(flowId, FetchStrategy.NO_RELATIONS)\n-                .map(diverseFlow -> {\n-                    if (diverseFlow.getGroupId() == null) {\n-                        String groupId = UUID.randomUUID().toString();\n-\n-                        diverseFlow.setGroupId(groupId);\n-                        super.createOrUpdate(diverseFlow);\n-                    }\n-                    return diverseFlow.getGroupId();\n-                }));\n-    }\n-\n-    @Override\n-    public void updateStatus(String flowId, FlowStatus flowStatus) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = ImmutableMap.of(\n-                \"flow_id\", flowId,\n-                \"status\", flowStatusConverter.toGraphProperty(flowStatus),\n-                \"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id}) \"\n-                        + \"SET f.status=$status, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id\", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusUpdate(flowStatus, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatus(@NonNull String flowId, @NonNull FlowStatus flowStatus, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status\", flowStatusConverter.toGraphProperty(flowStatus));\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id})  \"\n-                        + \"SET f.status=$status, f.status_info=$status_info, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id \", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusUpdate(flowStatus, flowStatusInfo, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatusInfo(@NonNull String flowId, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-        Optional<Long> updatedEntityId = queryForLong(\n-                \"MATCH (f:flow {flow_id: $flow_id})   \"\n-                        + \"SET f.status_info=$status_info, f.time_modify=$time_modify \"\n-                        + \"RETURN id(f) as id  \", parameters, \"id\");\n-        if (!updatedEntityId.isPresent()) {\n-            throw new PersistenceException(format(\"Flow not found to be updated: %s\", flowId));\n-        }\n-        postStatusInfoUpdate(flowStatusInfo, timestamp, updatedEntityId.get());\n-    }\n-\n-    @Override\n-    public void updateStatusSafe(@NonNull String flowId, @NonNull FlowStatus flowStatus, String flowStatusInfo) {\n-        Instant timestamp = Instant.now();\n-        Map<String, Object> parameters = new HashMap<>();\n-        parameters.put(\"flow_id\", flowId);\n-        parameters.put(\"status\", flowStatusConverter.toGraphProperty(flowStatus));\n-        parameters.put(\"keep_status\", flowStatusConverter.toGraphProperty(FlowStatus.IN_PROGRESS));\n-        parameters.put(\"status_info\", flowStatusInfo);\n-        parameters.put(\"time_modify\", instantStringConverter.toGraphProperty(timestamp));\n-\n-        String query = \"MATCH (f:flow {flow_id: $flow_id}) \"\n-                + \"WHERE f.status<>$keep_status \"\n-                + \"SET f.status=$status, f.status_info=$status_info, f.time_modify=$time_modify \"\n-                + \"RETURN id(f) as id\";\n-        Optional<Long> entityId = queryForLong(query, parameters, \"id\");\n-        entityId.ifPresent(id -> postStatusUpdate(flowStatus, flowStatusInfo, timestamp, id));\n-    }\n-\n-    @Override\n-    public long computeFlowsBandwidthSum(Set<String> flowIds) {\n-        Map<String, Object> parameters = ImmutableMap.of(\"flow_ids\", flowIds);\n-        return queryForLong(\"MATCH (f:flow) WHERE f.flow_id IN $flow_ids \"\n-                + \"RETURN sum(f.bandwidth) as bandwidth\", parameters, \"bandwidth\").orElse(0L);\n-    }\n-\n-    @Override\n-    public Collection<Flow> findLoopedByFlowIdAndLoopSwitchId(String flowId, String switchId) {\n-        Filter loopedFilter = new Filter(LOOPED_PROPERTY_NAME, ComparisonOperator.EQUALS, true);\n-        Filters filters = new Filters(loopedFilter);\n-        if (flowId != null) {\n-            Filter flowIdFilter = new Filter(FLOW_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, flowId);\n-            filters.and(flowIdFilter);\n-        }\n-        if (switchId != null) {\n-            Filter switchIdFilter = new Filter(LOOP_SWITCH_ID_PROPERTY_NAME, ComparisonOperator.EQUALS, switchId);\n-            filters.and(switchIdFilter);\n-        }\n-\n-        return loadAll(filters);\n-    }\n-\n-    @Override\n-    protected Class<Flow> getEntityType() {\n-        return Flow.class;\n-    }\n-\n-    @Override\n-    protected FetchStrategy getDefaultFetchStrategy() {\n-        return FetchStrategy.ALL_RELATIONS;\n-    }\n-\n-    @Override\n-    protected int getDepthLoadEntity(FetchStrategy fetchStrategy) {\n-        switch (fetchStrategy) {\n-            case ALL_RELATIONS:\n-                // depth 3 is needed to load switches in PathSegment entity.\n-                return 3;\n-            default:\n-                return super.getDepthLoadEntity(fetchStrategy);\n-        }\n-    }\n-\n-    @Override\n-    protected int getDepthCreateUpdateEntity() {\n-        // depth 3 is needed to create/update relations to switches, flow paths,\n-        // path segments and switches of path segments.\n-        return 3;\n-    }\n-\n-    private void postStatusUpdate(FlowStatus flowStatus, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatus(flowStatus);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-\n-    private void postStatusUpdate(FlowStatus flowStatus, String flowStatusInfo, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatus(flowStatus);\n-            updatedFlow.setStatusInfo(flowStatusInfo);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-\n-    private void postStatusInfoUpdate(String flowStatusInfo, Instant timestamp, Long entityId) {\n-        Session session = getSession();\n-        Object updatedEntity = ((Neo4jSession) session).context().getNodeEntity(entityId);\n-        if (updatedEntity instanceof Flow) {\n-            Flow updatedFlow = (Flow) updatedEntity;\n-            updatedFlow.setStatusInfo(flowStatusInfo);\n-            updatedFlow.setTimeModify(timestamp);\n-        } else if (updatedEntity != null) {\n-            throw new PersistenceException(format(\"Expected a Flow entity, but found %s.\", updatedEntity));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MDY5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508680695", "bodyText": "It definitely should be loops.", "author": "surabujin", "createdAt": "2020-10-20T16:41:55Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -160,6 +162,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loop\")", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTYwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619605", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MDY5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\nindex 3f623a383..15c61d34e 100644\n--- a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\n+++ b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java\n\n@@ -170,7 +168,7 @@ public class FlowControllerV2 extends BaseController {\n      * @return list of flow loops\n      */\n     @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n-    @GetMapping(value = \"/loop\")\n+    @GetMapping(value = \"/loops\")\n     @ResponseStatus(HttpStatus.OK)\n     public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(\n             @RequestParam(value = \"flow_id\", required = false) String flowId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MjAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508682032", "bodyText": "Why we allow \"no response\"?", "author": "surabujin", "createdAt": "2020-10-20T16:44:03Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -699,4 +707,50 @@ private FlowPathPayload buildFlowPathPayload(List<FlowPathDto> paths, String flo\n                 .thenApply(org.openkilda.messaging.nbtopology.response.FlowConnectedDevicesResponse.class::cast)\n                 .thenApply(connectedDeviceMapper::toResponse);\n     }\n+\n+    @Override\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(String flowId, String switchId) {\n+        logger.info(\"Get flow loops for flow {} and switch {}\", flowId, switchId);\n+\n+        GetFlowLoopsRequest request = new GetFlowLoopsRequest(flowId, switchId);\n+\n+        CommandMessage message = new CommandMessage(\n+                request, System.currentTimeMillis(), RequestCorrelationId.getId(), Destination.WFM);\n+\n+        return messagingChannel.sendAndGet(nbworkerTopic, message)\n+                .thenApply(result -> Optional.of(result).map(FlowLoopsResponse.class::cast)\n+                        .map(FlowLoopsResponse::getPayload)\n+                        .orElse(Collections.emptyList())", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDI2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620261", "bodyText": "System may not have any looped flows", "author": "rozdy", "createdAt": "2020-10-28T17:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MjAzMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508695275", "bodyText": "Can we move it to the DB level?", "author": "surabujin", "createdAt": "2020-10-20T17:04:27Z", "path": "src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java", "diffHunk": "@@ -500,6 +500,24 @@ public long computeFlowsBandwidthSum(Set<String> flowIds) {\n                         }));\n     }\n \n+    @Override\n+    public Collection<Flow> findLoopedByFlowIdAndLoopSwitchId(String flowId, SwitchId switchId) {\n+        return framedGraph().traverse(g -> {\n+            GraphTraversal<Vertex, Vertex> vertexVertexGraphTraversal = g.V()\n+                    .hasLabel(FlowFrame.FRAME_LABEL)\n+                    .has(FlowFrame.LOOPED_PROPERTY, true);\n+            if (flowId != null) {\n+                vertexVertexGraphTraversal.has(FlowFrame.FLOW_ID_PROPERTY, flowId);\n+            }\n+            return vertexVertexGraphTraversal;\n+        }).toListExplicit(FlowFrame.class).stream()\n+                .map(Flow::new)\n+                .filter(f -> switchId == null", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MjgxMw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511062813", "bodyText": "From performance standpoint, it's better to refactor this method into 2 traverses with subsequent concatenation:\nString switchIdAsStr = SwitchIdConverter.INSTANCE.toGraphProperty(switchId);\n\nList<Flow> result = new ArrayList<>();\n        \nframedGraph().traverse(g -> g.V()\n                .hasLabel(FlowFrame.FRAME_LABEL)\n                .has(FlowFrame.SRC_SWITCH_ID_PROPERTY, switchIdAsStr)\n                .has(FlowFrame.LOOPED_PROPERTY, true))\n                .frameExplicit(FlowFrame.class)\n                .forEachRemaining(frame -> result.add(new Flow(frame))));\n\nframedGraph().traverse(g -> g.V()\n                .hasLabel(FlowFrame.FRAME_LABEL)\n                .has(FlowFrame.DST_SWITCH_ID_PROPERTY, switchIdAsStr)\n               .has(FlowFrame.LOOPED_PROPERTY, true))\n                .frameExplicit(FlowFrame.class)\n                .forEachRemaining(frame -> result.add(new Flow(frame)));\n\nreturn result;\n\nIn this approach the indexes are used instead of full scan.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDM4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620389", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java b/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java\nindex 3c3513c45..6e37bc75d 100644\n--- a/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java\n+++ b/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java\n\n@@ -502,20 +503,25 @@ public class FermaFlowRepository extends FermaGenericRepository<Flow, FlowData,\n \n     @Override\n     public Collection<Flow> findLoopedByFlowIdAndLoopSwitchId(String flowId, SwitchId switchId) {\n-        return framedGraph().traverse(g -> {\n-            GraphTraversal<Vertex, Vertex> vertexVertexGraphTraversal = g.V()\n-                    .hasLabel(FlowFrame.FRAME_LABEL)\n-                    .has(FlowFrame.LOOPED_PROPERTY, true);\n-            if (flowId != null) {\n-                vertexVertexGraphTraversal.has(FlowFrame.FLOW_ID_PROPERTY, flowId);\n-            }\n-            return vertexVertexGraphTraversal;\n-        }).toListExplicit(FlowFrame.class).stream()\n-                .map(Flow::new)\n-                .filter(f -> switchId == null\n-                        || f.getSrcSwitchId().equals(switchId)\n-                        || f.getDestSwitchId().equals(switchId))\n-                .collect(Collectors.toList());\n+        String switchIdAsStr = SwitchIdConverter.INSTANCE.toGraphProperty(switchId);\n+\n+        List<Flow> result = new ArrayList<>();\n+\n+        framedGraph().traverse(g -> g.V()\n+                .hasLabel(FlowFrame.FRAME_LABEL)\n+                .has(FlowFrame.SRC_SWITCH_ID_PROPERTY, switchIdAsStr)\n+                .has(FlowFrame.LOOP_SWITCH_ID_PROPERTY, P.neq(null)))\n+                .frameExplicit(FlowFrame.class)\n+                .forEachRemaining(frame -> result.add(new Flow(frame)));\n+\n+        framedGraph().traverse(g -> g.V()\n+                .hasLabel(FlowFrame.FRAME_LABEL)\n+                .has(FlowFrame.DST_SWITCH_ID_PROPERTY, switchIdAsStr)\n+                .has(FlowFrame.LOOP_SWITCH_ID_PROPERTY, P.neq(null)))\n+                .frameExplicit(FlowFrame.class)\n+                .forEachRemaining(frame -> result.add(new Flow(frame)));\n+\n+        return result;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODAwNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511058006", "bodyText": "A switch statement inside another switch is very confusing. Pls, consider refactoring - e.g. move into a method.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:15:10Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java", "diffHunk": "@@ -84,16 +87,40 @@ protected void perform(State from, State to,\n     }\n \n     private Collection<FlowSegmentRequestFactory> buildCommands(FlowCommandBuilder commandBuilder,\n-                                                                CommandContext context, Flow flow,\n-                                                                FlowPath path, FlowPath oppositePath,\n-                                                                FlowUpdateFsm.EndpointUpdate endpointUpdate) {\n-        switch (endpointUpdate) {\n+                                                                FlowUpdateFsm stateMachine, Flow flow,\n+                                                                FlowPath path, FlowPath oppositePath) {\n+        CommandContext context = stateMachine.getCommandContext();\n+        switch (stateMachine.getEndpointUpdate()) {\n             case BOTH:\n                 return new ArrayList<>(commandBuilder.buildEgressOnly(context, flow, path, oppositePath));\n             case SOURCE:\n-                return new ArrayList<>(commandBuilder.buildEgressOnlyOneDirection(context, flow, oppositePath, path));\n+                switch (stateMachine.getFlowLoopOperation()) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDUyNw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620527", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java\nindex d87daa304..a6ee2e462 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java\n\n@@ -94,36 +94,49 @@ public class InstallNonIngressRulesAction\n             case BOTH:\n                 return new ArrayList<>(commandBuilder.buildEgressOnly(context, flow, path, oppositePath));\n             case SOURCE:\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        return new ArrayList<>(commandBuilder\n-                                .buildEgressOnlyOneDirection(context, flow, oppositePath, path));\n-                    case CREATE:\n-                        return commandBuilder.buildEgressOnlyOneDirection(context, flow, oppositePath, path).stream()\n-                                .filter(f -> f instanceof TransitFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList());\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                        return Collections.emptyList();\n-                }\n+                return buildCommandsForSourceUpdate(commandBuilder, stateMachine, flow, path, oppositePath, context);\n             case DESTINATION:\n-                switch (stateMachine.getFlowLoopOperation()) {\n-                    case NONE:\n-                        return new ArrayList<>(commandBuilder\n-                                .buildEgressOnlyOneDirection(context, flow, path, oppositePath));\n-                    case CREATE:\n-                        return commandBuilder.buildEgressOnlyOneDirection(context, flow, path, oppositePath).stream()\n-                                .filter(f -> f instanceof TransitFlowLoopSegmentRequestFactory)\n-                                .collect(Collectors.toList());\n-                    case DELETE:\n-                    default:\n-                        // No rules installation required\n-                        return Collections.emptyList();\n-                }\n+                return buildCommandsForDestinationUpdate(commandBuilder, stateMachine, flow, path, oppositePath,\n+                        context);\n             default:\n                 return new ArrayList<>(commandBuilder.buildAllExceptIngress(context, flow, path, oppositePath));\n \n         }\n     }\n+\n+    private Collection<FlowSegmentRequestFactory> buildCommandsForSourceUpdate(\n+            FlowCommandBuilder commandBuilder, FlowUpdateFsm stateMachine, Flow flow,\n+            FlowPath path, FlowPath oppositePath, CommandContext context) {\n+        switch (stateMachine.getFlowLoopOperation()) {\n+            case NONE:\n+                return new ArrayList<>(commandBuilder\n+                        .buildEgressOnlyOneDirection(context, flow, oppositePath, path));\n+            case CREATE:\n+                return commandBuilder.buildEgressOnlyOneDirection(context, flow, oppositePath, path).stream()\n+                        .filter(f -> f instanceof TransitFlowLoopSegmentRequestFactory)\n+                        .collect(Collectors.toList());\n+            case DELETE:\n+            default:\n+                // No rules installation required\n+                return Collections.emptyList();\n+        }\n+    }\n+\n+    private Collection<FlowSegmentRequestFactory> buildCommandsForDestinationUpdate(\n+            FlowCommandBuilder commandBuilder, FlowUpdateFsm stateMachine, Flow flow,\n+            FlowPath path, FlowPath oppositePath, CommandContext context) {\n+        switch (stateMachine.getFlowLoopOperation()) {\n+            case NONE:\n+                return new ArrayList<>(commandBuilder\n+                        .buildEgressOnlyOneDirection(context, flow, path, oppositePath));\n+            case CREATE:\n+                return commandBuilder.buildEgressOnlyOneDirection(context, flow, path, oppositePath).stream()\n+                        .filter(f -> f instanceof TransitFlowLoopSegmentRequestFactory)\n+                        .collect(Collectors.toList());\n+            case DELETE:\n+            default:\n+                // No rules installation required\n+                return Collections.emptyList();\n+        }\n+    }\n }\n"}}, {"oid": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "url": "https://github.com/telstra/open-kilda/commit/0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "message": "Flow loop feature implementation", "committedDate": "2020-10-28T16:54:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NjA4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r514056087", "bodyText": "The return value of OfAdapter.INSTANCE.makeVlanReplaceActions() is not used anywhere.", "author": "dpoltavets", "createdAt": "2020-10-29T07:38:43Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java", "diffHunk": "@@ -61,6 +63,21 @@ public IngressInstallFlowModFactory(\n         return instructions;\n     }\n \n+    @Override\n+    protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n+        List<OFAction> actions = new ArrayList<>();\n+        if (endpoint.getInnerVlanId() != 0) {\n+            OfAdapter.INSTANCE.makeVlanReplaceActions(of, Collections.singletonList(endpoint.getOuterVlanId()),", "originalCommit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4NzU1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r514287555", "bodyText": "Fixed", "author": "rozdy", "createdAt": "2020-10-29T14:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NjA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\nindex fc3aca87b..56a96451c 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java\n\n@@ -67,8 +67,9 @@ public abstract class IngressInstallFlowModFactory extends IngressFlowModFactory\n     protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n         List<OFAction> actions = new ArrayList<>();\n         if (endpoint.getInnerVlanId() != 0) {\n-            OfAdapter.INSTANCE.makeVlanReplaceActions(of, Collections.singletonList(endpoint.getOuterVlanId()),\n-                    endpoint.getVlanStack());\n+            actions.addAll(OfAdapter.INSTANCE.makeVlanReplaceActions(of,\n+                    Collections.singletonList(endpoint.getOuterVlanId()),\n+                    endpoint.getVlanStack()));\n         }\n         actions.add(of.actions().buildOutput()\n                 .setPort(OFPort.of(endpoint.getPortNumber()))\n"}}, {"oid": "c34918dd97ae0334c0d8aebac71022f3c248e970", "url": "https://github.com/telstra/open-kilda/commit/c34918dd97ae0334c0d8aebac71022f3c248e970", "message": "Flow loop feature implementation", "committedDate": "2020-10-29T14:05:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk3ODQ4NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r515978484", "bodyText": "Perhaps we should/can use another coordinate system. For example side identifier (source/dest) and the number of switches from this side 0..N. Relative address is simpler from flow modification perspective, but harder if you need to hit into the specific switch.\nThis is just an idea to think about.", "author": "surabujin", "createdAt": "2020-11-02T13:42:17Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java", "diffHunk": "@@ -183,6 +183,9 @@\n     @JsonProperty(\"diverse_with\")\n     private Set<String> diverseWith;\n \n+    @JsonProperty(\"loop_switch_id\")\n+    private SwitchId loopSwitchId;", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxODc4NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516018784", "bodyText": "Add \"0x\" prefix to get rid of any ambiguity.", "author": "surabujin", "createdAt": "2020-11-02T14:43:35Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java", "diffHunk": "@@ -59,7 +59,7 @@ public String toString() {\n             outVlanString = \"-\" + outVlanString;\n         }\n         return \"{sw:\" + switchId\n-                + \", ck:\" + cookie\n+                + \", ck:\" + Long.toHexString(cookie)", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTEwOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295108", "bodyText": "Added.", "author": "rozdy", "createdAt": "2020-11-05T19:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxODc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "927a0619b479d74187ae6bca84c9ad28604489ea", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java\nindex 933cbc1c6..8ab9ff49a 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java\n\n@@ -59,7 +59,7 @@ public class SimpleSwitchRule {\n             outVlanString = \"-\" + outVlanString;\n         }\n         return \"{sw:\" + switchId\n-                + \", ck:\" + Long.toHexString(cookie)\n+                + \", ck:0x\" + Long.toHexString(cookie)\n                 + \", in:\" + inPort + \"-\" + inVlan\n                 + \", out:\" + outPort + outVlanString\n                 + '}';\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MjM4MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516062380", "bodyText": "will it work in q-in-q?", "author": "surabujin", "createdAt": "2020-11-02T15:43:56Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (flow.getLoopSwitchId() == flowPath.getSrcSwitch().getSwitchId()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+            }\n         }\n+        rules.add(rule);\n \n-        return rule;\n+        return rules;\n+    }\n+\n+    private SimpleSwitchRule buildIngressLoopSimpleSwitchRule(SimpleSwitchRule rule, FlowPath flowPath,\n+                                                              FlowSideAdapter ingress) {\n+        return SimpleSwitchRule.builder()\n+                .switchId(rule.getSwitchId())\n+                .cookie(flowPath.getCookie().toBuilder().looped(true).build().getValue())\n+                .inPort(rule.getInPort())\n+                .inVlan(rule.getInVlan())", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTMxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295319", "bodyText": "q-in-q will be covered in next patch", "author": "rozdy", "createdAt": "2020-11-05T19:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MjM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "927a0619b479d74187ae6bca84c9ad28604489ea", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\nindex 5ca0471ba..8fe833277 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n\n@@ -120,7 +120,7 @@ public class SimpleSwitchRuleConverter {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n \n-            if (flow.getLoopSwitchId() == flowPath.getSrcSwitch().getSwitchId()) {\n+            if (flowPath.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId()) && !flowPath.isProtected()) {\n                 rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2Mjg5OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516062898", "bodyText": "same issue with naming :(", "author": "surabujin", "createdAt": "2020-11-02T15:44:38Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -182,8 +206,23 @@ private SimpleSwitchRule buildEgressSimpleSwitchRule(Flow flow, FlowPath flowPat\n             rule.setTunnelId(encapsulationId.getEncapsulationId());\n             rule.setOutVlan(calcVlanSetSequence(Collections.emptyList(), endpoint.getVlanStack()));\n         }\n+        if (flow.getLoopSwitchId() == endpoint.getSwitchId()) {\n+            rules.add(buildTransitLoopSimpleSwitchRule(rule, flowPath));", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTYzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295639", "bodyText": "I have changed naming. Is it better from your perspective?", "author": "rozdy", "createdAt": "2020-11-05T19:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2Mjg5OA=="}], "type": "inlineReview", "revised_code": {"commit": "927a0619b479d74187ae6bca84c9ad28604489ea", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\nindex 5ca0471ba..8fe833277 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n\n@@ -206,15 +206,15 @@ public class SimpleSwitchRuleConverter {\n             rule.setTunnelId(encapsulationId.getEncapsulationId());\n             rule.setOutVlan(calcVlanSetSequence(Collections.emptyList(), endpoint.getVlanStack()));\n         }\n-        if (flow.getLoopSwitchId() == endpoint.getSwitchId()) {\n-            rules.add(buildTransitLoopSimpleSwitchRule(rule, flowPath));\n+        if (endpoint.getSwitchId().equals(flow.getLoopSwitchId()) && !flowPath.isProtected()) {\n+            rules.add(buildTransitLoopRuleForEgressSwitch(rule, flowPath));\n         }\n \n         rules.add(rule);\n         return rules;\n     }\n \n-    private SimpleSwitchRule buildTransitLoopSimpleSwitchRule(SimpleSwitchRule rule, FlowPath flowPath) {\n+    private SimpleSwitchRule buildTransitLoopRuleForEgressSwitch(SimpleSwitchRule rule, FlowPath flowPath) {\n         return SimpleSwitchRule.builder()\n                 .switchId(rule.getSwitchId())\n                 .cookie(flowPath.getCookie().toBuilder().looped(true).build().getValue())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MzUyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516083529", "bodyText": "... why?", "author": "surabujin", "createdAt": "2020-11-02T16:13:05Z", "path": "src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java", "diffHunk": "@@ -48,6 +49,10 @@\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n+    @EqualsAndHashCode.Exclude", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTc0OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295748", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-11-05T19:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MzUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "927a0619b479d74187ae6bca84c9ad28604489ea", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java b/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\nindex 3c931e3fa..5bdb579b9 100644\n--- a/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\n+++ b/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\n\n@@ -49,7 +49,7 @@ public class FlowResponsePayload extends FlowPayload {\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n-    @EqualsAndHashCode.Exclude\n+    //@EqualsAndHashCode.Exclude\n     @JsonProperty(\"loop-switch-id\")\n     private SwitchId loopSwitchId;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4OTMxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516089315", "bodyText": "You loose looped flag in .toBuilder().build() cycle. Also you need getter for it.", "author": "surabujin", "createdAt": "2020-11-02T16:21:30Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/cookie/FlowSegmentCookie.java", "diffHunk": "@@ -133,7 +136,11 @@ private static long makeValue(CookieType type, FlowPathDirection direction, long\n         if (direction != null) {\n             value = makeValueDirection(direction);\n         }\n-        return setField(value, FLOW_EFFECTIVE_ID_FIELD, flowEffectiveId);\n+        long result = setField(value, FLOW_EFFECTIVE_ID_FIELD, flowEffectiveId);\n+        if (looped) {", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTg2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295860", "bodyText": "added", "author": "rozdy", "createdAt": "2020-11-05T19:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4OTMxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MTI2NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516091264", "bodyText": "other properties are named via underscores.", "author": "surabujin", "createdAt": "2020-11-02T16:24:16Z", "path": "src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java", "diffHunk": "@@ -73,6 +73,7 @@\n     public static final String DST_LLDP_PROPERTY = \"detect_dst_lldp_connected_devices\";\n     public static final String SRC_ARP_PROPERTY = \"detect_src_arp_connected_devices\";\n     public static final String DST_ARP_PROPERTY = \"detect_dst_arp_connected_devices\";\n+    public static final String LOOP_SWITCH_ID_PROPERTY = \"loopSwitchId\";", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTk0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295946", "bodyText": "changed", "author": "rozdy", "createdAt": "2020-11-05T19:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MTI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "927a0619b479d74187ae6bca84c9ad28604489ea", "chunk": "diff --git a/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java b/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java\nindex 04e002c3d..05068f2ef 100644\n--- a/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java\n+++ b/src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java\n\n@@ -73,7 +73,7 @@ public abstract class FlowFrame extends KildaBaseVertexFrame implements FlowData\n     public static final String DST_LLDP_PROPERTY = \"detect_dst_lldp_connected_devices\";\n     public static final String SRC_ARP_PROPERTY = \"detect_src_arp_connected_devices\";\n     public static final String DST_ARP_PROPERTY = \"detect_dst_arp_connected_devices\";\n-    public static final String LOOP_SWITCH_ID_PROPERTY = \"loopSwitchId\";\n+    public static final String LOOP_SWITCH_ID_PROPERTY = \"loop_switch_id\";\n \n     private Switch srcSwitch;\n     private Switch destSwitch;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mjg0OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516092848", "bodyText": "Are we going to have more than 1 loop per flow?", "author": "surabujin", "createdAt": "2020-11-02T16:26:22Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -158,6 +160,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loops\")\n+    @ResponseStatus(HttpStatus.OK)\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(\n+            @RequestParam(value = \"flow_id\", required = false) String flowId,\n+            @RequestParam(value = \"switch_id\", required = false) String switchId) {\n+        return flowService.getFlowLoops(flowId, switchId);\n+    }\n+\n+    /**\n+     * Create flow loop.\n+     *\n+     * @param flowId flow id\n+     * @param flowLoopPayload parameters for flow loop\n+     * @return created flow loop\n+     */\n+    @ApiOperation(value = \"Create flow loop\", response = FlowLoopResponse.class)\n+    @PostMapping(value = \"/{flow_id}/loops\")", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NjM3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518296375", "bodyText": "No, just a naming convention. We have plural forms everywhere.", "author": "rozdy", "createdAt": "2020-11-05T19:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mjg0OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "927a0619b479d74187ae6bca84c9ad28604489ea", "url": "https://github.com/telstra/open-kilda/commit/927a0619b479d74187ae6bca84c9ad28604489ea", "message": "Flow loop feature implementation", "committedDate": "2020-11-05T18:58:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MTU5MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518591590", "bodyText": "Other loop requests do not verify multitable flag, why this one needs it?", "author": "surabujin", "createdAt": "2020-11-06T08:25:20Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,7 +293,76 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n-    private FlowSegmentRequestFactory makeTransitRequest(\n+    private boolean ingressLoopRuleRequired(Flow flow, FlowSideAdapter flowSideAdapter, boolean isProtected) {\n+        return flow.isLooped() && flowSideAdapter.getEndpoint().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !isProtected;\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(\n+            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n+            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egress) {\n+        PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n+\n+        UUID commandId = commandIdGenerator.generate();\n+        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n+        Cookie cookie = path.getCookie().toBuilder().looped(true).build();\n+\n+        return IngressFlowLoopSegmentRequestFactory.builder()\n+                .messageContext(messageContext)\n+                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyOTgwNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519929806", "bodyText": "Removed vefification", "author": "rozdy", "createdAt": "2020-11-09T16:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MTU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\nindex c468a89d7..a55028996 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n\n@@ -309,12 +309,7 @@ public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n \n         return IngressFlowLoopSegmentRequestFactory.builder()\n                 .messageContext(messageContext)\n-                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n-                        flowSide.isMultiTableSegment(), segmentSide.isMultiTable(),\n-                        String.format(\"First flow(id:%s, path:%s) segment and flow level multi-table flag values are \"\n-                                              + \"incompatible to each other - flow(%s) != segment(%s)\",\n-                                      path.getFlow().getFlowId(), path.getPathId(),\n-                                      flowSide.isMultiTableSegment(), segmentSide.isMultiTable()))))\n+                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, segmentSide.isMultiTable()))\n                 .endpoint(flowSide.getEndpoint())\n                 .egressSwitchId(egress.getEndpoint().getSwitchId())\n                 .islPort(segmentSide.getEndpoint().getPortNumber())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5NzA2NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518597065", "bodyText": "If I were you I will put such check/condition into FlowSideAdapter.", "author": "surabujin", "createdAt": "2020-11-06T08:36:13Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -98,6 +99,10 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             FlowEndpoint egressEndpoint = FlowSideAdapter.makeEgressAdapter(flow, flowPath).getEndpoint();\n             rule.setOutPort(outPort);\n             rule.setOutVlan(calcVlanSetSequence(ingress, egressEndpoint.getVlanStack()));\n+\n+            if (flow.getSrcSwitchId().equals(flow.getLoopSwitchId())) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyOTk3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519929971", "bodyText": "done", "author": "rozdy", "createdAt": "2020-11-09T16:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5NzA2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\nindex 8fe833277..f1c660030 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n\n@@ -100,7 +100,7 @@ public class SimpleSwitchRuleConverter {\n             rule.setOutPort(outPort);\n             rule.setOutVlan(calcVlanSetSequence(ingress, egressEndpoint.getVlanStack()));\n \n-            if (flow.getSrcSwitchId().equals(flow.getLoopSwitchId())) {\n+            if (ingress.isLooped()) {\n                 rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n             }\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5ODI5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518598292", "bodyText": "em???", "author": "surabujin", "createdAt": "2020-11-06T08:38:48Z", "path": "src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java", "diffHunk": "@@ -48,6 +49,10 @@\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n+    //@EqualsAndHashCode.Exclude", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDE4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519930185", "bodyText": "fixed", "author": "rozdy", "createdAt": "2020-11-09T16:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5ODI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java b/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\nindex 5bdb579b9..4942d902e 100644\n--- a/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\n+++ b/src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java\n\n@@ -49,7 +49,6 @@ public class FlowResponsePayload extends FlowPayload {\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n-    //@EqualsAndHashCode.Exclude\n     @JsonProperty(\"loop-switch-id\")\n     private SwitchId loopSwitchId;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYwOTAwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518609009", "bodyText": "Can/should we check that the loop switch is already null and do nothing in this case? (same for create request, but in case of an equality of the loop switches)", "author": "surabujin", "createdAt": "2020-11-06T08:58:50Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowUpdateService.java", "diffHunk": "@@ -147,6 +133,78 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    /**\n+     * Handles create flow loop request.\n+     *\n+     * @param request request to handle.\n+     */\n+    public void handleCreateFlowLoopRequest(String key, CommandContext commandContext,\n+                                            CreateFlowLoopRequest request) {\n+        Optional<Flow> flow = flowRepository.findById(request.getFlowId());\n+        if (flow.isPresent()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(flow.get());\n+            flowRequest.setLoopSwitchId(request.getSwitchId());\n+            handleRequest(key, commandContext, flowRequest);\n+        } else {\n+            carrier.sendNorthboundResponse(buildFlowNotFoundErrorMessage(request.getFlowId(), commandContext));\n+        }\n+    }\n+\n+    /**\n+     * Handles delete flow loop request.\n+     *\n+     * @param request request to handle.\n+     */\n+    public void handleDeleteFlowLoopRequest(String key, CommandContext commandContext,\n+                                            DeleteFlowLoopRequest request) {\n+        Optional<Flow> flow = flowRepository.findById(request.getFlowId());\n+        if (flow.isPresent()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(flow.get());\n+            flowRequest.setLoopSwitchId(null);", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDUzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519930535", "bodyText": "This checks already in FSM code", "author": "rozdy", "createdAt": "2020-11-09T16:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYwOTAwOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDI2NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518610265", "bodyText": "Move it into some method. And you can make this check flow side/endpoint, not for whole flow. Just extend EndpointDescriptor with the required data.", "author": "surabujin", "createdAt": "2020-11-06T09:01:02Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java", "diffHunk": "@@ -94,6 +94,41 @@ public void validate(RequestedFlow flow, Set<String> bulkUpdateFlowIds)\n         }\n     }\n \n+    /**\n+     * Validates the specified flow.\n+     *\n+     * @param flow current flow state.\n+     * @param requestedFlow a flow to be validated.\n+     * @param bulkUpdateFlowIds flows to be ignored when check endpoints.\n+     * @throws InvalidFlowException is thrown if a violation is found.\n+     */\n+    public void validate(Flow flow, RequestedFlow requestedFlow, Set<String> bulkUpdateFlowIds)\n+            throws InvalidFlowException, UnavailableFlowEndpointException {\n+        validate(requestedFlow, bulkUpdateFlowIds);\n+        if (requestedFlow.getLoopSwitchId() != null) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjAxMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519932010", "bodyText": "Moved to method. I don't think EndpointDescriptor is useful here.", "author": "rozdy", "createdAt": "2020-11-09T16:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\nindex deb483887..eb25ba80f 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\n\n@@ -105,6 +105,10 @@ public class FlowValidator {\n     public void validate(Flow flow, RequestedFlow requestedFlow, Set<String> bulkUpdateFlowIds)\n             throws InvalidFlowException, UnavailableFlowEndpointException {\n         validate(requestedFlow, bulkUpdateFlowIds);\n+        validateFlowLoop(flow, requestedFlow);\n+    }\n+\n+    private void validateFlowLoop(Flow flow, RequestedFlow requestedFlow) throws InvalidFlowException {\n         if (requestedFlow.getLoopSwitchId() != null) {\n             //todo: fix loops for q-in-q and singe switch loops\n             if (requestedFlow.getSrcInnerVlan() != 0 || requestedFlow.getDestInnerVlan() != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDYwOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518610608", "bodyText": "em?..", "author": "surabujin", "createdAt": "2020-11-06T09:01:40Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java", "diffHunk": "@@ -352,7 +392,7 @@ private void checkForMultiTableRequirement(EndpointDescriptor descriptor) throws\n         SwitchProperties switchProperties = switchPropertiesRepository.findBySwitchId(\n                 endpoint.getSwitchId())\n                 .orElseGet(() -> SwitchProperties.builder().build());\n-        if (! switchProperties.isMultiTable()) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjIwMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519932200", "bodyText": "Autoformat. Fixed back.", "author": "rozdy", "createdAt": "2020-11-09T16:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\nindex deb483887..eb25ba80f 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java\n\n@@ -392,7 +402,7 @@ public class FlowValidator {\n         SwitchProperties switchProperties = switchPropertiesRepository.findBySwitchId(\n                 endpoint.getSwitchId())\n                 .orElseGet(() -> SwitchProperties.builder().build());\n-        if (!switchProperties.isMultiTable()) {\n+        if (! switchProperties.isMultiTable()) {\n             final String errorMessage = format(\n                     \"Flow's %s endpoint is double VLAN tagged, switch %s is not capable to support such endpoint \"\n                             + \"encapsulation.\",\n"}}, {"oid": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "url": "https://github.com/telstra/open-kilda/commit/93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "message": "Flow loop feature implementation", "committedDate": "2020-11-09T16:05:58Z", "type": "forcePushed"}, {"oid": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "url": "https://github.com/telstra/open-kilda/commit/b1c7a3c40fd889aee68ae336cf09b7d274e88914", "message": "Flow loop feature implementation", "committedDate": "2020-11-09T18:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3MjU0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520372546", "bodyText": "We are making the same rule for single-switch and for multi-switch flows is it expected behavior?", "author": "surabujin", "createdAt": "2020-11-10T08:24:46Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (ingress.isLooped() && !flowPath.isProtected()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5Njc1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520796752", "bodyText": "Ingress loop rule is dependent only on input port and vlan stack so it's the same for single-switch and multi-switch flows.", "author": "rozdy", "createdAt": "2020-11-10T18:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3MjU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\nindex f1c660030..c13650caf 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n\n@@ -119,26 +116,27 @@ public class SimpleSwitchRuleConverter {\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n-\n-            if (ingress.isLooped() && !flowPath.isProtected()) {\n-                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n-            }\n         }\n         rules.add(rule);\n+        if (ingress.isLooped() && !flowPath.isProtected()) {\n+            rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+        }\n \n         return rules;\n     }\n \n     private SimpleSwitchRule buildIngressLoopSimpleSwitchRule(SimpleSwitchRule rule, FlowPath flowPath,\n                                                               FlowSideAdapter ingress) {\n-        return SimpleSwitchRule.builder()\n+        SimpleSwitchRuleBuilder builder = SimpleSwitchRule.builder()\n                 .switchId(rule.getSwitchId())\n                 .cookie(flowPath.getCookie().toBuilder().looped(true).build().getValue())\n                 .inPort(rule.getInPort())\n                 .inVlan(rule.getInVlan())\n-                .outPort(rule.getInPort())\n-                .outVlan(ingress.getEndpoint().getVlanStack())\n-                .build();\n+                .outPort(rule.getInPort());\n+        if (ingress.getEndpoint().getInnerVlanId() != 0) {\n+            builder.outVlan(Collections.singletonList(ingress.getEndpoint().getOuterVlanId()));\n+        }\n+        return builder.build();\n     }\n \n     private List<SimpleSwitchRule> buildTransitAndEgressSimpleSwitchRules(Flow flow, FlowPath flowPath,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3NTQyMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520375422", "bodyText": "Here you have a direct and indirect fill of rules. I would like to not mix these approaches, it makes it difficult to understand from reading in one glance.", "author": "surabujin", "createdAt": "2020-11-10T08:29:32Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (ingress.isLooped() && !flowPath.isProtected()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+            }\n         }\n+        rules.add(rule);", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NjkyMw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520796923", "bodyText": "Fixed.", "author": "rozdy", "createdAt": "2020-11-10T18:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3NTQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\nindex f1c660030..c13650caf 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java\n\n@@ -119,26 +116,27 @@ public class SimpleSwitchRuleConverter {\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n-\n-            if (ingress.isLooped() && !flowPath.isProtected()) {\n-                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n-            }\n         }\n         rules.add(rule);\n+        if (ingress.isLooped() && !flowPath.isProtected()) {\n+            rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+        }\n \n         return rules;\n     }\n \n     private SimpleSwitchRule buildIngressLoopSimpleSwitchRule(SimpleSwitchRule rule, FlowPath flowPath,\n                                                               FlowSideAdapter ingress) {\n-        return SimpleSwitchRule.builder()\n+        SimpleSwitchRuleBuilder builder = SimpleSwitchRule.builder()\n                 .switchId(rule.getSwitchId())\n                 .cookie(flowPath.getCookie().toBuilder().looped(true).build().getValue())\n                 .inPort(rule.getInPort())\n                 .inVlan(rule.getInVlan())\n-                .outPort(rule.getInPort())\n-                .outVlan(ingress.getEndpoint().getVlanStack())\n-                .build();\n+                .outPort(rule.getInPort());\n+        if (ingress.getEndpoint().getInnerVlanId() != 0) {\n+            builder.outVlan(Collections.singletonList(ingress.getEndpoint().getOuterVlanId()));\n+        }\n+        return builder.build();\n     }\n \n     private List<SimpleSwitchRule> buildTransitAndEgressSimpleSwitchRules(Flow flow, FlowPath flowPath,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjA4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520386089", "bodyText": "em... why for?", "author": "surabujin", "createdAt": "2020-11-10T08:46:51Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command.flow;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static org.openkilda.messaging.Utils.FLOW_ID;\n+import static org.openkilda.messaging.Utils.TRANSACTION_ID;\n+\n+import org.openkilda.model.FlowEncapsulationType;\n+import org.openkilda.model.FlowEndpoint;\n+import org.openkilda.model.OutputVlanType;\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Class represents egress flow installation info.\n+ * Transit vlan id is used in matching.\n+ * Output action depends on flow input and output vlan presence, but should at least contain transit vlan stripping.\n+ * Output vlan id is optional, because flow could be untagged on outgoing side.\n+ */\n+@JsonSerialize\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder(value = {", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NzAzMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520797030", "bodyText": "Removed.", "author": "rozdy", "createdAt": "2020-11-10T18:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "chunk": "diff --git a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java\nindex 69ab45966..db17b4417 100644\n--- a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java\n+++ b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java\n\n@@ -27,7 +27,6 @@ import org.openkilda.model.SwitchId;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n import java.util.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjQyMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520386422", "bodyText": "same here", "author": "surabujin", "createdAt": "2020-11-10T08:47:22Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command.flow;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static org.openkilda.messaging.Utils.FLOW_ID;\n+import static org.openkilda.messaging.Utils.TRANSACTION_ID;\n+\n+import org.openkilda.model.FlowEncapsulationType;\n+import org.openkilda.model.FlowEndpoint;\n+import org.openkilda.model.OutputVlanType;\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Class represents egress flow installation info.\n+ * Transit vlan id is used in matching.\n+ * Output action depends on flow input and output vlan presence, but should at least contain transit vlan stripping.\n+ * Output vlan id is optional, because flow could be untagged on outgoing side.\n+ */\n+@JsonSerialize\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder(value = {", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NzE4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520797189", "bodyText": "Removed.", "author": "rozdy", "createdAt": "2020-11-10T18:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "chunk": "diff --git a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java\nindex 7db237100..5ce86e06f 100644\n--- a/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java\n+++ b/src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java\n\n@@ -27,7 +27,6 @@ import org.openkilda.model.SwitchId;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n import java.util.Objects;\n"}}, {"oid": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "url": "https://github.com/telstra/open-kilda/commit/24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "message": "Flow loop feature implementation", "committedDate": "2020-11-10T18:50:23Z", "type": "forcePushed"}, {"oid": "4c1e12811fc2702d37ab12147d00be869883c3c3", "url": "https://github.com/telstra/open-kilda/commit/4c1e12811fc2702d37ab12147d00be869883c3c3", "message": "Flow loop feature implementation", "committedDate": "2020-11-11T20:27:54Z", "type": "forcePushed"}, {"oid": "c8749d82814eb9920cdc0caf7cba65595eebb324", "url": "https://github.com/telstra/open-kilda/commit/c8749d82814eb9920cdc0caf7cba65595eebb324", "message": "Flow loop feature implementation", "committedDate": "2020-11-12T09:14:07Z", "type": "forcePushed"}, {"oid": "a62ec8fc0532698c3afa7547f74963475562a2eb", "url": "https://github.com/telstra/open-kilda/commit/a62ec8fc0532698c3afa7547f74963475562a2eb", "message": "Flow loop feature implementation", "committedDate": "2020-11-12T17:18:39Z", "type": "forcePushed"}, {"oid": "5a5439563627f529fa034c5fb875ecac912c30e7", "url": "https://github.com/telstra/open-kilda/commit/5a5439563627f529fa034c5fb875ecac912c30e7", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T09:23:56Z", "type": "forcePushed"}, {"oid": "8051d5cb778ef38261553c630aca8b74040473ef", "url": "https://github.com/telstra/open-kilda/commit/8051d5cb778ef38261553c630aca8b74040473ef", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T10:18:10Z", "type": "commit"}, {"oid": "8051d5cb778ef38261553c630aca8b74040473ef", "url": "https://github.com/telstra/open-kilda/commit/8051d5cb778ef38261553c630aca8b74040473ef", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T10:18:10Z", "type": "forcePushed"}]}