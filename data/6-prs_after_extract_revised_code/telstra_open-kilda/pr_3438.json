{"pr_number": 3438, "pr_title": "Introducing flow with 2 levels of VLAN tagging on endpoints", "pr_createdAt": "2020-05-04T14:08:36Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3438", "timeline": [{"oid": "f498b0b508404ebd55aac7ba17db99642e2940e0", "url": "https://github.com/telstra/open-kilda/commit/f498b0b508404ebd55aac7ba17db99642e2940e0", "message": "Introducing flow with 2 levels of VLAN tagging on endpoints\n\nThis change adds the ability to use 2 levels of VLAN tags on flow\nendpoints.  I.e. you can define 2 (outer and inner) VLAN tags for each\nflow endpoint.\n\nFlow's endpoints (source and dest) encoding are independent, so it can\nbe defined as \"default port\" (no VLAN tags), as VLAN tagged and as QinQ\nor double VLAN tagged for each end of the flow.\n\nOF spec allow to the switch to reject flows that manipulate with\npossible missing ethernet packet's field. If the OF flow's action list\ncontains pop VLAN tag(for example) action it must have VLAN tag match in\nit's match field (see section 7.2.6 Action Structures OF specification\nv1.5.1 for more details). As a result we can't do the flow's endpoint\nencapsulation on egress switch as before, we need to unwrap ingress\nendpoint encapsulation on egress switch and apply/wrap egress\nencapsulation on egress switch.\n\nSo ingress switch will drop all(except last in case of transit-VLAN\nencapsulation) VLAN tags from ethernet packet, wrap it into transit\nencapsulation and on egress switch transit encapsulation will be\nunwrapped and corresponding egress endpoint VLAN tags are added.", "committedDate": "2020-05-04T14:29:47Z", "type": "forcePushed"}, {"oid": "3440e2b177df0fc07f345b7ac74b2bc8f1b067ad", "url": "https://github.com/telstra/open-kilda/commit/3440e2b177df0fc07f345b7ac74b2bc8f1b067ad", "message": "Introducing flow with 2 levels of VLAN tagging on endpoints\n\nThis change adds the ability to use 2 levels of VLAN tags on flow\nendpoints.  I.e. you can define 2 (outer and inner) VLAN tags for each\nflow endpoint.\n\nFlow's endpoints (source and dest) encoding are independent, so it can\nbe defined as \"default port\" (no VLAN tags), as VLAN tagged and as QinQ\nor double VLAN tagged for each end of the flow.\n\nOF spec allow to the switch to reject flows that manipulate with\npossible missing ethernet packet's field. If the OF flow's action list\ncontains pop VLAN tag(for example) action it must have VLAN tag match in\nit's match field (see section 7.2.6 Action Structures OF specification\nv1.5.1 for more details). As a result we can't do the flow's endpoint\nencapsulation on egress switch as before, we need to unwrap ingress\nendpoint encapsulation on egress switch and apply/wrap egress\nencapsulation on egress switch.\n\nSo ingress switch will drop all(except last in case of transit-VLAN\nencapsulation) VLAN tags from ethernet packet, wrap it into transit\nencapsulation and on egress switch transit encapsulation will be\nunwrapped and corresponding egress endpoint VLAN tags are added.", "committedDate": "2020-05-04T14:59:30Z", "type": "forcePushed"}, {"oid": "baf37477d4a4439671f69d0b4a0effa80c8ea93e", "url": "https://github.com/telstra/open-kilda/commit/baf37477d4a4439671f69d0b4a0effa80c8ea93e", "message": "Introducing flow with 2 levels of VLAN tagging on endpoints\n\nThis change adds the ability to use 2 levels of VLAN tags on flow\nendpoints.  I.e. you can define 2 (outer and inner) VLAN tags for each\nflow endpoint.\n\nFlow's endpoints (source and dest) encoding are independent, so it can\nbe defined as \"default port\" (no VLAN tags), as VLAN tagged and as QinQ\nor double VLAN tagged for each end of the flow.\n\nOF spec allow to the switch to reject flows that manipulate with\npossible missing ethernet packet's field. If the OF flow's action list\ncontains pop VLAN tag(for example) action it must have VLAN tag match in\nit's match field (see section 7.2.6 Action Structures OF specification\nv1.5.1 for more details). As a result we can't do the flow's endpoint\nencapsulation on egress switch as before, we need to unwrap ingress\nendpoint encapsulation on egress switch and apply/wrap egress\nencapsulation on egress switch.\n\nSo ingress switch will drop all(except last in case of transit-VLAN\nencapsulation) VLAN tags from ethernet packet, wrap it into transit\nencapsulation and on egress switch transit encapsulation will be\nunwrapped and corresponding egress endpoint VLAN tags are added.", "committedDate": "2020-05-05T10:54:09Z", "type": "forcePushed"}, {"oid": "6cba45390f4cb23b57fcce2b47e7620236093b27", "url": "https://github.com/telstra/open-kilda/commit/6cba45390f4cb23b57fcce2b47e7620236093b27", "message": "(wip)", "committedDate": "2020-05-07T20:48:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwNjk2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r422106962", "bodyText": "this constant is unused", "author": "niksv", "createdAt": "2020-05-08T12:09:01Z", "path": "src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java", "diffHunk": "@@ -83,12 +83,15 @@\n             75, FlowEncapsulationType.VXLAN);\n \n     protected static final FlowEndpoint endpointEgressZeroVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 11, 0);\n-    protected static final FlowEndpoint endpointEgressOneVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressSingleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n+    protected static final FlowEndpoint endpointEgressDoubleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 13, 70, 71);", "originalCommit": "6cba45390f4cb23b57fcce2b47e7620236093b27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk0OTI3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424949276", "bodyText": "Removed.", "author": "surabujin", "createdAt": "2020-05-14T08:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwNjk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java b/src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java\nindex e59da7050..fbd4e1627 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/test/java/org/openkilda/floodlight/command/AbstractSpeakerCommandTest.java\n\n@@ -84,7 +84,6 @@ public abstract class AbstractSpeakerCommandTest extends EasyMockSupport {\n \n     protected static final FlowEndpoint endpointEgressZeroVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 11, 0);\n     protected static final FlowEndpoint endpointEgressSingleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 12, 60);\n-    protected static final FlowEndpoint endpointEgressDoubleVlan = new FlowEndpoint(mapSwitchId(dpIdNext), 13, 70, 71);\n \n     protected static final FlowEndpoint endpointIngressZeroVlan = new FlowEndpoint(\n             mapSwitchId(dpId), 21, 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjExODUyMw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r422118523", "bodyText": "we have method  findByEndpointAndVlan() so you can use it instead of checking outer vlan manually\nI'm not really sure about this break. Example:\nyou have 2 flows: common flow and one switch one port flow.\nflow1 src:  sw = 1, port = 1, outer vlan = 1, inner vlan = 2\nflow2 src:  sw = 1, port = 1, outer vlan = 5, inner vlan = 5\nflow2 dst:  sw = 1, port = 1, outer vlan = 1, inner vlan = 3\n\nneedle will be equal to sw = 1, port = 1, outer vlan = 1\nduring first iteration you will add flow1 to the result\nduring second iteration you will compare needle with flow2 src but flow2.src.outerVlal != needle.outerClan\nthat is why you will break and you wouldn't compare needle with flow2.dst\nExpected result: flow1 and flow2 in result\nActual Result: flow1 in result\n\nI think you should also check src/dstMultiTableFlag for flows, because only flows which are in multiTable mode use shared rule.", "author": "niksv", "createdAt": "2020-05-08T12:37:17Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java", "diffHunk": "@@ -98,6 +104,29 @@ protected FlowPath getFlowPath(PathId pathId) {\n         return new HashSet<>(flowRepository.findFlowsIdsByEndpointWithMultiTableSupport(switchId, port));\n     }\n \n+    protected List<Flow> findOuterVlanMatchSharedRuleUsage(FlowEndpoint needle) {\n+        if (! FlowEndpoint.isVlanIdSet(needle.getOuterVlanId())) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<Flow> results = new ArrayList<>();\n+        for (Flow entry : flowRepository.findByEndpoint(needle.getSwitchId(), needle.getPortNumber())) {\n+            for (FlowSideAdapter flowSide : new FlowSideAdapter[] {\n+                    new FlowSourceAdapter(entry),\n+                    new FlowDestAdapter(entry)}) {\n+                FlowEndpoint endpoint = flowSide.getEndpoint();\n+                if (needle.isSwitchPortEquals(endpoint)) {\n+                    if (needle.getOuterVlanId() == endpoint.getOuterVlanId()) {\n+                        results.add(entry);\n+                    }\n+                    break;", "originalCommit": "6cba45390f4cb23b57fcce2b47e7620236093b27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NTU2Mw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424955563", "bodyText": "1 - findByEndpointAndVlan return only 1 flow (this is incorrect from what this method should do/return.\n2 - fixed.\n3 - fixed.", "author": "surabujin", "createdAt": "2020-05-14T08:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjExODUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java\nindex 9d081aa63..703446cd9 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/FlowProcessingAction.java\n\n@@ -115,15 +115,14 @@ public abstract class FlowProcessingAction<T extends FlowProcessingFsm<T, S, E,\n                     new FlowSourceAdapter(entry),\n                     new FlowDestAdapter(entry)}) {\n                 FlowEndpoint endpoint = flowSide.getEndpoint();\n-                if (needle.isSwitchPortEquals(endpoint)) {\n+                if (needle.isSwitchPortEquals(endpoint) && flowSide.isMultiTableSegment()) {\n                     if (needle.getOuterVlanId() == endpoint.getOuterVlanId()) {\n                         results.add(entry);\n+                        break;\n                     }\n-                    break;\n                 }\n             }\n         }\n-\n         return results;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDAwNg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423534006", "bodyText": "filter is a bad naming. It should be something like switchRules, expectedRules, rulesToBeInstalled, etc\nfilter is to general", "author": "niksv", "createdAt": "2020-05-12T07:54:36Z", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {", "originalCommit": "fddff585c5eca08f2c07cbd9447b5a4b79062756", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MjI2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424962267", "bodyText": "renamed", "author": "surabujin", "createdAt": "2020-05-14T08:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\nindex 0312341c9..f109845b9 100644\n--- a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\n+++ b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\n\n@@ -195,16 +195,16 @@ public class CommandBuilderImpl implements CommandBuilder {\n         return commands;\n     }\n \n-    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {\n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> switchRules) {\n         List<BaseFlow> results = new ArrayList<>();\n-        for (long entry : filter) {\n-            FlowSharedSegmentCookie cookie = new FlowSharedSegmentCookie(entry);\n+        for (long rawCookie : switchRules) {\n+            FlowSharedSegmentCookie cookie = new FlowSharedSegmentCookie(rawCookie);\n             if (cookie.getType() != CookieType.SHARED_OF_FLOW) {\n                 continue;\n             }\n \n             results.add(new InstallSharedFlow(\n-                    transactionIdGenerator.generate(), \"SWMANAGER_SHARED_FLOW_INSTALL\", entry, switchId));\n+                    transactionIdGenerator.generate(), \"SWMANAGER_SHARED_FLOW_INSTALL\", rawCookie, switchId));\n         }\n \n         return results;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDc5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423534792", "bodyText": "entry is a bad naming too. it must be rawCookie ot something connected with cookie", "author": "niksv", "createdAt": "2020-05-12T07:55:49Z", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java", "diffHunk": "@@ -190,6 +195,21 @@ private static boolean isDefaultRuleWithSpecialRequirements(long cookie) {\n         return commands;\n     }\n \n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {\n+        List<BaseFlow> results = new ArrayList<>();\n+        for (long entry : filter) {", "originalCommit": "fddff585c5eca08f2c07cbd9447b5a4b79062756", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2MjYyMw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424962623", "bodyText": "... don't agree. Renamed.", "author": "surabujin", "createdAt": "2020-05-14T08:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\nindex 0312341c9..f109845b9 100644\n--- a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\n+++ b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/CommandBuilderImpl.java\n\n@@ -195,16 +195,16 @@ public class CommandBuilderImpl implements CommandBuilder {\n         return commands;\n     }\n \n-    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> filter) {\n+    private List<BaseFlow> buildInstallFlowSharedRuleCommands(SwitchId switchId, List<Long> switchRules) {\n         List<BaseFlow> results = new ArrayList<>();\n-        for (long entry : filter) {\n-            FlowSharedSegmentCookie cookie = new FlowSharedSegmentCookie(entry);\n+        for (long rawCookie : switchRules) {\n+            FlowSharedSegmentCookie cookie = new FlowSharedSegmentCookie(rawCookie);\n             if (cookie.getType() != CookieType.SHARED_OF_FLOW) {\n                 continue;\n             }\n \n             results.add(new InstallSharedFlow(\n-                    transactionIdGenerator.generate(), \"SWMANAGER_SHARED_FLOW_INSTALL\", entry, switchId));\n+                    transactionIdGenerator.generate(), \"SWMANAGER_SHARED_FLOW_INSTALL\", rawCookie, switchId));\n         }\n \n         return results;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NjIyMA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423546220", "bodyText": "I'm not very sure about naming. Why Egress? here you are checking that flow endpoint is source and path is forward. I thought such paths called ingress", "author": "niksv", "createdAt": "2020-05-12T08:14:52Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSourceAdapter.java", "diffHunk": "@@ -37,4 +40,9 @@ public FlowEndpoint getEndpoint() {\n     public boolean isMultiTableSegment() {\n         return flow.isSrcWithMultiTable();\n     }\n+\n+    @Override\n+    public boolean isPrimaryEgressPath(@NonNull PathId pathId) {\n+        return pathId.equals(flow.getForwardPathId());", "originalCommit": "fddff585c5eca08f2c07cbd9447b5a4b79062756", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2NjU0NA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424966544", "bodyText": "This path goes from source to dest i.e. it is forward path. So from the \"source\" flow side view, it is egress path, because it starts at the \"source\" side and goes somewhere else (in our case to the dest side of the flow).\nWhy it must be \"ingress\"?", "author": "surabujin", "createdAt": "2020-05-14T08:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NjIyMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0OTAxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423549011", "bodyText": "You must check that flow is in multiTable mode.\nScenario:\n\nset multiTable = false on switches\ncreate flow with one vlan\nvalidate src/dst switch\n\nExpected Result:\nno missing rules.\nActual Result:\nmissing shared rule", "author": "niksv", "createdAt": "2020-05-12T08:19:19Z", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +182,41 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (switchId.equals(endpoint.getSwitchId())\n+                    && FlowEndpoint.isVlanIdSet(endpoint.getOuterVlanId())\n+                    && ingress.isPrimaryEgressPath(path.getPathId())) {\n+                result.add(FlowSharedSegmentCookie.builder(SharedSegmentType.QINQ_OUTER_VLAN)", "originalCommit": "fddff585c5eca08f2c07cbd9447b5a4b79062756", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3NTA0MQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424975041", "bodyText": "fixed", "author": "surabujin", "createdAt": "2020-05-14T08:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0OTAxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\nindex b6369a30b..9f8042201 100644\n--- a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\n+++ b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\n\n@@ -192,6 +196,8 @@ public class ValidationServiceImpl implements ValidationService {\n                 .map(Cookie::getValue)\n                 .forEach(result::add);\n \n+        boolean isMultiTableMode = isSwitchInMultiTableMode(switchId);\n+\n         // collect termination segments\n         for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n             Flow flow = path.getFlow();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcwNDYzNA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r423704634", "bodyText": "Here must be Ingress table.\nThere is a problem with priorities.\nCurrent priorities:\nDouble tag 0\nSingle tag -10\nDefault Port -1\n\nIt means that Default Port will catch all single tag traffic\nDefault port priority must be changed.", "author": "niksv", "createdAt": "2020-05-12T12:47:47Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "diffHunk": "@@ -72,28 +78,83 @@ public IngressFlowModFactory(\n     /**\n      * Make rule to match traffic by port+vlan and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeOuterVlanOnlyForwardMessage(MeterId effectiveMeterId) {\n+    public OFFlowMod makeOuterOnlyVlanForwardMessage(MeterId effectiveMeterId) {\n         FlowEndpoint endpoint = command.getEndpoint();\n         OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n-                .setCookie(U64.of(command.getCookie().getValue()))\n                 .setMatch(OfAdapter.INSTANCE.matchVlanId(of, of.buildMatch(), endpoint.getOuterVlanId())\n-                                  .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n-                                  .build());\n-        return makeForwardMessage(of, builder, effectiveMeterId);\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, endpoint.getVlanStack());\n+    }\n+\n+    /**\n+     * Make rule to forward traffic matched by outer VLAN tag and forward in in ISL (or out port in case one-switch\n+     * flow).\n+     */\n+    public OFFlowMod makeSingleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -10)\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n+    }\n+\n+    /**\n+     * Make rule to match inner VLAN tag and forward in in ISL (or out port in case one-switch flow).\n+     */\n+    public OFFlowMod makeDoubleVlanForwardMessage(MeterId effectiveMeterId) {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        RoutingMetadata metadata = RoutingMetadata.builder()\n+                .outerVlanId(endpoint.getOuterVlanId())\n+                .build(switchFeatures);\n+        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n+                .setMatch(of.buildMatch()\n+                        .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n+                        .setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlan(endpoint.getInnerVlanId()))\n+                        .setMasked(MatchField.METADATA,\n+                                OFMetadata.of(metadata.getValue()), OFMetadata.of(metadata.getMask()))\n+                        .build());\n+        return makeForwardMessage(builder, effectiveMeterId, FlowEndpoint.makeVlanStack(endpoint.getInnerVlanId()));\n     }\n \n     /**\n      * Make rule to match whole port traffic and route it into ISL/egress end.\n      */\n-    public OFFlowMod makeDefaultPortFlowMatchAndForwardMessage(MeterId effectiveMeterId) {\n-        // FIXME we need some space between match rules (so it should be -10 instead of -1)\n-        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID),\n-                                                                      -1)\n-                .setCookie(U64.of(command.getCookie().getValue()))\n+    public OFFlowMod makeDefaultPortForwardMessage(MeterId effectiveMeterId) {\n+        // FIXME we need some space between match rules (so priorityOffset should be -10 instead of -1)\n+        OFFlowMod.Builder builder = flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.PRE_INGRESS_TABLE_ID), -1)", "originalCommit": "7bbb89c75492dc74881c5487adf7aee8dff06aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk3NTM3OA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r424975378", "bodyText": "yes - fixed", "author": "surabujin", "createdAt": "2020-05-14T08:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcwNDYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\nindex baddd712e..500000d19 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java\n\n@@ -96,8 +96,7 @@ public abstract class IngressFlowModFactory {\n         RoutingMetadata metadata = RoutingMetadata.builder()\n                 .outerVlanId(endpoint.getOuterVlanId())\n                 .build(switchFeatures);\n-        OFFlowMod.Builder builder = flowModBuilderFactory\n-                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -10)\n+        OFFlowMod.Builder builder = flowModBuilderFactory.makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID))\n                 .setMatch(of.buildMatch()\n                         .setExact(MatchField.IN_PORT, OFPort.of(endpoint.getPortNumber()))\n                         .setMasked(MatchField.METADATA,\n"}}, {"oid": "961dbe176ddf3041fdb3867754d429fc10c15cb1", "url": "https://github.com/telstra/open-kilda/commit/961dbe176ddf3041fdb3867754d429fc10c15cb1", "message": "(wip)", "committedDate": "2020-05-14T10:29:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0MTEzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r425741131", "bodyText": "We must NOT check that switch is in multiTable. We must check that flow endpoint in multi table\nscenario:\n\nswitch is in multiTable\ncreate flow outer vlan 1, inner vlan 0.\nupdate switch props (multiTable=false)\n\nExpected result:\nshared rule still on switch because flow still in multiTableMode\nActualResult:\nshared rules was removed. flow doesn't work", "author": "niksv", "createdAt": "2020-05-15T11:33:29Z", "path": "src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java", "diffHunk": "@@ -191,6 +186,45 @@ public ValidateMetersResult validateMeters(SwitchId switchId, List<MeterEntry> p\n         return comparePresentedAndExpectedMeters(isESwitch, presentMeters, expectedMeters);\n     }\n \n+    private Set<Long> getExpectedFlowRules(SwitchId switchId) {\n+        Set<Long> result = new HashSet<>();\n+\n+        // collect transit segments\n+        flowPathRepository.findBySegmentDestSwitch(switchId).stream()\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getCookie)\n+                .map(Cookie::getValue)\n+                .forEach(result::add);\n+\n+        boolean isMultiTableMode = isSwitchInMultiTableMode(switchId);\n+\n+        // collect termination segments\n+        for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n+            Flow flow = path.getFlow();\n+            if (! flow.isActualPathId(path.getPathId())) {\n+                continue;\n+            }\n+\n+            result.add(path.getCookie().getValue());\n+\n+            // shared outer vlan match rule\n+            FlowSideAdapter ingress = FlowSideAdapter.makeIngressAdapter(flow, path);\n+            FlowEndpoint endpoint = ingress.getEndpoint();\n+            if (isMultiTableMode\n+                    && ingress.isMultiTableSegment()", "originalCommit": "8d48d8b440b9fc9573b6f3253f4c6248b1f5db35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxOTExMw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426419113", "bodyText": "Why this scenario is invalid? After multi-table mode change affected flows must be updated too. Unless this moment they are invalid and must report discrepancies on validation.", "author": "surabujin", "createdAt": "2020-05-18T07:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0MTEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6017369fc753368dc479281c656ab630b8b9a7be", "chunk": "diff --git a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\nindex 9f8042201..c62e5aeaf 100644\n--- a/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\n+++ b/src-java/swmanager-topology/swmanager-storm-topology/src/main/java/org/openkilda/wfm/topology/switchmanager/service/impl/ValidationServiceImpl.java\n\n@@ -196,8 +195,6 @@ public class ValidationServiceImpl implements ValidationService {\n                 .map(Cookie::getValue)\n                 .forEach(result::add);\n \n-        boolean isMultiTableMode = isSwitchInMultiTableMode(switchId);\n-\n         // collect termination segments\n         for (FlowPath path : flowPathRepository.findByEndpointSwitch(switchId)) {\n             Flow flow = path.getFlow();\n"}}, {"oid": "329544d6089870ff55118b5a81c0afb009d0a6a5", "url": "https://github.com/telstra/open-kilda/commit/329544d6089870ff55118b5a81c0afb009d0a6a5", "message": "Introducing flow with 2 levels of VLAN tagging on endpoints\n\nThis change adds the ability to use 2 levels of VLAN tags on flow\nendpoints.  I.e. you can define 2 (outer and inner) VLAN tags for each\nflow endpoint.\n\nFlow's endpoints (source and dest) encoding are independent, so it can\nbe defined as \"default port\" (no VLAN tags), as VLAN tagged and as QinQ\nor double VLAN tagged for each end of the flow.\n\nOF spec allow to the switch to reject flows that manipulate with\npossible missing ethernet packet's field. If the OF flow's action list\ncontains pop VLAN tag(for example) action it must have VLAN tag match in\nit's match field (see section 7.2.6 Action Structures OF specification\nv1.5.1 for more details). As a result we can't do the flow's endpoint\nencapsulation on egress switch as before, we need to unwrap ingress\nendpoint encapsulation on egress switch and apply/wrap egress\nencapsulation on egress switch.\n\nSo ingress switch will drop all(except last in case of transit-VLAN\nencapsulation) VLAN tags from ethernet packet, wrap it into transit\nencapsulation and on egress switch transit encapsulation will be\nunwrapped and corresponding egress endpoint VLAN tags are added.", "committedDate": "2020-05-15T13:57:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTI5MA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426431290", "bodyText": "pleas Update toString() too", "author": "niksv", "createdAt": "2020-05-18T07:50:51Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressFlow.java", "diffHunk": "@@ -336,6 +329,7 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "originalCommit": "be123379d6ba7fb3667a2e5be6f1f23726770448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5NzQ2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426497461", "bodyText": "nice catch ... too used to lombok", "author": "surabujin", "createdAt": "2020-05-18T09:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMTI5MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzI4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426433289", "bodyText": "please update toString() too", "author": "niksv", "createdAt": "2020-05-18T07:54:26Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallOneSwitchFlow.java", "diffHunk": "@@ -330,7 +315,9 @@ public boolean equals(Object object) {\n                 && Objects.equals(getInputPort(), that.getInputPort())\n                 && Objects.equals(getOutputPort(), that.getOutputPort())\n                 && Objects.equals(getInputVlanId(), that.getInputVlanId())\n+                && Objects.equals(getInputInnerVlanId(), that.getInputInnerVlanId())", "originalCommit": "be123379d6ba7fb3667a2e5be6f1f23726770448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5NzU4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426497587", "bodyText": "added", "author": "surabujin", "createdAt": "2020-05-18T09:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzMzI4OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NDkzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426444935", "bodyText": "(nit) As you added @getter to each field you can just add @getter to the class", "author": "niksv", "createdAt": "2020-05-18T08:14:28Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -16,26 +16,38 @@\n package org.openkilda.floodlight.model;\n \n import org.openkilda.floodlight.error.CorruptedNetworkDataException;\n+import org.openkilda.messaging.model.NetworkEndpoint;\n import org.openkilda.messaging.model.Ping;\n import org.openkilda.messaging.model.PingMeters;\n+import org.openkilda.model.FlowEndpoint;\n \n import com.auth0.jwt.JWTCreator;\n import com.auth0.jwt.interfaces.DecodedJWT;\n+import lombok.Getter;\n+import lombok.Setter;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.projectfloodlight.openflow.types.DatapathId;\n \n import java.util.UUID;\n \n public class PingData implements ISignPayload {\n-    private static String JWT_KEY_PREFIX = \"openkilda.ping.\";\n-\n+    @Getter @Setter\n     private long sendTime = 0;\n+    @Getter @Setter\n     private long senderLatency = 0;\n \n-    private final Short sourceVlan;\n+    @Getter\n+    private final int ingressPortNumber;\n+    @Getter\n+    private final int ingressVlanId;\n+    @Getter\n+    private final int ingressInnerVlanId;\n+    @Getter\n     private final DatapathId source;\n+    @Getter\n     private final DatapathId dest;\n+    @Getter", "originalCommit": "097bae993bf85cca48ece853577137f82cb07a84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMDIwMg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426500202", "bodyText": "In this case, I must remove all generic getters, it increases change size, I am not allowed to do it now.", "author": "surabujin", "createdAt": "2020-05-18T09:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NDkzNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTk1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426445952", "bodyText": "key is unused", "author": "niksv", "createdAt": "2020-05-18T08:16:14Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java", "diffHunk": "@@ -168,7 +157,47 @@ public int hashCode() {\n                 .toHashCode();\n     }\n \n+    private static int decodeVlanId(DecodedJWT token, String key) {", "originalCommit": "097bae993bf85cca48ece853577137f82cb07a84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwMjMzNA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426502334", "bodyText": "fixed", "author": "surabujin", "createdAt": "2020-05-18T09:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6017369fc753368dc479281c656ab630b8b9a7be", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java\nindex 29c59857b..83015e5fe 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/model/PingData.java\n\n@@ -158,7 +158,7 @@ public class PingData implements ISignPayload {\n     }\n \n     private static int decodeVlanId(DecodedJWT token, String key) {\n-        Integer vlanId = token.getClaim(makeIngressInnerVlanIdRef()).asInt();\n+        Integer vlanId = token.getClaim(key).asInt();\n         if (vlanId != null) {\n             return vlanId;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426482157", "bodyText": "Can we use new RulesContext() instead of null to do new face with NPE?", "author": "niksv", "createdAt": "2020-05-18T09:14:15Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);", "originalCommit": "097bae993bf85cca48ece853577137f82cb07a84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwNTQ1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426505455", "bodyText": "RulesContext() is used only in *Remove commands and only after null check i.e it is a nullable field by its design.\nAs for me - invalid \"default\" values for a nullable field can make much more damage than null.\nFixed.", "author": "surabujin", "createdAt": "2020-05-18T09:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6017369fc753368dc479281c656ab630b8b9a7be", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\nindex 87862b8de..722f9a63a 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n\n@@ -1792,6 +1819,8 @@ class RecordHandler implements Runnable {\n             command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n         } else if (request instanceof InstallOneSwitchFlow) {\n             command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallEgressFlow) {\n+            command = makeSyncCommand((InstallEgressFlow) request, messageContext, replyTopic);\n         } else {\n             command = null;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426482193", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-18T09:14:18Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -1754,6 +1785,55 @@ private void parseRecord(ConsumerRecord<String, String> record) {\n         }\n     }\n \n+    private Optional<FlowSegmentSyncWrapperCommand> makeSyncCommand(\n+            BaseFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowSegmentSyncWrapperCommand command;\n+        if (request instanceof InstallIngressFlow) {\n+            command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallOneSwitchFlow) {\n+            command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else {\n+            command = null;\n+        }\n+        return Optional.ofNullable(command);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallIngressFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        FlowTransitEncapsulation encapsulation = new FlowTransitEncapsulation(\n+                request.getTransitEncapsulationId(), request.getTransitEncapsulationType());\n+        IngressFlowSegmentInstallCommand command = new IngressFlowSegmentInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig,\n+                request.getEgressSwitchId(), request.getOutputPort(), encapsulation, null);\n+\n+        return new FlowSegmentSyncWrapperCommand(command, replyTopic);\n+    }\n+\n+    private FlowSegmentSyncWrapperCommand makeSyncCommand(\n+            InstallOneSwitchFlow request, MessageContext messageContext, String replyTopic) {\n+        FlowEndpoint endpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getInputPort(), request.getInputVlanId(), request.getInputInnerVlanId(),\n+                request.isEnableLldp(), request.isEnableArp());\n+        FlowEndpoint egressEndpoint = new FlowEndpoint(\n+                request.getSwitchId(), request.getOutputPort(), request.getOutputVlanId(),\n+                request.getOutputInnerVlanId());\n+        MeterConfig meterConfig = new MeterConfig(new MeterId(request.getMeterId()), request.getBandwidth());\n+        OneSwitchFlowInstallCommand command = new OneSwitchFlowInstallCommand(\n+                messageContext, EMPTY_COMMAND_ID, makeSegmentMetadata(request), endpoint, meterConfig, egressEndpoint,\n+                null);", "originalCommit": "097bae993bf85cca48ece853577137f82cb07a84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUwNTY0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426505642", "bodyText": "same :)", "author": "surabujin", "createdAt": "2020-05-18T09:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ4MjE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6017369fc753368dc479281c656ab630b8b9a7be", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\nindex 87862b8de..722f9a63a 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n\n@@ -1792,6 +1819,8 @@ class RecordHandler implements Runnable {\n             command = makeSyncCommand((InstallIngressFlow) request, messageContext, replyTopic);\n         } else if (request instanceof InstallOneSwitchFlow) {\n             command = makeSyncCommand((InstallOneSwitchFlow) request, messageContext, replyTopic);\n+        } else if (request instanceof InstallEgressFlow) {\n+            command = makeSyncCommand((InstallEgressFlow) request, messageContext, replyTopic);\n         } else {\n             command = null;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY0ODkyOA==", "url": "https://github.com/telstra/open-kilda/pull/3438#discussion_r426648928", "bodyText": "should we also map connected devices fields in method\npublic abstract FlowEndpoint mapFlowEndpoint(FlowEndpointV2 input); ?", "author": "niksv", "createdAt": "2020-05-18T14:02:05Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java", "diffHunk": "@@ -149,9 +150,43 @@ public FlowResponseV2 toFlowResponseV2(FlowDto flowDto) {\n     @Mapping(target = \"type\", ignore = true)\n     public abstract FlowRequest toFlowRequest(FlowRequestV2 request);\n \n+    @Mapping(target = \"flowId\", source = \"id\")\n+    @Mapping(target = \"bandwidth\", source = \"maximumBandwidth\")\n+    @Mapping(target = \"transitEncapsulationId\", ignore = true)\n+    @Mapping(target = \"type\", ignore = true)\n+    @Mapping(target = \"detectConnectedDevices\", ignore = true)\n+    public abstract FlowRequest toFlowRequest(FlowCreatePayload request);\n+\n     @Mapping(target = \"outerVlanId\", source = \"vlanId\")\n     public abstract FlowEndpoint mapFlowEndpoint(FlowEndpointV2 input);\n \n+    @Mapping(target = \"switchId\", source = \"datapath\")\n+    @Mapping(target = \"outerVlanId\", source = \"vlanId\")\n+    @Mapping(target = \"trackLldpConnectedDevices\", source = \"detectConnectedDevices.lldp\")\n+    @Mapping(target = \"trackArpConnectedDevices\", source = \"detectConnectedDevices.arp\")\n+    public abstract FlowEndpoint mapFlowEndpoint(FlowEndpointPayload input);", "originalCommit": "e32f01ec039da28c7915b6e097fc49cf1e06f242", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6017369fc753368dc479281c656ab630b8b9a7be", "chunk": "diff --git a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java\nindex aa567926a..83a40d27e 100644\n--- a/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java\n+++ b/src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/converter/FlowMapper.java\n\n@@ -158,6 +158,8 @@ public abstract class FlowMapper {\n     public abstract FlowRequest toFlowRequest(FlowCreatePayload request);\n \n     @Mapping(target = \"outerVlanId\", source = \"vlanId\")\n+    @Mapping(target = \"trackLldpConnectedDevices\", source = \"detectConnectedDevices.lldp\")\n+    @Mapping(target = \"trackArpConnectedDevices\", source = \"detectConnectedDevices.arp\")\n     public abstract FlowEndpoint mapFlowEndpoint(FlowEndpointV2 input);\n \n     @Mapping(target = \"switchId\", source = \"datapath\")\n"}}, {"oid": "6017369fc753368dc479281c656ab630b8b9a7be", "url": "https://github.com/telstra/open-kilda/commit/6017369fc753368dc479281c656ab630b8b9a7be", "message": "(func-test-incompatibility)", "committedDate": "2020-05-19T10:44:53Z", "type": "forcePushed"}, {"oid": "b2c0d3734d0bb2b0cf45c33be95dc2902eceb88c", "url": "https://github.com/telstra/open-kilda/commit/b2c0d3734d0bb2b0cf45c33be95dc2902eceb88c", "message": "QinQ limit capabilities\n\nLimit QinQ capabilities - remove the ability to have QinQ and single\nVLAN flows on the same port when outer VLAN matches. In exchange for\nkeeping existing OF flows format for single-VLAN flows in multi-table\nmode.", "committedDate": "2020-05-20T14:43:38Z", "type": "forcePushed"}, {"oid": "7dc28460da4b8f408cb3b28b6fa244d217e09729", "url": "https://github.com/telstra/open-kilda/commit/7dc28460da4b8f408cb3b28b6fa244d217e09729", "message": "QinQ limit capabilities\n\nLimit QinQ capabilities - remove the ability to have QinQ and single\nVLAN flows on the same port when outer VLAN matches. In exchange for\nkeeping existing OF flows format for single-VLAN flows in multi-table\nmode.", "committedDate": "2020-05-20T18:35:46Z", "type": "forcePushed"}, {"oid": "b472fde4337a58e1de13c1ddd9d000536e84099e", "url": "https://github.com/telstra/open-kilda/commit/b472fde4337a58e1de13c1ddd9d000536e84099e", "message": "(do-not-push) func-tests fixes stealed from test/qinq-final branch", "committedDate": "2020-05-21T10:30:13Z", "type": "forcePushed"}, {"oid": "564d57707895999c5648823d3aee012f0a3f3396", "url": "https://github.com/telstra/open-kilda/commit/564d57707895999c5648823d3aee012f0a3f3396", "message": "(do-not-push) func-tests fixes stealed from test/qinq-final branch", "committedDate": "2020-05-21T13:32:52Z", "type": "forcePushed"}, {"oid": "e8fb71d501ffb1ac696f9b4eb1c7ac44b1c60019", "url": "https://github.com/telstra/open-kilda/commit/e8fb71d501ffb1ac696f9b4eb1c7ac44b1c60019", "message": "QinQ limit capabilities\n\nLimit QinQ capabilities - remove the ability to have QinQ and single\nVLAN flows on the same port when outer VLAN matches. In exchange for\nkeeping existing OF flows format for single-VLAN flows in multi-table\nmode.", "committedDate": "2020-05-26T14:27:32Z", "type": "forcePushed"}, {"oid": "63c7548830e1a75ba26f22ac6f785de235fd4d06", "url": "https://github.com/telstra/open-kilda/commit/63c7548830e1a75ba26f22ac6f785de235fd4d06", "message": "Introducing flow with 2 levels of VLAN tagging on endpoints\n\nThis change adds the ability to use 2 levels of VLAN tags on flow\nendpoints.  I.e. you can define 2 (outer and inner) VLAN tags for each\nflow endpoint.\n\nFlow's endpoints (source and dest) encoding are independent, so it can\nbe defined as \"default port\" (no VLAN tags), as VLAN tagged and as QinQ\nor double VLAN tagged for each end of the flow.\n\nOF spec allow to the switch to reject flows that manipulate with\npossible missing ethernet packet's field. If the OF flow's action list\ncontains pop VLAN tag(for example) action it must have VLAN tag match in\nit's match field (see section 7.2.6 Action Structures OF specification\nv1.5.1 for more details). As a result we can't do the flow's endpoint\nencapsulation on egress switch as before, we need to unwrap ingress\nendpoint encapsulation on egress switch and apply/wrap egress\nencapsulation on egress switch.\n\nSo ingress switch will drop all(except last in case of transit-VLAN\nencapsulation) VLAN tags from ethernet packet, wrap it into transit\nencapsulation and on egress switch transit encapsulation will be\nunwrapped and corresponding egress endpoint VLAN tags are added.", "committedDate": "2020-05-27T06:36:00Z", "type": "commit"}, {"oid": "0b76c9c93d556e55195a1ce14fb13a2c56ca2bc3", "url": "https://github.com/telstra/open-kilda/commit/0b76c9c93d556e55195a1ce14fb13a2c56ca2bc3", "message": "QinQ limit capabilities\n\nLimit QinQ capabilities - remove the ability to have QinQ and single\nVLAN flows on the same port when outer VLAN matches. In exchange for\nkeeping existing OF flows format for single-VLAN flows in multi-table\nmode.", "committedDate": "2020-05-27T06:36:02Z", "type": "commit"}, {"oid": "0b76c9c93d556e55195a1ce14fb13a2c56ca2bc3", "url": "https://github.com/telstra/open-kilda/commit/0b76c9c93d556e55195a1ce14fb13a2c56ca2bc3", "message": "QinQ limit capabilities\n\nLimit QinQ capabilities - remove the ability to have QinQ and single\nVLAN flows on the same port when outer VLAN matches. In exchange for\nkeeping existing OF flows format for single-VLAN flows in multi-table\nmode.", "committedDate": "2020-05-27T06:36:02Z", "type": "forcePushed"}, {"oid": "dfbd1c26ba5e1c54719ef22c2b70dee02586528f", "url": "https://github.com/telstra/open-kilda/commit/dfbd1c26ba5e1c54719ef22c2b70dee02586528f", "message": "Test/qinq final (#3466)\n\n* Dispatch v1 flow create to flow hs\r\n\r\n- changed worker for flow v1 create request\r\n- fixed compile time warnings\r\n\r\n* adjust test framework to work with list of vlans\r\n\r\n* add QinQFlow spec\r\n\r\n* delete duplicated test\r\n\r\n* test traffic for vlan/default/qinq flows at the same time\r\n\r\n* add test for issue 3472\r\n\r\n* (func-test-incompatibility)\r\n\r\n* (func-tests-incompatibility)\r\n\r\n* (func-tests-incompatibility)\r\n\r\n* add test swap endpoints qinq\r\n\r\n* adjust connectedDevices work with qinq and add test\r\n\r\n* update SwitchHelper(ignore shared rule)\r\n\r\n* fix MetersSpec\r\n\r\n* fix errorMessages in tests for APIv1\r\n\r\nCo-authored-by: Timofey Durakov <timofei.nd@gmail.com>\r\nCo-authored-by: Dmitriy Bogun <nyaka@nyaka.org>", "committedDate": "2020-05-28T11:26:26Z", "type": "commit"}]}