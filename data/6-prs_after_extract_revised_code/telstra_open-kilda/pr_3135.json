{"pr_number": 3135, "pr_title": "Added MAX_LATENCY PCE strategy.", "pr_createdAt": "2020-01-22T07:08:43Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3135", "timeline": [{"oid": "7fc66966fefe86fe74b7bfdd48a2e1f8ee36f213", "url": "https://github.com/telstra/open-kilda/commit/7fc66966fefe86fe74b7bfdd48a2e1f8ee36f213", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-22T07:40:20Z", "type": "forcePushed"}, {"oid": "97335b57d136a498112eb81c01d92cd13e5f2943", "url": "https://github.com/telstra/open-kilda/commit/97335b57d136a498112eb81c01d92cd13e5f2943", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-22T08:14:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMTQwMA==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r369621400", "bodyText": "Pair of ordered lists that represents forward path from start to end and reverse one\nCorrect javadoc for previous method also, please.", "author": "rozdy", "createdAt": "2020-01-22T15:17:41Z", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java", "diffHunk": "@@ -39,6 +39,16 @@\n                                                    WeightFunction weightFunction)\n             throws UnroutableFlowException;\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return an ordered list that represents the path from start to end, or an empty list if no path found.", "originalCommit": "97335b57d136a498112eb81c01d92cd13e5f2943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2NzYyNA==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370067624", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-01-23T11:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMTQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "fb52f0ef5af1de5dac793b24ef37dccbf2760af1", "chunk": "diff --git a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java\nindex 9bce3374c..1d03efebc 100644\n--- a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java\n+++ b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/PathFinder.java\n\n@@ -32,7 +32,7 @@ public interface PathFinder {\n     /**\n      * Find a path from the start to the end switch.\n      *\n-     * @return an ordered list that represents the path from start to end, or an empty list if no path found.\n+     * @return a pair of ordered lists that represents the path from start to end, or an empty list if no path found.\n      */\n     Pair<List<Edge>, List<Edge>> findPathInNetwork(AvailableNetwork network,\n                                                    SwitchId startSwitchId, SwitchId endSwitchId,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r369631942", "bodyText": "Algorithm with max weight is very similar to previous one. Maybe we can generalize it using different weight shift and path weight comparison functions to avoid code duplication?", "author": "rozdy", "createdAt": "2020-01-22T15:34:24Z", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,69 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return An ordered list that represents the path from start to end, or an empty list\n+     */\n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long bestWeight = Long.MAX_VALUE;\n+        SearchNode bestPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < bestWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    bestWeight = shiftedCurrentWeight;\n+                    bestPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {\n+                continue;\n+            }\n+\n+            // Otherwise, if we've been here before, see if this path is better\n+            SearchNode prior = visited.get(current.dstSw);\n+            if (prior != null && shiftedCurrentWeight >= Math.abs(maxWeight - prior.parentWeight)) {\n+                continue;\n+            }\n+\n+            // Either this is the first time, or this one has less weight .. either way, this node should\n+            // be the one in the visited list\n+            visited.put(current.dstSw, current);\n+\n+            // At this stage .. haven't found END, haven't gone too deep, and we are not over weight.\n+            // So, add the outbound isls.\n+            current.dstSw.getOutgoingLinks().stream()\n+                    .sorted(Comparator.comparing(edge -> edge.getDestSwitch().getSwitchId()))\n+                    .forEach(edge -> toVisit.add(current.addNode(edge)));\n+        }\n+\n+        return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n+    }", "originalCommit": "97335b57d136a498112eb81c01d92cd13e5f2943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2ODkxNg==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370068916", "bodyText": "Algorithm with max weight looks similar, but we are searching path in another way.", "author": "dpoltavets", "createdAt": "2020-01-23T11:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "fb52f0ef5af1de5dac793b24ef37dccbf2760af1", "chunk": "diff --git a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\nindex 34f1965a8..2eb6285ef 100644\n--- a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n+++ b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n\n@@ -311,8 +311,8 @@ public class BestWeightAndShortestPathFinder implements PathFinder {\n      * @return An ordered list that represents the path from start to end, or an empty list\n      */\n     private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n-        long bestWeight = Long.MAX_VALUE;\n-        SearchNode bestPath = null;\n+        long desiredWeight = Long.MAX_VALUE;\n+        SearchNode desiredPath = null;\n \n         Deque<SearchNode> toVisit = new LinkedList<>();\n         Map<Node, SearchNode> visited = new HashMap<>();\n"}}, {"oid": "fb52f0ef5af1de5dac793b24ef37dccbf2760af1", "url": "https://github.com/telstra/open-kilda/commit/fb52f0ef5af1de5dac793b24ef37dccbf2760af1", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-23T11:33:00Z", "type": "forcePushed"}, {"oid": "704b7ffc18ac14165fdea675e7b4499d9618fdb4", "url": "https://github.com/telstra/open-kilda/commit/704b7ffc18ac14165fdea675e7b4499d9618fdb4", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-24T08:28:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNzQ1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370527452", "bodyText": "here must be current.parentWeight >= maxWeight", "author": "niksv", "createdAt": "2020-01-24T08:57:46Z", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */\n+    private SearchNode getDesiredPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        long desiredWeight = Long.MAX_VALUE;\n+        SearchNode desiredPath = null;\n+\n+        Deque<SearchNode> toVisit = new LinkedList<>();\n+        Map<Node, SearchNode> visited = new HashMap<>();\n+\n+        toVisit.add(new SearchNode(weightFunction, start, allowedDepth, 0, emptyList()));\n+\n+        while (!toVisit.isEmpty()) {\n+            SearchNode current = toVisit.pop();\n+\n+            // Leave if the path contains this node\n+            if (current.containsSwitch(current.dstSw.getSwitchId())) {\n+                continue;\n+            }\n+\n+            // Shift the current weight relative to maxWeight\n+            long shiftedCurrentWeight = Math.abs(maxWeight - current.parentWeight);\n+\n+            // Determine if this node is the destination node.\n+            if (current.dstSw.equals(end)) {\n+                // We found the destination\n+                if (shiftedCurrentWeight < desiredWeight && current.parentWeight < maxWeight) {\n+                    // We found a best path. If we don't get here, then the entire graph will be\n+                    // searched until we run out of nodes or the depth is reached.\n+                    desiredWeight = shiftedCurrentWeight;\n+                    desiredPath = current;\n+                }\n+                // We found dest, no need to keep processing\n+                continue;\n+            }\n+\n+            // Stop processing entirely if we've gone too far, or over maxWeight\n+            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {", "originalCommit": "704b7ffc18ac14165fdea675e7b4499d9618fdb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU0NjM2OA==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370546368", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-01-24T09:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNzQ1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ef35092b26935953e80ab6a3cc7ce9634d08ee04", "chunk": "diff --git a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\nindex d7cdf8c4b..59d08fad4 100644\n--- a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n+++ b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n\n@@ -357,7 +357,7 @@ public class BestWeightAndShortestPathFinder implements PathFinder {\n             }\n \n             // Stop processing entirely if we've gone too far, or over maxWeight\n-            if (current.allowedDepth <= 0 || current.parentWeight > maxWeight) {\n+            if (current.allowedDepth <= 0 || current.parentWeight >= maxWeight) {\n                 continue;\n             }\n \n"}}, {"oid": "ef35092b26935953e80ab6a3cc7ce9634d08ee04", "url": "https://github.com/telstra/open-kilda/commit/ef35092b26935953e80ab6a3cc7ce9634d08ee04", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-24T09:44:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3MTk5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370571993", "bodyText": "Javadoc return section is outdated.", "author": "rozdy", "createdAt": "2020-01-24T10:43:12Z", "path": "services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java", "diffHunk": "@@ -286,6 +305,82 @@ private void restoreEdge(Edge edge) {\n         return (bestPath != null) ? bestPath.parentPath : new LinkedList<>();\n     }\n \n+    private List<Edge> getPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n+        SearchNode desiredPath = getDesiredPath(start, end, weightFunction, maxWeight);\n+        SearchNode desiredReversePath = getDesiredPath(end, start, weightFunction, maxWeight);\n+\n+        if (desiredReversePath != null) {\n+            if (desiredPath == null || desiredReversePath.parentWeight > desiredPath.parentWeight) {\n+                desiredPath = desiredReversePath;\n+            }\n+        }\n+\n+        return (desiredPath != null) ? desiredPath.parentPath : new LinkedList<>();\n+    }\n+\n+    /**\n+     * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n+     *\n+     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     */", "originalCommit": "ef35092b26935953e80ab6a3cc7ce9634d08ee04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3Njg3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370576871", "bodyText": "Fixed.", "author": "dpoltavets", "createdAt": "2020-01-24T10:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3MTk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "35bc5ddc2377813fc903d5f41cfe3d22e751550f", "chunk": "diff --git a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\nindex 59d08fad4..13d4ae1e7 100644\n--- a/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n+++ b/services/src/kilda-pce/src/main/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinder.java\n\n@@ -321,7 +321,7 @@ public class BestWeightAndShortestPathFinder implements PathFinder {\n     /**\n      * Finds a path whose weight is less than maxWeight and as close to maxWeight as possible.\n      *\n-     * @return A pair of ordered lists that represents the path from start to end, or an empty list\n+     * @return A desired path from start to end as SearchNode representation, or null\n      */\n     private SearchNode getDesiredPath(Node start, Node end, WeightFunction weightFunction, long maxWeight) {\n         long desiredWeight = Long.MAX_VALUE;\n"}}, {"oid": "35bc5ddc2377813fc903d5f41cfe3d22e751550f", "url": "https://github.com/telstra/open-kilda/commit/35bc5ddc2377813fc903d5f41cfe3d22e751550f", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-24T10:53:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU3OTM4OA==", "url": "https://github.com/telstra/open-kilda/pull/3135#discussion_r370579388", "bodyText": "I genuinely do not understand the narrative of these tests. How do you compare cheapness to deepness in test names?", "author": "rtretyak", "createdAt": "2020-01-24T11:01:28Z", "path": "services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java", "diffHunk": "@@ -135,6 +135,71 @@ public void shouldChooseCheaperWithSameDepth() throws  UnroutableFlowException {\n         assertEquals(SWITCH_ID_3, rpath.get(0).getDestSwitch().getSwitchId());\n     }\n \n+    @Test\n+    public void shouldChooseCheaperOverTooDeepMaxWeightStrategy() throws  UnroutableFlowException {", "originalCommit": "35bc5ddc2377813fc903d5f41cfe3d22e751550f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c80f8237d5b0afdc4ea4baea456e5ddfdfc088f3", "chunk": "diff --git a/services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java b/services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java\ndeleted file mode 100644\nindex 39adb2b8d..000000000\n--- a/services/src/kilda-pce/src/test/java/org/openkilda/pce/finder/BestWeightAndShortestPathFinderTest.java\n+++ /dev/null\n\n@@ -1,747 +0,0 @@\n-/* Copyright 2018 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.pce.finder;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertThat;\n-\n-import org.openkilda.model.Isl;\n-import org.openkilda.model.IslConfig;\n-import org.openkilda.model.Switch;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.pce.exception.UnroutableFlowException;\n-import org.openkilda.pce.impl.AvailableNetwork;\n-import org.openkilda.pce.model.Edge;\n-import org.openkilda.pce.model.WeightFunction;\n-\n-import com.google.common.collect.Lists;\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.hamcrest.Matchers;\n-import org.junit.Test;\n-\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-public class BestWeightAndShortestPathFinderTest {\n-\n-    private static final int ALLOWED_DEPTH = 35;\n-    private static final WeightFunction WEIGHT_FUNCTION = edge -> {\n-        long total = edge.getCost();\n-        if (edge.isUnderMaintenance()) {\n-            total += 10_000;\n-        }\n-        if (edge.isUnstable()) {\n-            total += 10_000;\n-        }\n-        total += edge.getDiversityGroupUseCounter() * 1000 + edge.getDestSwitch().getDiversityGroupUseCounter() * 100;\n-        return total;\n-    };\n-\n-    private static final SwitchId SWITCH_ID_A = new SwitchId(\"00:00:00:22:3d:5a:04:87\");\n-    private static final SwitchId SWITCH_ID_B = new SwitchId(\"00:00:70:72:cf:d2:48:6c\");\n-    private static final SwitchId SWITCH_ID_C = new SwitchId(\"00:00:00:22:3d:6c:00:b8\");\n-    private static final SwitchId SWITCH_ID_D = new SwitchId(\"00:00:00:22:3d:6b:00:04\");\n-    private static final SwitchId SWITCH_ID_E = new SwitchId(\"00:00:70:72:cf:d2:47:a6\");\n-    private static final SwitchId SWITCH_ID_F = new SwitchId(\"00:00:b0:d2:f5:00:5a:b8\");\n-\n-    private static final SwitchId SWITCH_ID_1 = new SwitchId(\"00:00:00:00:00:00:00:01\");\n-    private static final SwitchId SWITCH_ID_2 = new SwitchId(\"00:00:00:00:00:00:00:02\");\n-    private static final SwitchId SWITCH_ID_3 = new SwitchId(\"00:00:00:00:00:00:00:03\");\n-    private static final SwitchId SWITCH_ID_4 = new SwitchId(\"00:00:00:00:00:00:00:04\");\n-    private static final SwitchId SWITCH_ID_5 = new SwitchId(\"00:00:00:00:00:00:00:05\");\n-\n-    @Test\n-    public void shouldChooseExpensiveOverTooDeep() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(2);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_4, WEIGHT_FUNCTION);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, fpath.get(1).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseExpensiveOverTooDeepForReverseOrder()\n-            throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(2);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_4, SWITCH_ID_1, WEIGHT_FUNCTION);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, fpath.get(1).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseDeeperOverExpensive() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(4);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_4, WEIGHT_FUNCTION);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(4));\n-        assertEquals(SWITCH_ID_5, fpath.get(3).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(4));\n-        assertEquals(SWITCH_ID_5, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseCheaperWithSameDepth() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(3);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_3, fpath.get(2).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_3, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseCheaperOverTooDeepMaxWeightStrategy() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(2);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_3, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, fpath.get(1).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseCheaperOverTooDeepForReverseOrderMaxWeightStrategy()\n-            throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(2);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_3, SWITCH_ID_1, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, fpath.get(1).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_2, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseDeeperOverCheaperMaxWeightStrategy() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(4);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_3, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(4));\n-        assertEquals(SWITCH_ID_5, fpath.get(3).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(4));\n-        assertEquals(SWITCH_ID_5, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldChooseExpensiveWithSameDepthMaxWeightStrategy() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildLongAndExpensivePathsNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(3);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_4, fpath.get(2).getSrcSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_4, rpath.get(0).getDestSwitch().getSwitchId());\n-    }\n-\n-    private AvailableNetwork buildLongAndExpensivePathsNetwork() {\n-        /*\n-         *   Topology:\n-         *\n-         *   SW1---SW2~~~SW4\n-         *          |     |\n-         *         SW3---SW5\n-         *\n-         *   SW2 - SW4 is expensive by cost.\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 2, 100);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_4, 3, 4, 10000);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 5, 6, 100);\n-        addBidirectionalLink(network, SWITCH_ID_3, SWITCH_ID_5, 7, 8, 100);\n-        addBidirectionalLink(network, SWITCH_ID_4, SWITCH_ID_5, 9, 10, 100);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    @Test(expected = UnroutableFlowException.class)\n-    public void shouldFailWhenPathIsLongerThenAllowedDepth() throws UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(1);\n-        pathFinder.findPathInNetwork(network, SWITCH_ID_D, SWITCH_ID_F, WEIGHT_FUNCTION);\n-    }\n-\n-    @Test(expected = UnroutableFlowException.class)\n-    public void shouldFailWhenPathIsLongerThenAllowedDepthMaxWeightStrategy() throws UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(1);\n-        pathFinder.findPathInNetwork(network, SWITCH_ID_D, SWITCH_ID_F, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-    }\n-\n-    @Test\n-    public void shouldReturnTheShortestPath() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_E, SWITCH_ID_F, WEIGHT_FUNCTION);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_E, fpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_F, fpath.get(1).getDestSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_F, rpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, rpath.get(1).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test\n-    public void shouldReturnThePathClosestToMaxWeight() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-        // found path should be E -10-> A -40-> C -10-> F\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_E, SWITCH_ID_F, WEIGHT_FUNCTION, 65L);\n-        List<Edge> fpath = pairPath.getLeft();\n-        assertThat(fpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_E, fpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, fpath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_F, fpath.get(2).getDestSwitch().getSwitchId());\n-\n-        List<Edge> rpath = pairPath.getRight();\n-        assertThat(rpath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_F, rpath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, fpath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, rpath.get(2).getDestSwitch().getSwitchId());\n-    }\n-\n-    @Test(expected = UnroutableFlowException.class)\n-    public void failToFindASwitch() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-\n-        SwitchId srcDpid = new SwitchId(\"00:00:00:00:00:00:00:ff\");\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        pathFinder.findPathInNetwork(network, srcDpid, SWITCH_ID_F, WEIGHT_FUNCTION);\n-    }\n-\n-    @Test(expected = UnroutableFlowException.class)\n-    public void failToFindASwitchMaxWeightStrategy() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-\n-        SwitchId srcDpid = new SwitchId(\"00:00:00:00:00:00:00:ff\");\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        pathFinder.findPathInNetwork(network, srcDpid, SWITCH_ID_F, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-    }\n-\n-    @Test\n-    public void testForwardAndBackwardPathsEquality() throws UnroutableFlowException {\n-        AvailableNetwork network = buildEqualCostsNetwork();\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> paths =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION);\n-\n-        List<SwitchId> forwardSwitchPath = getSwitchIdsFlowPath(paths.getLeft());\n-        List<SwitchId> backwardSwitchPath = Lists.reverse(getSwitchIdsFlowPath(paths.getRight()));\n-        assertEquals(forwardSwitchPath, backwardSwitchPath);\n-    }\n-\n-    @Test\n-    public void shouldAddIntermediateSwitchWeightOnce() throws UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-        // shouldn't affect path if added once\n-        network.getSwitch(SWITCH_ID_A).increaseDiversityGroupUseCounter();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> paths =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_D, SWITCH_ID_F, WEIGHT_FUNCTION);\n-\n-        assertEquals(Arrays.asList(SWITCH_ID_D, SWITCH_ID_A, SWITCH_ID_F), getSwitchIdsFlowPath(paths.getLeft()));\n-    }\n-\n-    @Test\n-    public void shouldAddIntermediateSwitchWeightOnceMaxWeightStrategy() throws UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetwork();\n-        // shouldn't affect path if added once\n-        network.getSwitch(SWITCH_ID_A).increaseDiversityGroupUseCounter();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> paths =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_D, SWITCH_ID_F, WEIGHT_FUNCTION, Long.MAX_VALUE);\n-\n-        assertEquals(Arrays.asList(SWITCH_ID_D, SWITCH_ID_C, SWITCH_ID_A, SWITCH_ID_E, SWITCH_ID_B, SWITCH_ID_F),\n-                getSwitchIdsFlowPath(paths.getLeft()));\n-    }\n-\n-    @Test\n-    public void shouldFindSymmetricPath() throws UnroutableFlowException {\n-        AvailableNetwork network = buildLinearNetworkWithPairLinks();\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(2);\n-\n-        Pair<List<Edge>, List<Edge>> pathPair =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_3, WEIGHT_FUNCTION);\n-        List<Edge> forward = pathPair.getLeft();\n-        List<Edge> reverse = Lists.reverse(pathPair.getRight());\n-\n-        List<Boolean> validation = IntStream.range(0, forward.size())\n-                .mapToObj(i -> Objects.equals(forward.get(i).getSrcPort(), reverse.get(i).getDestPort()))\n-                .collect(Collectors.toList());\n-        assertFalse(validation.contains(false));\n-    }\n-\n-    private AvailableNetwork buildLinearNetworkWithPairLinks() {\n-        /*\n-         * Topology:\n-         *\n-         * SW1===SW2===SW3\n-         *\n-         * All ISLs have equal cost.\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 2, 10000);\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 3, 4, 10000);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 5, 6, 10000);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 7, 8, 10000);\n-        return network;\n-    }\n-\n-    private AvailableNetwork buildEqualCostsNetwork() {\n-        /*\n-         *   Topology:\n-         *\n-         *   SW1---SW2---SW4\n-         *          |     |\n-         *         SW3---SW5\n-         *\n-         *   All ISLs have equal cost.\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 2, 100);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_4, 3, 4, 100);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 5, 6, 100);\n-        addBidirectionalLink(network, SWITCH_ID_3, SWITCH_ID_5, 7, 8, 100);\n-        addBidirectionalLink(network, SWITCH_ID_4, SWITCH_ID_5, 9, 10, 100);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    @Test\n-    public void testForwardAndBackwardPathsEqualityEvenWhenReverseHasCheaperPath()\n-            throws  UnroutableFlowException {\n-        // since our ISLs are bidirectional and cost may vary, we need to be sure that cost on reverse ISL won't be\n-        // taken into account during searching of reverse path.\n-        AvailableNetwork network = buildNetworkWithCostInReversePathBiggerThanForward();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> paths =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_5, WEIGHT_FUNCTION);\n-\n-        List<SwitchId> forwardSwitchPath = getSwitchIdsFlowPath(paths.getLeft());\n-        List<SwitchId> backwardSwitchPath = Lists.reverse(getSwitchIdsFlowPath(paths.getRight()));\n-        assertEquals(forwardSwitchPath, backwardSwitchPath);\n-    }\n-\n-    private AvailableNetwork buildNetworkWithCostInReversePathBiggerThanForward() {\n-        /*\n-         *   Topology:\n-         *\n-         *   SW1---SW2---SW4\n-         *          |     |\n-         *         SW3---SW5\n-         *\n-         *   SW3---SW5 isl has lower cost then reverse one.\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 2, 100);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_4, 3, 4, 100);\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 5, 68, 100);\n-        addLink(network, SWITCH_ID_3, SWITCH_ID_5, 7, 8, 10, 100, null, false);\n-        addLink(network, SWITCH_ID_5, SWITCH_ID_3, 8, 7, 10000, 100, null, false);\n-        addLink(network, SWITCH_ID_4, SWITCH_ID_5, 9, 10, 100, 100, null, false);\n-        addLink(network, SWITCH_ID_5, SWITCH_ID_4, 10, 9, 100, 100, null, false);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-\n-    @Test\n-    public void shouldHandleVeryExpensiveLinks() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildExpensiveNetwork();\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> paths =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_1, SWITCH_ID_3, WEIGHT_FUNCTION);\n-\n-        List<SwitchId> forwardSwitchPath = getSwitchIdsFlowPath(paths.getLeft());\n-        List<SwitchId> reverseSwitchPath = Lists.reverse(getSwitchIdsFlowPath(paths.getRight()));\n-        assertEquals(forwardSwitchPath, reverseSwitchPath);\n-        assertEquals(forwardSwitchPath, Lists.newArrayList(SWITCH_ID_1, SWITCH_ID_3));\n-    }\n-\n-    private AvailableNetwork buildExpensiveNetwork() {\n-        /*\n-         *   Triangle topology:\n-         *\n-         *   SW1---2 000 000 000---SW2---2 000 000 000---SW3\n-         *   |                                           |\n-         *   +---------------------1---------------------+\n-         */\n-\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_2, 1, 2, 2000000000); //cost near to MAX_INTEGER\n-        addBidirectionalLink(network, SWITCH_ID_2, SWITCH_ID_3, 3, 4, 2000000000); //cost near to MAX_INTEGER\n-        addBidirectionalLink(network, SWITCH_ID_1, SWITCH_ID_3, 5, 6, 1);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    private List<SwitchId> getSwitchIdsFlowPath(List<Edge> path) {\n-        List<SwitchId> switchIds = new ArrayList<>();\n-        if (!path.isEmpty()) {\n-            switchIds.add(path.get(0).getSrcSwitch().getSwitchId());\n-            for (Edge edge : path) {\n-                switchIds.add(edge.getDestSwitch().getSwitchId());\n-            }\n-        }\n-        return switchIds;\n-    }\n-\n-    private void addBidirectionalLink(AvailableNetwork network, SwitchId firstSwitch, SwitchId secondSwitch,\n-                                      int srcPort, int dstPort, int cost) {\n-        addLink(network, firstSwitch, secondSwitch, srcPort, dstPort, cost, 1, null, false);\n-        addLink(network, secondSwitch, firstSwitch, dstPort, srcPort, cost, 1, null, false);\n-    }\n-\n-    private AvailableNetwork buildTestNetwork() {\n-        /*\n-         *   Topology:\n-         *\n-         *   D---C---F---B---E\n-         *   |   |   |   |   |\n-         *   |   +---A---+   |\n-         *   |      / \\      |\n-         *   +-----+   +-----+\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_F,\n-                7, 60, 0, 3, null, false);\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_B,\n-                5, 32, 10, 18, null, false);\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_D,\n-                2, 2, 10, 2, null, false);\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_E,\n-                6, 16, 10, 15, null, false);\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_C,\n-                1, 3, 40, 4, null, false);\n-        addLink(network, SWITCH_ID_D, SWITCH_ID_C,\n-                1, 1, 100, 7, null, false);\n-        addLink(network, SWITCH_ID_D, SWITCH_ID_A,\n-                2, 2, 10, 1, null, false);\n-        addLink(network, SWITCH_ID_C, SWITCH_ID_F,\n-                6, 19, 10, 3, null, false);\n-        addLink(network, SWITCH_ID_C, SWITCH_ID_D,\n-                1, 1, 100, 2, null, false);\n-        addLink(network, SWITCH_ID_C, SWITCH_ID_A,\n-                3, 1, 100, 2, null, false);\n-        addLink(network, SWITCH_ID_E, SWITCH_ID_B,\n-                52, 52, 10, 381, null, false);\n-        addLink(network, SWITCH_ID_E, SWITCH_ID_A,\n-                16, 6, 10, 18, null, false);\n-        addLink(network, SWITCH_ID_B, SWITCH_ID_F,\n-                48, 49, 10, 97, null, false);\n-        addLink(network, SWITCH_ID_B, SWITCH_ID_E,\n-                52, 52, 10, 1021, null, false);\n-        addLink(network, SWITCH_ID_B, SWITCH_ID_A,\n-                32, 5, 10, 16, null, false);\n-        addLink(network, SWITCH_ID_F, SWITCH_ID_B,\n-                49, 48, 10, 0, null, false);\n-        addLink(network, SWITCH_ID_F, SWITCH_ID_C,\n-                19, 6, 10, 3, null, false);\n-        addLink(network, SWITCH_ID_F, SWITCH_ID_A,\n-                50, 7, 0, 3, null, false);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    @Test\n-    public void shouldBuildPathDependsOnIslConfig() throws  UnroutableFlowException {\n-        // Network without unstable and under maintenance links.\n-        AvailableNetwork network = buildTestNetworkForVerifyIslConfig(false, false);\n-\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        Pair<List<Edge>, List<Edge>> pairPath =\n-                pathFinder.findPathInNetwork(network, SWITCH_ID_A, SWITCH_ID_B, WEIGHT_FUNCTION);\n-        List<Edge> forwardPath = pairPath.getLeft();\n-        assertThat(forwardPath, Matchers.hasSize(1));\n-        assertEquals(SWITCH_ID_A, forwardPath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_B, forwardPath.get(0).getDestSwitch().getSwitchId());\n-\n-        List<Edge> reversePath = pairPath.getRight();\n-        assertThat(reversePath, Matchers.hasSize(1));\n-        assertEquals(SWITCH_ID_B, reversePath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_A, reversePath.get(0).getDestSwitch().getSwitchId());\n-\n-        // Network where shortest path has under maintenance link.\n-        network = buildTestNetworkForVerifyIslConfig(true, false);\n-\n-        pairPath = pathFinder.findPathInNetwork(network, SWITCH_ID_A, SWITCH_ID_B, WEIGHT_FUNCTION);\n-        forwardPath = pairPath.getLeft();\n-        assertThat(forwardPath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_A, forwardPath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, forwardPath.get(0).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, forwardPath.get(1).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_B, forwardPath.get(1).getDestSwitch().getSwitchId());\n-\n-        reversePath = pairPath.getRight();\n-        assertThat(reversePath, Matchers.hasSize(2));\n-        assertEquals(SWITCH_ID_B, reversePath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, reversePath.get(0).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_C, reversePath.get(1).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_A, reversePath.get(1).getDestSwitch().getSwitchId());\n-\n-        // Network where shortest path has under maintenance link and another short path has unstable link.\n-        network = buildTestNetworkForVerifyIslConfig(true, true);\n-\n-        pairPath = pathFinder.findPathInNetwork(network, SWITCH_ID_A, SWITCH_ID_B, WEIGHT_FUNCTION);\n-        forwardPath = pairPath.getLeft();\n-        assertThat(forwardPath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_A, forwardPath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_D, forwardPath.get(0).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_D, forwardPath.get(1).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, forwardPath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, forwardPath.get(2).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_B, forwardPath.get(2).getDestSwitch().getSwitchId());\n-\n-        reversePath = pairPath.getRight();\n-        assertThat(reversePath, Matchers.hasSize(3));\n-        assertEquals(SWITCH_ID_B, reversePath.get(0).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, reversePath.get(0).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_E, reversePath.get(1).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_D, reversePath.get(1).getDestSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_D, reversePath.get(2).getSrcSwitch().getSwitchId());\n-        assertEquals(SWITCH_ID_A, reversePath.get(2).getDestSwitch().getSwitchId());\n-    }\n-\n-    private AvailableNetwork buildTestNetworkForVerifyIslConfig(boolean shortestPathHasUnderMaintenanceLink,\n-                                                                boolean shortPathHasUnstableLink) {\n-        /*\n-         *   Topology:\n-         *\n-         *   A-------B\n-         *   |\\     /|\n-         *   | +-C-+ |\n-         *   D-------E\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_B,\n-                1, 1, 0, 0, null, shortestPathHasUnderMaintenanceLink);\n-\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_C,\n-                2, 1, 0, 0, null, false);\n-        addLink(network, SWITCH_ID_C, SWITCH_ID_B,\n-                2, 2, 0, 0, shortPathHasUnstableLink ? Instant.now() : null, false);\n-\n-        addLink(network, SWITCH_ID_A, SWITCH_ID_D,\n-                3, 1, 0, 0, null, false);\n-        addLink(network, SWITCH_ID_D, SWITCH_ID_E,\n-                1, 1, 0, 0, null, false);\n-        addLink(network, SWITCH_ID_E, SWITCH_ID_B,\n-                2, 3, 0, 0, null, false);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    @Test\n-    public void shouldFindNPath() throws  UnroutableFlowException {\n-        AvailableNetwork network = buildTestNetworkForTestYensAlgorithm();\n-        BestWeightAndShortestPathFinder pathFinder = new BestWeightAndShortestPathFinder(ALLOWED_DEPTH);\n-        List<List<SwitchId>> expectedPaths = new ArrayList<>();\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_C, SWITCH_ID_F));\n-        List<List<Edge>> paths =\n-                pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 1, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 2, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_D, SWITCH_ID_C, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 3, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_E, SWITCH_ID_C, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 4, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_B, SWITCH_ID_C, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 5, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_C, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 6, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_C, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 7, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_D, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 8, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths\n-                .add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_D, SWITCH_ID_C, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 9, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths\n-                .add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_D, SWITCH_ID_E, SWITCH_ID_C, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 10, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths\n-                .add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_D, SWITCH_ID_B, SWITCH_ID_C, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 11, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths.add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_C, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 12, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        expectedPaths\n-                .add(Lists.newArrayList(SWITCH_ID_A, SWITCH_ID_B, SWITCH_ID_C, SWITCH_ID_D, SWITCH_ID_E, SWITCH_ID_F));\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 13, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-\n-        paths = pathFinder.findNPathsBetweenSwitches(network, SWITCH_ID_A, SWITCH_ID_F, 500, WEIGHT_FUNCTION);\n-        assertEquals(expectedPaths, convertPaths(paths));\n-    }\n-\n-    private AvailableNetwork buildTestNetworkForTestYensAlgorithm() {\n-        /*\n-         *   Topology:\n-         *\n-         *   A--B--C\n-         *    \\ | /|\\\n-         *     \\|/ | \\\n-         *      D--E--F\n-         */\n-        AvailableNetwork network = new AvailableNetwork();\n-        addBidirectionalLink(network, SWITCH_ID_A, SWITCH_ID_B, 1, 1, 3);\n-        addBidirectionalLink(network, SWITCH_ID_A, SWITCH_ID_D, 2, 1, 2);\n-        addBidirectionalLink(network, SWITCH_ID_B, SWITCH_ID_C, 2, 1, 4);\n-        addBidirectionalLink(network, SWITCH_ID_B, SWITCH_ID_D, 3, 2, 1);\n-        addBidirectionalLink(network, SWITCH_ID_C, SWITCH_ID_D, 2, 3, 2);\n-        addBidirectionalLink(network, SWITCH_ID_C, SWITCH_ID_E, 3, 1, 2);\n-        addBidirectionalLink(network, SWITCH_ID_C, SWITCH_ID_F, 4, 1, 1);\n-        addBidirectionalLink(network, SWITCH_ID_D, SWITCH_ID_E, 4, 2, 3);\n-        addBidirectionalLink(network, SWITCH_ID_E, SWITCH_ID_F, 3, 2, 2);\n-\n-        network.reduceByWeight(WEIGHT_FUNCTION);\n-        return network;\n-    }\n-\n-    private List<List<SwitchId>> convertPaths(List<List<Edge>> paths) {\n-        List<List<SwitchId>> convertedPaths = new ArrayList<>();\n-        for (List<Edge> path : paths) {\n-            List<SwitchId> convertedPath = new ArrayList<>();\n-            for (Edge edge : path) {\n-                convertedPath.add(edge.getSrcSwitch().getSwitchId());\n-            }\n-            convertedPath.add(path.get(path.size() - 1).getDestSwitch().getSwitchId());\n-            convertedPaths.add(convertedPath);\n-        }\n-        return convertedPaths;\n-    }\n-\n-    private void addLink(AvailableNetwork network, SwitchId srcDpid, SwitchId dstDpid, int srcPort, int dstPort,\n-                         int cost, int latency, Instant timeUnstable, boolean isUnderMaintenance) {\n-        Switch srcSwitch = Switch.builder().switchId(srcDpid).build();\n-        Switch dstSwitch = Switch.builder().switchId(dstDpid).build();\n-        IslConfig islConfig = IslConfig.builder()\n-                .unstableIslTimeout(Duration.ofSeconds(120))\n-                .build();\n-\n-        Isl isl = Isl.builder()\n-                .srcSwitch(srcSwitch)\n-                .destSwitch(dstSwitch)\n-                .srcPort(srcPort)\n-                .destPort(dstPort)\n-                .cost(cost)\n-                .latency(latency)\n-                .timeUnstable(timeUnstable)\n-                .underMaintenance(isUnderMaintenance)\n-                .build();\n-        isl.setIslConfig(islConfig);\n-        network.addLink(isl);\n-    }\n-\n-}\n"}}, {"oid": "bc9372531d8b0a3e72baa346d153511d301ce572", "url": "https://github.com/telstra/open-kilda/commit/bc9372531d8b0a3e72baa346d153511d301ce572", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-27T06:33:14Z", "type": "forcePushed"}, {"oid": "f8509e569c20608a5e249b6819e0ba94d984fad7", "url": "https://github.com/telstra/open-kilda/commit/f8509e569c20608a5e249b6819e0ba94d984fad7", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-01-27T09:56:55Z", "type": "forcePushed"}, {"oid": "c80f8237d5b0afdc4ea4baea456e5ddfdfc088f3", "url": "https://github.com/telstra/open-kilda/commit/c80f8237d5b0afdc4ea4baea456e5ddfdfc088f3", "message": "Add tests for MAX_LATENCY PCE strategy", "committedDate": "2020-02-10T08:23:32Z", "type": "forcePushed"}, {"oid": "f8b1d6c9191eaa5aa1c6fbcf4917b0ae070d4b96", "url": "https://github.com/telstra/open-kilda/commit/f8b1d6c9191eaa5aa1c6fbcf4917b0ae070d4b96", "message": "Added MAX_LATENCY PCE strategy.", "committedDate": "2020-03-02T06:07:11Z", "type": "commit"}, {"oid": "236cb9f5a6745b29aa4186bfeb631ae11f2b3243", "url": "https://github.com/telstra/open-kilda/commit/236cb9f5a6745b29aa4186bfeb631ae11f2b3243", "message": "Add tests for MAX_LATENCY PCE strategy", "committedDate": "2020-03-02T06:07:13Z", "type": "commit"}, {"oid": "236cb9f5a6745b29aa4186bfeb631ae11f2b3243", "url": "https://github.com/telstra/open-kilda/commit/236cb9f5a6745b29aa4186bfeb631ae11f2b3243", "message": "Add tests for MAX_LATENCY PCE strategy", "committedDate": "2020-03-02T06:07:13Z", "type": "forcePushed"}]}