{"pr_number": 3093, "pr_title": "Fix the mess with flow endpoints during the flow update", "pr_createdAt": "2020-01-03T20:54:30Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3093", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTczOTkwOA==", "url": "https://github.com/telstra/open-kilda/pull/3093#discussion_r375739908", "bodyText": "Why do we allow to build flow segment requests for \"null\" path?", "author": "sergii-iakovenko", "createdAt": "2020-02-06T10:00:41Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -103,22 +103,21 @@ public SpeakerFlowSegmentRequestBuilder(FlowResourcesManager resourcesManager) {\n \n         List<FlowSegmentRequestFactory> requests = new ArrayList<>();\n         requests.addAll(makePathRequests(\n-                path, context, encapsulation, doIngress, doTransit, doEgress));\n+                flow, path, context, encapsulation, doIngress, doTransit, doEgress));\n         if (oppositePath != null) {\n-            if (!flow.isOneSwitchFlow() && oppositePath != null) {\n+            if (!flow.isOneSwitchFlow()) {\n                 encapsulation = getEncapsulation(\n                         flow.getEncapsulationType(), oppositePath.getPathId(), path.getPathId());\n             }\n             requests.addAll(makePathRequests(\n-                    oppositePath, context, encapsulation, doIngress, doTransit, doEgress));\n+                    flow, oppositePath, context, encapsulation, doIngress, doTransit, doEgress));\n         }\n         return requests;\n     }\n \n     private List<FlowSegmentRequestFactory> makePathRequests(\n-            @NonNull FlowPath path, CommandContext context, FlowTransitEncapsulation encapsulation,\n+            Flow flow, FlowPath path, CommandContext context, FlowTransitEncapsulation encapsulation,", "originalCommit": "d0095184f6861762cf996ab7005a3420a8aa5fda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc5NTk4OA==", "url": "https://github.com/telstra/open-kilda/pull/3093#discussion_r387795988", "bodyText": "We don't. This is a private method, I have doubts regarding the usefulness of @NonNull annotations for private methods.", "author": "surabujin", "createdAt": "2020-03-04T16:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTczOTkwOA=="}], "type": "inlineReview", "revised_code": {"commit": "05ae25a2f8c6e1f42851d191191547a288cdd9a8", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java b/services/wfm/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\ndeleted file mode 100644\nindex f9ffb2972..000000000\n--- a/services/wfm/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java\n+++ /dev/null\n\n@@ -1,293 +0,0 @@\n-/* Copyright 2019 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.wfm.share.service;\n-\n-import static java.lang.String.format;\n-\n-import org.openkilda.adapter.FlowSideAdapter;\n-import org.openkilda.floodlight.api.request.factory.EgressFlowSegmentRequestFactory;\n-import org.openkilda.floodlight.api.request.factory.FlowSegmentRequestFactory;\n-import org.openkilda.floodlight.api.request.factory.IngressFlowSegmentRequestFactory;\n-import org.openkilda.floodlight.api.request.factory.OneSwitchFlowRequestFactory;\n-import org.openkilda.floodlight.api.request.factory.TransitFlowSegmentRequestFactory;\n-import org.openkilda.floodlight.model.FlowSegmentMetadata;\n-import org.openkilda.messaging.MessageContext;\n-import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowEncapsulationType;\n-import org.openkilda.model.FlowPath;\n-import org.openkilda.model.FlowTransitEncapsulation;\n-import org.openkilda.model.IslEndpoint;\n-import org.openkilda.model.MeterConfig;\n-import org.openkilda.model.PathId;\n-import org.openkilda.model.PathSegment;\n-import org.openkilda.wfm.CommandContext;\n-import org.openkilda.wfm.share.flow.resources.EncapsulationResources;\n-import org.openkilda.wfm.share.flow.resources.FlowResourcesManager;\n-import org.openkilda.wfm.topology.flowhs.service.FlowCommandBuilder;\n-\n-import com.fasterxml.uuid.Generators;\n-import com.fasterxml.uuid.NoArgGenerator;\n-import lombok.NonNull;\n-import lombok.Value;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.UUID;\n-\n-public class SpeakerFlowSegmentRequestBuilder implements FlowCommandBuilder {\n-    private final NoArgGenerator commandIdGenerator = Generators.timeBasedGenerator();\n-    private final FlowResourcesManager resourcesManager;\n-\n-    public SpeakerFlowSegmentRequestBuilder(FlowResourcesManager resourcesManager) {\n-        this.resourcesManager = resourcesManager;\n-    }\n-\n-    @Override\n-    public List<FlowSegmentRequestFactory> buildAll(\n-            CommandContext context, Flow flow, FlowPath forwardPath, FlowPath reversePath) {\n-        return makeRequests(context, flow, forwardPath, reversePath, true, true, true);\n-    }\n-\n-    @Override\n-    public List<FlowSegmentRequestFactory> buildAllExceptIngress(CommandContext context, @NonNull Flow flow) {\n-        return buildAllExceptIngress(context, flow, flow.getForwardPath(), flow.getReversePath());\n-    }\n-\n-    @Override\n-    public List<FlowSegmentRequestFactory> buildAllExceptIngress(\n-            CommandContext context, Flow flow, FlowPath path, FlowPath oppositePath) {\n-        return makeRequests(context, flow, path, oppositePath, false, true, true);\n-    }\n-\n-    @Override\n-    public List<FlowSegmentRequestFactory> buildIngressOnly(CommandContext context, @NonNull Flow flow) {\n-        return buildIngressOnly(context, flow, flow.getForwardPath(), flow.getReversePath());\n-    }\n-\n-    @Override\n-    public List<FlowSegmentRequestFactory> buildIngressOnly(\n-            CommandContext context, Flow flow, FlowPath path, FlowPath oppositePath) {\n-        return makeRequests(context, flow, path, oppositePath, true, false, false);\n-    }\n-\n-    private List<FlowSegmentRequestFactory> makeRequests(\n-            CommandContext context, Flow flow, FlowPath path, FlowPath oppositePath,\n-            boolean doIngress, boolean doTransit, boolean doEgress) {\n-        if (path == null) {\n-            path = oppositePath;\n-            oppositePath = null;\n-        }\n-        if (path == null) {\n-            throw new IllegalArgumentException(\"At least one flow path must be not null\");\n-        }\n-\n-        FlowTransitEncapsulation encapsulation = null;\n-        if (!flow.isOneSwitchFlow()) {\n-            encapsulation = getEncapsulation(\n-                    flow.getEncapsulationType(), path.getPathId(),\n-                    oppositePath != null ? oppositePath.getPathId() : null);\n-        }\n-\n-        List<FlowSegmentRequestFactory> requests = new ArrayList<>();\n-        requests.addAll(makePathRequests(\n-                flow, path, context, encapsulation, doIngress, doTransit, doEgress));\n-        if (oppositePath != null) {\n-            if (!flow.isOneSwitchFlow()) {\n-                encapsulation = getEncapsulation(\n-                        flow.getEncapsulationType(), oppositePath.getPathId(), path.getPathId());\n-            }\n-            requests.addAll(makePathRequests(\n-                    flow, oppositePath, context, encapsulation, doIngress, doTransit, doEgress));\n-        }\n-        return requests;\n-    }\n-\n-    private List<FlowSegmentRequestFactory> makePathRequests(\n-            Flow flow, FlowPath path, CommandContext context, FlowTransitEncapsulation encapsulation,\n-            boolean doIngress, boolean doTransit, boolean doEgress) {\n-        final FlowSideAdapter ingressSide = FlowSideAdapter.makeIngressAdapter(flow, path);\n-        final FlowSideAdapter egressSide = FlowSideAdapter.makeEgressAdapter(flow, path);\n-\n-        final List<FlowSegmentRequestFactory> requests = new ArrayList<>();\n-\n-        PathSegment lastSegment = null;\n-        for (PathSegment segment : path.getSegments()) {\n-            if (lastSegment == null) {\n-                if (doIngress) {\n-                    requests.add(makeIngressRequest(context, path, encapsulation, ingressSide, segment, egressSide));\n-                }\n-            } else {\n-                if (doTransit) {\n-                    requests.add(makeTransitRequest(context, path, encapsulation, lastSegment, segment));\n-                }\n-            }\n-            lastSegment = segment;\n-        }\n-\n-        if (lastSegment != null) {\n-            if (doEgress) {\n-                requests.add(makeEgressRequest(context, path, encapsulation, lastSegment, egressSide, ingressSide));\n-            }\n-        } else if (doIngress) {\n-            // one switch flow (path without path segments)\n-            requests.add(makeOneSwitchRequest(context, path, ingressSide, egressSide));\n-        }\n-\n-        return requests;\n-    }\n-\n-    private FlowSegmentRequestFactory makeIngressRequest(\n-            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egressFlowSide) {\n-        PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n-\n-        UUID commandId = commandIdGenerator.generate();\n-        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        return IngressFlowSegmentRequestFactory.builder()\n-                .messageContext(messageContext)\n-                .metadata(makeMetadata(path, ensureEqualMultiTableFlag(\n-                        flowSide.isMultiTableSegment(), segmentSide.isMultiTable(),\n-                        String.format(\"First flow(id:%s, path:%s) segment and flow level multi-table flag values are \"\n-                                              + \"incompatible to each other - flow(%s) != segment(%s)\",\n-                                      path.getFlow().getFlowId(), path.getPathId(),\n-                                      flowSide.isMultiTableSegment(), segmentSide.isMultiTable()))))\n-                .endpoint(flowSide.getEndpoint())\n-                .meterConfig(getMeterConfig(path))\n-                .egressSwitchId(egressFlowSide.getEndpoint().getSwitchId())\n-                .islPort(segmentSide.getEndpoint().getPortNumber())\n-                .encapsulation(encapsulation)\n-                .build();\n-    }\n-\n-    private FlowSegmentRequestFactory makeTransitRequest(\n-            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            PathSegment ingress, PathSegment egress) {\n-        final PathSegmentSide inboundSide = makePathSegmentDestSide(ingress);\n-        final PathSegmentSide outboundSide = makePathSegmentSourceSide(egress);\n-\n-        final IslEndpoint ingressEndpoint = inboundSide.getEndpoint();\n-        final IslEndpoint egressEndpoint = outboundSide.getEndpoint();\n-\n-        assert ingressEndpoint.getSwitchId().equals(egressEndpoint.getSwitchId())\n-                : \"Only neighbor segments can be used for for transit segment request creation\";\n-\n-        UUID commandId = commandIdGenerator.generate();\n-        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        return TransitFlowSegmentRequestFactory.builder()\n-                .messageContext(messageContext)\n-                .switchId(ingressEndpoint.getSwitchId())\n-                .metadata(makeMetadata(path, ensureEqualMultiTableFlag(\n-                        inboundSide.isMultiTable(), outboundSide.isMultiTable(),\n-                        String.format(\n-                                \"Flow(id:%s, path:%s) have incompatible multi-table flags between segments %s \"\n-                                        + \"and %s\", path.getFlow().getFlowId(), path.getPathId(), ingress,\n-                                egress))))\n-                .ingressIslPort(ingressEndpoint.getPortNumber())\n-                .egressIslPort(egressEndpoint.getPortNumber())\n-                .encapsulation(encapsulation)\n-                .build();\n-    }\n-\n-    private FlowSegmentRequestFactory makeEgressRequest(\n-            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n-            PathSegment segment, FlowSideAdapter flowSide, FlowSideAdapter ingressFlowSide) {\n-        Flow flow = flowSide.getFlow();\n-        PathSegmentSide segmentSide = makePathSegmentDestSide(segment);\n-\n-        UUID commandId = commandIdGenerator.generate();\n-        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-\n-        return EgressFlowSegmentRequestFactory.builder()\n-                .messageContext(messageContext)\n-                .metadata(makeMetadata(path, ensureEqualMultiTableFlag(\n-                        segmentSide.isMultiTable(), flowSide.isMultiTableSegment(),\n-                        String.format(\"Last flow(id:%s, path:%s) segment and flow level multi-table flags value are \"\n-                                              + \"incompatible to each other - segment(%s) != flow(%s)\",\n-                                      flow.getFlowId(), path.getPathId(), segmentSide.isMultiTable(),\n-                                      flowSide.isMultiTableSegment()))))\n-                .endpoint(flowSide.getEndpoint())\n-                .ingressEndpoint(ingressFlowSide.getEndpoint())\n-                .islPort(segmentSide.getEndpoint().getPortNumber())\n-                .encapsulation(encapsulation)\n-                .build();\n-    }\n-\n-    private FlowSegmentRequestFactory makeOneSwitchRequest(\n-            CommandContext context, FlowPath path, FlowSideAdapter ingressSide, FlowSideAdapter egressSide) {\n-        Flow flow = ingressSide.getFlow();\n-\n-        UUID commandId = commandIdGenerator.generate();\n-        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n-        return OneSwitchFlowRequestFactory.builder()\n-                .messageContext(messageContext)\n-                .metadata(makeMetadata(path, ensureEqualMultiTableFlag(\n-                        ingressSide.isMultiTableSegment(), egressSide.isMultiTableSegment(),\n-                        String.format(\"Flow(id:%s) have incompatible for one-switch flow per-side multi-table flags - \"\n-                                              + \"src(%s) != dst(%s)\",\n-                                      flow.getFlowId(), flow.isSrcWithMultiTable(), flow.isDestWithMultiTable()))))\n-                .endpoint(ingressSide.getEndpoint())\n-                .meterConfig(getMeterConfig(path))\n-                .egressEndpoint(egressSide.getEndpoint())\n-                .build();\n-    }\n-\n-    private boolean ensureEqualMultiTableFlag(boolean ingress, boolean egress, String errorMessage) {\n-        if (ingress != egress) {\n-            throw new IllegalArgumentException(errorMessage);\n-        }\n-        return ingress;\n-    }\n-\n-    private PathSegmentSide makePathSegmentSourceSide(PathSegment segment) {\n-        return new PathSegmentSide(\n-                new IslEndpoint(segment.getSrcSwitch().getSwitchId(), segment.getSrcPort()),\n-                segment.isSrcWithMultiTable());\n-    }\n-\n-    private PathSegmentSide makePathSegmentDestSide(PathSegment segment) {\n-        return new PathSegmentSide(\n-                new IslEndpoint(segment.getDestSwitch().getSwitchId(), segment.getDestPort()),\n-                segment.isDestWithMultiTable());\n-    }\n-\n-    private FlowSegmentMetadata makeMetadata(FlowPath path, boolean isMultitable) {\n-        Flow flow = path.getFlow();\n-        return new FlowSegmentMetadata(flow.getFlowId(), path.getCookie(), isMultitable);\n-    }\n-\n-    @Value\n-    private static class PathSegmentSide {\n-        private final IslEndpoint endpoint;\n-\n-        private boolean multiTable;\n-    }\n-\n-    private MeterConfig getMeterConfig(FlowPath path) {\n-        if (path.getMeterId() == null) {\n-            return null;\n-        }\n-        return new MeterConfig(path.getMeterId(), path.getBandwidth());\n-    }\n-\n-    private FlowTransitEncapsulation getEncapsulation(\n-            FlowEncapsulationType encapsulation, PathId pathId, PathId oppositePathId) {\n-        EncapsulationResources resources = resourcesManager\n-                .getEncapsulationResources(pathId, oppositePathId, encapsulation)\n-                .orElseThrow(() -> new IllegalStateException(format(\n-                        \"No encapsulation resources found for flow path %s (opposite: %s)\", pathId, oppositePathId)));\n-        return new FlowTransitEncapsulation(resources.getTransitEncapsulationId(), resources.getEncapsulationType());\n-    }\n-}\n"}}, {"oid": "05ae25a2f8c6e1f42851d191191547a288cdd9a8", "url": "https://github.com/telstra/open-kilda/commit/05ae25a2f8c6e1f42851d191191547a288cdd9a8", "message": "Fix mess with flow endpoints duriong update\n\nThe mess happened because of usage inter-object reference stored inside\nobjects. Because there is no \"consistency\" into provided objects on the\ncaller side (at least now it is part of design) it leads to ... mess.\n\nSo always use provided \"parts\" of domain objects and avoid usage of\ninter-objects links/relations.", "committedDate": "2020-03-04T16:44:41Z", "type": "forcePushed"}, {"oid": "3059705aa8bf4d526dd1eab6ff6bba3d025bbdcc", "url": "https://github.com/telstra/open-kilda/commit/3059705aa8bf4d526dd1eab6ff6bba3d025bbdcc", "message": "Fix the mess with flow endpoints during the flow update\n\nThe mess happened because of the usage of inter-object reference stored\ninside objects. The caller code directly defines which objects must be\nused, so service code must not rely on relation stored inside objects.\nOr else... incorrect data will be used for flow segment speaker\nrequests.\n\nSo always use provided \"parts\" of domain objects and avoid usage of\ninter-objects links/relations.", "committedDate": "2020-03-04T16:51:23Z", "type": "forcePushed"}, {"oid": "e2a78386ead7d479bcf4cab04647e0a113b62bec", "url": "https://github.com/telstra/open-kilda/commit/e2a78386ead7d479bcf4cab04647e0a113b62bec", "message": "Fix the mess with flow endpoints during the flow update\n\nThe mess happened because of the usage of inter-object reference stored\ninside objects. The caller code directly defines which objects must be\nused, so service code must not rely on relation stored inside objects.\nOr else... incorrect data will be used for flow segment speaker\nrequests.\n\nSo always use provided \"parts\" of domain objects and avoid usage of\ninter-objects links/relations.", "committedDate": "2020-03-11T14:13:03Z", "type": "forcePushed"}, {"oid": "9012632f032834e3af272399041d6c79419637ed", "url": "https://github.com/telstra/open-kilda/commit/9012632f032834e3af272399041d6c79419637ed", "message": "Fix the mess with flow endpoints during the flow update\n\nThe mess happened because of the usage of inter-object reference stored\ninside objects. The caller code directly defines which objects must be\nused, so service code must not rely on relation stored inside objects.\nOr else... incorrect data will be used for flow segment speaker\nrequests.\n\nSo always use provided \"parts\" of domain objects and avoid usage of\ninter-objects links/relations.", "committedDate": "2020-03-27T08:29:15Z", "type": "commit"}, {"oid": "9012632f032834e3af272399041d6c79419637ed", "url": "https://github.com/telstra/open-kilda/commit/9012632f032834e3af272399041d6c79419637ed", "message": "Fix the mess with flow endpoints during the flow update\n\nThe mess happened because of the usage of inter-object reference stored\ninside objects. The caller code directly defines which objects must be\nused, so service code must not rely on relation stored inside objects.\nOr else... incorrect data will be used for flow segment speaker\nrequests.\n\nSo always use provided \"parts\" of domain objects and avoid usage of\ninter-objects links/relations.", "committedDate": "2020-03-27T08:29:15Z", "type": "forcePushed"}]}