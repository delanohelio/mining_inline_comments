{"pr_number": 3313, "pr_title": "Toolset for cookie bit manipulations", "pr_createdAt": "2020-03-18T13:36:28Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3313", "timeline": [{"oid": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "url": "https://github.com/telstra/open-kilda/commit/97ddfaefcb8a3d297c9937caec65ca6114ac466e", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-03-23T08:47:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTI5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399961295", "bodyText": "Why methods in Schema are not static? Are they have some state?\nWe have only 2 directions. Do we really need to pass direction emun every time? Maybe it's better to create 2 methods like: makeForward(long effectiveId) and makeReverse(long effectiveId)?\n\nBecause of these 2 points we have to use\nFlowSegmentCookieSchema.INSTANCE.make(cookie, FlowPathDirection.FORWARD)\ninstead of\nFlowSegmentCookieSchema.makeForward(cookie)", "author": "niksv", "createdAt": "2020-03-30T06:50:10Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwODM5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401608399", "bodyText": "1 - there are too many limits from static methods and no benefits (if you take a look at #3331 you will see that in some cases schemas can inherit each other).\n2 - direction can be not only written in the cookie but read too.", "author": "surabujin", "createdAt": "2020-04-01T13:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTI5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399962339", "bodyText": "why effective? what does it mean?", "author": "niksv", "createdAt": "2020-03-30T06:52:49Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwOTA4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401609083", "bodyText": "This is my personal... preferences, I follow naming style of linux/unix system ('effective' term goes from effective-user-id term - this is not some constant ID but ID used right now, I believe it is close enough to our use case). Propose a better term.", "author": "surabujin", "createdAt": "2020-04-01T13:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1Njg4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404656886", "bodyText": "+1 to @niksv for me it doesn't meaningful, let's try to rename?", "author": "timofei-durakov", "createdAt": "2020-04-07T09:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MjMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399963009", "bodyText": "What if direction flag is NOT set? is it a valid case?", "author": "niksv", "createdAt": "2020-03-30T06:54:25Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxNDU2NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401614564", "bodyText": "The current implementation (https://github.com/telstra/open-kilda/blob/develop/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java#L234) do not enforce presence of direction bits. I do not want to introduce this limit now.", "author": "surabujin", "createdAt": "2020-04-01T13:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjAwOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399966008", "bodyText": "Why LLDP type and ARP type have different naming?\nI guess it must be LLDP_INPUT_CUSTOMER_TYPE and ARP_INPUT_CUSTOMER_TYPE", "author": "niksv", "createdAt": "2020-03-30T07:01:23Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        return resolveEnum(CookieType.values(), getRawType(cookie), CookieType.class);\n+    }\n+\n+    // TODO: drop?\n+    protected int getRawType(Cookie cookie) {\n+        return (int) getField(cookie.getValue(), TYPE_FIELD);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP(0x001),", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxODcxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401618719", "bodyText": "Because... I took it from the existing definition in Cookie.java (it was renamed later). Renamed.", "author": "surabujin", "createdAt": "2020-04-01T13:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\nindex c884ea031..f49fa82a4 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n\n@@ -89,7 +89,7 @@ public abstract class CookieSchema {\n     // 9 bit long field\n     public enum CookieType implements NumericEnumField {\n         SERVICE_OR_FLOW_SEGMENT(0x000),\n-        LLDP(0x001),\n+        LLDP_INPUT_CUSTOMER_TYPE(0x001),\n         MULTI_TABLE_ISL_VLAN_EGRESS_RULES(0x002),\n         MULTI_TABLE_ISL_VXLAN_EGRESS_RULES(0x003),\n         MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES(0x004),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NzUyNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399967526", "bodyText": "why effective? It is confusing. Do you mean \"unmasked cookie\" or something else?", "author": "niksv", "createdAt": "2020-03-30T07:04:54Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);\n+        return new Cookie(raw);\n+    }\n+\n+    public Cookie setFlowEffectiveId(Cookie cookie, long effectiveId) {\n+        return new Cookie(setField(cookie.getValue(), FLOW_EFFECTIVE_ID_FIELD, effectiveId));", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxOTE3MA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401619170", "bodyText": "You have already asked it.", "author": "surabujin", "createdAt": "2020-04-01T13:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NzUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTk3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399969976", "bodyText": "maybe we need to add Method isForward()?", "author": "niksv", "createdAt": "2020-03-30T07:10:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java", "diffHunk": "@@ -40,7 +42,7 @@ public static FlowSideAdapter makeIngressAdapter(Flow flow, FlowPath path) {\n      * Determine \"forward\" direction for provided flow/path pair and create adapter to access dest endpoint.\n      */\n     public static FlowSideAdapter makeEgressAdapter(Flow flow, FlowPath path) {\n-        if (path.getCookie().isMaskedAsForward()) {\n+        if (FlowSegmentCookieSchema.INSTANCE.getValidatedDirection(path.getCookie()) == FlowPathDirection.FORWARD) {", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMDM2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401620367", "bodyText": "No. Read direction and compare.\nYou will need too many such 'isSomething()` methods.", "author": "surabujin", "createdAt": "2020-04-01T13:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java b/src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java\nindex 8225a87c6..437d952f4 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/adapter/FlowSideAdapter.java\n\n@@ -42,7 +41,7 @@ public abstract class FlowSideAdapter {\n      * Determine \"forward\" direction for provided flow/path pair and create adapter to access dest endpoint.\n      */\n     public static FlowSideAdapter makeEgressAdapter(Flow flow, FlowPath path) {\n-        if (FlowSegmentCookieSchema.INSTANCE.getValidatedDirection(path.getCookie()) == FlowPathDirection.FORWARD) {\n+        if (path.getCookie().getDirection() == FlowPathDirection.FORWARD) {\n             return new FlowDestAdapter(flow);\n         } else {\n             return new FlowSourceAdapter(flow);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjQzMg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399972432", "bodyText": "Why do we need to set UNKNOWN direction? where it can be used?", "author": "niksv", "createdAt": "2020-03-30T07:15:13Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyMTQwOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401621408", "bodyText": "Because direction bits are not enforced.", "author": "surabujin", "createdAt": "2020-04-01T13:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjQzMg=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NjExOA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r399976118", "bodyText": "I think this is not a best way to set a field. Try to put setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward); into if (direction == FlowPathDirection.FORWARD) {\nSomething like this:\n        long raw = cookie.getValue();\n        if (direction == FlowPathDirection.FORWARD) {\n            raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.REVERSE) {\n            raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, 1);\n        } else if (direction == FlowPathDirection.UNKNOWN) {\n            // nothing to do\n        } else {\n            throw new IllegalArgumentException(String.format(\n                    \"Unable to map %s.%s into cookie direction bits\",\n                    FlowPathDirection.class.getSimpleName(), direction));\n        }\n\n        return new Cookie(raw);", "author": "niksv", "createdAt": "2020-03-30T07:23:03Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {\n+            forward = 1;\n+        } else if (direction == FlowPathDirection.REVERSE) {\n+            reverse = 1;\n+        } else if (direction == FlowPathDirection.UNKNOWN) {\n+            // nothing to do\n+        } else {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Unable to map %s.%s into cookie direction bits\",\n+                    FlowPathDirection.class.getSimpleName(), direction));\n+        }\n+\n+        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n+        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNDA1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401624052", "bodyText": "I still don't see any benefits here. Is the benefit in not defining 2 int variables?\nPS You lost 0 0 variant (\"nothing to do branch\"), plus you must update both bits, or you can make the cookie with both direction bits set.", "author": "surabujin", "createdAt": "2020-04-01T13:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NjExOA=="}], "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTM3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009379", "bodyText": "you can use @Test(expected = IllegalArgumentException.class) for such tests\n    @Test(expected = IllegalArgumentException.class)\n    public void ensureNoEmptyMasks() {\n             new BitField(0);\n    }", "author": "niksv", "createdAt": "2020-03-30T08:23:25Z", "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYyNTQzMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401625430", "bodyText": "ok", "author": "surabujin", "createdAt": "2020-04-01T13:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTM3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "chunk": "diff --git a/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java b/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\nindex f208178d3..b87369417 100644\n--- a/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\n+++ b/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\n\n@@ -22,24 +22,14 @@ import org.junit.Assert;\n import org.junit.Test;\n \n public class CookieSchemaTest extends GenericCookieSchemaTest {\n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void ensureNoEmptyMasks() {\n-        try {\n-            new BitField(0);\n-            Assert.fail();\n-        } catch (IllegalArgumentException e) {\n-            // expected behaviour\n-        }\n+        new BitField(0);\n     }\n \n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void ensureNoGapsInMask() {\n-        try {\n-            new BitField(5);\n-            Assert.fail();\n-        } catch (IllegalArgumentException e) {\n-            // expected behaviour\n-        }\n+        new BitField(5);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwOTQ2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400009469", "bodyText": "same", "author": "niksv", "createdAt": "2020-03-30T08:23:33Z", "path": "src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CookieSchemaTest extends GenericCookieSchemaTest {\n+    @Test\n+    public void ensureNoEmptyMasks() {\n+        try {\n+            new BitField(0);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }\n+    }\n+\n+    @Test\n+    public void ensureNoGapsInMask() {\n+        try {\n+            new BitField(5);\n+            Assert.fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected behaviour\n+        }", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "chunk": "diff --git a/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java b/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\nindex f208178d3..b87369417 100644\n--- a/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\n+++ b/src-java/kilda-model/src/test/java/org/openkilda/model/bitops/cookie/CookieSchemaTest.java\n\n@@ -22,24 +22,14 @@ import org.junit.Assert;\n import org.junit.Test;\n \n public class CookieSchemaTest extends GenericCookieSchemaTest {\n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void ensureNoEmptyMasks() {\n-        try {\n-            new BitField(0);\n-            Assert.fail();\n-        } catch (IllegalArgumentException e) {\n-            // expected behaviour\n-        }\n+        new BitField(0);\n     }\n \n-    @Test\n+    @Test(expected = IllegalArgumentException.class)\n     public void ensureNoGapsInMask() {\n-        try {\n-            new BitField(5);\n-            Assert.fail();\n-        } catch (IllegalArgumentException e) {\n-            // expected behaviour\n-        }\n+        new BitField(5);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzgyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013820", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "author": "niksv", "createdAt": "2020-03-30T08:30:54Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.MeterId;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceCookieSchema extends CookieSchema {\n+    public static final ServiceCookieSchema INSTANCE = new ServiceCookieSchema();\n+\n+    private static final Set<CookieType> allowedTypes = Stream.of(\n+            CookieType.SERVICE_OR_FLOW_SEGMENT,\n+            CookieType.LLDP,\n+            CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES,\n+            CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES,\n+            CookieType.MULTI_TABLE_INGRESS_RULES,\n+            CookieType.ARP_INPUT_CUSTOMER_TYPE\n+    ).collect(Collectors.toSet());\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                   used by generic cookie -> 0x9FF0_0000_0000_0000L", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYzMDI3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401630273", "bodyText": "hex(0x8000000000000000 | 0x1ff0000000000000) => 0x9ff0000000000000\nbin(0x8000000000000000 | 0x1ff0000000000000) => 0b1001111111110000000000000000000000000000000000000000000000000000", "author": "surabujin", "createdAt": "2020-04-01T13:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java\nindex f49b6cb53..ea72b245a 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/ServiceCookieSchema.java\n\n@@ -32,7 +32,7 @@ public class ServiceCookieSchema extends CookieSchema {\n \n     private static final Set<CookieType> allowedTypes = Stream.of(\n             CookieType.SERVICE_OR_FLOW_SEGMENT,\n-            CookieType.LLDP,\n+            CookieType.LLDP_INPUT_CUSTOMER_TYPE,\n             CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES,\n             CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES,\n             CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAxMzg4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400013883", "bodyText": "why 9?\nit is 1001 as binary. should it be 7FF0?", "author": "niksv", "createdAt": "2020-03-30T08:31:00Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fad4c687d5a5138b887dd521e1d2356c2533828b", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\nindex e38767f96..2c3f1cdf1 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n\n@@ -27,9 +27,9 @@ public class FlowSegmentCookieSchema extends CookieSchema {\n \n     // update ALL_FIELDS if modify fields list\n     //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n     static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAyNjA3MA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r400026070", "bodyText": "Honestly I don't like the idea of creating so many classes (schemas, types, etc).\nCookie class is a one place were you can find all information related to cookie(types, subtypes, schema with description of all bits used in cookie)\nInformation from the left(which were removed ) is readable, complete and easy understandable.\nNow we have several classes, with several subtypes, placed in different files. It's hard to work with such number of classes. It's easy to make a mistake. Usage in code doesn't looks like a syntax sugar. Example\nWas:\nlong cookie = flowResources.getUnmaskedCookie();\nCookie.buildForwardCookie(cookie)\n\nNow:\nCookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();\nCookie flowCookie = FlowSegmentCookieSchema.INSTANCE.setFlowEffectiveId(\nblank, flowResources.getUnmaskedCookie());\nFlowSegmentCookieSchema.INSTANCE.setDirection(flowCookie, FlowPathDirection.FORWARD)\n\nMaybe we shouldn't make simple things difficult?", "author": "niksv", "createdAt": "2020-03-30T08:50:51Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -45,101 +47,110 @@\n  * </p>\n  */\n @Value\n+@EqualsAndHashCode(of = {\"value\"})\n public class Cookie implements Comparable<Cookie>, Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n-\n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n-\n-    private final long value;\n-\n-    /**\n-     * Create {@code Cookie} instance and perform it's validation.\n-     */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n-    }\n+    // FIXME(surabujin): get rid from this constants", "originalCommit": "97ddfaefcb8a3d297c9937caec65ca6114ac466e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0MjY0NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r401642644", "bodyText": "At first, we have used long type to represent cookie in our code. It produced a great number of different errors in all imaginable places. So it was wrapped into special type to ensure that if code expect the cookie it will receive the cookie and compiler will guarantee this - this is when Cookie class appears. At some later point, this guarantee was eliminated with methods like\n    public static long encodeIslVlanEgress(int port) {\n        return new Cookie(port | DEFAULT_RULE_FLAG)\n                .setType(CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES)\n                .getValue();\n    }\n\ni.e. methods that receive simple/generic type and return simple/generic type.\nLater cookie \"schema\" becomes more complex - type field was introduced and this field defines the meaning of other bits. So now cookie have not documented and not defined in any way restrictions which bits can be defined at the same time and which must collide. Keeping this all in \"simple\" way how it now - is keeping it in the way this restriction can't be easily defined in code and as the result can't be covered with tests.\nThe goal of all these \"extra classes as you say\" is to define each \"conflicting\" schema in its own class. It is verbose enough way to define \"compatible\" bits (and not compatible). Another goal is to eliminate the possibility to use simple/generic types instead of Cookie type (but it can't be reached so easy).", "author": "surabujin", "createdAt": "2020-04-01T14:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAyNjA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\nindex 09fe602a7..860a213cb 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n\n@@ -145,7 +145,7 @@ public class Cookie implements Comparable<Cookie>, Serializable {\n      */\n     public static long encodeLldpInputCustomer(int port) {\n         // FIXME(surabujin): do not allow to return \"raw\" long value\n-        return ServiceCookieSchema.INSTANCE.make(CookieType.LLDP, port).getValue();\n+        return ServiceCookieSchema.INSTANCE.make(CookieType.LLDP_INPUT_CUSTOMER_TYPE, port).getValue();\n     }\n \n     public static long encodeArpInputCustomer(int port) {\n"}}, {"oid": "bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "url": "https://github.com/telstra/open-kilda/commit/bc5b9e18387ae5eaeb4125dc40722eb55e50ad81", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-01T15:56:41Z", "type": "forcePushed"}, {"oid": "4cf03b92f9d6af815863798c1b4a8216dd65f16a", "url": "https://github.com/telstra/open-kilda/commit/4cf03b92f9d6af815863798c1b4a8216dd65f16a", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T12:23:43Z", "type": "forcePushed"}, {"oid": "fad4c687d5a5138b887dd521e1d2356c2533828b", "url": "https://github.com/telstra/open-kilda/commit/fad4c687d5a5138b887dd521e1d2356c2533828b", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T13:14:03Z", "type": "forcePushed"}, {"oid": "5cf0df10539a775f8eace6e31727df522945edf6", "url": "https://github.com/telstra/open-kilda/commit/5cf0df10539a775f8eace6e31727df522945edf6", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-02T17:36:23Z", "type": "forcePushed"}, {"oid": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "url": "https://github.com/telstra/open-kilda/commit/16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-06T11:14:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404647500", "bodyText": "this approach will lead to issue in future, it's like using Maps instead of Class Objects", "author": "timofei-durakov", "createdAt": "2020-04-07T08:56:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4MDQ3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405480475", "bodyText": "+1 Please, consider introducing a cookie builder.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNjM0NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406806344", "bodyText": "...", "author": "surabujin", "createdAt": "2020-04-10T15:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0NzUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nsimilarity index 52%\nrename from src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\nrename to src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fcee7e5b6..fca82724f 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -13,64 +13,100 @@\n  *   limitations under the License.\n  */\n \n-package org.openkilda.model.bitops.cookie;\n+package org.openkilda.model;\n \n import org.openkilda.exception.InvalidCookieException;\n-import org.openkilda.model.Cookie;\n import org.openkilda.model.bitops.BitField;\n import org.openkilda.model.bitops.NumericEnumField;\n \n-public abstract class CookieSchema {\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n     // update ALL_FIELDS if modify fields list\n-    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n     static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n \n-    protected abstract Cookie makeBlank();\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n \n-    public void validate(Cookie cookie) throws InvalidCookieException {\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {\n+        try {\n+            validate();\n+            return true;\n+        } catch (InvalidCookieException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void validate() throws InvalidCookieException {\n         // inheritors can implement validate logic\n     }\n \n+    @JsonValue\n+    public long getValue() {\n+        return value;\n+    }\n+\n     /**\n      * Extract and return \"type\" field.\n      */\n-    public CookieType getType(Cookie cookie) {\n-        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+    public CookieType getType() {\n+        int numericType = (int) getField(TYPE_FIELD);\n         return resolveEnum(CookieType.values(), numericType, CookieType.class);\n     }\n \n-    protected long setType(long value, CookieType type) {\n-        return setField(value, TYPE_FIELD, type.getValue());\n-    }\n-\n-    protected long getField(long value, BitField field) {\n+    protected long getField(BitField field) {\n         long payload = value & field.getMask();\n         return payload >>> field.getOffset();\n     }\n \n-    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n-        long raw = setField(cookie.getValue(), field, payload);\n-        return new Cookie(raw);\n+    @Override\n+    public String toString() {\n+        return toString(value);\n     }\n \n-    protected long setField(long value, BitField field, long payload) {\n-        long mask = field.getMask();\n-        payload <<= field.getOffset();\n-        payload &= mask;\n-        return (value & ~mask) | payload;\n+    @Deprecated\n+    public static String toString(long cookie) {\n+        return String.format(\"0x%016X\", cookie);\n+    }\n+\n+    protected int cookieComparison(CookieBase other) {\n+        return Long.compare(value, other.value);\n     }\n \n-    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n-        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+    protected void validateServiceFlag(boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(SERVICE_FLAG) != 0;\n         if (expectedValue != actual) {\n             throw new InvalidCookieException(\n-                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), this);\n         }\n     }\n \n+    /**\n+     * Scan all enum elements and compare their numberic representation with {@code needle} argument. Returns matched\n+     * enum element.\n+     */\n     protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n         for (T entry : valuesSpace) {\n             if (entry.getValue() == needle) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTcwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404649701", "bodyText": "why not switch/case?", "author": "timofei-durakov", "createdAt": "2020-04-07T08:59:24Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.FlowPathDirection;\n+import org.openkilda.model.bitops.BitField;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+public class FlowSegmentCookieSchema extends CookieSchema {\n+    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n+\n+    // update ALL_FIELDS if modify fields list\n+    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n+    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n+    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n+    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n+            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n+\n+    public Cookie make(long effectiveId) {\n+        return setFlowEffectiveId(makeBlank(), effectiveId);\n+    }\n+\n+    public Cookie make(long effectiveId, FlowPathDirection direction) {\n+        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n+        return setDirection(cookie, direction);\n+    }\n+\n+    @Override\n+    public Cookie makeBlank() {\n+        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n+    }\n+\n+    @Override\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        super.validate(cookie);\n+\n+        validateServiceFlag(cookie, false);\n+\n+        long raw = cookie.getValue();\n+        int directionBitsSetCount = 0;\n+        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n+        for (BitField field : mutuallyExclusiveFlags) {\n+            directionBitsSetCount += getField(raw, field);\n+        }\n+\n+        if (1 < directionBitsSetCount) {\n+            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n+        }\n+    }\n+\n+    /**\n+     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n+     *\n+     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n+     */\n+    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n+        FlowPathDirection direction = getDirection(cookie);\n+        if (FlowPathDirection.UNKNOWN == direction) {\n+            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n+        }\n+        return direction;\n+    }\n+\n+    /**\n+     * Extract and return normalized representation flow path direction.\n+     */\n+    public FlowPathDirection getDirection(Cookie cookie) {\n+        long raw = cookie.getValue();\n+        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.FORWARD;\n+        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n+            return FlowPathDirection.REVERSE;\n+        } else {\n+            return FlowPathDirection.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Set direction bits to the value passed as directions argument.\n+     */\n+    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n+        int forward = 0;\n+        int reverse = 0;\n+        if (direction == FlowPathDirection.FORWARD) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgwNjUzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406806539", "bodyText": "don't matter.", "author": "surabujin", "createdAt": "2020-04-10T15:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\ndeleted file mode 100644\nindex 2c3f1cdf1..000000000\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/FlowSegmentCookieSchema.java\n+++ /dev/null\n\n@@ -1,131 +0,0 @@\n-/* Copyright 2020 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.model.bitops.cookie;\n-\n-import org.openkilda.exception.InvalidCookieException;\n-import org.openkilda.model.Cookie;\n-import org.openkilda.model.FlowPathDirection;\n-import org.openkilda.model.bitops.BitField;\n-\n-import org.apache.commons.lang3.ArrayUtils;\n-\n-public class FlowSegmentCookieSchema extends CookieSchema {\n-    public static final FlowSegmentCookieSchema INSTANCE = new FlowSegmentCookieSchema();\n-\n-    // update ALL_FIELDS if modify fields list\n-    //                                     used by generic cookie -> 0x9FF0_0000_0000_0000L\n-    static final BitField FLOW_EFFECTIVE_ID_FIELD     = new BitField(0x0000_0000_000F_FFFFL);\n-    static final BitField FLOW_REVERSE_DIRECTION_FLAG = new BitField(0x2000_0000_0000_0000L);\n-    static final BitField FLOW_FORWARD_DIRECTION_FLAG = new BitField(0x4000_0000_0000_0000L);\n-\n-    // used by unit tests to check fields intersections\n-    static final BitField[] ALL_FIELDS = ArrayUtils.addAll(\n-            CookieSchema.ALL_FIELDS, FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG, FLOW_EFFECTIVE_ID_FIELD);\n-\n-    public Cookie make(long effectiveId) {\n-        return setFlowEffectiveId(makeBlank(), effectiveId);\n-    }\n-\n-    public Cookie make(long effectiveId, FlowPathDirection direction) {\n-        Cookie cookie = setFlowEffectiveId(makeBlank(), effectiveId);\n-        return setDirection(cookie, direction);\n-    }\n-\n-    @Override\n-    public Cookie makeBlank() {\n-        return new Cookie(setType(0, CookieType.SERVICE_OR_FLOW_SEGMENT));\n-    }\n-\n-    @Override\n-    public void validate(Cookie cookie) throws InvalidCookieException {\n-        super.validate(cookie);\n-\n-        validateServiceFlag(cookie, false);\n-\n-        long raw = cookie.getValue();\n-        int directionBitsSetCount = 0;\n-        BitField[] mutuallyExclusiveFlags = {FLOW_FORWARD_DIRECTION_FLAG, FLOW_REVERSE_DIRECTION_FLAG};\n-        for (BitField field : mutuallyExclusiveFlags) {\n-            directionBitsSetCount += getField(raw, field);\n-        }\n-\n-        if (1 < directionBitsSetCount) {\n-            throw new InvalidCookieException(\"Illegal flags combination - both the direction bits are set\", cookie);\n-        }\n-    }\n-\n-    /**\n-     * Read the direction bits and return direction as {@link FlowPathDirection} constant.\n-     *\n-     * <p>Raise {@link IllegalArgumentException} if all direction bits are equal to 0.\n-     */\n-    public FlowPathDirection getValidatedDirection(Cookie cookie) {\n-        FlowPathDirection direction = getDirection(cookie);\n-        if (FlowPathDirection.UNKNOWN == direction) {\n-            throw new IllegalArgumentException(String.format(\"Cookie %s have no the direction marker\", cookie));\n-        }\n-        return direction;\n-    }\n-\n-    /**\n-     * Extract and return normalized representation flow path direction.\n-     */\n-    public FlowPathDirection getDirection(Cookie cookie) {\n-        long raw = cookie.getValue();\n-        if (getField(raw, FLOW_FORWARD_DIRECTION_FLAG) != 0) {\n-            return FlowPathDirection.FORWARD;\n-        } else if (getField(raw, FLOW_REVERSE_DIRECTION_FLAG) != 0) {\n-            return FlowPathDirection.REVERSE;\n-        } else {\n-            return FlowPathDirection.UNKNOWN;\n-        }\n-    }\n-\n-    /**\n-     * Set direction bits to the value passed as directions argument.\n-     */\n-    public Cookie setDirection(Cookie cookie, FlowPathDirection direction) {\n-        int forward = 0;\n-        int reverse = 0;\n-        if (direction == FlowPathDirection.FORWARD) {\n-            forward = 1;\n-        } else if (direction == FlowPathDirection.REVERSE) {\n-            reverse = 1;\n-        } else if (direction == FlowPathDirection.UNKNOWN) {\n-            // nothing to do\n-        } else {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Unable to map %s.%s into cookie direction bits\",\n-                    FlowPathDirection.class.getSimpleName(), direction));\n-        }\n-\n-        long raw = setField(cookie.getValue(), FLOW_FORWARD_DIRECTION_FLAG, forward);\n-        raw = setField(raw, FLOW_REVERSE_DIRECTION_FLAG, reverse);\n-        return new Cookie(raw);\n-    }\n-\n-    public Cookie setFlowEffectiveId(Cookie cookie, long effectiveId) {\n-        return new Cookie(setField(cookie.getValue(), FLOW_EFFECTIVE_ID_FIELD, effectiveId));\n-    }\n-\n-    public long getFlowEffectiveId(Cookie cookie) {\n-        return getField(cookie.getValue(), FLOW_EFFECTIVE_ID_FIELD);\n-    }\n-\n-    protected FlowSegmentCookieSchema() {\n-        super();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NTgzMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404655830", "bodyText": "this need a javadoc", "author": "timofei-durakov", "createdAt": "2020-04-07T09:09:22Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nsimilarity index 52%\nrename from src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\nrename to src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fcee7e5b6..fca82724f 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -13,64 +13,100 @@\n  *   limitations under the License.\n  */\n \n-package org.openkilda.model.bitops.cookie;\n+package org.openkilda.model;\n \n import org.openkilda.exception.InvalidCookieException;\n-import org.openkilda.model.Cookie;\n import org.openkilda.model.bitops.BitField;\n import org.openkilda.model.bitops.NumericEnumField;\n \n-public abstract class CookieSchema {\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n     // update ALL_FIELDS if modify fields list\n-    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n     static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n \n-    protected abstract Cookie makeBlank();\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n \n-    public void validate(Cookie cookie) throws InvalidCookieException {\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {\n+        try {\n+            validate();\n+            return true;\n+        } catch (InvalidCookieException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void validate() throws InvalidCookieException {\n         // inheritors can implement validate logic\n     }\n \n+    @JsonValue\n+    public long getValue() {\n+        return value;\n+    }\n+\n     /**\n      * Extract and return \"type\" field.\n      */\n-    public CookieType getType(Cookie cookie) {\n-        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+    public CookieType getType() {\n+        int numericType = (int) getField(TYPE_FIELD);\n         return resolveEnum(CookieType.values(), numericType, CookieType.class);\n     }\n \n-    protected long setType(long value, CookieType type) {\n-        return setField(value, TYPE_FIELD, type.getValue());\n-    }\n-\n-    protected long getField(long value, BitField field) {\n+    protected long getField(BitField field) {\n         long payload = value & field.getMask();\n         return payload >>> field.getOffset();\n     }\n \n-    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n-        long raw = setField(cookie.getValue(), field, payload);\n-        return new Cookie(raw);\n+    @Override\n+    public String toString() {\n+        return toString(value);\n     }\n \n-    protected long setField(long value, BitField field, long payload) {\n-        long mask = field.getMask();\n-        payload <<= field.getOffset();\n-        payload &= mask;\n-        return (value & ~mask) | payload;\n+    @Deprecated\n+    public static String toString(long cookie) {\n+        return String.format(\"0x%016X\", cookie);\n+    }\n+\n+    protected int cookieComparison(CookieBase other) {\n+        return Long.compare(value, other.value);\n     }\n \n-    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n-        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+    protected void validateServiceFlag(boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(SERVICE_FLAG) != 0;\n         if (expectedValue != actual) {\n             throw new InvalidCookieException(\n-                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), this);\n         }\n     }\n \n+    /**\n+     * Scan all enum elements and compare their numberic representation with {@code needle} argument. Returns matched\n+     * enum element.\n+     */\n     protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n         for (T entry : valuesSpace) {\n             if (entry.getValue() == needle) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1OTA1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r404659055", "bodyText": "No java doc", "author": "timofei-durakov", "createdAt": "2020-04-07T09:14:25Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\nindex 23bddcc68..a7e0be025 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\n\n@@ -19,6 +19,9 @@ import org.openkilda.model.Cookie;\n \n import lombok.Getter;\n \n+/**\n+ * Represent bit-mask and offset of continuous(without 0 in the middle) bit-field.\n+ */\n @Getter\n public class BitField {\n     private final long mask;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0ODI5OA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405348298", "bodyText": "nit: This could be a part of the generatedMap.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T08:29:11Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java", "diffHunk": "@@ -97,25 +99,18 @@\n      * Note: you have to additionally set {@link org.openkilda.wfm.share.history.model.FlowDumpData.DumpType}\n      * to the dump data.\n      */\n-    @Mapping(target = \"sourceSwitch\", expression = \"java(flow.getSrcSwitch().getSwitchId())\")\n-    @Mapping(target = \"destinationSwitch\", expression = \"java(flow.getDestSwitch().getSwitchId())\")\n-    @Mapping(source = \"flow.srcPort\", target = \"sourcePort\")\n-    @Mapping(source = \"flow.destPort\", target = \"destinationPort\")\n-    @Mapping(source = \"flow.srcVlan\", target = \"sourceVlan\")\n-    @Mapping(source = \"flow.destVlan\", target = \"destinationVlan\")\n-    @Mapping(source = \"flow.flowId\", target = \"flowId\")\n-    @Mapping(source = \"flow.bandwidth\", target = \"bandwidth\")\n-    @Mapping(source = \"flow.ignoreBandwidth\", target = \"ignoreBandwidth\")\n-    @Mapping(target = \"forwardCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildForwardCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(target = \"reverseCookie\", expression =\n-            \"java(org.openkilda.model.Cookie.buildReverseCookie(resources.getUnmaskedCookie()))\")\n-    @Mapping(source = \"resources.forward.meterId\", target = \"forwardMeterId\")\n-    @Mapping(source = \"resources.reverse.meterId\", target = \"reverseMeterId\")\n-    @Mapping(source = \"dumpType\", target = \"dumpType\")\n-    @BeanMapping(ignoreByDefault = true)\n-    public abstract FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType);\n+    public FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType) {\n+        FlowDumpData result = generatedMap(flow, resources, dumpType);\n+\n+        result.setSourceSwitch(flow.getSrcSwitch().getSwitchId());", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMDAwMw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406810003", "bodyText": "moved.", "author": "surabujin", "createdAt": "2020-04-10T15:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0ODI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java\nindex 3426df284..47bf6774a 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/HistoryMapper.java\n\n@@ -102,12 +102,10 @@ public abstract class HistoryMapper {\n     public FlowDumpData map(Flow flow, FlowResources resources, DumpType dumpType) {\n         FlowDumpData result = generatedMap(flow, resources, dumpType);\n \n-        result.setSourceSwitch(flow.getSrcSwitch().getSwitchId());\n-        result.setDestinationSwitch(flow.getDestSwitch().getSwitchId());\n-\n-        Cookie blank = FlowSegmentCookieSchema.INSTANCE.make(resources.getUnmaskedCookie());\n-        result.setForwardCookie(FlowSegmentCookieSchema.INSTANCE.setDirection(blank, FlowPathDirection.FORWARD));\n-        result.setReverseCookie(FlowSegmentCookieSchema.INSTANCE.setDirection(blank, FlowPathDirection.REVERSE));\n+        FlowSegmentCookieBuilder cookieBuilder = FlowSegmentCookie.builder()\n+                .flowEffectiveId(resources.getUnmaskedCookie());\n+        result.setForwardCookie(cookieBuilder.direction(FlowPathDirection.FORWARD).build());\n+        result.setReverseCookie(cookieBuilder.direction(FlowPathDirection.REVERSE).build());\n \n         return result;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MDY5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405440692", "bodyText": "nit: although there's no such rule in OpenKilda code convention, comparing of enum values in reverse argument order (CookieType.XYZ == cookieType instead of cookieType == CookieType.XYZ) is a controversial practice, which has no benefits but leads to poor readability. BTW, the sonar rule doesn't list this variant as a compliant one - https://rules.sonarsource.com/java/RSPEC-4551", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:03:06Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -710,27 +714,27 @@ private Long processInstallDefaultFlowByCookie(SwitchId switchId, long cookie) t\n             return switchManager.installArpPostIngressOneSwitchFlow(dpid);\n         } else if (cookie == ARP_TRANSIT_COOKIE) {\n             return switchManager.installArpTransitFlow(dpid);\n-        } else if (Cookie.isIngressRulePassThrough(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_INGRESS_RULES == cookieType) {\n+            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n             return switchManager.installIntermediateIngressRule(dpid, (int) port);\n-        } else if (Cookie.isIslVlanEgress(cookie)) {\n-            long port = Cookie.getValueFromIntermediateCookie(cookie);\n+        } else if (CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES == cookieType) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMjU5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406812595", "bodyText": "Don't see any difference in readability - in any case you must read both sides of ==. Swapped.", "author": "surabujin", "createdAt": "2020-04-10T15:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MDY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\nindex 2218448ee..9450a14c9 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java\n\n@@ -714,24 +715,18 @@ class RecordHandler implements Runnable {\n             return switchManager.installArpPostIngressOneSwitchFlow(dpid);\n         } else if (cookie == ARP_TRANSIT_COOKIE) {\n             return switchManager.installArpTransitFlow(dpid);\n-        } else if (CookieType.MULTI_TABLE_INGRESS_RULES == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installIntermediateIngressRule(dpid, (int) port);\n-        } else if (CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installEgressIslVlanRule(dpid, (int) port);\n-        } else if (CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installTransitIslVxlanRule(dpid, (int) port);\n-        } else if (CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installEgressIslVxlanRule(dpid, (int) port);\n-        } else if (CookieType.LLDP_INPUT_CUSTOMER_TYPE == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installLldpInputCustomerFlow(dpid, (int) port);\n-        } else if (CookieType.ARP_INPUT_CUSTOMER_TYPE == cookieType) {\n-            long port = ServiceCookieSchema.INSTANCE.getUniqueId(encodedCookie);\n-            return switchManager.installArpInputCustomerFlow(dpid, (int) port);\n+        } else if (cookieType == CookieType.MULTI_TABLE_INGRESS_RULES) {\n+            return switchManager.installIntermediateIngressRule(dpid, portColourCookie.getPortNumber());\n+        } else if (cookieType == CookieType.MULTI_TABLE_ISL_VLAN_EGRESS_RULES) {\n+            return switchManager.installEgressIslVlanRule(dpid, portColourCookie.getPortNumber());\n+        } else if (cookieType == CookieType.MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES) {\n+            return switchManager.installTransitIslVxlanRule(dpid, portColourCookie.getPortNumber());\n+        } else if (cookieType == CookieType.MULTI_TABLE_ISL_VXLAN_EGRESS_RULES) {\n+            return switchManager.installEgressIslVxlanRule(dpid, portColourCookie.getPortNumber());\n+        } else if (cookieType == CookieType.LLDP_INPUT_CUSTOMER_TYPE) {\n+            return switchManager.installLldpInputCustomerFlow(dpid, portColourCookie.getPortNumber());\n+        } else if (cookieType == CookieType.ARP_INPUT_CUSTOMER_TYPE) {\n+            return switchManager.installArpInputCustomerFlow(dpid, portColourCookie.getPortNumber());\n         } else {\n             logger.warn(\"Skipping the installation of unexpected default switch rule {} for switch {}\",\n                     encodedCookie, switchId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzY3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405443679", "bodyText": "Please, don't use internal or library-specific collection classes. In addition to standard java collections, we have 2 libraries in dependencies: apache commons and guava.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:09:06Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxMzE3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406813172", "bodyText": "It was not intentional.", "author": "surabujin", "createdAt": "2020-04-10T15:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0MzY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\nindex 7fb64ebbb..6c7fdfe3a 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\n\n@@ -30,18 +30,18 @@ import org.openkilda.messaging.info.InfoMessage;\n import org.openkilda.messaging.info.event.ArpInfoData;\n import org.openkilda.messaging.info.event.LldpInfoData;\n import org.openkilda.model.Cookie;\n+import org.openkilda.model.ServiceCookie;\n+import org.openkilda.model.ServiceCookie.ServiceCookieTag;\n import org.openkilda.model.SwitchId;\n-import org.openkilda.model.bitops.cookie.ServiceCookieSchema;\n-import org.openkilda.model.bitops.cookie.ServiceCookieSchema.ServiceCookieTag;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n import lombok.Value;\n import net.floodlightcontroller.core.module.FloodlightModuleContext;\n import net.floodlightcontroller.packet.ARP;\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n-import org.mapstruct.ap.internal.util.Collections;\n import org.projectfloodlight.openflow.protocol.OFType;\n import org.projectfloodlight.openflow.types.U64;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ0ODQ5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405448496", "bodyText": "If this is supposed to be a constant, then use an unmodifiable set and name the field in upper-case. Please, check guava's ImmutableSet.of.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:18:53Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java", "diffHunk": "@@ -52,17 +41,35 @@\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n+import org.mapstruct.ap.internal.util.Collections;\n import org.projectfloodlight.openflow.protocol.OFType;\n import org.projectfloodlight.openflow.types.U64;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Set;\n \n public class ConnectedDevicesService implements IService, IInputTranslator {\n     private static final Logger logger = LoggerFactory.getLogger(ConnectedDevicesService.class);\n \n+    private static final Set<ServiceCookieTag> lldpServiceTags = Collections.asSet(", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\nindex 7fb64ebbb..6c7fdfe3a 100644\n--- a/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\n+++ b/src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/service/connected/ConnectedDevicesService.java\n\n@@ -30,18 +30,18 @@ import org.openkilda.messaging.info.InfoMessage;\n import org.openkilda.messaging.info.event.ArpInfoData;\n import org.openkilda.messaging.info.event.LldpInfoData;\n import org.openkilda.model.Cookie;\n+import org.openkilda.model.ServiceCookie;\n+import org.openkilda.model.ServiceCookie.ServiceCookieTag;\n import org.openkilda.model.SwitchId;\n-import org.openkilda.model.bitops.cookie.ServiceCookieSchema;\n-import org.openkilda.model.bitops.cookie.ServiceCookieSchema.ServiceCookieTag;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n import lombok.Value;\n import net.floodlightcontroller.core.module.FloodlightModuleContext;\n import net.floodlightcontroller.packet.ARP;\n import net.floodlightcontroller.packet.Ethernet;\n import net.floodlightcontroller.packet.IPacket;\n import net.floodlightcontroller.packet.LLDP;\n-import org.mapstruct.ap.internal.util.Collections;\n import org.projectfloodlight.openflow.protocol.OFType;\n import org.projectfloodlight.openflow.types.U64;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NjM2NA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405456364", "bodyText": "What does the blank cookie mean from business logic standpoint? Shouldn't this be some kind of cookie builder?", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:34:40Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java", "diffHunk": "@@ -190,12 +192,17 @@ protected boolean isNotSamePath(PathPair pathPair, FlowPathPair flowPathPair) {\n \n     protected FlowPathPair createFlowPathPair(Flow flow, FlowPathPair pathsToReuseBandwidth,\n                                               PathPair pathPair, FlowResources flowResources) {\n-        long cookie = flowResources.getUnmaskedCookie();\n-        FlowPath newForwardPath = flowPathBuilder.buildFlowPath(flow, flowResources.getForward(),\n-                pathPair.getForward(), Cookie.buildForwardCookie(cookie));\n+        Cookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java\nindex 0d56d93ba..28bd5ef13 100644\n--- a/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java\n+++ b/src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/common/actions/BaseResourceAllocationAction.java\n\n@@ -192,17 +192,16 @@ public abstract class BaseResourceAllocationAction<T extends FlowPathSwappingFsm\n \n     protected FlowPathPair createFlowPathPair(Flow flow, FlowPathPair pathsToReuseBandwidth,\n                                               PathPair pathPair, FlowResources flowResources) {\n-        Cookie blank = FlowSegmentCookieSchema.INSTANCE.makeBlank();\n-        Cookie flowCookie = FlowSegmentCookieSchema.INSTANCE.setFlowEffectiveId(\n-                blank, flowResources.getUnmaskedCookie());\n+        final FlowSegmentCookieBuilder cookieBuilder = FlowSegmentCookie.builder()\n+                .flowEffectiveId(flowResources.getUnmaskedCookie());\n \n         FlowPath newForwardPath = flowPathBuilder.buildFlowPath(\n                 flow, flowResources.getForward(), pathPair.getForward(),\n-                FlowSegmentCookieSchema.INSTANCE.setDirection(flowCookie, FlowPathDirection.FORWARD));\n+                cookieBuilder.direction(FlowPathDirection.FORWARD).build());\n         newForwardPath.setStatus(FlowPathStatus.IN_PROGRESS);\n         FlowPath newReversePath = flowPathBuilder.buildFlowPath(\n                 flow, flowResources.getReverse(), pathPair.getReverse(),\n-                FlowSegmentCookieSchema.INSTANCE.setDirection(flowCookie, FlowPathDirection.REVERSE));\n+                cookieBuilder.direction(FlowPathDirection.REVERSE).build());\n         newReversePath.setStatus(FlowPathStatus.IN_PROGRESS);\n         FlowPathPair newFlowPaths = FlowPathPair.builder().forward(newForwardPath).reverse(newReversePath).build();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405465916", "bodyText": "Could you please add javadoc with some explanation why UNKNOWN path direction is available / possible in Kilda data model?\nLooks like this value was introduced just to cover a specific case when a method can't determine a cookie direction, which not a reason to introduce a new direction into the model. Null or Optional.empty() may address this.", "author": "sergii-iakovenko", "createdAt": "2020-04-08T11:53:00Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+public enum FlowPathDirection {\n+    UNKNOWN,", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxNjA1MQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406816051", "bodyText": "I can't explain why this value is possible. Up to now, we do not restrict the flow(also we do not have a separation between flow cookies and other cookies) cookie to have a specific direction. And I have no plans to add this restriction in this PR.", "author": "surabujin", "createdAt": "2020-04-10T15:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MDkzNw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408690937", "bodyText": "Ok, then I'd call those cookies as with \"unspecified\" direction rather than UNKNOWN. The current version (UNKNOWN) sounds like we can't determine it for some reason...", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMDEyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409400120", "bodyText": "Renamed to \"UNDEFINED\".", "author": "surabujin", "createdAt": "2020-04-16T09:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTkxNg=="}], "type": "inlineReview", "revised_code": {"commit": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java b/src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java\nindex eb6d8271c..e6c5aa25b 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/FlowPathDirection.java\n\n@@ -16,7 +16,11 @@\n package org.openkilda.model;\n \n public enum FlowPathDirection {\n-    UNKNOWN,\n+    /**\n+     * At this moment there is no strict requirement to define direction bit in {@link FlowSegmentCookie} so direction\n+     * can be undefined.\n+     */\n+    UNDEFINED,\n     FORWARD,\n     REVERSE\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405477819", "bodyText": "nit: Can't this be just as following?\nif (mask == 0) throw new IllegalArgumentException(\"Bit field mask must not be 0\");\nlong theBit = Long.lowestOneBit(mask);\nif (theBit != mask) throw new IllegalArgumentException(\"Illegal bit field mask\");\noffset = Long.numberOfTrailingZeros(theBit) + 1;", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:14:17Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops;\n+\n+import org.openkilda.model.Cookie;\n+\n+import lombok.Getter;\n+\n+@Getter\n+public class BitField {\n+    private final long mask;\n+    private final int offset;\n+\n+    public BitField(long mask) {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjU4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406826586", "bodyText": "Long.lowestOneBit(mask) return one lowest bit, so this approach fails for any bit field(mask) longer than 1 bit.", "author": "surabujin", "createdAt": "2020-04-10T16:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NDgyMA==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408694820", "bodyText": "Got it.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3NzgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\nindex 23bddcc68..a7e0be025 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/BitField.java\n\n@@ -19,6 +19,9 @@ import org.openkilda.model.Cookie;\n \n import lombok.Getter;\n \n+/**\n+ * Represent bit-mask and offset of continuous(without 0 in the middle) bit-field.\n+ */\n @Getter\n public class BitField {\n     private final long mask;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405479856", "bodyText": "Why did CookieSchema become a part of the bitops package? Shouldn't it be on the same level as the cookie entity? I'd propose to move the cookie and cookie schema under \"org.openkilda.model.cookie\".", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:18:04Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzg4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r406827885", "bodyText": "Move Cookie class and all related classes into org.openkilda.model.cookie was my initial idea. But it produces so huge change, that I have decided to do it in some late and as a PR that contains class movements only.", "author": "surabujin", "createdAt": "2020-04-10T16:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NTI0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408695245", "bodyText": "Ok", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3OTg1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nsimilarity index 52%\nrename from src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\nrename to src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fcee7e5b6..fca82724f 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -13,64 +13,100 @@\n  *   limitations under the License.\n  */\n \n-package org.openkilda.model.bitops.cookie;\n+package org.openkilda.model;\n \n import org.openkilda.exception.InvalidCookieException;\n-import org.openkilda.model.Cookie;\n import org.openkilda.model.bitops.BitField;\n import org.openkilda.model.bitops.NumericEnumField;\n \n-public abstract class CookieSchema {\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n     // update ALL_FIELDS if modify fields list\n-    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n     static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n \n-    protected abstract Cookie makeBlank();\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n \n-    public void validate(Cookie cookie) throws InvalidCookieException {\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {\n+        try {\n+            validate();\n+            return true;\n+        } catch (InvalidCookieException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void validate() throws InvalidCookieException {\n         // inheritors can implement validate logic\n     }\n \n+    @JsonValue\n+    public long getValue() {\n+        return value;\n+    }\n+\n     /**\n      * Extract and return \"type\" field.\n      */\n-    public CookieType getType(Cookie cookie) {\n-        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+    public CookieType getType() {\n+        int numericType = (int) getField(TYPE_FIELD);\n         return resolveEnum(CookieType.values(), numericType, CookieType.class);\n     }\n \n-    protected long setType(long value, CookieType type) {\n-        return setField(value, TYPE_FIELD, type.getValue());\n-    }\n-\n-    protected long getField(long value, BitField field) {\n+    protected long getField(BitField field) {\n         long payload = value & field.getMask();\n         return payload >>> field.getOffset();\n     }\n \n-    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n-        long raw = setField(cookie.getValue(), field, payload);\n-        return new Cookie(raw);\n+    @Override\n+    public String toString() {\n+        return toString(value);\n     }\n \n-    protected long setField(long value, BitField field, long payload) {\n-        long mask = field.getMask();\n-        payload <<= field.getOffset();\n-        payload &= mask;\n-        return (value & ~mask) | payload;\n+    @Deprecated\n+    public static String toString(long cookie) {\n+        return String.format(\"0x%016X\", cookie);\n+    }\n+\n+    protected int cookieComparison(CookieBase other) {\n+        return Long.compare(value, other.value);\n     }\n \n-    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n-        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+    protected void validateServiceFlag(boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(SERVICE_FLAG) != 0;\n         if (expectedValue != actual) {\n             throw new InvalidCookieException(\n-                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), this);\n         }\n     }\n \n+    /**\n+     * Scan all enum elements and compare their numberic representation with {@code needle} argument. Returns matched\n+     * enum element.\n+     */\n     protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n         for (T entry : valuesSpace) {\n             if (entry.getValue() == needle) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ5NjkyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r405496925", "bodyText": "nit: where is @OverRide?", "author": "sergii-iakovenko", "createdAt": "2020-04-08T12:47:20Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model.bitops.cookie;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.Cookie;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+public abstract class CookieSchema {\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    protected abstract Cookie makeBlank();\n+\n+    public void validate(Cookie cookie) throws InvalidCookieException {\n+        // inheritors can implement validate logic\n+    }\n+\n+    /**\n+     * Extract and return \"type\" field.\n+     */\n+    public CookieType getType(Cookie cookie) {\n+        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+        return resolveEnum(CookieType.values(), numericType, CookieType.class);\n+    }\n+\n+    protected long setType(long value, CookieType type) {\n+        return setField(value, TYPE_FIELD, type.getValue());\n+    }\n+\n+    protected long getField(long value, BitField field) {\n+        long payload = value & field.getMask();\n+        return payload >>> field.getOffset();\n+    }\n+\n+    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n+        long raw = setField(cookie.getValue(), field, payload);\n+        return new Cookie(raw);\n+    }\n+\n+    protected long setField(long value, BitField field, long payload) {\n+        long mask = field.getMask();\n+        payload <<= field.getOffset();\n+        payload &= mask;\n+        return (value & ~mask) | payload;\n+    }\n+\n+    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+        if (expectedValue != actual) {\n+            throw new InvalidCookieException(\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+        }\n+    }\n+\n+    protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n+        for (T entry : valuesSpace) {\n+            if (entry.getValue() == needle) {\n+                return entry;\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(String.format(\n+                \"Unable to map value %x value into %s value\", needle, typeRef.getSimpleName()));\n+    }\n+\n+    // 9 bit long type field\n+    public enum CookieType implements NumericEnumField {\n+        SERVICE_OR_FLOW_SEGMENT(0x000),\n+        LLDP_INPUT_CUSTOMER_TYPE(0x001),\n+        MULTI_TABLE_ISL_VLAN_EGRESS_RULES(0x002),\n+        MULTI_TABLE_ISL_VXLAN_EGRESS_RULES(0x003),\n+        MULTI_TABLE_ISL_VXLAN_TRANSIT_RULES(0x004),\n+        MULTI_TABLE_INGRESS_RULES(0x005),\n+        ARP_INPUT_CUSTOMER_TYPE(0x006),\n+        INGRESS_SEGMENT(0x007),   // used for ingress flow segment and for one switch flow segments\n+        SHARED_OF_FLOW(0x008);\n+\n+        private int value;\n+\n+        CookieType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int getValue() {", "originalCommit": "16ba3a6a83e38ad5fb0826f172fb9bab12c519ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d18950867d8d842cfbda875554772e850533ec88", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nsimilarity index 52%\nrename from src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\nrename to src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fcee7e5b6..fca82724f 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/bitops/cookie/CookieSchema.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -13,64 +13,100 @@\n  *   limitations under the License.\n  */\n \n-package org.openkilda.model.bitops.cookie;\n+package org.openkilda.model;\n \n import org.openkilda.exception.InvalidCookieException;\n-import org.openkilda.model.Cookie;\n import org.openkilda.model.bitops.BitField;\n import org.openkilda.model.bitops.NumericEnumField;\n \n-public abstract class CookieSchema {\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n     // update ALL_FIELDS if modify fields list\n-    static final BitField TYPE_FIELD   = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n     static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n \n     // used by unit tests to check fields intersections\n     static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n \n-    protected abstract Cookie makeBlank();\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n \n-    public void validate(Cookie cookie) throws InvalidCookieException {\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {\n+        try {\n+            validate();\n+            return true;\n+        } catch (InvalidCookieException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void validate() throws InvalidCookieException {\n         // inheritors can implement validate logic\n     }\n \n+    @JsonValue\n+    public long getValue() {\n+        return value;\n+    }\n+\n     /**\n      * Extract and return \"type\" field.\n      */\n-    public CookieType getType(Cookie cookie) {\n-        int numericType = (int) getField(cookie.getValue(), TYPE_FIELD);\n+    public CookieType getType() {\n+        int numericType = (int) getField(TYPE_FIELD);\n         return resolveEnum(CookieType.values(), numericType, CookieType.class);\n     }\n \n-    protected long setType(long value, CookieType type) {\n-        return setField(value, TYPE_FIELD, type.getValue());\n-    }\n-\n-    protected long getField(long value, BitField field) {\n+    protected long getField(BitField field) {\n         long payload = value & field.getMask();\n         return payload >>> field.getOffset();\n     }\n \n-    protected Cookie setField(Cookie cookie, BitField field, long payload) {\n-        long raw = setField(cookie.getValue(), field, payload);\n-        return new Cookie(raw);\n+    @Override\n+    public String toString() {\n+        return toString(value);\n     }\n \n-    protected long setField(long value, BitField field, long payload) {\n-        long mask = field.getMask();\n-        payload <<= field.getOffset();\n-        payload &= mask;\n-        return (value & ~mask) | payload;\n+    @Deprecated\n+    public static String toString(long cookie) {\n+        return String.format(\"0x%016X\", cookie);\n+    }\n+\n+    protected int cookieComparison(CookieBase other) {\n+        return Long.compare(value, other.value);\n     }\n \n-    protected void validateServiceFlag(Cookie cookie, boolean expectedValue) throws InvalidCookieException {\n-        boolean actual = getField(cookie.getValue(), SERVICE_FLAG) != 0;\n+    protected void validateServiceFlag(boolean expectedValue) throws InvalidCookieException {\n+        boolean actual = getField(SERVICE_FLAG) != 0;\n         if (expectedValue != actual) {\n             throw new InvalidCookieException(\n-                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), cookie);\n+                    String.format(\"Service flag is expected to be %s\", expectedValue ? \"set\" : \"unset\"), this);\n         }\n     }\n \n+    /**\n+     * Scan all enum elements and compare their numberic representation with {@code needle} argument. Returns matched\n+     * enum element.\n+     */\n     protected static <T extends NumericEnumField> T resolveEnum(T[] valuesSpace, long needle, Class<T> typeRef) {\n         for (T entry : valuesSpace) {\n             if (entry.getValue() == needle) {\n"}}, {"oid": "d18950867d8d842cfbda875554772e850533ec88", "url": "https://github.com/telstra/open-kilda/commit/d18950867d8d842cfbda875554772e850533ec88", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-10T19:50:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5ODQwNw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408698407", "bodyText": "It makes sense to declare the class as abstract. No need to allow instantiating it.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:16:23Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMTQxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409401415", "bodyText": "done", "author": "surabujin", "createdAt": "2020-04-16T09:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5ODQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fca82724f..3566eeea4 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -27,7 +27,7 @@ import java.util.Set;\n import java.util.stream.Collectors;\n \n @EqualsAndHashCode(of = {\"value\"})\n-public class CookieBase implements Serializable {\n+public abstract class CookieBase implements Serializable {\n     private static final long serialVersionUID = 1L;\n \n     // update ALL_FIELDS if modify fields list\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408701747", "bodyText": "You can allow the builder to set both value and type, but as for now use only the type.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:22:05Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwNzIwNg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409407206", "bodyText": "Em... why for? This 2 different use cases - one \"restore\" cookie from the raw value (direct new Cookie(raw) call) and another build new cookie from fields provided by the app (builder way). I do not want to add value field into the builder, to will make it less obvious.", "author": "surabujin", "createdAt": "2020-04-16T09:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMDM3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r412630372", "bodyText": "Got it.", "author": "sergii-iakovenko", "createdAt": "2020-04-22T02:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMTc0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\nindex e93be7d30..9fbd1e380 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n\n@@ -107,8 +107,8 @@ public class Cookie extends CookieBase implements Comparable<Cookie> {\n                 .type(getType());\n     }\n \n-    protected Cookie(long blank, CookieType type) {\n-        super(blank, type);\n+    protected Cookie(long value, CookieType type) {\n+        super(value, type);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjI0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408702245", "bodyText": "Why is the value called \"blank\"?", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:22:49Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java", "diffHunk": "@@ -44,102 +38,133 @@\n  * 5 - Multi-table customer flow rule for ingress table pass-through\n  * </p>\n  */\n-@Value\n-public class Cookie implements Comparable<Cookie>, Serializable {\n-    private static final long serialVersionUID = 1L;\n-\n-    public static final long DEFAULT_RULE_FLAG                   = 0x8000_0000_0000_0000L;\n-    public static final long FLOW_PATH_FORWARD_FLAG              = 0x4000_0000_0000_0000L;\n-    public static final long FLOW_PATH_REVERSE_FLAG              = 0x2000_0000_0000_0000L;\n-\n-    // There is no alive system that use this deprecated direction flags so it should be save to drop it.\n-    @Deprecated\n-    public static final long DEPRECATED_FLOW_PATH_DIRECTION_FLAG = 0x0080_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_VALUE_MASK              = 0x0000_0000_000F_FFFFL;\n-    public static final long ISL_COOKIE_VALUE_MASK               = 0x0000_0000_000F_FFFFL;\n-    public static final long INGRESS_RULE_COOKIE_VALUE_MASK      = 0x0000_0000_000F_FFFFL;\n-\n-    public static final long DROP_RULE_COOKIE                           = 0x01L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_BROADCAST_RULE_COOKIE         = 0x02L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_RULE_COOKIE           = 0x03L | DEFAULT_RULE_FLAG;\n-    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE         = 0x04L | DEFAULT_RULE_FLAG;\n-    public static final long CATCH_BFD_RULE_COOKIE                      = 0x05L | DEFAULT_RULE_FLAG;\n-    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE             = 0x06L | DEFAULT_RULE_FLAG;\n-    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE     = 0x07L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = 0x08L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_INGRESS_DROP_COOKIE             = 0x09L | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE        = 0x0AL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE      = 0x0BL | DEFAULT_RULE_FLAG;\n-    public static final long MULTITABLE_TRANSIT_DROP_COOKIE             = 0x0CL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INPUT_PRE_DROP_COOKIE                 = 0x0DL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_TRANSIT_COOKIE                        = 0x0EL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_INGRESS_COOKIE                        = 0x0FL | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_COOKIE                   = 0x10L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE             = 0x11L | DEFAULT_RULE_FLAG;\n-    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE        = 0x12L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INPUT_PRE_DROP_COOKIE                  = 0x13L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_TRANSIT_COOKIE                         = 0x14L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_INGRESS_COOKIE                         = 0x15L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_COOKIE                    = 0x16L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_VXLAN_COOKIE              = 0x17L | DEFAULT_RULE_FLAG;\n-    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE         = 0x18L | DEFAULT_RULE_FLAG;\n+public class Cookie extends CookieBase implements Comparable<Cookie> {\n+    // FIXME(surabujin): get rid from this constants (it will allow to merge CookieBase into Cookie)\n+    public static final long DROP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_BROADCAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_BROADCAST_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_RULE_COOKIE).getValue();\n+    public static final long DROP_VERIFICATION_LOOP_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.DROP_VERIFICATION_LOOP_RULE_COOKIE).getValue();\n+    public static final long CATCH_BFD_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.CATCH_BFD_RULE_COOKIE).getValue();\n+    public static final long ROUND_TRIP_LATENCY_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ROUND_TRIP_LATENCY_RULE_COOKIE).getValue();\n+    public static final long VERIFICATION_UNICAST_VXLAN_RULE_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.VERIFICATION_UNICAST_VXLAN_RULE_COOKIE).getValue();\n+    public static final long MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_PRE_INGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_POST_INGRESS_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_POST_INGRESS_DROP_COOKIE).getValue();\n+    public static final long MULTITABLE_EGRESS_PASS_THROUGH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_EGRESS_PASS_THROUGH_COOKIE).getValue();\n+    public static final long MULTITABLE_TRANSIT_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.MULTITABLE_TRANSIT_DROP_COOKIE).getValue();\n+    public static final long LLDP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long LLDP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_TRANSIT_COOKIE).getValue();\n+    public static final long LLDP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long LLDP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.LLDP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n+    public static final long ARP_INPUT_PRE_DROP_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INPUT_PRE_DROP_COOKIE).getValue();\n+    public static final long ARP_TRANSIT_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_TRANSIT_COOKIE).getValue();\n+    public static final long ARP_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_VXLAN_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_VXLAN_COOKIE).getValue();\n+    public static final long ARP_POST_INGRESS_ONE_SWITCH_COOKIE = new ServiceCookie(\n+            ServiceCookie.ServiceCookieTag.ARP_POST_INGRESS_ONE_SWITCH_COOKIE).getValue();\n \n-    // 9 bits cookie type \"field\"\n-    public static final long TYPE_MASK                               = 0x1FF0_0000_0000_0000L;\n-    public static final long FLOW_COOKIE_TYPE                        = 0x0000_0000_0000_0000L;\n-    public static final long LLDP_INPUT_CUSTOMER_TYPE                = 0x0010_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VLAN_EGRESS_RULES_TYPE   = 0x0020_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_EGRESS_RULES_TYPE  = 0x0030_0000_0000_0000L;\n-    public static final long MULTITABLE_ISL_VXLAN_TRANSIT_RULES_TYPE = 0x0040_0000_0000_0000L;\n-    public static final long MULTITABLE_INGRESS_RULES_TYPE           = 0x0050_0000_0000_0000L;\n-    public static final long ARP_INPUT_CUSTOMER_TYPE                 = 0x0060_0000_0000_0000L;\n+    @JsonCreator\n+    public Cookie(long value) {\n+        super(value);\n+    }\n \n-    private final long value;\n+    @Builder\n+    public Cookie(CookieType type) {\n+        super(0, type);\n+    }\n \n     /**\n-     * Create {@code Cookie} instance and perform it's validation.\n+     * Conver existing {@link Cookie} instance into {@link CookieBuilder}.\n      */\n-    public static Cookie decode(long rawValue) {\n-        Cookie cookie = new Cookie(rawValue);\n-        cookie.ensureNoFlagsConflicts();\n-        return cookie;\n+    public CookieBuilder toBuilder() {\n+        return new CookieBuilder()\n+                .type(getType());\n     }\n \n-    @JsonCreator\n-    public Cookie(long value) {\n-        this.value = value;\n-    }\n-\n-    public static Cookie buildForwardCookie(long unmaskedCookie) {\n-        return new Cookie(unmaskedCookie | Cookie.FLOW_PATH_FORWARD_FLAG);\n+    protected Cookie(long blank, CookieType type) {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxODUxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409418515", "bodyText": "Because it is incomplete yet... Can't find normal name for this argument. If not blank only stub is coming to the mind. Renamed it into value :(", "author": "surabujin", "createdAt": "2020-04-16T09:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwMjI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\nindex e93be7d30..9fbd1e380 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/Cookie.java\n\n@@ -107,8 +107,8 @@ public class Cookie extends CookieBase implements Comparable<Cookie> {\n                 .type(getType());\n     }\n \n-    protected Cookie(long blank, CookieType type) {\n-        super(blank, type);\n+    protected Cookie(long value, CookieType type) {\n+        super(value, type);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDY0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r408704649", "bodyText": "nit: I'd call it \"isValid\" and swap with \"validate\" to be overwritten by inheritors.", "author": "sergii-iakovenko", "createdAt": "2020-04-15T09:26:46Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.model;\n+\n+import org.openkilda.exception.InvalidCookieException;\n+import org.openkilda.model.bitops.BitField;\n+import org.openkilda.model.bitops.NumericEnumField;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import lombok.EqualsAndHashCode;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@EqualsAndHashCode(of = {\"value\"})\n+public class CookieBase implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    // update ALL_FIELDS if modify fields list\n+    static final BitField TYPE_FIELD = new BitField(0x1FF0_0000_0000_0000L);\n+    static final BitField SERVICE_FLAG = new BitField(0x8000_0000_0000_0000L);\n+\n+    // used by unit tests to check fields intersections\n+    static final BitField[] ALL_FIELDS = new BitField[]{SERVICE_FLAG, TYPE_FIELD};\n+\n+    private final long value;\n+\n+    CookieBase(long value) {\n+        this.value = value;\n+    }\n+\n+    protected CookieBase(long blank, CookieType type) {\n+        value = setField(blank, TYPE_FIELD, type.getValue());\n+    }\n+\n+    /**\n+     * Validate cookie value without throwing exception in case of validation fail, but returning {@code false} result.\n+     */\n+    public boolean safeValidate() {", "originalCommit": "d18950867d8d842cfbda875554772e850533ec88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQyODQ3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3313#discussion_r409428471", "bodyText": "In this case it can't report what exactly goes wrong (not this info brought with exception raised by validate).\nPS safeValidate renamed into isValid.", "author": "surabujin", "createdAt": "2020-04-16T09:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "chunk": "diff --git a/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\nindex fca82724f..3566eeea4 100644\n--- a/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n+++ b/src-java/kilda-model/src/main/java/org/openkilda/model/CookieBase.java\n\n@@ -27,7 +27,7 @@ import java.util.Set;\n import java.util.stream.Collectors;\n \n @EqualsAndHashCode(of = {\"value\"})\n-public class CookieBase implements Serializable {\n+public abstract class CookieBase implements Serializable {\n     private static final long serialVersionUID = 1L;\n \n     // update ALL_FIELDS if modify fields list\n"}}, {"oid": "72ec444294b5826d0b25ba4e1bddec7cad08452a", "url": "https://github.com/telstra/open-kilda/commit/72ec444294b5826d0b25ba4e1bddec7cad08452a", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-16T10:09:55Z", "type": "forcePushed"}, {"oid": "ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "url": "https://github.com/telstra/open-kilda/commit/ab215549cabd075f8736e2d5efd41c1fd1b8a2d1", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-21T10:28:48Z", "type": "forcePushed"}, {"oid": "9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "url": "https://github.com/telstra/open-kilda/commit/9fcf126a66db8bbe254862ed4d2ce4bd3be23c22", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-21T10:39:55Z", "type": "forcePushed"}, {"oid": "c55abc7650b8adfd5e68f95844deac4c502e511e", "url": "https://github.com/telstra/open-kilda/commit/c55abc7650b8adfd5e68f95844deac4c502e511e", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-23T13:00:05Z", "type": "forcePushed"}, {"oid": "716fb4d1429b877edd0916e708bf5ce222b3ed59", "url": "https://github.com/telstra/open-kilda/commit/716fb4d1429b877edd0916e708bf5ce222b3ed59", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-23T13:55:31Z", "type": "forcePushed"}, {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-24T08:02:43Z", "type": "commit"}, {"oid": "274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "url": "https://github.com/telstra/open-kilda/commit/274fb37f9a52685e00edb5ab9351e8ed6e3bda94", "message": "Toolset for cookie bit manipulations\n\nDecouple different kind of cookies biit layout intto different\ntools(schemas).", "committedDate": "2020-04-24T08:02:43Z", "type": "forcePushed"}]}