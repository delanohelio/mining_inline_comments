{"pr_number": 3508, "pr_title": "Implement persistence layer for OrientDB", "pr_createdAt": "2020-05-27T00:35:27Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3508", "timeline": [{"oid": "9d15000458fac9ae7a32dea3b04dc1825b958373", "url": "https://github.com/telstra/open-kilda/commit/9d15000458fac9ae7a32dea3b04dc1825b958373", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-27T14:44:17Z", "type": "forcePushed"}, {"oid": "eb6a353be243e80defc5fac66228ee021a5735a1", "url": "https://github.com/telstra/open-kilda/commit/eb6a353be243e80defc5fac66228ee021a5735a1", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-27T17:13:00Z", "type": "forcePushed"}, {"oid": "3ea477d63a2f719200462a157020494ed4e7ffcb", "url": "https://github.com/telstra/open-kilda/commit/3ea477d63a2f719200462a157020494ed4e7ffcb", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T04:05:09Z", "type": "forcePushed"}, {"oid": "eac772eed5139347e86852be9fb883d5d23f31f9", "url": "https://github.com/telstra/open-kilda/commit/eac772eed5139347e86852be9fb883d5d23f31f9", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T06:32:42Z", "type": "forcePushed"}, {"oid": "6f5d79cec07263467a5d576b32226bfb783d663b", "url": "https://github.com/telstra/open-kilda/commit/6f5d79cec07263467a5d576b32226bfb783d663b", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-05-28T10:50:29Z", "type": "forcePushed"}, {"oid": "f60f0a254e8706a451f86f104dde9be921b2625d", "url": "https://github.com/telstra/open-kilda/commit/f60f0a254e8706a451f86f104dde9be921b2625d", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-08-19T19:50:59Z", "type": "forcePushed"}, {"oid": "8d7026f35f76ba0c3f1c07f94e0d4b1d351cde9e", "url": "https://github.com/telstra/open-kilda/commit/8d7026f35f76ba0c3f1c07f94e0d4b1d351cde9e", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-02T23:06:34Z", "type": "forcePushed"}, {"oid": "8dd10e044e260b816f77dce9695219264fc6a233", "url": "https://github.com/telstra/open-kilda/commit/8dd10e044e260b816f77dce9695219264fc6a233", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-02T23:13:21Z", "type": "forcePushed"}, {"oid": "0dc30cf13bdf39cea4a745756a062e76eec429d3", "url": "https://github.com/telstra/open-kilda/commit/0dc30cf13bdf39cea4a745756a062e76eec429d3", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-08T04:31:00Z", "type": "forcePushed"}, {"oid": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "url": "https://github.com/telstra/open-kilda/commit/c84e814a5dcd272031eec9c4fcc7039d79662afb", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-09T13:01:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486375260", "bodyText": "cookie -> meter", "author": "rozdy", "createdAt": "2020-09-10T14:10:39Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java", "diffHunk": "@@ -42,60 +44,78 @@\n public class MeterPool {\n     private final TransactionManager transactionManager;\n     private final FlowMeterRepository flowMeterRepository;\n-    private final SwitchRepository switchRepository;\n \n     private final MeterId minMeterId;\n     private final MeterId maxMeterId;\n+    private final int poolSize;\n \n-    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId) {\n+    private Map<SwitchId, MeterId> nextMeters = new HashMap<>();\n+\n+    public MeterPool(PersistenceManager persistenceManager, MeterId minMeterId, MeterId maxMeterId, int poolSize) {\n         transactionManager = persistenceManager.getTransactionManager();\n         RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n         flowMeterRepository = repositoryFactory.createFlowMeterRepository();\n-        switchRepository = repositoryFactory.createSwitchRepository();\n \n         this.minMeterId = minMeterId;\n         this.maxMeterId = maxMeterId;\n+        this.poolSize = poolSize;\n     }\n \n     /**\n      * Allocates a meter for the flow path.\n      */\n+    @TransactionRequired\n     public MeterId allocate(SwitchId switchId, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            Switch theSwitch = switchRepository.findById(switchId)\n-                    .orElseThrow(() ->\n-                            new ResourceNotAvailableException(format(\"No switch for meter allocation: %s\", switchId)));\n-            return allocate(theSwitch, flowId, pathId);\n-        });\n-    }\n-\n-    /**\n-     * Allocates a meter for the flow path.\n-     */\n-    public MeterId allocate(Switch theSwitch, String flowId, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            String noMetersErrorMessage = format(\"No meter available for switch %s\", theSwitch);\n-\n-            MeterId startMeterId = new MeterId(\n-                    ResourceUtils.computeStartValue(minMeterId.getValue(), maxMeterId.getValue()));\n-            SwitchId switchId = theSwitch.getSwitchId();\n-            MeterId availableMeterId = flowMeterRepository.findUnassignedMeterId(switchId, startMeterId, maxMeterId)\n-                    .orElse(flowMeterRepository.findUnassignedMeterId(switchId, minMeterId, maxMeterId)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(noMetersErrorMessage)));\n-            if (availableMeterId.compareTo(maxMeterId) > 0) {\n-                throw new ResourceNotAvailableException(noMetersErrorMessage);\n+        MeterId nextMeter = nextMeters.get(switchId);\n+        if (nextMeter != null && nextMeter.getValue() > 0) {\n+            if (nextMeter.compareTo(maxMeterId) <= 0 && !flowMeterRepository.exists(switchId, nextMeter)) {\n+                addMeter(flowId, pathId, switchId, nextMeter);\n+                nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                return nextMeter;\n+            } else {\n+                nextMeters.remove(switchId);\n             }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (!nextMeters.containsKey(switchId)) {\n+            long numOfPools = (maxMeterId.getValue() - minMeterId.getValue()) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<MeterId> availableMeter = flowMeterRepository.findFirstUnassignedMeter(switchId,\n+                        new MeterId(minMeterId.getValue() + poolToTake * poolSize),\n+                        new MeterId(minMeterId.getValue() + (poolToTake + 1) * poolSize - 1));\n+                if (availableMeter.isPresent()) {\n+                    nextMeter = availableMeter.get();\n+                    addMeter(flowId, pathId, switchId, nextMeter);\n+                    nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n+                    return nextMeter;\n+                }\n+            }\n+            // The pool requires full scan.\n+            nextMeter = new MeterId(-1);\n+            nextMeters.put(switchId, nextMeter);\n+        }\n+        if (nextMeter != null && nextMeter.getValue() == -1) {\n+            Optional<MeterId> availableCookie = flowMeterRepository.findFirstUnassignedMeter(switchId,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODQyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038425", "bodyText": "Nice catch. Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NTI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java\nindex 242c1fd86..02f7042de 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/MeterPool.java\n\n@@ -96,10 +96,10 @@ public class MeterPool {\n             nextMeters.put(switchId, nextMeter);\n         }\n         if (nextMeter != null && nextMeter.getValue() == -1) {\n-            Optional<MeterId> availableCookie = flowMeterRepository.findFirstUnassignedMeter(switchId,\n+            Optional<MeterId> availableMeter = flowMeterRepository.findFirstUnassignedMeter(switchId,\n                     minMeterId, maxMeterId);\n-            if (availableCookie.isPresent()) {\n-                nextMeter = availableCookie.get();\n+            if (availableMeter.isPresent()) {\n+                nextMeter = availableMeter.get();\n                 addMeter(flowId, pathId, switchId, nextMeter);\n                 nextMeters.put(switchId, new MeterId(nextMeter.getValue() + 1));\n                 return nextMeter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486376331", "bodyText": "cookie -> vlan", "author": "rozdy", "createdAt": "2020-09-10T14:12:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java", "diffHunk": "@@ -60,27 +66,53 @@ public TransitVlanEncapsulation allocate(Flow flow, PathId pathId, PathId opposi\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private TransitVlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minTransitVlan, maxTransitVlan);\n-            int availableVlan = transitVlanRepository.findUnassignedTransitVlan(startValue, maxTransitVlan)\n-                    .orElse(transitVlanRepository.findUnassignedTransitVlan(minTransitVlan, maxTransitVlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vlan available\")));\n-            if (availableVlan > maxTransitVlan) {\n-                throw new ResourceNotAvailableException(\"No vlan available\");\n+        if (nextVlan > 0) {\n+            if (nextVlan <= maxTransitVlan && !transitVlanRepository.exists(nextVlan)) {\n+                return addVlan(flow, pathId, nextVlan++);\n+            } else {\n+                nextVlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVlan == 0) {\n+            long numOfPools = (maxTransitVlan - minTransitVlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = transitVlanRepository.findFirstUnassignedVlan(\n+                        minTransitVlan + (int) poolToTake * poolSize,\n+                        minTransitVlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVlan = availableVlan.get();\n+                    return addVlan(flow, pathId, nextVlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVlan = -1;\n+        }\n+        if (nextVlan == -1) {\n+            Optional<Integer> availableCookie = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODgyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488038825", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NjMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java\nindex ca4596d0c..e43d3262e 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/transitvlan/TransitVlanPool.java\n\n@@ -92,10 +92,10 @@ public class TransitVlanPool implements EncapsulationResourcesProvider<TransitVl\n             nextVlan = -1;\n         }\n         if (nextVlan == -1) {\n-            Optional<Integer> availableCookie = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,\n+            Optional<Integer> availableVlan = transitVlanRepository.findFirstUnassignedVlan(minTransitVlan,\n                     minTransitVlan);\n-            if (availableCookie.isPresent()) {\n-                nextVlan = availableCookie.get();\n+            if (availableVlan.isPresent()) {\n+                nextVlan = availableVlan.get();\n                 return addVlan(flow, pathId, nextVlan++);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377521", "bodyText": "vlan -> vxlan", "author": "rozdy", "createdAt": "2020-09-10T14:13:36Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzOTE4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488039189", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3NzUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\nindex c2a9a48a3..2fd231991 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\n\n@@ -79,11 +79,11 @@ public class VxlanPool implements EncapsulationResourcesProvider<VxlanEncapsulat\n             long numOfPools = (maxVxlan - minVxlan) / poolSize;\n             if (numOfPools > 1) {\n                 long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n-                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                Optional<Integer> availableVxlan = vxlanRepository.findFirstUnassignedVxlan(\n                         minVxlan + (int) poolToTake * poolSize,\n                         minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n-                if (availableVlan.isPresent()) {\n-                    nextVxlan = availableVlan.get();\n+                if (availableVxlan.isPresent()) {\n+                    nextVxlan = availableVxlan.get();\n                     return addVxlan(flow, pathId, nextVxlan++);\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486377870", "bodyText": "cookie -> vxlan", "author": "rozdy", "createdAt": "2020-09-10T14:14:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java", "diffHunk": "@@ -60,27 +65,53 @@ public VxlanEncapsulation allocate(Flow flow, PathId pathId, PathId oppositePath\n                 .orElseGet(() -> allocate(flow, pathId));\n     }\n \n+    @TransactionRequired\n     private VxlanEncapsulation allocate(Flow flow, PathId pathId) {\n-        return transactionManager.doInTransaction(() -> {\n-            int startValue = ResourceUtils.computeStartValue(minVxlan, maxVxlan);\n-            int availableVxlan = vxlanRepository.findUnassignedVxlan(startValue, maxVxlan)\n-                    .orElse(vxlanRepository.findUnassignedVxlan(minVxlan, maxVxlan)\n-                            .orElseThrow(() -> new ResourceNotAvailableException(\"No vxlan available\")));\n-            if (availableVxlan > maxVxlan) {\n-                throw new ResourceNotAvailableException(\"No vxlan available\");\n+        if (nextVxlan > 0) {\n+            if (nextVxlan <= maxVxlan && !vxlanRepository.exists(nextVxlan)) {\n+                return addVxlan(flow, pathId, nextVxlan++);\n+            } else {\n+                nextVxlan = 0;\n+            }\n+        }\n+        // The pool requires (re-)initialization.\n+        if (nextVxlan == 0) {\n+            long numOfPools = (maxVxlan - minVxlan) / poolSize;\n+            if (numOfPools > 1) {\n+                long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n+                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                        minVxlan + (int) poolToTake * poolSize,\n+                        minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n+                if (availableVlan.isPresent()) {\n+                    nextVxlan = availableVlan.get();\n+                    return addVxlan(flow, pathId, nextVxlan++);\n+                }\n             }\n+            // The pool requires full scan.\n+            nextVxlan = -1;\n+        }\n+        if (nextVxlan == -1) {\n+            Optional<Integer> availableCookie = vxlanRepository.findFirstUnassignedVxlan(minVxlan,", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDE4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284187", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T22:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3Nzg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\nindex c2a9a48a3..2fd231991 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPool.java\n\n@@ -79,11 +79,11 @@ public class VxlanPool implements EncapsulationResourcesProvider<VxlanEncapsulat\n             long numOfPools = (maxVxlan - minVxlan) / poolSize;\n             if (numOfPools > 1) {\n                 long poolToTake = Math.abs(new Random().nextInt()) % numOfPools;\n-                Optional<Integer> availableVlan = vxlanRepository.findFirstUnassignedVxlan(\n+                Optional<Integer> availableVxlan = vxlanRepository.findFirstUnassignedVxlan(\n                         minVxlan + (int) poolToTake * poolSize,\n                         minVxlan + (int) (poolToTake + 1) * poolSize - 1);\n-                if (availableVlan.isPresent()) {\n-                    nextVxlan = availableVlan.get();\n+                if (availableVxlan.isPresent()) {\n+                    nextVxlan = availableVxlan.get();\n                     return addVxlan(flow, pathId, nextVxlan++);\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486382477", "bodyText": "You can chain this calls as it is builder now.", "author": "rozdy", "createdAt": "2020-09-10T14:20:01Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java", "diffHunk": "@@ -72,29 +72,29 @@ public IslInfoData map(Isl isl) {\n             return null;\n         }\n \n-        Isl isl = new Isl();\n-\n+        Isl.IslBuilder isl = Isl.builder();\n         PathNode sourcePathNode = islInfoData.getSource();\n         if (sourcePathNode != null) {\n-            isl.setSrcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n-            isl.setSrcPort(sourcePathNode.getPortNo());\n+            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n+            isl.srcPort(sourcePathNode.getPortNo());\n         }\n \n         PathNode destinationPathNode = islInfoData.getDestination();\n         if (destinationPathNode != null) {\n-            isl.setDestSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n-            isl.setDestPort(destinationPathNode.getPortNo());\n+            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n+            isl.destPort(destinationPathNode.getPortNo());\n         }\n-        isl.setLatency((int) islInfoData.getLatency());\n-        isl.setSpeed(islInfoData.getSpeed());\n-        isl.setAvailableBandwidth(islInfoData.getAvailableBandwidth());\n-        isl.setStatus(map(islInfoData.getState()));\n-        isl.setCost(islInfoData.getCost());\n-        isl.setUnderMaintenance(islInfoData.isUnderMaintenance());\n-        isl.setEnableBfd(islInfoData.isEnableBfd());\n-        isl.setBfdSessionStatus(islInfoData.getBfdSessionStatus());\n-\n-        return isl;\n+\n+        isl.latency((int) islInfoData.getLatency());\n+        isl.speed(islInfoData.getSpeed());\n+        isl.availableBandwidth(islInfoData.getAvailableBandwidth());\n+        isl.status(map(islInfoData.getState()));\n+        isl.cost(islInfoData.getCost());\n+        isl.underMaintenance(islInfoData.isUnderMaintenance());\n+        isl.enableBfd(islInfoData.isEnableBfd());\n+        isl.bfdSessionStatus(islInfoData.getBfdSessionStatus());", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NDc3Ng==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488284776", "bodyText": "Make sense. Refactored.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4MjQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java\nindex c504c7e31..7d8b6caef 100644\n--- a/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java\n+++ b/src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/mappers/IslMapper.java\n\n@@ -75,24 +77,24 @@ public abstract class IslMapper {\n         Isl.IslBuilder isl = Isl.builder();\n         PathNode sourcePathNode = islInfoData.getSource();\n         if (sourcePathNode != null) {\n-            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build());\n-            isl.srcPort(sourcePathNode.getPortNo());\n+            isl.srcSwitch(Switch.builder().switchId(sourcePathNode.getSwitchId()).build())\n+                    .srcPort(sourcePathNode.getPortNo());\n         }\n \n         PathNode destinationPathNode = islInfoData.getDestination();\n         if (destinationPathNode != null) {\n-            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build());\n-            isl.destPort(destinationPathNode.getPortNo());\n+            isl.destSwitch(Switch.builder().switchId(destinationPathNode.getSwitchId()).build())\n+                    .destPort(destinationPathNode.getPortNo());\n         }\n \n-        isl.latency((int) islInfoData.getLatency());\n-        isl.speed(islInfoData.getSpeed());\n-        isl.availableBandwidth(islInfoData.getAvailableBandwidth());\n-        isl.status(map(islInfoData.getState()));\n-        isl.cost(islInfoData.getCost());\n-        isl.underMaintenance(islInfoData.isUnderMaintenance());\n-        isl.enableBfd(islInfoData.isEnableBfd());\n-        isl.bfdSessionStatus(islInfoData.getBfdSessionStatus());\n+        isl.latency((int) islInfoData.getLatency())\n+                .speed(islInfoData.getSpeed())\n+                .availableBandwidth(islInfoData.getAvailableBandwidth())\n+                .status(map(islInfoData.getState()))\n+                .cost(islInfoData.getCost())\n+                .underMaintenance(islInfoData.isUnderMaintenance())\n+                .enableBfd(islInfoData.isEnableBfd())\n+                .bfdSessionStatus(map(islInfoData.getBfdSessionStatus()));\n \n         return isl.build();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486388638", "bodyText": "vlans -> vxlans", "author": "rozdy", "createdAt": "2020-09-10T14:27:43Z", "path": "src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java", "diffHunk": "@@ -53,48 +52,52 @@\n \n     @Before\n     public void setUp() {\n-        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN);\n+        vxlanPool = new VxlanPool(persistenceManager, MIN_VXLAN, MAX_VXLAN, 1);\n         vxlanRepository = persistenceManager.getRepositoryFactory().createVxlanRepository();\n-\n-        SwitchRepository switchRepository = persistenceManager.getRepositoryFactory().createSwitchRepository();\n-        switchRepository.createOrUpdate(SWITCH_A);\n-        switchRepository.createOrUpdate(SWITCH_B);\n     }\n \n     @Test\n     public void vxlanIdPool() {\n-        Set<Integer> vxlans = new HashSet<>();\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            vxlans.add(vxlanPool.allocate(\n-                    flow,\n-                    new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n-        }\n-        assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n-        vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        transactionManager.doInTransaction(() -> {\n+            Set<Integer> vxlans = new HashSet<>();\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                vxlans.add(vxlanPool.allocate(\n+                        flow,\n+                        new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"opposite_dummy_%d\", i))).getVxlan().getVni());\n+            }\n+            assertEquals(MAX_VXLAN - MIN_VXLAN + 1, vxlans.size());\n+            vxlans.forEach(vni -> assertTrue(vni >= MIN_VXLAN && vni <= MAX_VXLAN));\n+        });\n     }\n \n \n     @Test(expected = ResourceNotAvailableException.class)\n     public void vxlanPoolFullTest() {\n-        for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n-            Flow flow = Flow.builder().flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n-            assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n-                    new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n-        }\n+        transactionManager.doInTransaction(() -> {\n+            for (int i = MIN_VXLAN; i <= MAX_VXLAN + 1; i++) {\n+                Flow flow = Flow.builder()\n+                        .flowId(format(\"flow_%d\", i)).srcSwitch(SWITCH_A).destSwitch(SWITCH_B).build();\n+                assertTrue(vxlanPool.allocate(flow, new PathId(format(\"path_%d\", i)),\n+                        new PathId(format(\"op_path_%d\", i))).getVxlan().getVni() > 0);\n+            }\n+        });\n     }\n \n     @Test\n     public void deallocateVxlanTest() {\n-        vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n-        vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n-        int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n-        assertEquals(2, vxlanRepository.findAll().size());\n+        transactionManager.doInTransaction(() -> {\n+            vxlanPool.allocate(FLOW_1, PATH_ID_1, PATH_ID_2);\n+            vxlanPool.allocate(FLOW_2, PATH_ID_2, PATH_ID_1);\n+            int vni = vxlanPool.allocate(FLOW_3, PATH_ID_3, PATH_ID_3).getVxlan().getVni();\n+            assertEquals(2, vxlanRepository.findAll().size());\n \n-        vxlanPool.deallocate(PATH_ID_1);\n-        Collection<Vxlan> transitVlans = vxlanRepository.findAll();\n-        assertEquals(1, transitVlans.size());\n-        assertEquals(vni, transitVlans.iterator().next().getVni());\n+            vxlanPool.deallocate(PATH_ID_1);\n+            Collection<Vxlan> transitVlans = vxlanRepository.findAll();", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NTIxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488285211", "bodyText": "Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4ODYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java b/src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java\nindex 98b9c5c2c..ce7ed7df7 100644\n--- a/src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java\n+++ b/src-java/base-topology/base-storm-topology/src/test/java/org/openkilda/wfm/share/flow/resources/vxlan/VxlanPoolTest.java\n\n@@ -95,9 +95,9 @@ public class VxlanPoolTest extends InMemoryGraphBasedTest {\n             assertEquals(2, vxlanRepository.findAll().size());\n \n             vxlanPool.deallocate(PATH_ID_1);\n-            Collection<Vxlan> transitVlans = vxlanRepository.findAll();\n-            assertEquals(1, transitVlans.size());\n-            assertEquals(vni, transitVlans.iterator().next().getVni());\n+            Collection<Vxlan> vxlans = vxlanRepository.findAll();\n+            assertEquals(1, vxlans.size());\n+            assertEquals(vni, vxlans.iterator().next().getVni());\n         });\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486479814", "bodyText": "Why we need do detach if we already used copying constructor?", "author": "rozdy", "createdAt": "2020-09-10T16:32:39Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java", "diffHunk": "@@ -95,8 +95,11 @@ public SwitchOperationsService(RepositoryFactory repositoryFactory,\n      * @param switchId switch id.\n      */\n     public GetSwitchResponse getSwitch(SwitchId switchId) throws SwitchNotFoundException {\n-        return new GetSwitchResponse(\n-                switchRepository.findById(switchId).orElseThrow(() -> new SwitchNotFoundException(switchId)));\n+        Switch sw = switchRepository.findById(switchId)\n+                .map(Switch::new)\n+                .orElseThrow(() -> new SwitchNotFoundException(switchId));\n+        switchRepository.detach(sw);", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjQ5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488286499", "bodyText": "Nice catch! Fixed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3OTgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java b/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java\nindex 014db93e7..03ca702a8 100644\n--- a/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java\n+++ b/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/SwitchOperationsService.java\n\n@@ -96,7 +96,6 @@ public class SwitchOperationsService implements ILinkOperationsServiceCarrier {\n      */\n     public GetSwitchResponse getSwitch(SwitchId switchId) throws SwitchNotFoundException {\n         Switch sw = switchRepository.findById(switchId)\n-                .map(Switch::new)\n                 .orElseThrow(() -> new SwitchNotFoundException(switchId));\n         switchRepository.detach(sw);\n         return new GetSwitchResponse(sw);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486487393", "bodyText": "What is sf?", "author": "rozdy", "createdAt": "2020-09-10T16:44:54Z", "path": "src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java", "diffHunk": "@@ -907,9 +903,7 @@ private void verifyNewSwitchAfterSwitchSync(List<SpeakerSwitchPortView> ports) {\n                 LinkStatus.of(ports.get(0).getState()));\n         verify(carrier).sendAffectedFlowRerouteRequest(alphaDatapath);\n \n-        verify(switchRepository).createOrUpdate(argThat(sw ->\n-                sw.getStatus() == SwitchStatus.INACTIVE && sw.getSwitchId() == alphaDatapath));\n-        verify(switchPropertiesRepository).createOrUpdate(argThat(sf ->\n+        verify(switchPropertiesRepository).add(argThat(sf ->", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDM3OA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488040378", "bodyText": "No idea. It wasn't changed in this PR. However, I'll rename it to \"s\".", "author": "sergii-iakovenko", "createdAt": "2020-09-14T15:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NzM5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java b/src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java\nindex 807785bfb..cdc88cf10 100644\n--- a/src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java\n+++ b/src-java/network-topology/network-storm-topology/src/test/java/org/openkilda/wfm/topology/network/service/NetworkSwitchServiceTest.java\n\n@@ -903,8 +903,8 @@ public class NetworkSwitchServiceTest {\n                 LinkStatus.of(ports.get(0).getState()));\n         verify(carrier).sendAffectedFlowRerouteRequest(alphaDatapath);\n \n-        verify(switchPropertiesRepository).add(argThat(sf ->\n-                sf.getSupportedTransitEncapsulation().equals(SwitchProperties.DEFAULT_FLOW_ENCAPSULATION_TYPES)));\n+        verify(switchPropertiesRepository).add(argThat(s ->\n+                s.getSupportedTransitEncapsulation().equals(SwitchProperties.DEFAULT_FLOW_ENCAPSULATION_TYPES)));\n     }\n \n     private List<SpeakerSwitchPortView> doSpeakerOnline(NetworkSwitchService service, Set<SwitchFeature> features) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492272", "bodyText": "Looks like we don't need this inheritance.", "author": "rozdy", "createdAt": "2020-09-10T16:53:10Z", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java", "diffHunk": "@@ -64,7 +64,7 @@\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n @TestPropertySource(\"classpath:northbound.properties\")\n-public class FlowControllerTest extends NorthboundBaseTest {\n+public class FlowControllerTest extends InMemoryGraphBasedTest {", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NzgyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287829", "bodyText": "Right. Removed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java b/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java\nindex eb330ffce..20f308ffb 100644\n--- a/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java\n+++ b/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/FlowControllerTest.java\n\n@@ -64,7 +63,7 @@ import java.util.concurrent.TimeUnit;\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n @TestPropertySource(\"classpath:northbound.properties\")\n-public class FlowControllerTest extends InMemoryGraphBasedTest {\n+public class FlowControllerTest {\n     private static final String USERNAME = \"kilda\";\n     private static final String PASSWORD = \"kilda\";\n     private static final String ROLE = \"ADMIN\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r486492481", "bodyText": "And here.", "author": "rozdy", "createdAt": "2020-09-10T16:53:26Z", "path": "src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java", "diffHunk": "@@ -53,7 +53,7 @@\n @RunWith(SpringJUnit4ClassRunner.class)\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n-public class SwitchControllerTest extends NorthboundBaseTest {\n+public class SwitchControllerTest extends InMemoryGraphBasedTest {", "originalCommit": "c84e814a5dcd272031eec9c4fcc7039d79662afb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4Nzg4MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r488287880", "bodyText": "Right. Removed.", "author": "sergii-iakovenko", "createdAt": "2020-09-14T23:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MjQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "chunk": "diff --git a/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java b/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java\nindex 3005a9dfa..3b2a5ea46 100644\n--- a/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java\n+++ b/src-java/northbound-service/northbound/src/test/java/org/openkilda/northbound/controller/v1/SwitchControllerTest.java\n\n@@ -53,7 +52,7 @@ import java.util.concurrent.TimeUnit;\n @RunWith(SpringJUnit4ClassRunner.class)\n @WebAppConfiguration\n @ContextConfiguration(classes = TestConfig.class)\n-public class SwitchControllerTest extends InMemoryGraphBasedTest {\n+public class SwitchControllerTest {\n \n     private static final String USERNAME = \"kilda\";\n     private static final String PASSWORD = \"kilda\";\n"}}, {"oid": "047ccb4ac7c7c0e1368abc7061198be78a903388", "url": "https://github.com/telstra/open-kilda/commit/047ccb4ac7c7c0e1368abc7061198be78a903388", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-14T07:01:32Z", "type": "forcePushed"}, {"oid": "d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "url": "https://github.com/telstra/open-kilda/commit/d4d3d1e93029769ea3bae5b3bcd89be37268cf99", "message": "Temporary disable failing functional tests.", "committedDate": "2020-09-15T06:54:22Z", "type": "forcePushed"}, {"oid": "5c75729c529676f470cd51a0b1302b8d3d63809f", "url": "https://github.com/telstra/open-kilda/commit/5c75729c529676f470cd51a0b1302b8d3d63809f", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-15T23:35:27Z", "type": "forcePushed"}, {"oid": "e87ded82f3d353ba7e0dac70aff574403fb88825", "url": "https://github.com/telstra/open-kilda/commit/e87ded82f3d353ba7e0dac70aff574403fb88825", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-23T21:53:27Z", "type": "forcePushed"}, {"oid": "731547e6ff7803213c447010bcc28013fb300b48", "url": "https://github.com/telstra/open-kilda/commit/731547e6ff7803213c447010bcc28013fb300b48", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-24T10:00:33Z", "type": "forcePushed"}, {"oid": "03afdab3d9bd6dcda5e962d7dd13788012df2217", "url": "https://github.com/telstra/open-kilda/commit/03afdab3d9bd6dcda5e962d7dd13788012df2217", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-09-24T21:42:42Z", "type": "forcePushed"}, {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "url": "https://github.com/telstra/open-kilda/commit/aae9afddb5c903273f253e4fcf957c671a9ed2cd", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-10-01T16:39:09Z", "type": "commit"}, {"oid": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "url": "https://github.com/telstra/open-kilda/commit/aae9afddb5c903273f253e4fcf957c671a9ed2cd", "message": "Implement persistence layer for OrientDB", "committedDate": "2020-10-01T16:39:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498517670", "bodyText": "I'm not very familiar with new DB but how it should work? After changing local Instance of device it will be saved in DB automatically?", "author": "niksv", "createdAt": "2020-10-01T21:16:35Z", "path": "src-java/connecteddevices-topology/connecteddevices-storm-topology/src/main/java/org/openkilda/wfm/topology/connecteddevices/service/PacketService.java", "diffHunk": "@@ -97,8 +97,6 @@ public void handleLldpData(LldpInfoData data) {\n             device.setTimeLastSeen(Instant.ofEpochMilli(data.getTimestamp()));\n             device.setFlowId(flowRelatedData.flowId);\n             device.setSource(flowRelatedData.source);\n-\n-            switchConnectedDeviceRepository.createOrUpdate(device);", "originalCommit": "aae9afddb5c903273f253e4fcf957c671a9ed2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4MTA3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3508#discussion_r498681079", "bodyText": "The implementation relies on the concept of persistence context (persistence-layer). When the entity instance is in the persistent state, all changes that you make to this instance will be applied to the corresponding storage records upon committing of the transaction or closing the persistence context. This means that you don't have to call save, update or other repository methods to get these changes to the storage.\nThe same approach is used in JPA, Hibernate and many other solutions.", "author": "sergii-iakovenko", "createdAt": "2020-10-02T08:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzY3MA=="}], "type": "inlineReview", "revised_code": null}]}