{"pr_number": 3664, "pr_title": "Fix possible race condition in get flow by switch operation", "pr_createdAt": "2020-07-28T13:00:41Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3664", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3664#discussion_r463650387", "bodyText": "HashSet ... is unordered, how do you propose to define \"the last one\"?", "author": "surabujin", "createdAt": "2020-07-31T14:39:03Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java", "diffHunk": "@@ -198,8 +198,10 @@ public Flow getFlow(String flowId) throws FlowNotFoundException {\n             flows.addAll(flowRepository.findByEndpointSwitch(switchId));\n         }\n         // need to return Flows unique by id\n+        // Due to possible race condition we can have one flow with different flow paths\n+        // In this case we should get the last one", "originalCommit": "dc3bc6679acd600d52eb5554d97d95878d890284", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NTIyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3664#discussion_r464475225", "bodyText": "Reworked code to remove intermediate set at all.", "author": "rozdy", "createdAt": "2020-08-03T15:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1MDM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9f6910cd13d7970eee8a8d97c98f5a26fc541d10", "chunk": "diff --git a/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java b/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\nindex 051374753..f47ef24c4 100644\n--- a/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n+++ b/src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/services/FlowOperationsService.java\n\n@@ -180,27 +181,26 @@ public class FlowOperationsService {\n         if (!switchRepository.findById(switchId).isPresent()) {\n             throw new SwitchNotFoundException(switchId);\n         }\n-        Set<Flow> flows = new HashSet<>();\n \n         if (port != null) {\n-            flowPathRepository.findBySegmentEndpoint(switchId, port).stream()\n-                    // NOTE(tdurakov): filter out paths here that are orphaned for the flow\n-                    .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n-                    .map(FlowPath::getFlow)\n-                    .forEach(flows::add);\n-            flows.addAll(flowRepository.findByEndpoint(switchId, port));\n+            return getFlowsForEndpoint(flowPathRepository.findBySegmentEndpoint(switchId, port),\n+                    flowRepository.findByEndpoint(switchId, port));\n         } else {\n-            flowPathRepository.findBySegmentSwitch(switchId).stream()\n-                    // NOTE(tdurakov): filter out paths here that are orphaned for the flow\n-                    .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n-                    .map(FlowPath::getFlow)\n-                    .forEach(flows::add);\n-            flows.addAll(flowRepository.findByEndpointSwitch(switchId));\n+            return getFlowsForEndpoint(flowPathRepository.findBySegmentSwitch(switchId),\n+                    flowRepository.findByEndpointSwitch(switchId));\n         }\n+    }\n+\n+    private Collection<Flow> getFlowsForEndpoint(Collection<FlowPath> flowPaths,\n+                                                 Collection<Flow> flows) {\n+        Stream<Flow> flowBySegment = flowPaths.stream()\n+                // NOTE(tdurakov): filter out paths here that are orphaned for the flow\n+                .filter(flowPath -> flowPath.getFlow().isActualPathId(flowPath.getPathId()))\n+                .map(FlowPath::getFlow);\n         // need to return Flows unique by id\n         // Due to possible race condition we can have one flow with different flow paths\n         // In this case we should get the last one\n-        return flows.stream()\n+        return Stream.concat(flowBySegment, flows.stream())\n                 .collect(Collectors.toMap(Flow::getFlowId, Function.identity(), (flow1, flow2) -> flow2))\n                 .values();\n     }\n"}}, {"oid": "9f6910cd13d7970eee8a8d97c98f5a26fc541d10", "url": "https://github.com/telstra/open-kilda/commit/9f6910cd13d7970eee8a8d97c98f5a26fc541d10", "message": "Fix possible race condition in get flow by switch operation", "committedDate": "2020-08-03T15:05:37Z", "type": "forcePushed"}, {"oid": "4494aca7b97b961c7e6a8ed81850e56bb68a509d", "url": "https://github.com/telstra/open-kilda/commit/4494aca7b97b961c7e6a8ed81850e56bb68a509d", "message": "Fix possible race condition in get flow by switch operation", "committedDate": "2020-08-03T18:07:44Z", "type": "commit"}, {"oid": "4494aca7b97b961c7e6a8ed81850e56bb68a509d", "url": "https://github.com/telstra/open-kilda/commit/4494aca7b97b961c7e6a8ed81850e56bb68a509d", "message": "Fix possible race condition in get flow by switch operation", "committedDate": "2020-08-03T18:07:44Z", "type": "forcePushed"}]}