{"pr_number": 3097, "pr_title": "Fix double network failure handling", "pr_createdAt": "2020-01-08T17:24:07Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3097", "timeline": [{"oid": "237e1f090231481b2aa3fae832556654109d843f", "url": "https://github.com/telstra/open-kilda/commit/237e1f090231481b2aa3fae832556654109d843f", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T09:09:20Z", "type": "forcePushed"}, {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "url": "https://github.com/telstra/open-kilda/commit/d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T11:42:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODQwMg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364698402", "bodyText": "nit: wouldn't call it queue since you refactored that", "author": "timofei-durakov", "createdAt": "2020-01-09T11:50:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..75a841c07 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n\n@@ -43,11 +43,7 @@ public class RerouteRetryQueue {\n      * Return first/active queue entry.\n      */\n     public Optional<FlowRerouteFact> get() {\n-        FlowRerouteFact result = active;\n-        if (result == null) {\n-            result = pending;\n-        }\n-        return Optional.ofNullable(result);\n+        return Optional.ofNullable(active);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5OTc5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364699791", "bodyText": "nit: why not to throw exception here?", "author": "timofei-durakov", "createdAt": "2020-01-09T11:54:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n\n@@ -28,10 +28,10 @@ public class RerouteRetryManager {\n     private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n \n     /**\n-     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n-     * postponed).\n+     * Register request in retry \"queue\" and check is it can be processed now. Return true if this request can be\n+     * processed now.\n      */\n-    public boolean push(FlowRerouteFact entity) {\n+    public boolean record(FlowRerouteFact entity) {\n         RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n                 entity.getFlowId(), ignore -> new RerouteRetryQueue());\n         queue.add(entity);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMDI4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364700283", "bodyText": "same", "author": "timofei-durakov", "createdAt": "2020-01-09T11:55:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();\n+        }\n+\n+        // use method raises exception on empty queue access, because queue can't be empty by used design\n+        return queue.get();\n+    }\n+\n+    /**\n+     * Locate, remove and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> remove(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n\n@@ -28,10 +28,10 @@ public class RerouteRetryManager {\n     private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n \n     /**\n-     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n-     * postponed).\n+     * Register request in retry \"queue\" and check is it can be processed now. Return true if this request can be\n+     * processed now.\n      */\n-    public boolean push(FlowRerouteFact entity) {\n+    public boolean record(FlowRerouteFact entity) {\n         RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n                 entity.getFlowId(), ignore -> new RerouteRetryQueue());\n         queue.add(entity);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMTI4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364701286", "bodyText": "let's rename it to handlePostponedRequest?", "author": "timofei-durakov", "createdAt": "2020-01-09T11:58:12Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -69,6 +73,16 @@ public FlowRerouteService(FlowRerouteHubCarrier carrier, PersistenceManager pers\n                 speakerCommandRetriesLimit);\n     }\n \n+    /**\n+     * Handle postponed reroute request.\n+     */\n+    public void handleRequest(FlowRerouteFact reroute) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..36bafbd38 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n\n@@ -73,16 +73,6 @@ public class FlowRerouteService {\n                 speakerCommandRetriesLimit);\n     }\n \n-    /**\n-     * Handle postponed reroute request.\n-     */\n-    public void handleRequest(FlowRerouteFact reroute) {\n-        log.info(\"Handling postponed flow reroute request with key {} and flow ID: {}\",\n-                 reroute.getKey(), reroute.getFlowId());\n-        carrier.setupTimeoutCallback(reroute.getKey());\n-        initReroute(reroute);\n-    }\n-\n     /**\n      * Handles request for flow reroute.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364702453", "bodyText": "this is a very strange return result for a method call, tbh I'd implement size here istead", "author": "timofei-durakov", "createdAt": "2020-01-09T12:01:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMjQ4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364712489", "bodyText": "+1", "author": "niksv", "createdAt": "2020-01-09T12:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n\n@@ -28,10 +28,10 @@ public class RerouteRetryManager {\n     private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n \n     /**\n-     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n-     * postponed).\n+     * Register request in retry \"queue\" and check is it can be processed now. Return true if this request can be\n+     * processed now.\n      */\n-    public boolean push(FlowRerouteFact entity) {\n+    public boolean record(FlowRerouteFact entity) {\n         RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n                 entity.getFlowId(), ignore -> new RerouteRetryQueue());\n         queue.add(entity);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwNjY2MA==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364706660", "bodyText": "check queue size rather than push return value that is tight to 1 size", "author": "timofei-durakov", "createdAt": "2020-01-09T12:12:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -87,24 +101,15 @@ public void handleRequest(String key, CommandContext commandContext, String flow\n             return;\n         }\n \n-        String eventKey = commandContext.getCorrelationId();\n-        if (flowEventRepository.existsByTaskId(eventKey)) {\n-            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n-            return;\n+        FlowRerouteFact reroute = new FlowRerouteFact(\n+                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n+        if (retryQueue.push(reroute)) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..36bafbd38 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n\n@@ -112,6 +102,16 @@ public class FlowRerouteService {\n         }\n     }\n \n+    /**\n+     * Handle postponed flow reroute request.\n+     */\n+    public void handlePostponedRequest(FlowRerouteFact reroute) {\n+        log.info(\"Handling postponed flow reroute request with key {} and flow ID: {}\",\n+                 reroute.getKey(), reroute.getFlowId());\n+        carrier.setupTimeoutCallback(reroute.getKey());\n+        initReroute(reroute);\n+    }\n+\n     /**\n      * Handles async response from worker.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwODI0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364708243", "bodyText": "will this exception be raised each time there are no pending reroutes in a queue?", "author": "timofei-durakov", "createdAt": "2020-01-09T12:16:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -151,12 +156,54 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    private void initReroute(FlowRerouteFact reroute) {\n+        final CommandContext commandContext = reroute.getCommandContext();\n+\n+        String eventKey = commandContext.getCorrelationId();\n+        if (flowEventRepository.existsByTaskId(eventKey)) {\n+            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n+            return;\n+        }\n+\n+        final String flowId =  reroute.getFlowId();\n+        final String key = reroute.getKey();\n+        FlowRerouteFsm fsm = fsmFactory.newInstance(commandContext, flowId);\n+        fsms.put(key, fsm);\n+\n+        FlowRerouteContext context = FlowRerouteContext.builder()\n+                .flowId(flowId)\n+                .pathsToReroute(reroute.getPathsToReroute())\n+                .forceReroute(reroute.isForceReroute())\n+                .rerouteReason(reroute.getRerouteReason())\n+                .build();\n+        fsmExecutor.fire(fsm, Event.NEXT, context);\n+\n+        removeIfFinished(fsm, key);\n+    }\n+\n     private void removeIfFinished(FlowRerouteFsm fsm, String key) {\n         if (fsm.isTerminated()) {\n-            log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n-            fsms.remove(key);\n+            performHousekeeping(fsm, key);\n \n-            carrier.cancelTimeoutCallback(key);\n+            // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n+            retryQueue.peek(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n+        }\n+    }\n+\n+    private void performHousekeeping(FlowRerouteFsm fsm, String key) {\n+        log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+        fsms.remove(key);\n+\n+        carrier.cancelTimeoutCallback(key);\n+\n+        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+                .orElseThrow(() -> new IllegalStateException(String.format(", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n\n@@ -186,7 +186,7 @@ public class FlowRerouteService {\n             performHousekeeping(fsm, key);\n \n             // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n-            retryQueue.peek(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n+            retryManager.read(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364711646", "bodyText": "As far as I can see state with active == null and pending != null is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?", "author": "rozdy", "createdAt": "2020-01-09T12:25:15Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {\n+    private FlowRerouteFact active = null;\n+    private FlowRerouteFact pending = null;\n+\n+    /**\n+     * Add request into \"queue\".\n+     */\n+    public void add(FlowRerouteFact reroute) {\n+        if (active == null) {\n+            active = reroute;\n+        } else if (pending == null) {\n+            pending = reroute;\n+        } else {\n+            pending = mergePending(pending, reroute);\n+        }\n+    }\n+\n+    /**\n+     * Return first/active queue entry.\n+     */\n+    public Optional<FlowRerouteFact> get() {\n+        FlowRerouteFact result = active;\n+        if (result == null) {\n+            result = pending;\n+        }", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNjg1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364716852", "bodyText": "or throw exception if active == null and pending != null", "author": "niksv", "createdAt": "2020-01-09T12:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "chunk": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..75a841c07 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n\n@@ -43,11 +43,7 @@ public class RerouteRetryQueue {\n      * Return first/active queue entry.\n      */\n     public Optional<FlowRerouteFact> get() {\n-        FlowRerouteFact result = active;\n-        if (result == null) {\n-            result = pending;\n-        }\n-        return Optional.ofNullable(result);\n+        return Optional.ofNullable(active);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNTcwNw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364715707", "bodyText": "all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons", "author": "niksv", "createdAt": "2020-01-09T12:36:07Z", "path": "services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class RerouteRetryQueueTest {\n+    private final CommandContext context = new CommandContext();\n+    private final String flowId = \"flowA\";\n+    private final FlowRerouteFact rerouteEmpty = new FlowRerouteFact(\n+            \"empty\", context, flowId, null, false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathA = new FlowRerouteFact(\n+            \"pathA\", context, flowId, Collections.singleton(new PathId(\"flowA-pathA\")), false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathB = new FlowRerouteFact(\n+            \"pathB\", context, flowId, Collections.singleton(new PathId(\"flowA-pathB\")), false, \"reason 1\");\n+    private final FlowRerouteFact rerouteForced = new FlowRerouteFact(\n+            \"forced\", context, flowId, null, true, \"reason 1\");\n+\n+    @Test\n+    public void addAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        Assert.assertEquals(0, queue.size());\n+        Assert.assertTrue(queue.isEmpty());\n+\n+        queue.add(rerouteEmpty);\n+        Assert.assertEquals(1, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathA);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathB);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+    }\n+\n+    @Test\n+    public void removeAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        // empty\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+\n+        // one entry\n+        queue.add(rerouteEmpty);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        // two entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        // more than 2 entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(reroutePathB);\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertNotEquals(reroutePathA, reroute.get());  // merged entry\n+        Assert.assertNotEquals(reroutePathB, reroute.get());  // merged entry\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+    }\n+\n+    @Test\n+    public void getOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        Assert.assertFalse(queue.get().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+        queue.add(rerouteEmpty);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.add(reroutePathA);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.remove();\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+    }\n+\n+    @Test\n+    public void mergeOperation() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(rerouteForced);\n+        queue.add(reroutePathB);\n+\n+        Optional<FlowRerouteFact> potential;\n+        queue.remove();\n+        potential = queue.get();\n+        Assert.assertTrue(potential.isPresent());\n+\n+        FlowRerouteFact reroute = potential.get();\n+        Assert.assertEquals(reroutePathB.getKey(), reroute.getKey());\n+        Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n+        Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n+\n+        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n+                .map(FlowRerouteFact::getPathsToReroute)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toSet());\n+        Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n+        Assert.assertTrue(reroute.isForceReroute());\n+        Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "chunk": "diff --git a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\nindex 55082e7e1..52d061cd1 100644\n--- a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n+++ b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n\n@@ -22,13 +22,9 @@ import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n import org.junit.Assert;\n import org.junit.Test;\n \n-import java.util.Collection;\n import java.util.Collections;\n-import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n public class RerouteRetryQueueTest {\n     private final CommandContext context = new CommandContext();\n"}}, {"oid": "ea3030ad2005623b88080eea0083e72050543e0c", "url": "https://github.com/telstra/open-kilda/commit/ea3030ad2005623b88080eea0083e72050543e0c", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T12:37:10Z", "type": "forcePushed"}, {"oid": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "url": "https://github.com/telstra/open-kilda/commit/69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T15:06:53Z", "type": "forcePushed"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "commit"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "forcePushed"}]}