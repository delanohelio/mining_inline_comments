{"pr_number": 368, "pr_title": "Refactor compliance config", "pr_createdAt": "2020-04-09T21:48:56Z", "pr_url": "https://github.com/opensearch-project/security/pull/368", "timeline": [{"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "url": "https://github.com/opensearch-project/security/commit/ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "message": "Refactor compliance config", "committedDate": "2020-04-12T08:21:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MDgxOA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407660818", "bodyText": "I see you have changed values with the class member variables. Why opposite here?", "author": "palashhedau", "createdAt": "2020-04-13T19:11:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -41,209 +56,302 @@\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n \n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.format.DateTimeFormat;\n-import org.joda.time.format.DateTimeFormatter;\n-\n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n-import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n-import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n-\n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n-    private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n+\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n+\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n-        return this.enabled;\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n+        return true;", "originalCommit": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3ODExNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407678115", "bodyText": "I will revert this back to class member variable.\nI actually wanted to remove this isEnabled() itself because its always set to true. I believe this is something we inherited from search-guard where compliance was offered as a separate feature that could be disabled.\nOther places check for this explicitly hence I retained for some future use-cases.", "author": "sujithvm", "createdAt": "2020-04-13T19:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MDgxOA=="}], "type": "inlineReview", "revised_code": {"commit": "386c749bda35c01b02003b827c6cd9b105598784", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex caabe99e..29805add 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -82,6 +82,7 @@ public class ComplianceConfig {\n     private final byte[] salt16;\n     private final DateTimeFormatter auditLogPattern;\n     private final String auditLogIndex;\n+    private volatile boolean enabled = true;\n \n     private ComplianceConfig(\n             final boolean logExternalConfig,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Nzk1OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407677959", "bodyText": "Please avoid reordering of imports.", "author": "vrozov", "createdAt": "2020-04-13T19:44:21Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -30,6 +30,21 @@\n \n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;", "originalCommit": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2NDAyMg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407764022", "bodyText": "Done!", "author": "sujithvm", "createdAt": "2020-04-13T22:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Nzk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "754b209fe115330a13a900a3769ba03a262886ab", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex caabe99e..7f41deba 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -30,21 +30,6 @@\n \n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n-import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n-import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n-import com.google.common.collect.ImmutableSet;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.common.settings.Settings;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.format.DateTimeFormat;\n-import org.joda.time.format.DateTimeFormatter;\n-\n import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.Arrays;\n"}}, {"oid": "386c749bda35c01b02003b827c6cd9b105598784", "url": "https://github.com/opensearch-project/security/commit/386c749bda35c01b02003b827c6cd9b105598784", "message": "Use class member variable", "committedDate": "2020-04-13T19:45:47Z", "type": "commit"}, {"oid": "754b209fe115330a13a900a3769ba03a262886ab", "url": "https://github.com/opensearch-project/security/commit/754b209fe115330a13a900a3769ba03a262886ab", "message": "revert back re-ordering of imports", "committedDate": "2020-04-13T22:48:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDU3NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407864574", "bodyText": "move check complianceConfig != null  to isIndexImmutable().", "author": "vrozov", "createdAt": "2020-04-14T04:46:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if(complianceConfig != null && isIndexImmutable(request)) {", "originalCommit": "754b209fe115330a13a900a3769ba03a262886ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwMDQ1MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407900450", "bodyText": "Done!", "author": "sujithvm", "createdAt": "2020-04-14T06:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex a52072bd..029bb3a9 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -335,7 +335,7 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n"}}, {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "url": "https://github.com/opensearch-project/security/commit/ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "message": "Move compliance config null check into isIndexImmutable func", "committedDate": "2020-04-14T06:41:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408158743", "bodyText": "Possible race condition, two threads may race for externalConfigLogged.", "author": "vrozov", "createdAt": "2020-04-14T13:59:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -1010,10 +1015,10 @@ public void onNodeStarted() {\n         }\n         final Set<ModuleInfo> securityModules = ReflectionHelper.getModulesLoaded();\n         log.info(\"{} Open Distro Security modules loaded so far: {}\", securityModules.size(), securityModules);\n-        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.isLogExternalConfig() && !complianceConfig.isExternalConfigLogged()) {\n-        \tlog.info(\"logging external config\");\n-        \tauditLog.logExternalConfig(complianceConfig.getSettings(), complianceConfig.getEnvironment());\n-            complianceConfig.setExternalConfigLogged(true);\n+        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged) {\n+            log.info(\"logging external config\");\n+            auditLog.logExternalConfig(settings, environment);\n+            externalConfigLogged = true;", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxODQyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408218427", "bodyText": "externalConfigLogged is set t volatile. This is existing behavior as well. It is just pulled out of compliance config", "author": "sujithvm", "createdAt": "2020-04-14T15:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMjUwNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408232506", "bodyText": "volatile does not prevent race condition, it only provides memory barrier. It will be OK to file that as an issue and address in a separate PR.", "author": "vrozov", "createdAt": "2020-04-14T15:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MzA0NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408253045", "bodyText": "Yes it would be great to address it separately.\nAre you saying onNodeStarted will be called by multiple threads ? Need to investigate the race condition", "author": "sujithvm", "createdAt": "2020-04-14T16:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzIwMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408353203", "bodyText": "It is a possible race condition. As plugin has no control when and how onNodeStarted() is called, it will be safer to avoid the race condition, especially that it will not cost anything. Just replace volatile with AtomicBoolean and use getAndSet().", "author": "vrozov", "createdAt": "2020-04-14T18:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java\nindex e77dabcf..f74a1305 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java\n\n@@ -1015,10 +1016,9 @@ public final class OpenDistroSecurityPlugin extends OpenDistroSecuritySSLPlugin\n         }\n         final Set<ModuleInfo> securityModules = ReflectionHelper.getModulesLoaded();\n         log.info(\"{} Open Distro Security modules loaded so far: {}\", securityModules.size(), securityModules);\n-        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged) {\n+        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged.getAndSet(true)) {\n             log.info(\"logging external config\");\n             auditLog.logExternalConfig(settings, environment);\n-            externalConfigLogged = true;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MzY1OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408173659", "bodyText": "nit: move to enclosing if", "author": "vrozov", "createdAt": "2020-04-14T14:19:14Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -311,7 +316,7 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n                 || request instanceof IndicesAliasesRequest //TODO only remove index\n                 ) {\n             \n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyNDQ4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408224481", "bodyText": "Retained existing code.", "author": "sujithvm", "createdAt": "2020-04-14T15:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MzY1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex 029bb3a9..7ab82886 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -305,57 +305,31 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n     \n     @SuppressWarnings(\"rawtypes\")\n     private boolean checkImmutableIndices(Object request, ActionListener listener) {\n-\n-        if(        request instanceof DeleteRequest \n-                || request instanceof UpdateRequest \n-                || request instanceof UpdateByQueryRequest \n+        final boolean isModifyIndexRequest = request instanceof DeleteRequest\n+                || request instanceof UpdateRequest\n+                || request instanceof UpdateByQueryRequest\n                 || request instanceof DeleteByQueryRequest\n                 || request instanceof DeleteIndexRequest\n                 || request instanceof RestoreSnapshotRequest\n                 || request instanceof CloseIndexRequest\n-                || request instanceof IndicesAliasesRequest //TODO only remove index\n-                ) {\n-            \n-            if (isIndexImmutable(request)) {\n-                //auditLog.log\n-                \n-                //check index for type = remove index\n-                //IndicesAliasesRequest iar = (IndicesAliasesRequest) request;\n-                //for(AliasActions aa: iar.getAliasActions()) {\n-                //    if(aa.actionType() == Type.REMOVE_INDEX) {\n-                        \n-                //    }\n-                //}\n-                \n-                \n-                \n-                listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n-                return true;\n-            }\n+                || request instanceof IndicesAliasesRequest;\n+\n+        if (isModifyIndexRequest && isRequestIndexImmutable(request)) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n+            return true;\n         }\n         \n-        if(request instanceof IndexRequest) {\n-            if (isIndexImmutable(request)) {\n-                ((IndexRequest) request).opType(OpType.CREATE);\n-            }\n+        if ((request instanceof IndexRequest) && isRequestIndexImmutable(request)) {\n+            ((IndexRequest) request).opType(OpType.CREATE);\n         }\n         \n         return false;\n     }\n \n-    private boolean isIndexImmutable(Object request) {\n-        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n-            return false;\n-        }\n-\n-        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n-        if (immutableIndicesPatterns.isEmpty()) {\n-            return false;\n-        }\n-\n+    private boolean isRequestIndexImmutable(Object request) {\n         final IndexResolverReplacer.Resolved resolved = indexResolverReplacer.resolveRequest(request);\n         final Set<String> allIndices = resolved.getAllIndices();\n \n-        return WildcardMatcher.matchAny(immutableIndicesPatterns, allIndices);\n+        return WildcardMatcher.matchAny(complianceConfig.getImmutableIndicesPatterns(), allIndices);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NDgwMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408174803", "bodyText": "nit: move to enclosing if", "author": "vrozov", "createdAt": "2020-04-14T14:20:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex 029bb3a9..7ab82886 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -305,57 +305,31 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n     \n     @SuppressWarnings(\"rawtypes\")\n     private boolean checkImmutableIndices(Object request, ActionListener listener) {\n-\n-        if(        request instanceof DeleteRequest \n-                || request instanceof UpdateRequest \n-                || request instanceof UpdateByQueryRequest \n+        final boolean isModifyIndexRequest = request instanceof DeleteRequest\n+                || request instanceof UpdateRequest\n+                || request instanceof UpdateByQueryRequest\n                 || request instanceof DeleteByQueryRequest\n                 || request instanceof DeleteIndexRequest\n                 || request instanceof RestoreSnapshotRequest\n                 || request instanceof CloseIndexRequest\n-                || request instanceof IndicesAliasesRequest //TODO only remove index\n-                ) {\n-            \n-            if (isIndexImmutable(request)) {\n-                //auditLog.log\n-                \n-                //check index for type = remove index\n-                //IndicesAliasesRequest iar = (IndicesAliasesRequest) request;\n-                //for(AliasActions aa: iar.getAliasActions()) {\n-                //    if(aa.actionType() == Type.REMOVE_INDEX) {\n-                        \n-                //    }\n-                //}\n-                \n-                \n-                \n-                listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n-                return true;\n-            }\n+                || request instanceof IndicesAliasesRequest;\n+\n+        if (isModifyIndexRequest && isRequestIndexImmutable(request)) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n+            return true;\n         }\n         \n-        if(request instanceof IndexRequest) {\n-            if (isIndexImmutable(request)) {\n-                ((IndexRequest) request).opType(OpType.CREATE);\n-            }\n+        if ((request instanceof IndexRequest) && isRequestIndexImmutable(request)) {\n+            ((IndexRequest) request).opType(OpType.CREATE);\n         }\n         \n         return false;\n     }\n \n-    private boolean isIndexImmutable(Object request) {\n-        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n-            return false;\n-        }\n-\n-        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n-        if (immutableIndicesPatterns.isEmpty()) {\n-            return false;\n-        }\n-\n+    private boolean isRequestIndexImmutable(Object request) {\n         final IndexResolverReplacer.Resolved resolved = indexResolverReplacer.resolveRequest(request);\n         final Set<String> allIndices = resolved.getAllIndices();\n \n-        return WildcardMatcher.matchAny(immutableIndicesPatterns, allIndices);\n+        return WildcardMatcher.matchAny(complianceConfig.getImmutableIndicesPatterns(), allIndices);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408193547", "bodyText": "nit: consider isRequestIndexImmutable", "author": "vrozov", "createdAt": "2020-04-14T14:44:32Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIxODkwNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408218907", "bodyText": "Retained the existing function name. Wanted to reduce diffs", "author": "sujithvm", "createdAt": "2020-04-14T15:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyMzU4NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408223584", "bodyText": "This is a new function, the diff is already there.", "author": "vrozov", "createdAt": "2020-04-14T15:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex 029bb3a9..7ab82886 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -305,57 +305,31 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n     \n     @SuppressWarnings(\"rawtypes\")\n     private boolean checkImmutableIndices(Object request, ActionListener listener) {\n-\n-        if(        request instanceof DeleteRequest \n-                || request instanceof UpdateRequest \n-                || request instanceof UpdateByQueryRequest \n+        final boolean isModifyIndexRequest = request instanceof DeleteRequest\n+                || request instanceof UpdateRequest\n+                || request instanceof UpdateByQueryRequest\n                 || request instanceof DeleteByQueryRequest\n                 || request instanceof DeleteIndexRequest\n                 || request instanceof RestoreSnapshotRequest\n                 || request instanceof CloseIndexRequest\n-                || request instanceof IndicesAliasesRequest //TODO only remove index\n-                ) {\n-            \n-            if (isIndexImmutable(request)) {\n-                //auditLog.log\n-                \n-                //check index for type = remove index\n-                //IndicesAliasesRequest iar = (IndicesAliasesRequest) request;\n-                //for(AliasActions aa: iar.getAliasActions()) {\n-                //    if(aa.actionType() == Type.REMOVE_INDEX) {\n-                        \n-                //    }\n-                //}\n-                \n-                \n-                \n-                listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n-                return true;\n-            }\n+                || request instanceof IndicesAliasesRequest;\n+\n+        if (isModifyIndexRequest && isRequestIndexImmutable(request)) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n+            return true;\n         }\n         \n-        if(request instanceof IndexRequest) {\n-            if (isIndexImmutable(request)) {\n-                ((IndexRequest) request).opType(OpType.CREATE);\n-            }\n+        if ((request instanceof IndexRequest) && isRequestIndexImmutable(request)) {\n+            ((IndexRequest) request).opType(OpType.CREATE);\n         }\n         \n         return false;\n     }\n \n-    private boolean isIndexImmutable(Object request) {\n-        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n-            return false;\n-        }\n-\n-        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n-        if (immutableIndicesPatterns.isEmpty()) {\n-            return false;\n-        }\n-\n+    private boolean isRequestIndexImmutable(Object request) {\n         final IndexResolverReplacer.Resolved resolved = indexResolverReplacer.resolveRequest(request);\n         final Set<String> allIndices = resolved.getAllIndices();\n \n-        return WildcardMatcher.matchAny(immutableIndicesPatterns, allIndices);\n+        return WildcardMatcher.matchAny(complianceConfig.getImmutableIndicesPatterns(), allIndices);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408195113", "bodyText": "Actually this check is redundant. There is the same condition on line 198 before checkImmutableIndices() call.", "author": "vrozov", "createdAt": "2020-04-14T14:46:30Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyNDA2OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408224068", "bodyText": "Well, I think this should be retained here while calling this function", "author": "sujithvm", "createdAt": "2020-04-14T15:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNDY0MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408234641", "bodyText": "Why? It is a private method and there is no need to duplicate the check.", "author": "vrozov", "createdAt": "2020-04-14T15:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw=="}], "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex 029bb3a9..7ab82886 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -305,57 +305,31 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n     \n     @SuppressWarnings(\"rawtypes\")\n     private boolean checkImmutableIndices(Object request, ActionListener listener) {\n-\n-        if(        request instanceof DeleteRequest \n-                || request instanceof UpdateRequest \n-                || request instanceof UpdateByQueryRequest \n+        final boolean isModifyIndexRequest = request instanceof DeleteRequest\n+                || request instanceof UpdateRequest\n+                || request instanceof UpdateByQueryRequest\n                 || request instanceof DeleteByQueryRequest\n                 || request instanceof DeleteIndexRequest\n                 || request instanceof RestoreSnapshotRequest\n                 || request instanceof CloseIndexRequest\n-                || request instanceof IndicesAliasesRequest //TODO only remove index\n-                ) {\n-            \n-            if (isIndexImmutable(request)) {\n-                //auditLog.log\n-                \n-                //check index for type = remove index\n-                //IndicesAliasesRequest iar = (IndicesAliasesRequest) request;\n-                //for(AliasActions aa: iar.getAliasActions()) {\n-                //    if(aa.actionType() == Type.REMOVE_INDEX) {\n-                        \n-                //    }\n-                //}\n-                \n-                \n-                \n-                listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n-                return true;\n-            }\n+                || request instanceof IndicesAliasesRequest;\n+\n+        if (isModifyIndexRequest && isRequestIndexImmutable(request)) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n+            return true;\n         }\n         \n-        if(request instanceof IndexRequest) {\n-            if (isIndexImmutable(request)) {\n-                ((IndexRequest) request).opType(OpType.CREATE);\n-            }\n+        if ((request instanceof IndexRequest) && isRequestIndexImmutable(request)) {\n+            ((IndexRequest) request).opType(OpType.CREATE);\n         }\n         \n         return false;\n     }\n \n-    private boolean isIndexImmutable(Object request) {\n-        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n-            return false;\n-        }\n-\n-        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n-        if (immutableIndicesPatterns.isEmpty()) {\n-            return false;\n-        }\n-\n+    private boolean isRequestIndexImmutable(Object request) {\n         final IndexResolverReplacer.Resolved resolved = indexResolverReplacer.resolveRequest(request);\n         final Set<String> allIndices = resolved.getAllIndices();\n \n-        return WildcardMatcher.matchAny(immutableIndicesPatterns, allIndices);\n+        return WildcardMatcher.matchAny(complianceConfig.getImmutableIndicesPatterns(), allIndices);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwMjY3Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408202673", "bodyText": "Should this be part of the check on line 198? You can check that immutableIndicesPatterns is not empty once for BulkShardRequest and assume that it is not empty here or pass it to checkImmutableIndices().", "author": "vrozov", "createdAt": "2020-04-14T14:55:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n+            return false;\n+        }\n+\n+        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n+        if (immutableIndicesPatterns.isEmpty()) {", "originalCommit": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\nindex 029bb3a9..7ab82886 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java\n\n@@ -305,57 +305,31 @@ public class OpenDistroSecurityFilter implements ActionFilter {\n     \n     @SuppressWarnings(\"rawtypes\")\n     private boolean checkImmutableIndices(Object request, ActionListener listener) {\n-\n-        if(        request instanceof DeleteRequest \n-                || request instanceof UpdateRequest \n-                || request instanceof UpdateByQueryRequest \n+        final boolean isModifyIndexRequest = request instanceof DeleteRequest\n+                || request instanceof UpdateRequest\n+                || request instanceof UpdateByQueryRequest\n                 || request instanceof DeleteByQueryRequest\n                 || request instanceof DeleteIndexRequest\n                 || request instanceof RestoreSnapshotRequest\n                 || request instanceof CloseIndexRequest\n-                || request instanceof IndicesAliasesRequest //TODO only remove index\n-                ) {\n-            \n-            if (isIndexImmutable(request)) {\n-                //auditLog.log\n-                \n-                //check index for type = remove index\n-                //IndicesAliasesRequest iar = (IndicesAliasesRequest) request;\n-                //for(AliasActions aa: iar.getAliasActions()) {\n-                //    if(aa.actionType() == Type.REMOVE_INDEX) {\n-                        \n-                //    }\n-                //}\n-                \n-                \n-                \n-                listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n-                return true;\n-            }\n+                || request instanceof IndicesAliasesRequest;\n+\n+        if (isModifyIndexRequest && isRequestIndexImmutable(request)) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"Index is immutable\", RestStatus.FORBIDDEN));\n+            return true;\n         }\n         \n-        if(request instanceof IndexRequest) {\n-            if (isIndexImmutable(request)) {\n-                ((IndexRequest) request).opType(OpType.CREATE);\n-            }\n+        if ((request instanceof IndexRequest) && isRequestIndexImmutable(request)) {\n+            ((IndexRequest) request).opType(OpType.CREATE);\n         }\n         \n         return false;\n     }\n \n-    private boolean isIndexImmutable(Object request) {\n-        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n-            return false;\n-        }\n-\n-        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n-        if (immutableIndicesPatterns.isEmpty()) {\n-            return false;\n-        }\n-\n+    private boolean isRequestIndexImmutable(Object request) {\n         final IndexResolverReplacer.Resolved resolved = indexResolverReplacer.resolveRequest(request);\n         final Set<String> allIndices = resolved.getAllIndices();\n \n-        return WildcardMatcher.matchAny(immutableIndicesPatterns, allIndices);\n+        return WildcardMatcher.matchAny(complianceConfig.getImmutableIndicesPatterns(), allIndices);\n     }\n }\n"}}, {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "url": "https://github.com/opensearch-project/security/commit/1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "message": "Address code reviews", "committedDate": "2020-04-15T02:58:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMDI0Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410400243", "bodyText": "Consider:\n        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n        }\n        try {\n            ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(saltAsString);\n            byteBuffer.get(salt16);\n            if (byteBuffer.remaining() > 0) {\n                log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n            }\n        } catch (BufferUnderflowException e) {\n            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\", e);\n        }\n\nPlease add test cases for salt.", "author": "vrozov", "createdAt": "2020-04-17T18:32:16Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);", "originalCommit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27d15469e0c14fd342441f62200adfd654e5323a", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..0f59dc5d 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDEyMQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410434121", "bodyText": "Consider:\n        this.readEnabledFields = watchedReadFields.stream()\n                .map(watchedReadField -> watchedReadField.split(\",\"))\n                .filter(split -> split.length != 0)\n                .collect(Collectors.toMap(\n                        split -> split[0],\n                        split -> split.length == 1 ?\n                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n                ));", "author": "vrozov", "createdAt": "2020-04-17T19:44:17Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {", "originalCommit": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27d15469e0c14fd342441f62200adfd654e5323a", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..0f59dc5d 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "url": "https://github.com/opensearch-project/security/commit/9cac07bcbd203f2ee90acbfae5e75592080ac27e", "message": "Fetch current compliance config from auditlog", "committedDate": "2020-04-17T19:48:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTQzNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410471436", "bodyText": "Should it be Set<String> watchedWriteIndicesPatterns to be consistent with Set<String> immutableIndicesPatterns?", "author": "vrozov", "createdAt": "2020-04-17T21:09:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27d15469e0c14fd342441f62200adfd654e5323a", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..0f59dc5d 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NjAwNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410476005", "bodyText": "nit: please change cache to a more descriptive name.", "author": "vrozov", "createdAt": "2020-04-17T21:21:27Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27d15469e0c14fd342441f62200adfd654e5323a", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..0f59dc5d 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"oid": "27d15469e0c14fd342441f62200adfd654e5323a", "url": "https://github.com/opensearch-project/security/commit/27d15469e0c14fd342441f62200adfd654e5323a", "message": "address code reviews\n\nFix non null", "committedDate": "2020-04-17T21:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410496495", "bodyText": "I don't think that copy/clone is necessary, but if it is, I would rather use Arrays.copyOf().", "author": "vrozov", "createdAt": "2020-04-17T22:18:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMzcwNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410503706", "bodyText": "The array can be modified by some other classes right? Requesting salt will give the modified array.", "author": "sujithvm", "createdAt": "2020-04-17T22:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcyNDczMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410724733", "bodyText": "There are no other classes that modify the array. In this particular case, if you track how salt is used, it will be copied twice.", "author": "vrozov", "createdAt": "2020-04-18T17:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNDYyNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410734626", "bodyText": "If you look at MaskedField where you are passing salt16, you are passing the salt to 3rd lib function like this https://github.com/opendistro-for-elasticsearch/security/blob/master/src/main/java/com/amazon/opendistroforelasticsearch/security/configuration/MaskedField.java#L176\nYou never know if other libs modify the array or not. Is it safer to return a copy and I would prefer doing the same.\nMoreover copying salt is current functionality and can changes around this if needed be done separately?", "author": "sujithvm", "createdAt": "2020-04-18T18:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..478b0490 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NzA3Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410497077", "bodyText": "Consider:\n        return readEnabledFields.entrySet().stream()\n                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n                .flatMap(entry -> entry.getValue().stream())\n                .collect(Collectors.toSet());\n\nThere is no point of adding null or empty indexPattern to readEnabledFields, add it as a filter to the constructor.", "author": "vrozov", "createdAt": "2020-04-17T22:20:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n \n         final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n+        for (String indexPattern : readEnabledFields.keySet()) {", "originalCommit": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 7f41deba..478b0490 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -31,15 +31,14 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n"}}, {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "url": "https://github.com/opensearch-project/security/commit/8aa0b0a7808adf463c7811313142895ccbeaa0b9", "message": "address code reviews", "committedDate": "2020-04-17T22:50:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410505776", "bodyText": "private volatile or private final AtomicReference", "author": "vrozov", "createdAt": "2020-04-17T22:53:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected ComplianceConfig complianceConfig;", "originalCommit": "27d15469e0c14fd342441f62200adfd654e5323a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjc0OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506748", "bodyText": "I thought of doing the volatile change when subscribe is added.\nBut I ll add it here itself", "author": "sujithvm", "createdAt": "2020-04-17T22:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDQ3Ng==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520476", "bodyText": "If you remove setter (setComplienceConfig()), it can wait till subscribe is added.", "author": "vrozov", "createdAt": "2020-04-18T00:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjE5OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410522199", "bodyText": "Alright. I will remove setter setComplienceConfig  and re-add when needed", "author": "sujithvm", "createdAt": "2020-04-18T00:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f118d8ca5ec55ee20cda0fb93080283cb170f872", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\nindex 5e007e96..46ac3387 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\n\n@@ -87,7 +87,7 @@ public abstract class AbstractAuditLog implements AuditLog {\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n-    protected ComplianceConfig complianceConfig;\n+    protected volatile ComplianceConfig complianceConfig;\n \n     private static final List<String> writeClasses = new ArrayList<>();\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506585", "bodyText": "getCurrentComplianceConfig -> getComplianceConfig", "author": "vrozov", "createdAt": "2020-04-17T22:57:25Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);\n+\n+    ComplianceConfig getCurrentComplianceConfig();", "originalCommit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjkyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506927", "bodyText": "I thought the name getCurrentComplianceConfig will be more descriptive that config fetched is the latest/current config", "author": "sujithvm", "createdAt": "2020-04-17T22:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjg0Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410516847", "bodyText": "Let me know if you would like to use getComplianceConfig itself or some other name.", "author": "sujithvm", "createdAt": "2020-04-17T23:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDE0OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520148", "bodyText": "getCurrentComplienceConfig() is confusing, IMO. It is just a getter method, it can only get the current value, there is no any other values to get.", "author": "vrozov", "createdAt": "2020-04-18T00:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "039cbb512fed692151bfebe74121e0466d9b4426", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\nindex 5f105823..bedf8e23 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\n\n@@ -77,7 +77,7 @@ public interface AuditLog extends Closeable {\n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);\n \n-    ComplianceConfig getCurrentComplianceConfig();\n+    ComplianceConfig getComplianceConfig();\n     \n     public enum Origin {\n         REST, TRANSPORT, LOCAL\n"}}, {"oid": "f118d8ca5ec55ee20cda0fb93080283cb170f872", "url": "https://github.com/opensearch-project/security/commit/f118d8ca5ec55ee20cda0fb93080283cb170f872", "message": "address code review - use volatile for compliance config", "committedDate": "2020-04-17T23:44:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410516974", "bodyText": "Is it necessary to have setComplianceConfig() method? Can it be instantiated inside AbstractAuditLog constructor?", "author": "vrozov", "createdAt": "2020-04-17T23:44:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);", "originalCommit": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNzUzNQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410517535", "bodyText": "I want to retain this method as subscribing for changes should be as simple as adding @Subscribe to the function.", "author": "sujithvm", "createdAt": "2020-04-17T23:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxOTg4OA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410519888", "bodyText": "@Subscribe should not be on the interface method. NullAuditLog should not subscribe to the event bus.", "author": "vrozov", "createdAt": "2020-04-18T00:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMDgyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410520827", "bodyText": "Sorry I meant the function in AuditLogImpl and not this interface method", "author": "sujithvm", "createdAt": "2020-04-18T00:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "039cbb512fed692151bfebe74121e0466d9b4426", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\nindex 5f105823..bedf8e23 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java\n\n@@ -77,7 +77,7 @@ public interface AuditLog extends Closeable {\n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);\n \n-    ComplianceConfig getCurrentComplianceConfig();\n+    ComplianceConfig getComplianceConfig();\n     \n     public enum Origin {\n         REST, TRANSPORT, LOCAL\n"}}, {"oid": "039cbb512fed692151bfebe74121e0466d9b4426", "url": "https://github.com/opensearch-project/security/commit/039cbb512fed692151bfebe74121e0466d9b4426", "message": "Address code reviews - use auditLog getComplianceConfig()", "committedDate": "2020-04-18T00:09:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkzNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410522937", "bodyText": "It should be private. If necessary, there is public getter.", "author": "vrozov", "createdAt": "2020-04-18T00:19:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected volatile ComplianceConfig complianceConfig;", "originalCommit": "039cbb512fed692151bfebe74121e0466d9b4426", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3f743f226d46372e95f363db243080b0406694", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\nindex 6deb68b1..24100650 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java\n\n@@ -87,7 +87,7 @@ public abstract class AbstractAuditLog implements AuditLog {\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n-    protected volatile ComplianceConfig complianceConfig;\n+    private volatile ComplianceConfig complianceConfig;\n \n     private static final List<String> writeClasses = new ArrayList<>();\n     {\n"}}, {"oid": "3b3f743f226d46372e95f363db243080b0406694", "url": "https://github.com/opensearch-project/security/commit/3b3f743f226d46372e95f363db243080b0406694", "message": "remove setComplianceConfig", "committedDate": "2020-04-18T01:13:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NDU5Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410574597", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            return getFieldsForIndex(index).isEmpty();", "author": "vrozov", "createdAt": "2020-04-18T02:53:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "85291e8e7cb67e13808080725cb078b3e28a69ec", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 2e0419d1..fde96b23 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -351,8 +351,8 @@ public class ComplianceConfig {\n         try {\n             return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n-            log.error(e);\n-            return true;\n+            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n+            return getFieldsForIndex(index).isEmpty();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NTE4NA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410575184", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            fields = getFieldsForIndex(index);", "author": "vrozov", "createdAt": "2020-04-18T02:54:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);\n             return true;\n         }\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForField(String index, String field) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            final Set<String> fields = cache.get(index);\n-            if(fields.isEmpty()) {\n+            final Set<String> fields = readEnabledFieldsCache.get(index);\n+            if (fields.isEmpty()) {\n                 return false;\n             }\n-\n             return WildcardMatcher.matchAny(fields, field);\n         } catch (ExecutionException e) {\n             log.error(e);", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "85291e8e7cb67e13808080725cb078b3e28a69ec", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\nindex 2e0419d1..fde96b23 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java\n\n@@ -351,8 +351,8 @@ public class ComplianceConfig {\n         try {\n             return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n-            log.error(e);\n-            return true;\n+            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n+            return getFieldsForIndex(index).isEmpty();\n         }\n     }\n \n"}}, {"oid": "85291e8e7cb67e13808080725cb078b3e28a69ec", "url": "https://github.com/opensearch-project/security/commit/85291e8e7cb67e13808080725cb078b3e28a69ec", "message": "address code review", "committedDate": "2020-04-18T03:09:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzUyMQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410607521", "bodyText": "complianceDisabled -> isComplienceConfigEnabled (true -> enabled)", "author": "vrozov", "createdAt": "2020-04-18T04:14:53Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {\n+\tpublic final void route(final AuditMessage msg, final boolean complianceDisabled) {", "originalCommit": "3b3f743f226d46372e95f363db243080b0406694", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07c85006481dabe045a39c569035c2ba5a7d2245", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\nindex d9fa4534..735203ee 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\n\n@@ -67,14 +67,14 @@ public class AuditMessageRouter {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg, final boolean complianceDisabled) {\n+\tpublic final void route(final AuditMessage msg, final boolean isComplianceConfigEnabled) {\n \t\tif (!enabled) {\n \t\t\t// should not happen since we check in AuditLogImpl, so this is just a safeguard\n \t\t\tlog.error(\"#route(AuditMessage) called but message router is disabled\");\n \t\t\treturn;\n \t\t}\n \t\t// if we do not run the compliance features or no extended configuration is present, only log to default.\n-\t\tif (!hasMultipleEndpoints || complianceDisabled) {\n+\t\tif (!hasMultipleEndpoints || !isComplianceConfigEnabled) {\n \t\t\tstore(defaultSink, msg);\n \t\t} else {\n \t\t\tfor (AuditLogSink sink : categorySinks.get(msg.getCategory())) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410609283", "bodyText": "keep public final void route(final AuditMessage msg) and use the most common default to call route(msg, ...)", "author": "vrozov", "createdAt": "2020-04-18T04:18:58Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {", "originalCommit": "85291e8e7cb67e13808080725cb078b3e28a69ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYxNDA4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410614081", "bodyText": "What do you mean by most common default ?", "author": "sujithvm", "createdAt": "2020-04-18T04:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYxOTAzNA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410619034", "bodyText": "route(msg, true)", "author": "vrozov", "createdAt": "2020-04-18T04:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYyMjkzNg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410622936", "bodyText": "Are you saying to have two functions\n\nroute(msg, true)\nroute(msg) calling the above ?\n\nroute(msg) would probably be useful only for tests (which I have updated already). Dont want to add more code to main just for tests.", "author": "sujithvm", "createdAt": "2020-04-18T04:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYzMzM4OQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410633389", "bodyText": "It is OK to provide a default so that test don't need to be changed.", "author": "vrozov", "createdAt": "2020-04-18T05:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYzNjU3Nw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410636577", "bodyText": "The tests are already updated", "author": "sujithvm", "createdAt": "2020-04-18T05:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY2MDI3MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410660270", "bodyText": "Please consider the following approach:\n\nrevert changes to the route() method (it should only take AuditMessage msg as an argument)\nintroduce a boolean instance variable areRoutesEnabled (false by default).\nin route() instead of  isComplianceConfigEnabled use areRoutesEnabled.\nrename setupRoutes() to enableRoutes() and make it public\ndo not call enableRoutes() from AuditMessageRouter constructor, instead, call it from AuditLogImpl if it is enabled and complianceConfig is also enabled", "author": "vrozov", "createdAt": "2020-04-18T07:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMTU4MQ==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410731581", "bodyText": "Could you explain the value in doing this and insisting on removing the current change ?\nIMO, I see no issue in route(msg, isComplianceConfigEnabled) as it determines what route to take from the audit log based on current compliance configuration for hot reload.\nAlso would appreciate if you could send the changes in a PR against this branch so that we can quickly move forward :)", "author": "sujithvm", "createdAt": "2020-04-18T18:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNDA4MA==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410734080", "bodyText": "The value of the proposal is that\n\nareRoutesEnabled is the state of AuditMessageRouter instance that is simply a delegate of AuditLogImpl, not a parameter for the route() method (that should only take message to route). Such state will be shared by many calls to the route() until there is a state transition.\nIt is not necessary to initialize routes if routes are not enabled.", "author": "vrozov", "createdAt": "2020-04-18T18:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNjUyMw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410736523", "bodyText": "Please see https://github.com/sujithvm/security/pull/57", "author": "vrozov", "createdAt": "2020-04-18T18:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNzEyNw==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410737127", "bodyText": "I would prefer AuditMessageRouter improvements to be done separately.\nWould appreciate if you could share your changes :) Dont want to trigger another set of changes around this.", "author": "sujithvm", "createdAt": "2020-04-18T19:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczOTE0Mg==", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410739142", "bodyText": "The improvements to AuditMessageRouter are minimal, but it is necessary to keep original route() to take message as the only parameter.", "author": "vrozov", "createdAt": "2020-04-18T19:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "07c85006481dabe045a39c569035c2ba5a7d2245", "chunk": "diff --git a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\nindex d9fa4534..735203ee 100644\n--- a/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\n+++ b/src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java\n\n@@ -67,14 +67,14 @@ public class AuditMessageRouter {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg, final boolean complianceDisabled) {\n+\tpublic final void route(final AuditMessage msg, final boolean isComplianceConfigEnabled) {\n \t\tif (!enabled) {\n \t\t\t// should not happen since we check in AuditLogImpl, so this is just a safeguard\n \t\t\tlog.error(\"#route(AuditMessage) called but message router is disabled\");\n \t\t\treturn;\n \t\t}\n \t\t// if we do not run the compliance features or no extended configuration is present, only log to default.\n-\t\tif (!hasMultipleEndpoints || complianceDisabled) {\n+\t\tif (!hasMultipleEndpoints || !isComplianceConfigEnabled) {\n \t\t\tstore(defaultSink, msg);\n \t\t} else {\n \t\t\tfor (AuditLogSink sink : categorySinks.get(msg.getCategory())) {\n"}}, {"oid": "07c85006481dabe045a39c569035c2ba5a7d2245", "url": "https://github.com/opensearch-project/security/commit/07c85006481dabe045a39c569035c2ba5a7d2245", "message": "Use is compliance enabled", "committedDate": "2020-04-18T04:36:50Z", "type": "commit"}, {"oid": "391cb4ad5179046f530d5507a19547bf817c592e", "url": "https://github.com/opensearch-project/security/commit/391cb4ad5179046f530d5507a19547bf817c592e", "message": "Update byte buffer", "committedDate": "2020-04-18T20:04:00Z", "type": "commit"}, {"oid": "f032e0ed642e3559c6782675356e0b6ff3e5953b", "url": "https://github.com/opensearch-project/security/commit/f032e0ed642e3559c6782675356e0b6ff3e5953b", "message": "code review", "committedDate": "2020-04-18T20:06:23Z", "type": "commit"}, {"oid": "36a20c42570969b77de30b3ba268471636b419f6", "url": "https://github.com/opensearch-project/security/commit/36a20c42570969b77de30b3ba268471636b419f6", "message": "fix tests", "committedDate": "2020-04-18T20:23:42Z", "type": "commit"}, {"oid": "6507fa9f0f85db02286be5825c7c21cef618fb15", "url": "https://github.com/opensearch-project/security/commit/6507fa9f0f85db02286be5825c7c21cef618fb15", "message": "fix test", "committedDate": "2020-04-18T20:59:12Z", "type": "commit"}, {"oid": "2116cd01e9c25688419ce16d3b58943b486f1713", "url": "https://github.com/opensearch-project/security/commit/2116cd01e9c25688419ce16d3b58943b486f1713", "message": "fixing test", "committedDate": "2020-04-18T22:54:16Z", "type": "commit"}, {"oid": "3a217b0d8ec560ef98314fb15afabe24338fa684", "url": "https://github.com/opensearch-project/security/commit/3a217b0d8ec560ef98314fb15afabe24338fa684", "message": "fixing test", "committedDate": "2020-04-18T22:58:01Z", "type": "commit"}, {"oid": "07a7b8cfe8dc01684755cf3e228d72b021ea9915", "url": "https://github.com/opensearch-project/security/commit/07a7b8cfe8dc01684755cf3e228d72b021ea9915", "message": "code review (#57)", "committedDate": "2020-04-19T03:06:52Z", "type": "commit"}]}