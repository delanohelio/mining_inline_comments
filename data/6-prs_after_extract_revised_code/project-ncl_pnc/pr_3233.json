{"pr_number": 3233, "pr_title": "[NCL-5891] add generalized way to update OneToMany relationships and add functionality to endpoints", "pr_createdAt": "2020-08-12T11:42:06Z", "pr_url": "https://github.com/project-ncl/pnc/pull/3233", "timeline": [{"oid": "6ce9696a30029089f8988bd71a56be57c6d40ec2", "url": "https://github.com/project-ncl/pnc/commit/6ce9696a30029089f8988bd71a56be57c6d40ec2", "message": "[NCL-5891] fix PV.Builder to also update BuildConfiguration's side", "committedDate": "2020-08-12T11:06:05Z", "type": "commit"}, {"oid": "bb989043f4005fa5bd9e497c35d7472c93133e14", "url": "https://github.com/project-ncl/pnc/commit/bb989043f4005fa5bd9e497c35d7472c93133e14", "message": "[NCL-5891] add general method for updating owning side of relationships", "committedDate": "2020-08-12T11:35:27Z", "type": "commit"}, {"oid": "9a3428229eef153d480bc285534a89f2bbe48e66", "url": "https://github.com/project-ncl/pnc/commit/9a3428229eef153d480bc285534a89f2bbe48e66", "message": "[NCL-5891] add PATCH request tests", "committedDate": "2020-08-12T11:35:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0NjM0NQ==", "url": "https://github.com/project-ncl/pnc/pull/3233#discussion_r469346345", "bodyText": "This will break the TreeSet as if A != B  then A > B && A < B. (or in best case will be as efficient as array list)\nYou would want to use Map<ID, Entity> I think.", "author": "janinko", "createdAt": "2020-08-12T15:29:48Z", "path": "datastore/src/main/java/org/jboss/pnc/datastore/repositories/internal/AbstractRepository.java", "diffHunk": "@@ -110,4 +116,54 @@ public int count(Collection<Predicate<T>> andPredicates, Collection<Predicate<T>\n                 .getContent();\n     }\n \n+    /**\n+     * @see Repository#cascadeUpdates) for full docs\n+     * \n+     * @param managedNonOwning current version of entity from DB (MUST be Hibernate managed (due to LAZY fetching))\n+     * @param updatedNonOwning proposed version of entity from request\n+     * @param collectionGetter getter with collection of owning side (f.e ProductVersion::getBuildConfigurations)\n+     * @param owningSetter setter which updates the owning side (f.e BuildConfiguration::setProductVersion)\n+     * @param filter\n+     * @param <N>\n+     */\n+    public <N extends GenericEntity<ID>> void cascadeUpdates(\n+            N managedNonOwning,\n+            N updatedNonOwning,\n+            Function<N, Collection<T>> collectionGetter,\n+            BiConsumer<T, N> owningSetter,\n+            java.util.function.Predicate<T>... filter) {\n+        // we want only to compare IDs because the data from request can be partial (due to dto refs in Maps)\n+        Comparator<T> idComparator = (t, t1) -> t.getId().equals(t1.getId()) ? 0 : 1;", "originalCommit": "9a3428229eef153d480bc285534a89f2bbe48e66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2ODI5MQ==", "url": "https://github.com/project-ncl/pnc/pull/3233#discussion_r469568291", "bodyText": "Yes, TreeSet will be inefficient, you are absolutely correct. Map with ID as a Key basically does exactly what I need. Thx for the suggestion.", "author": "michalovjan", "createdAt": "2020-08-12T21:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0NjM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0692293d180e64c206d6c2153b75f36c73ebaf0d", "chunk": "diff --git a/datastore/src/main/java/org/jboss/pnc/datastore/repositories/internal/AbstractRepository.java b/datastore/src/main/java/org/jboss/pnc/datastore/repositories/internal/AbstractRepository.java\nindex 632a37f4a..1047f45be 100644\n--- a/datastore/src/main/java/org/jboss/pnc/datastore/repositories/internal/AbstractRepository.java\n+++ b/datastore/src/main/java/org/jboss/pnc/datastore/repositories/internal/AbstractRepository.java\n\n@@ -132,38 +135,43 @@ public class AbstractRepository<T extends GenericEntity<ID>, ID extends Serializ\n             Function<N, Collection<T>> collectionGetter,\n             BiConsumer<T, N> owningSetter,\n             java.util.function.Predicate<T>... filter) {\n-        // we want only to compare IDs because the data from request can be partial (due to dto refs in Maps)\n-        Comparator<T> idComparator = (t, t1) -> t.getId().equals(t1.getId()) ? 0 : 1;\n-\n         Collection<T> original = collectionGetter.apply(managedNonOwning);\n         Collection<T> updated = collectionGetter.apply(updatedNonOwning);\n \n-        Set<T> toRemove = new TreeSet<>(idComparator);\n-        toRemove.addAll(original);\n-        toRemove.removeAll(updated);\n+        Map<ID, T> toRemove = new HashMap<>();\n+        insertToMap(original, toRemove);\n+        removeFromMap(updated, toRemove);\n \n-        for (T owning : toRemove) {\n+        for (T owning : toRemove.values()) {\n             owningSetter.accept(owning, null);\n             save(owning);\n         }\n \n-        Set<T> toAdd = new TreeSet<>(idComparator);\n-        toAdd.addAll(updated);\n-        toAdd.removeAll(original);\n+        Map<ID, T> toAdd = new HashMap<>();\n+        insertToMap(updated, toAdd);\n+        removeFromMap(original, toAdd);\n \n         java.util.function.Predicate<T> dontMatchAll = Arrays.stream(filter)\n                 .reduce(x -> true, java.util.function.Predicate::and)\n                 .negate();\n \n-        // the entry has to match all the filters (remove if it doesn't match all)\n-        toAdd.removeIf(dontMatchAll);\n+        // the entry value has to match all the filters (remove if it doesn't match all)\n+        toAdd.values().removeIf(dontMatchAll);\n \n-        for (T owning : toAdd) {\n-            // get full entity to avoid saving partial data (data from request may be partial)\n+        for (T owning : toAdd.values()) {\n+            // get full entity to avoid saving partial data from request(due to refs in dto maps)\n             T fullEntity = queryById(owning.getId());\n             owningSetter.accept(fullEntity, managedNonOwning);\n             save(fullEntity);\n         }\n     }\n \n+    private void insertToMap(Collection<T> entityCollection, Map<ID, T> map) {\n+        map.putAll(entityCollection.stream().collect(toMap(T::getId, id -> id)));\n+    }\n+\n+    private void removeFromMap(Collection<T> entityCollection, Map<ID, T> map) {\n+        map.keySet().removeAll(entityCollection.stream().map(T::getId).collect(toSet()));\n+    }\n+\n }\n"}}, {"oid": "0692293d180e64c206d6c2153b75f36c73ebaf0d", "url": "https://github.com/project-ncl/pnc/commit/0692293d180e64c206d6c2153b75f36c73ebaf0d", "message": "[NCL-5891] use Map<ID, T> instead of Set<T> in update cascading", "committedDate": "2020-08-12T21:44:24Z", "type": "commit"}]}