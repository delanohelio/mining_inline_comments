{"pr_number": 3571, "pr_title": "Local lock improvements", "pr_createdAt": "2020-09-10T07:18:53Z", "pr_url": "https://github.com/eclipse-vertx/vert.x/pull/3571", "timeline": [{"oid": "2bdec393355814a5831329a04b12fe1bfefbd3a0", "url": "https://github.com/eclipse-vertx/vert.x/commit/2bdec393355814a5831329a04b12fe1bfefbd3a0", "message": "Use ContextInternal#setTimer to have a timer firing on the context thread", "committedDate": "2020-09-10T07:31:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMDU4Mw==", "url": "https://github.com/eclipse-vertx/vert.x/pull/3571#discussion_r486200583", "bodyText": "Shouldn't the list be returned instead?", "author": "tsegismont", "createdAt": "2020-09-10T09:33:50Z", "path": "src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java", "diffHunk": "@@ -49,12 +47,30 @@\n       timerId = timeout != Long.MAX_VALUE ? context.owner().setTimer(timeout, tid -> timeout()) : null;\n     }\n \n-    boolean isWaiting() {\n-      return status.get() == Status.WAITING;\n-    }\n-\n     void timeout() {\n       if (status.compareAndSet(Status.WAITING, Status.TIMED_OUT)) {\n+        // Cleanup\n+        waitersMap.compute(lockName, (s, list) -> {\n+          if (list == null) {\n+            // Already removed by nextWaiter\n+            return null;\n+          } else {\n+            int idx = list.indexOf(LockWaiter.this);\n+            if (idx == -1) {\n+              // Already removed by nextWaiter\n+              return null;", "originalCommit": "e9c7361867e9e0b61b169c01aa7393faf0a647a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyMjUwOQ==", "url": "https://github.com/eclipse-vertx/vert.x/pull/3571#discussion_r486322509", "bodyText": "right, good catch, I'll try adding a test for this", "author": "vietj", "createdAt": "2020-09-10T13:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMDU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0af7ed61a2524de1aa54b549d2629fc960c947be", "chunk": "diff --git a/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java b/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\nindex 2ac5a95b8..9b1eb9877 100644\n--- a/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\n+++ b/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\n\n@@ -22,67 +22,55 @@ import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * @author Thomas Segismont\n  */\n public class LocalAsyncLocks {\n \n-  private enum Status {WAITING, ACQUIRED, TIMED_OUT}\n-\n   private class LockWaiter {\n \n-    final Context context;\n+    final ContextInternal context;\n     final String lockName;\n     final Promise<Lock> promise;\n-    final AtomicReference<Status> status;\n     final Long timerId;\n \n-    LockWaiter(Context context, String lockName, long timeout, Promise<Lock> promise) {\n-      this.context = context;\n+    LockWaiter(ContextInternal context, String lockName, long timeout, Promise<Lock> promise) {\n       this.lockName = lockName;\n       this.promise = promise;\n-      status = new AtomicReference<>(Status.WAITING);\n-      timerId = timeout != Long.MAX_VALUE ? context.owner().setTimer(timeout, tid -> timeout()) : null;\n+      this.context = context;\n+      timerId = timeout != Long.MAX_VALUE ? context.setTimer(timeout, tid -> timeout()) : null;\n     }\n \n     void timeout() {\n-      if (status.compareAndSet(Status.WAITING, Status.TIMED_OUT)) {\n-        // Cleanup\n-        waitersMap.compute(lockName, (s, list) -> {\n-          if (list == null) {\n-            // Already removed by nextWaiter\n-            return null;\n-          } else {\n-            int idx = list.indexOf(LockWaiter.this);\n-            if (idx == -1) {\n-              // Already removed by nextWaiter\n-              return null;\n-            }\n-            int size = list.size();\n-            ArrayList<LockWaiter> n = new ArrayList<>(size - 1);\n-            if (idx > 0) {\n-              n.addAll(list.subList(0, idx));\n-            }\n-            if (idx + 1 < size) {\n-              n.addAll(list.subList(idx + 1, size));\n-            }\n-            return n;\n+      // Cleanup\n+      waitersMap.compute(lockName, (s, list) -> {\n+        int idx;\n+        if (list == null || (idx = list.indexOf(LockWaiter.this)) == -1) {\n+          // Already removed by release()\n+          return list;\n+        } else if (list.size() == 1) {\n+          return null;\n+        } else {\n+          int size = list.size();\n+          List<LockWaiter> n = new ArrayList<>(size - 1);\n+          if (idx > 0) {\n+            n.addAll(list.subList(0, idx));\n           }\n-        });\n-        promise.fail(\"Timed out waiting to get lock\");\n-      }\n+          if (idx + 1 < size) {\n+            n.addAll(list.subList(idx + 1, size));\n+          }\n+          return n;\n+        }\n+      });\n+      promise.fail(\"Timed out waiting to get lock\");\n     }\n \n     void acquireLock() {\n-      if (status.compareAndSet(Status.WAITING, Status.ACQUIRED)) {\n-        if (timerId != null) {\n-          context.owner().cancelTimer(timerId);\n-        }\n+      if (timerId == null || context.owner().cancelTimer(timerId)) {\n         promise.complete(new AsyncLock(lockName));\n       } else {\n-        context.runOnContext(v -> nextWaiter(lockName));\n+        nextWaiter(lockName);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMjE0Mw==", "url": "https://github.com/eclipse-vertx/vert.x/pull/3571#discussion_r486202143", "bodyText": "Could we be more aggressive and check if we can return null when there's no other waiter or a SingletonList when there's just one?", "author": "tsegismont", "createdAt": "2020-09-10T09:36:20Z", "path": "src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java", "diffHunk": "@@ -49,12 +47,30 @@\n       timerId = timeout != Long.MAX_VALUE ? context.owner().setTimer(timeout, tid -> timeout()) : null;\n     }\n \n-    boolean isWaiting() {\n-      return status.get() == Status.WAITING;\n-    }\n-\n     void timeout() {\n       if (status.compareAndSet(Status.WAITING, Status.TIMED_OUT)) {\n+        // Cleanup\n+        waitersMap.compute(lockName, (s, list) -> {\n+          if (list == null) {\n+            // Already removed by nextWaiter\n+            return null;\n+          } else {\n+            int idx = list.indexOf(LockWaiter.this);\n+            if (idx == -1) {\n+              // Already removed by nextWaiter\n+              return null;\n+            }\n+            int size = list.size();\n+            ArrayList<LockWaiter> n = new ArrayList<>(size - 1);", "originalCommit": "e9c7361867e9e0b61b169c01aa7393faf0a647a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyMzQyMg==", "url": "https://github.com/eclipse-vertx/vert.x/pull/3571#discussion_r486323422", "bodyText": "yes we need to consider this case as it could be an actual one and leave an empty list in the map, I'll try to address this with a test", "author": "vietj", "createdAt": "2020-09-10T13:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMjE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0af7ed61a2524de1aa54b549d2629fc960c947be", "chunk": "diff --git a/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java b/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\nindex 2ac5a95b8..9b1eb9877 100644\n--- a/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\n+++ b/src/main/java/io/vertx/core/shareddata/impl/LocalAsyncLocks.java\n\n@@ -22,67 +22,55 @@ import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * @author Thomas Segismont\n  */\n public class LocalAsyncLocks {\n \n-  private enum Status {WAITING, ACQUIRED, TIMED_OUT}\n-\n   private class LockWaiter {\n \n-    final Context context;\n+    final ContextInternal context;\n     final String lockName;\n     final Promise<Lock> promise;\n-    final AtomicReference<Status> status;\n     final Long timerId;\n \n-    LockWaiter(Context context, String lockName, long timeout, Promise<Lock> promise) {\n-      this.context = context;\n+    LockWaiter(ContextInternal context, String lockName, long timeout, Promise<Lock> promise) {\n       this.lockName = lockName;\n       this.promise = promise;\n-      status = new AtomicReference<>(Status.WAITING);\n-      timerId = timeout != Long.MAX_VALUE ? context.owner().setTimer(timeout, tid -> timeout()) : null;\n+      this.context = context;\n+      timerId = timeout != Long.MAX_VALUE ? context.setTimer(timeout, tid -> timeout()) : null;\n     }\n \n     void timeout() {\n-      if (status.compareAndSet(Status.WAITING, Status.TIMED_OUT)) {\n-        // Cleanup\n-        waitersMap.compute(lockName, (s, list) -> {\n-          if (list == null) {\n-            // Already removed by nextWaiter\n-            return null;\n-          } else {\n-            int idx = list.indexOf(LockWaiter.this);\n-            if (idx == -1) {\n-              // Already removed by nextWaiter\n-              return null;\n-            }\n-            int size = list.size();\n-            ArrayList<LockWaiter> n = new ArrayList<>(size - 1);\n-            if (idx > 0) {\n-              n.addAll(list.subList(0, idx));\n-            }\n-            if (idx + 1 < size) {\n-              n.addAll(list.subList(idx + 1, size));\n-            }\n-            return n;\n+      // Cleanup\n+      waitersMap.compute(lockName, (s, list) -> {\n+        int idx;\n+        if (list == null || (idx = list.indexOf(LockWaiter.this)) == -1) {\n+          // Already removed by release()\n+          return list;\n+        } else if (list.size() == 1) {\n+          return null;\n+        } else {\n+          int size = list.size();\n+          List<LockWaiter> n = new ArrayList<>(size - 1);\n+          if (idx > 0) {\n+            n.addAll(list.subList(0, idx));\n           }\n-        });\n-        promise.fail(\"Timed out waiting to get lock\");\n-      }\n+          if (idx + 1 < size) {\n+            n.addAll(list.subList(idx + 1, size));\n+          }\n+          return n;\n+        }\n+      });\n+      promise.fail(\"Timed out waiting to get lock\");\n     }\n \n     void acquireLock() {\n-      if (status.compareAndSet(Status.WAITING, Status.ACQUIRED)) {\n-        if (timerId != null) {\n-          context.owner().cancelTimer(timerId);\n-        }\n+      if (timerId == null || context.owner().cancelTimer(timerId)) {\n         promise.complete(new AsyncLock(lockName));\n       } else {\n-        context.runOnContext(v -> nextWaiter(lockName));\n+        nextWaiter(lockName);\n       }\n     }\n   }\n"}}, {"oid": "0af7ed61a2524de1aa54b549d2629fc960c947be", "url": "https://github.com/eclipse-vertx/vert.x/commit/0af7ed61a2524de1aa54b549d2629fc960c947be", "message": "Use ContextInternal#setTimer to have a timer firing on the context thread", "committedDate": "2020-09-10T14:01:43Z", "type": "forcePushed"}, {"oid": "b17901c037360435e70164bca1f5d4240fd2212d", "url": "https://github.com/eclipse-vertx/vert.x/commit/b17901c037360435e70164bca1f5d4240fd2212d", "message": "Use ContextInternal#setTimer to have a timer firing on the context thread", "committedDate": "2020-09-10T14:35:27Z", "type": "forcePushed"}, {"oid": "d7ee4074ff7fbbda5d49b5434f5830e50686e5f1", "url": "https://github.com/eclipse-vertx/vert.x/commit/d7ee4074ff7fbbda5d49b5434f5830e50686e5f1", "message": "Local lock timeout now tries to remove the lock from the waiters list instead of relying on the lazy removal performed by the lock release operations - see #3570", "committedDate": "2020-09-11T07:31:36Z", "type": "commit"}, {"oid": "cba85b1c28348367821af054544b1795cb838691", "url": "https://github.com/eclipse-vertx/vert.x/commit/cba85b1c28348367821af054544b1795cb838691", "message": "Simplify a bit LockWaiter that is using an atomic value to handle concurrent acquire/timeout of a waiter. Instead we can use the timer information to achieve the same, on acquire if the timer can be cancelled then we can grant the owner the lock, on timeout we can try to evict the timeout from the list.", "committedDate": "2020-09-11T07:31:36Z", "type": "commit"}, {"oid": "6bb37902da50c9f5fdf41a754aea7f91369445f4", "url": "https://github.com/eclipse-vertx/vert.x/commit/6bb37902da50c9f5fdf41a754aea7f91369445f4", "message": "Use ContextInternal#setTimer to have a timer firing on the context thread", "committedDate": "2020-09-11T07:31:36Z", "type": "commit"}, {"oid": "6bb37902da50c9f5fdf41a754aea7f91369445f4", "url": "https://github.com/eclipse-vertx/vert.x/commit/6bb37902da50c9f5fdf41a754aea7f91369445f4", "message": "Use ContextInternal#setTimer to have a timer firing on the context thread", "committedDate": "2020-09-11T07:31:36Z", "type": "forcePushed"}]}