{"pr_number": 2169, "pr_title": "Frontend for configuring Maintenance Windows", "pr_createdAt": "2020-04-28T08:23:34Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2169", "timeline": [{"oid": "d479ab993ab002f922cd2e590d77b79a06a4e0b3", "url": "https://github.com/uyuni-project/uyuni/commit/d479ab993ab002f922cd2e590d77b79a06a4e0b3", "message": "Add details view for schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-04-30T15:17:27Z", "type": "forcePushed"}, {"oid": "18c1fb2b9d227d492af77337d80e3e63712a8cb4", "url": "https://github.com/uyuni-project/uyuni/commit/18c1fb2b9d227d492af77337d80e3e63712a8cb4", "message": "Controller save method\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-14T16:26:14Z", "type": "forcePushed"}, {"oid": "023327d3cae12b9e2bbd96677ab500ca15bb9474", "url": "https://github.com/uyuni-project/uyuni/commit/023327d3cae12b9e2bbd96677ab500ca15bb9474", "message": "Get detailed schedule info\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-19T11:15:14Z", "type": "forcePushed"}, {"oid": "96b21e7e8c966ee0ada155e656ee3ae799a05159", "url": "https://github.com/uyuni-project/uyuni/commit/96b21e7e8c966ee0ada155e656ee3ae799a05159", "message": "Add missing javadoc, fix checkstyle\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-27T09:01:11Z", "type": "forcePushed"}, {"oid": "eea876c7beb50d086a4beaeaa26f9f6adc018c86", "url": "https://github.com/uyuni-project/uyuni/commit/eea876c7beb50d086a4beaeaa26f9f6adc018c86", "message": "Handle reschedule strategy\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-02T16:26:01Z", "type": "forcePushed"}, {"oid": "a1af066a5ab3b6f3b19ab8d1ce1c8d5666f91ef5", "url": "https://github.com/uyuni-project/uyuni/commit/a1af066a5ab3b6f3b19ab8d1ce1c8d5666f91ef5", "message": "Support refreshing calendars from url\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-05T13:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMzE0Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437423143", "bodyText": "Looks like this comment has been copy-pasted all over the codebase, but it's wrong in many cases (including this one :) ).", "author": "hustodemon", "createdAt": "2020-06-09T13:37:52Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDQzNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437424436", "bodyText": "Later todo suggestion (as per our talk): Splitting this to MaintenanceScheduleController and MaintenanceCalendarController would be nicer.", "author": "hustodemon", "createdAt": "2020-06-09T13:39:42Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNTA3NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437425075", "bodyText": "The name for this endpoint should reflect its intent: maybe /manager/api/maintenance/calendar-names would be better?", "author": "hustodemon", "createdAt": "2020-06-09T13:40:25Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyODI2OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437428268", "bodyText": "In general, using Optional.get is discouraged, unless there is a very good reason for using it.\nI think this could be improved by using orElseThrow above:\nMaintenanceSchedule schedule = MM.lookupM.....(...)\n    .orElseThrow(() -> Spark.halt(\n        HttpStatus.SC_BAD_REQUEST,\n        GSON.toJson(ResultJson.error(LOCAL.getMessage(\"maintenance.schedule.id.not.exists\", scheduleId)))));\nThis way you get unwrapped MaintenanceSchedule.", "author": "hustodemon", "createdAt": "2020-06-09T13:43:27Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyOTI4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437429285", "bodyText": "Same as above.", "author": "hustodemon", "createdAt": "2020-06-09T13:44:26Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMDIwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437430206", "bodyText": "There is nothing wrong with this, but if you want to be less verbose, you can use this notation:\nMap.of(\n    \"id\", schedule.getId().toString(),\n    \"name\", schedule.getName());", "author": "hustodemon", "createdAt": "2020-06-09T13:45:20Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMjk0NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437432945", "bodyText": "I don't like the fact, that <None> is handled as a special value here. I believe this is something that should be handled internally by the frontend (and if user selects <None> from the combobox, null should be sent to the backend). Is there anything preventing us from using null?\nThis is related to all <None> occurences in here and in the js files.", "author": "hustodemon", "createdAt": "2020-06-09T13:47:56Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437434881", "bodyText": "In which situations is this check needed? Can you remove it? When we lookup the calendar from the database, it will always have null (the only exception would be, when the entity is not persisted yet, but I believe this is not the case here).", "author": "hustodemon", "createdAt": "2020-06-09T13:49:49Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNTkwMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440025903", "bodyText": "Yes we need it. This case happens, when the user tries to create a new calendar with a name that already exists. Without it you could override an existing calendar by creating a new one with the same name.", "author": "parlt91", "createdAt": "2020-06-15T08:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxNjg4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440716886", "bodyText": "Ok, that makes sense.", "author": "hustodemon", "createdAt": "2020-06-16T09:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNTc0OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437435749", "bodyText": "Please move this declaration & assignment to line 298.", "author": "hustodemon", "createdAt": "2020-06-09T13:50:35Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjI1Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437436257", "bodyText": "Please remove this line.", "author": "hustodemon", "createdAt": "2020-06-09T13:51:03Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTU2OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437439569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (schedule.isPresent()) {\n          \n          \n            \n                        MM.remove(user, schedule.get());\n          \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                        Spark.halt(HttpStatus.SC_BAD_REQUEST);\n          \n          \n            \n                    }\n          \n          \n            \n            schedule.ifPresentOrElse(                                                                                                                       \n          \n          \n            \n                s -> MM.remove(user, s),                                                                                                                \n          \n          \n            \n                () -> Spark.halt(HttpStatus.SC_BAD_REQUEST));", "author": "hustodemon", "createdAt": "2020-06-09T13:54:00Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MDE4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437440186", "bodyText": "Could be simplified as well ^^^.", "author": "hustodemon", "createdAt": "2020-06-09T13:54:37Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTIxOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437441218", "bodyText": "I'm not sure here: Do we want to report the first unsuccessful result, or all of them? In case of the latter, we might need something like this:\n        // maybe we want to report unsuccessful results?                                                                                                \n        String message = results.stream()                                                                                                               \n                .filter(r -> !r.isSuccess())                                                                                                            \n                .map(r -> LOCAL.getMessage(strategy.equals(\"Cancel\") ?                                                                                  \n                                \"maintenance.action.reschedule.error.cancel\" :                                                                          \n                                \"maintenance.action.reschedule.error.fail\",                                                                             \n                        r.getScheduleName()))                                                                                                           \n                .collect(Collectors.joining(\", \"));                                                                                                     \n                                                                                                                                                        \n        if (!message.isEmpty()) {                                                                                                                       \n            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(message)));                                                              \n        }", "author": "hustodemon", "createdAt": "2020-06-09T13:55:46Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {\n+            String strategy = json.getRescheduleStrategy();\n+            handleRescheduleResult(MM.remove(user, calendar.get(), strategy.equals(\"Cancel\")), strategy);\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void handleRescheduleResult(List<RescheduleResult> results, String strategy) {\n+        results.forEach(result -> {\n+            if (!result.isSuccess()) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDA0OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440020048", "bodyText": "We definitely want to display all of the failed results, but due to the lack of time I chose the minimalist approach. We cannot use a simple notification message to display multiple failures on the frontend, so we need to come up with something else here.", "author": "parlt91", "createdAt": "2020-06-15T08:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MzA1MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437443051", "bodyText": "Later todo: As discussed, this might be a good place for a specialized JPQL query. Moreover, it'd be great if we had a query that can handle multiple entities instead of calling this method N-times.", "author": "hustodemon", "createdAt": "2020-06-09T13:57:38Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {\n+            String strategy = json.getRescheduleStrategy();\n+            handleRescheduleResult(MM.remove(user, calendar.get(), strategy.equals(\"Cancel\")), strategy);\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void handleRescheduleResult(List<RescheduleResult> results, String strategy) {\n+        results.forEach(result -> {\n+            if (!result.isSuccess()) {\n+                String affectedSchedule = result.getScheduleName();\n+                String message = LOCAL.getMessage(strategy.equals(\"Cancel\") ?\n+                        \"maintenance.action.reschedule.error.cancel\" :\n+                        \"maintenance.action.reschedule.error.fail\",\n+                        affectedSchedule);\n+                Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(message)));\n+            }\n+        });\n+    }\n+\n+    private static List<MaintenanceWindowJson> schedulesToJson(List<MaintenanceSchedule> schedules) {\n+        return schedules.stream().map(MaintenanceController::scheduleToJson).collect(Collectors.toList());\n+    }\n+\n+    private static List<MaintenanceWindowJson> calendarsToJson(User user, List<MaintenanceCalendar> calendars) {\n+        return calendars.stream().map(calendar -> calendarToJson(user, calendar)).collect(Collectors.toList());\n+    }\n+\n+    private static MaintenanceWindowJson scheduleToJson(MaintenanceSchedule schedule) {\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        json.setScheduleId(schedule.getId());\n+        json.setScheduleName(schedule.getName());\n+        schedule.getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+        });\n+\n+        return json;\n+    }\n+\n+    private static MaintenanceWindowJson calendarToJson(User user, MaintenanceCalendar calendar) {\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        json.setCalendarId(calendar.getId());\n+        json.setCalendarName(calendar.getLabel());\n+\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar).stream().map(", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\nindex 90856a4fd68..7cf3cc6b575 100644\n--- a/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n+++ b/java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java\n\n@@ -19,30 +19,21 @@ import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n-import static spark.Spark.delete;\n import static spark.Spark.get;\n import static spark.Spark.post;\n \n-import com.redhat.rhn.common.localization.LocalizationService;\n-import com.redhat.rhn.common.util.download.DownloadException;\n import com.redhat.rhn.domain.user.User;\n-import com.redhat.rhn.manager.EntityExistsException;\n-import com.redhat.rhn.manager.EntityNotExistsException;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.suse.manager.maintenance.MaintenanceManager;\n-import com.suse.manager.maintenance.RescheduleResult;\n import com.suse.manager.model.maintenance.MaintenanceCalendar;\n import com.suse.manager.model.maintenance.MaintenanceSchedule;\n-import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n-import com.suse.manager.webui.utils.gson.ResultJson;\n-import org.apache.http.HttpStatus;\n+import com.suse.manager.webui.utils.gson.MaintenanceScheduleJson;\n+import org.apache.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Optional;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NDA3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437444079", "bodyText": "Long-term todo: As we discussed, maybe this could be split into Schedule and Calendar object.", "author": "hustodemon", "createdAt": "2020-06-09T13:58:39Z", "path": "java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.gson;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * JSON representation of the Maintenance Window scheduling\n+ */\n+public class MaintenanceWindowJson {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java b/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java\ndeleted file mode 100644\nindex 890e679ac77..00000000000\n--- a/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java\n+++ /dev/null\n\n@@ -1,215 +0,0 @@\n-/**\n- * Copyright (c) 2020 SUSE LLC\n- *\n- * This software is licensed to you under the GNU General Public License,\n- * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n- * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n- * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n- * along with this software; if not, see\n- * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n- *\n- * Red Hat trademarks are not licensed under GPLv2. No permission is\n- * granted to use or replicate Red Hat trademarks that are incorporated\n- * in this software or its documentation.\n- */\n-package com.suse.manager.webui.utils.gson;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * JSON representation of the Maintenance Window scheduling\n- */\n-public class MaintenanceWindowJson {\n-\n-    /** schedule ID */\n-    private Long scheduleId;\n-\n-    /** Name of the schedule */\n-    private String scheduleName;\n-\n-    /** Type of the schedule\n-     * Either SINGLE or MULTI\n-     */\n-    private String scheduleType;\n-\n-    /** calendar ID */\n-    private Long calendarId;\n-\n-    /** The name of the calendar */\n-    private String calendarName;\n-\n-    /** The url to the ical file */\n-    private String calendarUrl;\n-\n-    /** The calendars ical data */\n-    private String calendarData;\n-\n-    /** List of schedule names used by a calendar */\n-    private List<Map<String, String>> scheduleNames;\n-\n-    /** The reschedule strategy */\n-    private String strategy;\n-\n-    /**\n-     * Gets the id of the schedule\n-     *\n-     * @return the scheduleId\n-     */\n-    public Long getScheduleId() {\n-        return scheduleId;\n-    }\n-\n-    /**\n-     * Sets the id of the schedule\n-     *\n-     * @param scheduleIdIn the scheduleId\n-     */\n-    public void setScheduleId(Long scheduleIdIn) {\n-        this.scheduleId = scheduleIdIn;\n-    }\n-\n-    /**\n-     * Gets the name of the schedule\n-     *\n-     * @return the scheduleName\n-     */\n-    public String getScheduleName() {\n-        return scheduleName;\n-    }\n-\n-    /**\n-     * Sets the name of the schedule\n-     *\n-     * @param scheduleNameIn the scheduleName\n-     */\n-    public void setScheduleName(String scheduleNameIn) {\n-        this.scheduleName = scheduleNameIn;\n-    }\n-\n-    /**\n-     * Gets the type of the schedule\n-     *\n-     * @return the scheduleType\n-     */\n-    public String getScheduleType() {\n-        return scheduleType;\n-    }\n-\n-    /**\n-     * Sets the type of the schedule\n-     *\n-     * @param scheduleTypeIn the scheduleType\n-     */\n-    public void setScheduleType(String scheduleTypeIn) {\n-        this.scheduleType = scheduleTypeIn;\n-    }\n-\n-    /**\n-     * Gets the id of the calendar\n-     *\n-     * @return the calendarId\n-     */\n-    public Long getCalendarId() {\n-        return calendarId;\n-    }\n-\n-    /**\n-     * Sets the id of the calendar\n-     *\n-     * @param calendarIdIn the calendarId\n-     */\n-    public void setCalendarId(Long calendarIdIn) {\n-        this.calendarId = calendarIdIn;\n-    }\n-\n-    /**\n-     * Gets the name of the calendar\n-     *\n-     * @return the calendarName\n-     */\n-    public String getCalendarName() {\n-        return calendarName;\n-    }\n-\n-    /**\n-     * Sets the name of the calendar\n-     *\n-     * @param calendarNameIn the calendarName\n-     */\n-    public void setCalendarName(String calendarNameIn) {\n-        this.calendarName = calendarNameIn;\n-    }\n-\n-    /**\n-     * Gets the ical data of the calendar\n-     *\n-     * @return the calendarData\n-     */\n-    public String getCalendarData() {\n-        return calendarData;\n-    }\n-\n-    /**\n-     * Sets the ical data of the calendar\n-     *\n-     * @param calendarDataIn the calendarData\n-     */\n-    public void setCalendarData(String calendarDataIn) {\n-        this.calendarData = calendarDataIn;\n-    }\n-\n-    /**\n-     * Gets the url to the ical file\n-     *\n-     * @return the calendarUrl\n-     */\n-    public String getCalendarUrl() {\n-        return calendarUrl;\n-    }\n-\n-    /**\n-     * Sets the url to the ical file\n-     *\n-     * @param calendarUrlIn the calendarUrl\n-     */\n-    public void setCalendarUrl(String calendarUrlIn) {\n-        this.calendarUrl = calendarUrlIn;\n-    }\n-\n-    /**\n-     * Gets a list of schedule names using a calendar object\n-     *\n-     * @return the list of scheduleNames\n-     */\n-    public List<Map<String, String>> getScheduleNames() {\n-        return scheduleNames;\n-    }\n-\n-    /**\n-     * Sets a list of schedule names using a calendar object\n-     *\n-     * @param scheduleNamesIn the list of scheduleNames\n-     */\n-    public void setScheduleNames(List<Map<String, String>> scheduleNamesIn) {\n-        this.scheduleNames = scheduleNamesIn;\n-    }\n-\n-    /**\n-     * Gets the reschedule strategy\n-     *\n-     * @return the reschedule strategy\n-     */\n-    public String getRescheduleStrategy() {\n-        return strategy;\n-    }\n-\n-    /**\n-     * Sets the reschedule strategy\n-     *\n-     * @param strategyIn the reschedule strategy\n-     */\n-    public void setRescheduleStrategy(String strategyIn) {\n-        this.strategy = strategyIn;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437447403", "bodyText": "Is this annotation needed?", "author": "hustodemon", "createdAt": "2020-06-09T14:02:58Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -246,6 +246,34 @@ protected void save(MaintenanceCalendar calendar) {\n             .list();\n     }\n \n+    /**\n+     * List Maintenance Schedules belonging to the given User\n+     * @param user the user\n+     * @return a list of Maintenance Schedules\n+     */\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxMjM3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440012379", "bodyText": "All the other queries in this file added by mc also seem to have it. And it gets rid of annoying warnings", "author": "parlt91", "createdAt": "2020-06-15T08:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxODQ3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440718477", "bodyText": "What warnings? I don't see any.", "author": "hustodemon", "createdAt": "2020-06-16T09:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0MjkzNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r441342934", "bodyText": "It displays a unchecked assignment warning if removed.\nAnyway I am not opposed to removing it, but we should stay consistent.\nEither remove or add it everywhere.", "author": "parlt91", "createdAt": "2020-06-17T07:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/maintenance/MaintenanceManager.java b/java/code/src/com/suse/manager/maintenance/MaintenanceManager.java\nindex 764068aa2fe..cb184b53bbb 100644\n--- a/java/code/src/com/suse/manager/maintenance/MaintenanceManager.java\n+++ b/java/code/src/com/suse/manager/maintenance/MaintenanceManager.java\n\n@@ -246,34 +364,6 @@ public class MaintenanceManager {\n             .list();\n     }\n \n-    /**\n-     * List Maintenance Schedules belonging to the given User\n-     * @param user the user\n-     * @return a list of Maintenance Schedules\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public List<MaintenanceSchedule> listMaintenanceSchedulesByUser(User user) {\n-        return getSession()\n-                .createQuery(\"FROM MaintenanceSchedule WHERE org = :org\")\n-                .setParameter(\"org\", user.getOrg())\n-                .list();\n-    }\n-\n-    /**\n-     * List Schedule names that use given calendar\n-     * @param user the user\n-     * @param calendar the calendar\n-     * @return a list of MaintenanceSchedules\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public List<MaintenanceSchedule> listMaintenanceSchedulesByCalendar(User user, MaintenanceCalendar calendar) {\n-        return getSession()\n-                .createQuery(\"FROM MaintenanceSchedule WHERE org = :org and calendar = :calendar\")\n-                .setParameter(\"org\", user.getOrg())\n-                .setParameter(\"calendar\", calendar)\n-                .list();\n-    }\n-\n     /**\n      * Lookup a MaintenanceSchedule by user and name\n      * @param user the user\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437538675", "bodyText": "Just questioning to make sure: all users are allowed to reach these pages right? If so, then this is fine.", "author": "ncounter", "createdAt": "2020-06-09T15:51:48Z", "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "diffHunk": "@@ -288,6 +288,9 @@\n                 .addChild(new MenuItem(\"Action Chains\").withPrimaryUrl(\"/rhn/schedule/ActionChains.do\")\n                     .withAltUrl(\"/rhn/schedule/ActionChain.do\"))\n                 .addChild(new MenuItem(\"Recurring States\").withPrimaryUrl(\"/rhn/manager/schedule/recurring-states\"))\n+                .addChild(new MenuItem(\"Maintenance Windows\").withDir(\"/rhn/manager/schedule/maintenance\")", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxMDExMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440010111", "bodyText": "I am not sure actually. 'normal' users are not allowed to edit/delete, but I don't know about viewing schedules/calendars. I will clarify this.", "author": "parlt91", "createdAt": "2020-06-15T08:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NTc4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r441675786", "bodyText": "Restricted destructive operations to OrgAdmin user only as discussed", "author": "parlt91", "createdAt": "2020-06-17T16:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/menu/MenuTree.java b/java/code/src/com/suse/manager/webui/menu/MenuTree.java\nindex f4933860f57..e147824151e 100644\n--- a/java/code/src/com/suse/manager/webui/menu/MenuTree.java\n+++ b/java/code/src/com/suse/manager/webui/menu/MenuTree.java\n\n@@ -288,9 +294,6 @@ public class MenuTree {\n                 .addChild(new MenuItem(\"Action Chains\").withPrimaryUrl(\"/rhn/schedule/ActionChains.do\")\n                     .withAltUrl(\"/rhn/schedule/ActionChain.do\"))\n                 .addChild(new MenuItem(\"Recurring States\").withPrimaryUrl(\"/rhn/manager/schedule/recurring-states\"))\n-                .addChild(new MenuItem(\"Maintenance Windows\").withDir(\"/rhn/manager/schedule/maintenance\")\n-                    .addChild(new MenuItem(\"Schedules\").withPrimaryUrl(\"/rhn/manager/schedule/maintenance/schedules\"))\n-                    .addChild(new MenuItem(\"Calendars\").withPrimaryUrl(\"/rhn/manager/schedule/maintenance/calendars\")))\n                 );\n \n             // Users\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0MDMyNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437540324", "bodyText": "I'd better drop possible values of a filed: what if in the future the set change? This comment would be outdated but not easy to catch.", "author": "ncounter", "createdAt": "2020-06-09T15:53:59Z", "path": "java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.gson;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * JSON representation of the Maintenance Window scheduling\n+ */\n+public class MaintenanceWindowJson {\n+\n+    /** schedule ID */\n+    private Long scheduleId;\n+\n+    /** Name of the schedule */\n+    private String scheduleName;\n+\n+    /** Type of the schedule\n+     * Either SINGLE or MULTI", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "chunk": "diff --git a/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java b/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java\ndeleted file mode 100644\nindex 890e679ac77..00000000000\n--- a/java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java\n+++ /dev/null\n\n@@ -1,215 +0,0 @@\n-/**\n- * Copyright (c) 2020 SUSE LLC\n- *\n- * This software is licensed to you under the GNU General Public License,\n- * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n- * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n- * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n- * along with this software; if not, see\n- * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n- *\n- * Red Hat trademarks are not licensed under GPLv2. No permission is\n- * granted to use or replicate Red Hat trademarks that are incorporated\n- * in this software or its documentation.\n- */\n-package com.suse.manager.webui.utils.gson;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * JSON representation of the Maintenance Window scheduling\n- */\n-public class MaintenanceWindowJson {\n-\n-    /** schedule ID */\n-    private Long scheduleId;\n-\n-    /** Name of the schedule */\n-    private String scheduleName;\n-\n-    /** Type of the schedule\n-     * Either SINGLE or MULTI\n-     */\n-    private String scheduleType;\n-\n-    /** calendar ID */\n-    private Long calendarId;\n-\n-    /** The name of the calendar */\n-    private String calendarName;\n-\n-    /** The url to the ical file */\n-    private String calendarUrl;\n-\n-    /** The calendars ical data */\n-    private String calendarData;\n-\n-    /** List of schedule names used by a calendar */\n-    private List<Map<String, String>> scheduleNames;\n-\n-    /** The reschedule strategy */\n-    private String strategy;\n-\n-    /**\n-     * Gets the id of the schedule\n-     *\n-     * @return the scheduleId\n-     */\n-    public Long getScheduleId() {\n-        return scheduleId;\n-    }\n-\n-    /**\n-     * Sets the id of the schedule\n-     *\n-     * @param scheduleIdIn the scheduleId\n-     */\n-    public void setScheduleId(Long scheduleIdIn) {\n-        this.scheduleId = scheduleIdIn;\n-    }\n-\n-    /**\n-     * Gets the name of the schedule\n-     *\n-     * @return the scheduleName\n-     */\n-    public String getScheduleName() {\n-        return scheduleName;\n-    }\n-\n-    /**\n-     * Sets the name of the schedule\n-     *\n-     * @param scheduleNameIn the scheduleName\n-     */\n-    public void setScheduleName(String scheduleNameIn) {\n-        this.scheduleName = scheduleNameIn;\n-    }\n-\n-    /**\n-     * Gets the type of the schedule\n-     *\n-     * @return the scheduleType\n-     */\n-    public String getScheduleType() {\n-        return scheduleType;\n-    }\n-\n-    /**\n-     * Sets the type of the schedule\n-     *\n-     * @param scheduleTypeIn the scheduleType\n-     */\n-    public void setScheduleType(String scheduleTypeIn) {\n-        this.scheduleType = scheduleTypeIn;\n-    }\n-\n-    /**\n-     * Gets the id of the calendar\n-     *\n-     * @return the calendarId\n-     */\n-    public Long getCalendarId() {\n-        return calendarId;\n-    }\n-\n-    /**\n-     * Sets the id of the calendar\n-     *\n-     * @param calendarIdIn the calendarId\n-     */\n-    public void setCalendarId(Long calendarIdIn) {\n-        this.calendarId = calendarIdIn;\n-    }\n-\n-    /**\n-     * Gets the name of the calendar\n-     *\n-     * @return the calendarName\n-     */\n-    public String getCalendarName() {\n-        return calendarName;\n-    }\n-\n-    /**\n-     * Sets the name of the calendar\n-     *\n-     * @param calendarNameIn the calendarName\n-     */\n-    public void setCalendarName(String calendarNameIn) {\n-        this.calendarName = calendarNameIn;\n-    }\n-\n-    /**\n-     * Gets the ical data of the calendar\n-     *\n-     * @return the calendarData\n-     */\n-    public String getCalendarData() {\n-        return calendarData;\n-    }\n-\n-    /**\n-     * Sets the ical data of the calendar\n-     *\n-     * @param calendarDataIn the calendarData\n-     */\n-    public void setCalendarData(String calendarDataIn) {\n-        this.calendarData = calendarDataIn;\n-    }\n-\n-    /**\n-     * Gets the url to the ical file\n-     *\n-     * @return the calendarUrl\n-     */\n-    public String getCalendarUrl() {\n-        return calendarUrl;\n-    }\n-\n-    /**\n-     * Sets the url to the ical file\n-     *\n-     * @param calendarUrlIn the calendarUrl\n-     */\n-    public void setCalendarUrl(String calendarUrlIn) {\n-        this.calendarUrl = calendarUrlIn;\n-    }\n-\n-    /**\n-     * Gets a list of schedule names using a calendar object\n-     *\n-     * @return the list of scheduleNames\n-     */\n-    public List<Map<String, String>> getScheduleNames() {\n-        return scheduleNames;\n-    }\n-\n-    /**\n-     * Sets a list of schedule names using a calendar object\n-     *\n-     * @param scheduleNamesIn the list of scheduleNames\n-     */\n-    public void setScheduleNames(List<Map<String, String>> scheduleNamesIn) {\n-        this.scheduleNames = scheduleNamesIn;\n-    }\n-\n-    /**\n-     * Gets the reschedule strategy\n-     *\n-     * @return the reschedule strategy\n-     */\n-    public String getRescheduleStrategy() {\n-        return strategy;\n-    }\n-\n-    /**\n-     * Sets the reschedule strategy\n-     *\n-     * @param strategyIn the reschedule strategy\n-     */\n-    public void setRescheduleStrategy(String strategyIn) {\n-        this.strategy = strategyIn;\n-    }\n-}\n"}}, {"oid": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "url": "https://github.com/uyuni-project/uyuni/commit/6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "message": "Add controller class\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:53:33Z", "type": "commit"}, {"oid": "34c7ffa04e688a3cf004983b12dd6d512d1e0218", "url": "https://github.com/uyuni-project/uyuni/commit/34c7ffa04e688a3cf004983b12dd6d512d1e0218", "message": "Add controller to the Router\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "7830e6a7ffad5f43c913db6c010163a60be9cc96", "url": "https://github.com/uyuni-project/uyuni/commit/7830e6a7ffad5f43c913db6c010163a60be9cc96", "message": "Add jade file\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "89a68df73e8cda44e7f71c2ac4721b5620bac116", "url": "https://github.com/uyuni-project/uyuni/commit/89a68df73e8cda44e7f71c2ac4721b5620bac116", "message": "Add Json class for maintenance schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "23bb872d4b3d82e926df04d1c78d9576221136ec", "url": "https://github.com/uyuni-project/uyuni/commit/23bb872d4b3d82e926df04d1c78d9576221136ec", "message": "Create MenuTree item\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "e55b7d02a125d4c597e4964403506de41fd8b78a", "url": "https://github.com/uyuni-project/uyuni/commit/e55b7d02a125d4c597e4964403506de41fd8b78a", "message": "Add maintenance schedules index\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c8505882c2e8a5d151560cb834d85bb31f8a5c76", "url": "https://github.com/uyuni-project/uyuni/commit/c8505882c2e8a5d151560cb834d85bb31f8a5c76", "message": "Add maintenance schedule base class\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "68206de2c3938cf4763c01a26a4aad4436f915a2", "url": "https://github.com/uyuni-project/uyuni/commit/68206de2c3938cf4763c01a26a4aad4436f915a2", "message": "Add ui for listing maintenance schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "acfd8ba635af3bc9ec6be784223f4f8519819e96", "url": "https://github.com/uyuni-project/uyuni/commit/acfd8ba635af3bc9ec6be784223f4f8519819e96", "message": "Add ui page for creating/editing schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "61a8d0f48c0cb6cbc40ad97dbfc060e22f9f7505", "url": "https://github.com/uyuni-project/uyuni/commit/61a8d0f48c0cb6cbc40ad97dbfc060e22f9f7505", "message": "Add details view for schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "8abfe8352759118cc7aa98048969e7d1c3bef008", "url": "https://github.com/uyuni-project/uyuni/commit/8abfe8352759118cc7aa98048969e7d1c3bef008", "message": "Controller save method\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "70428e1dc85d962f754b17de3a6dd2e337cb81de", "url": "https://github.com/uyuni-project/uyuni/commit/70428e1dc85d962f754b17de3a6dd2e337cb81de", "message": "Make 'Add Calendar' button instead of checkbox\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c6bb6c6227ed1251fe984b9e6843c37710262170", "url": "https://github.com/uyuni-project/uyuni/commit/c6bb6c6227ed1251fe984b9e6843c37710262170", "message": "Add Calendar column in schedule list\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "2b0558ff9b9a422ce1e8b2c4329fa8ffabba805d", "url": "https://github.com/uyuni-project/uyuni/commit/2b0558ff9b9a422ce1e8b2c4329fa8ffabba805d", "message": "Fix details view not rendering\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c0eb71f4a9d780607cc4497000e2b53d88977efd", "url": "https://github.com/uyuni-project/uyuni/commit/c0eb71f4a9d780607cc4497000e2b53d88977efd", "message": "Add deleting of schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "e8ff6eaaa29bce7c96221465bd43adafe947940e", "url": "https://github.com/uyuni-project/uyuni/commit/e8ff6eaaa29bce7c96221465bd43adafe947940e", "message": "Get detailed schedule info\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "59b65698458620b58c1149ba449c81a56f90d37f", "url": "https://github.com/uyuni-project/uyuni/commit/59b65698458620b58c1149ba449c81a56f90d37f", "message": "Rename maintenance-schedules.jade -> maintenance-windows.jade\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "dc86231dd68ca2d9cf07aaaa2afa45e220c50357", "url": "https://github.com/uyuni-project/uyuni/commit/dc86231dd68ca2d9cf07aaaa2afa45e220c50357", "message": "Update MenuTree, add translation strings\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "e1a5686378751272e9e3f6b44d2d84a4d82cef4e", "url": "https://github.com/uyuni-project/uyuni/commit/e1a5686378751272e9e3f6b44d2d84a4d82cef4e", "message": "Add type to distinguish between calendar and schedule in UI\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "28393778459bed891c23e8b7ad473e5e5fa2e2fa", "url": "https://github.com/uyuni-project/uyuni/commit/28393778459bed891c23e8b7ad473e5e5fa2e2fa", "message": "Rename maintenance-schedules -> maintenance-windows\n\nSince these components will handle both schedules and calendar\nmaintenance-windows seems to be a more adequate name.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "53b6fe538367a42ddf9ccef880a0003203a91f66", "url": "https://github.com/uyuni-project/uyuni/commit/53b6fe538367a42ddf9ccef880a0003203a91f66", "message": "Rename MaintenanceScheduleJson -> MaintenanceWindowJson\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "a1bd2bbfdf079cd7de1e72e77da27b29f65b724d", "url": "https://github.com/uyuni-project/uyuni/commit/a1bd2bbfdf079cd7de1e72e77da27b29f65b724d", "message": "Adapt controller class to handle schedules/calendars individually\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "be62705601a12a6df135a4511c23a9a47a5e15a5", "url": "https://github.com/uyuni-project/uyuni/commit/be62705601a12a6df135a4511c23a9a47a5e15a5", "message": "Change webui to reflect controller changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "29307ae0f98bb4cb8309c38950b5f33bdb9d2989", "url": "https://github.com/uyuni-project/uyuni/commit/29307ae0f98bb4cb8309c38950b5f33bdb9d2989", "message": "Add missing javadoc, fix checkstyle\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "87d1d3dd3a48079470839a5e7e22e891057015dc", "url": "https://github.com/uyuni-project/uyuni/commit/87d1d3dd3a48079470839a5e7e22e891057015dc", "message": "Display ical file in details, distinguish between schedule/calendar\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "a74a24ed1adfa6d0f57cbd3172830a0f254df6a3", "url": "https://github.com/uyuni-project/uyuni/commit/a74a24ed1adfa6d0f57cbd3172830a0f254df6a3", "message": "Handle reschedule strategy\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "d5cee2cace92759f154264316f1df0583d456f8d", "url": "https://github.com/uyuni-project/uyuni/commit/d5cee2cace92759f154264316f1df0583d456f8d", "message": "Support refreshing calendars from url\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "50c03dce6350a53599cc131a4b1a81cb438e7282", "url": "https://github.com/uyuni-project/uyuni/commit/50c03dce6350a53599cc131a4b1a81cb438e7282", "message": "Create links to calendar/schedule details in list\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "31aa0d16e49186c0cafae67102bde46a48114e89", "url": "https://github.com/uyuni-project/uyuni/commit/31aa0d16e49186c0cafae67102bde46a48114e89", "message": "Add queries to get schedule/calendar objects\n\nRename listScheduleNamesByCalendar -> listMaintenanceSchedulesByCalendar\nto clarify the behavior.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "b75484f87a00eb1210aae53a26ffbd46896606e9", "url": "https://github.com/uyuni-project/uyuni/commit/b75484f87a00eb1210aae53a26ffbd46896606e9", "message": "Add localization to the controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "89b61c2a23603511459b9ec9687ae0b8ec4c4d72", "url": "https://github.com/uyuni-project/uyuni/commit/89b61c2a23603511459b9ec9687ae0b8ec4c4d72", "message": "Fix calendar data refresh\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "7ef882c4b967e2885edfd14bf2f3fb79abfab93e", "url": "https://github.com/uyuni-project/uyuni/commit/7ef882c4b967e2885edfd14bf2f3fb79abfab93e", "message": "Move styling to its own css file\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "eaf1d9911b21394aa97d5b235146f90307901e8c", "url": "https://github.com/uyuni-project/uyuni/commit/eaf1d9911b21394aa97d5b235146f90307901e8c", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-16T07:32:13Z", "type": "forcePushed"}, {"oid": "fea7795d3938893af6bc10ea8cd92697c9c1012d", "url": "https://github.com/uyuni-project/uyuni/commit/fea7795d3938893af6bc10ea8cd92697c9c1012d", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-16T16:20:39Z", "type": "forcePushed"}, {"oid": "2a9c70a4713f7a17118b803af8cb0840dbd0ea0a", "url": "https://github.com/uyuni-project/uyuni/commit/2a9c70a4713f7a17118b803af8cb0840dbd0ea0a", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T09:38:37Z", "type": "forcePushed"}, {"oid": "057260017842f4807c0b0a04706ef3d5297149cd", "url": "https://github.com/uyuni-project/uyuni/commit/057260017842f4807c0b0a04706ef3d5297149cd", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:26:12Z", "type": "forcePushed"}, {"oid": "e9e49c2292695fc30271fee1c836e69f049aa653", "url": "https://github.com/uyuni-project/uyuni/commit/e9e49c2292695fc30271fee1c836e69f049aa653", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:34Z", "type": "commit"}, {"oid": "70eef68b15725ecc9b578e8da6c57dc10db882c9", "url": "https://github.com/uyuni-project/uyuni/commit/70eef68b15725ecc9b578e8da6c57dc10db882c9", "message": "Display upcoming maintenance windows in schedule details view\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "commit"}, {"oid": "5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "url": "https://github.com/uyuni-project/uyuni/commit/5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "commit"}, {"oid": "5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "url": "https://github.com/uyuni-project/uyuni/commit/5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "forcePushed"}, {"oid": "fbb4c4f98a963b7093582dbe94c3bad1c14fbaac", "url": "https://github.com/uyuni-project/uyuni/commit/fbb4c4f98a963b7093582dbe94c3bad1c14fbaac", "message": "Use the Table component for the details view\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-18T16:25:24Z", "type": "commit"}]}