{"pr_number": 1766, "pr_title": "[SCB-1922] implemented core logic of zero-config registry", "pr_createdAt": "2020-05-20T00:21:01Z", "pr_url": "https://github.com/apache/servicecomb-java-chassis/pull/1766", "timeline": [{"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931", "url": "https://github.com/apache/servicecomb-java-chassis/commit/bfeca6e794add76bc7216c490d93af6b20fe5931", "message": "[SCB-1922] implemented core logic of zero-config registry", "committedDate": "2020-05-19T23:55:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427693412", "bodyText": "This line is too long. use etc/*xml code template to format files.", "author": "liubao68", "createdAt": "2020-05-20T01:38:02Z", "path": "service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.api.response.HeartbeatResponse;\n+import org.apache.servicecomb.serviceregistry.client.http.MicroserviceInstances;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.mockito.Mock;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_ID;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_BASE_PATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_SUBPATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.server.ZeroConfigRegistryService;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestZeroConfigRegistryClientImpl {\n+\n+    ZeroConfigRegistryClientImpl target;\n+\n+    @Mock\n+    ZeroConfigRegistryService zeroConfigRegistryService;\n+\n+    @Mock\n+    MulticastSocket multicastSocket;\n+\n+    @Mock\n+    RestTemplate restTemplate;\n+\n+    // testing data\n+    String selfServiceId = \"123\";\n+    String selfInstanceId = \"instanceId\";\n+    String otherServiceId = \"456\";\n+    String appId = \"appId\";\n+    String serviceName = \"serviceName\";\n+    String version = \"0.0.0.1\";\n+    String status = \"UP\";\n+    String host = \"host\";\n+    String schemaId1 = \"schemaId1\";\n+    String schemaContent1 = \"schemaContent1\";\n+    String newSchemaId = \"newSchemaId\";\n+    String newSchemaContent = \"newSchemaContent\";\n+    String nonExistSchemaId = \"nonExistSchemaId\";\n+    String endpoint1 = \"endpoint1\";\n+    String strVersionRule = \"0.0.0.0+\";\n+\n+    @Before\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        target = new ZeroConfigRegistryClientImpl(zeroConfigRegistryService, multicastSocket, restTemplate);\n+    }\n+\n+    private Microservice prepareService(String serviceId, boolean withId){\n+        Microservice microservice = new Microservice();\n+        if (withId){\n+            microservice.setServiceId(serviceId);\n+        }\n+        microservice.setServiceName(serviceName);\n+        microservice.setAppId(appId);\n+        microservice.setVersion(version);\n+        microservice.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        microservice.setSchemas(schemas);\n+        microservice.addSchema(schemaId1, schemaContent1);\n+        return microservice;\n+    }\n+\n+    private MicroserviceInstance prepareInstance(String instanceId, boolean withId){\n+        MicroserviceInstance instance = new MicroserviceInstance();\n+        if (withId){\n+            instance.setInstanceId(instanceId);\n+        }\n+        instance.setServiceId(selfServiceId);\n+        List<String> endpointList = new ArrayList<>();\n+        endpointList.add(endpoint1);\n+        instance.setEndpoints(endpointList);\n+        instance.setStatus(MicroserviceInstanceStatus.UP);\n+        instance.setHostName(host);\n+        return instance;\n+    }\n+\n+    private ServerMicroserviceInstance prepareServerServiceInstance(boolean withEndpoint){\n+        ServerMicroserviceInstance serverServiceInstance = new ServerMicroserviceInstance();\n+        serverServiceInstance.setServiceId(otherServiceId);\n+        serverServiceInstance.setInstanceId(selfInstanceId);\n+        serverServiceInstance.setServiceName(serviceName);\n+        serverServiceInstance.setAppId(appId);\n+        serverServiceInstance.setVersion(version);\n+        serverServiceInstance.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        serverServiceInstance.setSchemas(schemas);\n+        if (withEndpoint) {\n+            List<String> endpointList = new ArrayList<>();\n+            endpointList.add(endpoint1);\n+            serverServiceInstance.setEndpoints(endpointList);\n+        }\n+        serverServiceInstance.setHostName(host);\n+        return serverServiceInstance;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withID_shouldReturnSameID(){\n+        Microservice selfService = prepareService(selfServiceId, true);\n+        ClientUtil.microserviceSelf = selfService;\n+\n+        String returnedServiceId = target.registerMicroservice(selfService);\n+\n+        Assert.assertEquals(selfServiceId, returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withoutID_shouldReturnGeneratedID(){\n+        Microservice serviceWithoutID = prepareService(selfServiceId, false);\n+        ClientUtil.microserviceSelf = serviceWithoutID;\n+\n+        String returnedServiceId = target.registerMicroservice(serviceWithoutID);\n+\n+        Assert.assertEquals(ClientUtil.generateServiceId(serviceWithoutID), returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnItself_And_NotCallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);;\n+\n+        Microservice microservice = target.getMicroservice(selfServiceId);\n+\n+        Assert.assertEquals(microservice.getServiceId(), ClientUtil.microserviceSelf.getServiceId());\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnOtherService_And_CallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+\n+        Microservice returnedMicroservice = target.getMicroservice(otherServiceId);\n+\n+        Assert.assertEquals(otherServiceId, returnedMicroservice.getServiceId());\n+        verify(zeroConfigRegistryService, times(1)).getMicroservice(otherServiceId);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, false);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNotItselfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(otherServiceId, true);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenServiceIdIsItselfId_shouldReturnTrue(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, schemaId1);\n+        Assert.assertTrue(returnedResult);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenSchemaNotExist_shouldReturnFalse(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, nonExistSchemaId);\n+        Assert.assertFalse(returnedResult);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, false);\n+\n+        target.registerSchema(selfServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNotItSelfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        target.registerSchema(otherServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test\n+    public void test_registerSchema_whenReigsterForItself_shouldSuceed(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.registerSchema(selfServiceId, newSchemaId, newSchemaContent);\n+        Assert.assertTrue(returnedResult);\n+        Assert.assertEquals(newSchemaContent, ClientUtil.microserviceSelf.getSchemaMap().computeIfPresent(newSchemaId, (k, v) -> {\n+            return v;\n+        }));\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldSuceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldNotCallZeroConfigRegistryServiceAndSucceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForOtherMicroservice_shouldCallZeroConfigRegistryService(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+        String schemaContentEndpoint = endpoint1 + SCHEMA_CONTENT_ENDPOINT_BASE_PATH + SCHEMA_CONTENT_ENDPOINT_SUBPATH + \"?\" + SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD + \"=\" + schemaId1;", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODA0Mg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708042", "bodyText": "after removing those \"long\" constant\uff0c now. it's much shorter:)", "author": "jungan21", "createdAt": "2020-05-20T02:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "76a8c3b1476c2298ae039e32884b37247348eccd", "chunk": "diff --git a/service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java b/service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/zeroconfig/client/TestZeroConfigRegistryClientImpl.java\nsimilarity index 94%\nrename from service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java\nrename to service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/zeroconfig/client/TestZeroConfigRegistryClientImpl.java\nindex 03a32ad53..1b7140129 100644\n--- a/service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java\n+++ b/service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/zeroconfig/client/TestZeroConfigRegistryClientImpl.java\n\n@@ -14,20 +14,17 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry.client;\n+package org.apache.servicecomb.zeroconfig.client;\n \n import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n import org.apache.servicecomb.serviceregistry.api.response.HeartbeatResponse;\n import org.apache.servicecomb.serviceregistry.client.http.MicroserviceInstances;\n-import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n import org.mockito.Mock;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_ID;\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_BASE_PATH;\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD;\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_SUBPATH;\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.INSTANCE_ID;\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n import static org.mockito.Matchers.anyObject;\n import static org.mockito.Mockito.when;\n import static org.mockito.Mockito.times;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694389", "bodyText": "Suggestions: path and name only used in endpoints, I think use literal is more readable than using a constant, we can easly get what's the url and param from method signature without a code jump.", "author": "liubao68", "createdAt": "2020-05-20T01:41:54Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzkxNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707914", "bodyText": "sure. cleared those constant", "author": "jungan21", "createdAt": "2020-05-20T02:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "76a8c3b1476c2298ae039e32884b37247348eccd", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 64%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..a75334f65 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,31 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n     // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+    @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET )\n+    public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n         Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n+        if (!schemaMap.isEmpty() && schemaMap.containsKey(schemaId)){\n+           return schemaMap.get(schemaId);\n+        }\n+        LOGGER.warn(\"schemaId: {} doesn't exist:\", schemaId);\n+        return null;\n     }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694599", "bodyText": "Suggestions: package name can rename to org.apache.serviecomb.zeroconfig", "author": "liubao68", "createdAt": "2020-05-20T01:42:38Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzgyOA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707828", "bodyText": "agree. will renmae package naeme", "author": "jungan21", "createdAt": "2020-05-20T02:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "76a8c3b1476c2298ae039e32884b37247348eccd", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ClientUtil.java\nsimilarity index 96%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ClientUtil.java\nindex ed8191269..37bfd6691 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ClientUtil.java\n\n@@ -14,12 +14,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry.client;\n+package org.apache.servicecomb.zeroconfig.client;\n \n import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n-import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427698915", "bodyText": "better to use JAX-RS annotation, because not all project depend on swagger-generator-springmvc", "author": "wujimin", "createdAt": "2020-05-20T01:58:40Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODcxNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708714", "bodyText": "I see. thx for the reminder, Since I tested for Spingmvc version already.  I will make this change to JAX-RS version in next PR. thx", "author": "jungan21", "createdAt": "2020-05-20T02:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjE5MQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428916191", "bodyText": "I tried with pure JAX-RS annotation today It seems our swagger generator has issue for processing JAX-RS @QueryParam and @PathParam.  When there is no path parameter annotation, it's OK. Below please find the details.\n**1. Error when parsing JAX-RS @QueryParam annotation to take in query parameter. I\n\n@RestSchema(schemaId = \"schemaContentEndpoint\")\n@Path(\"/schemaEndpoint\")\n@Produces(MediaType.TEXT_PLAIN)\npublic class SchemaContentEndpoint {\n\n    @Path(\"/schemas\")\n    @GET\n    public String getSchemaEndpoint(**@QueryParam**(\"schemaId\") String schemaId) {\n        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n        return schemaMap.get(schemaId);\n    }\n}\n\nError message:\nCaused by: java.lang.IllegalStateException: parameter name is not present, method=org.apache.servicecomb.zeroconfigsc.SchemaContentEndpoint:getSchemaEndpoint\nsolution:\n  change pom.xml, add compiler argument: -parameters, for example:\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <configuration>\n        <compilerArgument>-parameters</compilerArgument>\n      </configuration>\n    </plugin>\n\tat org.apache.servicecomb.swagger.generator.SwaggerGeneratorUtils.collectParameterName(SwaggerGeneratorUtils.java:192)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:55)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:66)\n\tat org.apache.servicecomb.swagger.generator.core.AbstractOperationGenerator.initMethodParameterGenerators(AbstractOperationGenerator.java:230)\n\nBTW, if I replace @QueryParam with SpringMVC @RequestParameter, it works fine. Also If I remove @QueryParam, it works fine too.\nBased on the error message, it seems name attribute is required for swagger generator to be able to process/parse the Annotation.\n`", "author": "jungan21", "createdAt": "2020-05-21T21:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "76a8c3b1476c2298ae039e32884b37247348eccd", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 64%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..a75334f65 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,31 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n     // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+    @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET )\n+    public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n         Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n+        if (!schemaMap.isEmpty() && schemaMap.containsKey(schemaId)){\n+           return schemaMap.get(schemaId);\n+        }\n+        LOGGER.warn(\"schemaId: {} doesn't exist:\", schemaId);\n+        return null;\n     }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427702984", "bodyText": "seems http method should be GET", "author": "wujimin", "createdAt": "2020-05-20T02:14:11Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzczNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707734", "bodyText": "yup . agree", "author": "jungan21", "createdAt": "2020-05-20T02:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "76a8c3b1476c2298ae039e32884b37247348eccd", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 64%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..a75334f65 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,31 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n     // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+    @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET )\n+    public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n         Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n+        if (!schemaMap.isEmpty() && schemaMap.containsKey(schemaId)){\n+           return schemaMap.get(schemaId);\n+        }\n+        LOGGER.warn(\"schemaId: {} doesn't exist:\", schemaId);\n+        return null;\n     }\n }\n\\ No newline at end of file\n"}}, {"oid": "76a8c3b1476c2298ae039e32884b37247348eccd", "url": "https://github.com/apache/servicecomb-java-chassis/commit/76a8c3b1476c2298ae039e32884b37247348eccd", "message": "[SCB-1922] Address review comments", "committedDate": "2020-05-20T02:36:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427709279", "bodyText": "utils with data is not so good\neven a utils with data, should provide a getter method, not access it directly", "author": "wujimin", "createdAt": "2020-05-20T02:38:27Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDQ4MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710480", "bodyText": ":), it's eaiser for unit test", "author": "jungan21", "createdAt": "2020-05-20T02:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 57%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..03643b3dc 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,29 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n-    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n-        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n-    }\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n+\n+  // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+  @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET)\n+  public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n+    Map<String, String> schemaMap = ClientUtil.getMicroserviceSelf().getSchemaMap();\n+    return schemaMap.get(schemaId);\n+  }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710390", "bodyText": "please import codestyle:  etc/intellij-java-google-style.xml\nand then reformat new code.", "author": "wujimin", "createdAt": "2020-05-20T02:43:02Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDk5NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710994", "bodyText": "will do . thx", "author": "jungan21", "createdAt": "2020-05-20T02:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\ndeleted file mode 100644\nindex ed8191269..000000000\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\n+++ /dev/null\n\n@@ -1,141 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.servicecomb.serviceregistry.client;\n-\n-import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n-import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.net.DatagramPacket;\n-import java.net.InetAddress;\n-import java.net.MulticastSocket;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-public class ClientUtil {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n-\n-    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n-\n-    public static Microservice microserviceSelf = new Microservice();\n-\n-    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n-\n-    public static synchronized void init(){\n-        Runnable heartbeatRunnable = new Runnable() {\n-            @Override\n-            public void run() {\n-                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n-                    // after first registration succeeds\n-                    try {\n-                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n-                        MulticastSocket multicastSocket = new MulticastSocket();\n-                        multicastSocket.setLoopbackMode(false);\n-                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n-\n-                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n-                                InetAddress.getByName(GROUP), PORT);\n-\n-                        multicastSocket.send(instanceDataPacket);\n-                    } catch (Exception e) {\n-                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n-                    }\n-                }\n-            }\n-        };\n-        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n-    }\n-\n-    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n-                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n-        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n-\n-        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n-        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n-        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n-        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n-        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n-        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n-        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n-\n-        String hostName = microserviceInstance.getHostName();\n-        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n-\n-        // schema1$schema2\n-        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n-        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n-\n-        return Optional.of(serviceInstanceTextAttributesMap);\n-    }\n-\n-    private static String convertListToString (List<String> list){\n-        if (list != null && !list.isEmpty()){\n-            StringBuilder sb = new StringBuilder();\n-            for (String item : list) {\n-                sb.append(item + LIST_STRING_SPLITER);\n-            }\n-            // remove the last $\n-            return sb.toString().substring(0, sb.toString().length()-1);\n-        }\n-        return \"\";\n-    }\n-\n-    public static MicroserviceInstance convertToClientMicroserviceInstance(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        MicroserviceInstance microserviceInstance =  new MicroserviceInstance();\n-        microserviceInstance.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microserviceInstance.setInstanceId(serverMicroserviceInstance.getInstanceId());\n-        microserviceInstance.setHostName(serverMicroserviceInstance.getHostName());\n-        microserviceInstance.setEndpoints(serverMicroserviceInstance.getEndpoints());\n-        microserviceInstance.setStatus(MicroserviceInstanceStatus.valueOf(serverMicroserviceInstance.getStatus()));\n-        return microserviceInstance;\n-    }\n-\n-    public static Microservice convertToClientMicroservice(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        Microservice microservice=  new Microservice();\n-        microservice.setAppId(serverMicroserviceInstance.getAppId());\n-        microservice.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microservice.setServiceName(serverMicroserviceInstance.getServiceName());\n-        microservice.setVersion(serverMicroserviceInstance.getVersion());\n-        microservice.setStatus(serverMicroserviceInstance.getStatus());\n-        microservice.setSchemas(serverMicroserviceInstance.getSchemas());\n-        return microservice;\n-    }\n-\n-    public static String generateServiceId(Microservice microservice){\n-        String serviceIdStringIndex = String.join(SERVICE_ID_SPLITER, microservice.getAppId(),\n-                microservice.getServiceName(), microservice.getVersion());\n-        return UUID.nameUUIDFromBytes(serviceIdStringIndex.getBytes()).toString().split(UUID_SPLITER)[0];\n-    }\n-\n-    public static String generateServiceInstanceId(MicroserviceInstance microserviceInstance){\n-        return UUID.randomUUID().toString().split(UUID_SPLITER)[0];\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710637", "bodyText": "must new for each times?", "author": "wujimin", "createdAt": "2020-05-20T02:44:09Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMjAzOQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427712039", "bodyText": "no necessary.. will make change", "author": "jungan21", "createdAt": "2020-05-20T02:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\ndeleted file mode 100644\nindex ed8191269..000000000\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\n+++ /dev/null\n\n@@ -1,141 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.servicecomb.serviceregistry.client;\n-\n-import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n-import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.net.DatagramPacket;\n-import java.net.InetAddress;\n-import java.net.MulticastSocket;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-public class ClientUtil {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n-\n-    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n-\n-    public static Microservice microserviceSelf = new Microservice();\n-\n-    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n-\n-    public static synchronized void init(){\n-        Runnable heartbeatRunnable = new Runnable() {\n-            @Override\n-            public void run() {\n-                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n-                    // after first registration succeeds\n-                    try {\n-                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n-                        MulticastSocket multicastSocket = new MulticastSocket();\n-                        multicastSocket.setLoopbackMode(false);\n-                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n-\n-                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n-                                InetAddress.getByName(GROUP), PORT);\n-\n-                        multicastSocket.send(instanceDataPacket);\n-                    } catch (Exception e) {\n-                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n-                    }\n-                }\n-            }\n-        };\n-        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n-    }\n-\n-    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n-                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n-        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n-\n-        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n-        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n-        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n-        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n-        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n-        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n-        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n-\n-        String hostName = microserviceInstance.getHostName();\n-        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n-\n-        // schema1$schema2\n-        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n-        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n-\n-        return Optional.of(serviceInstanceTextAttributesMap);\n-    }\n-\n-    private static String convertListToString (List<String> list){\n-        if (list != null && !list.isEmpty()){\n-            StringBuilder sb = new StringBuilder();\n-            for (String item : list) {\n-                sb.append(item + LIST_STRING_SPLITER);\n-            }\n-            // remove the last $\n-            return sb.toString().substring(0, sb.toString().length()-1);\n-        }\n-        return \"\";\n-    }\n-\n-    public static MicroserviceInstance convertToClientMicroserviceInstance(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        MicroserviceInstance microserviceInstance =  new MicroserviceInstance();\n-        microserviceInstance.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microserviceInstance.setInstanceId(serverMicroserviceInstance.getInstanceId());\n-        microserviceInstance.setHostName(serverMicroserviceInstance.getHostName());\n-        microserviceInstance.setEndpoints(serverMicroserviceInstance.getEndpoints());\n-        microserviceInstance.setStatus(MicroserviceInstanceStatus.valueOf(serverMicroserviceInstance.getStatus()));\n-        return microserviceInstance;\n-    }\n-\n-    public static Microservice convertToClientMicroservice(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        Microservice microservice=  new Microservice();\n-        microservice.setAppId(serverMicroserviceInstance.getAppId());\n-        microservice.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microservice.setServiceName(serverMicroserviceInstance.getServiceName());\n-        microservice.setVersion(serverMicroserviceInstance.getVersion());\n-        microservice.setStatus(serverMicroserviceInstance.getStatus());\n-        microservice.setSchemas(serverMicroserviceInstance.getSchemas());\n-        return microservice;\n-    }\n-\n-    public static String generateServiceId(Microservice microservice){\n-        String serviceIdStringIndex = String.join(SERVICE_ID_SPLITER, microservice.getAppId(),\n-                microservice.getServiceName(), microservice.getVersion());\n-        return UUID.nameUUIDFromBytes(serviceIdStringIndex.getBytes()).toString().split(UUID_SPLITER)[0];\n-    }\n-\n-    public static String generateServiceInstanceId(MicroserviceInstance microserviceInstance){\n-        return UUID.randomUUID().toString().split(UUID_SPLITER)[0];\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427711788", "bodyText": "String.join(\",\", list)", "author": "wujimin", "createdAt": "2020-05-20T02:48:47Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();\n+                        multicastSocket.setLoopbackMode(false);\n+                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n+\n+                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n+                                InetAddress.getByName(GROUP), PORT);\n+\n+                        multicastSocket.send(instanceDataPacket);\n+                    } catch (Exception e) {\n+                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n+                    }\n+                }\n+            }\n+        };\n+        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n+                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n+        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n+\n+        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n+        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n+        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n+        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n+        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n+        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n+        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n+\n+        String hostName = microserviceInstance.getHostName();\n+        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n+\n+        // schema1$schema2\n+        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n+        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n+\n+        return Optional.of(serviceInstanceTextAttributesMap);\n+    }\n+\n+    private static String convertListToString (List<String> list){", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU2OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713568", "bodyText": "Thanks! clean code :)", "author": "jungan21", "createdAt": "2020-05-20T02:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\ndeleted file mode 100644\nindex ed8191269..000000000\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java\n+++ /dev/null\n\n@@ -1,141 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.servicecomb.serviceregistry.client;\n-\n-import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n-import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n-import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.net.DatagramPacket;\n-import java.net.InetAddress;\n-import java.net.MulticastSocket;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-public class ClientUtil {\n-\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n-\n-    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n-\n-    public static Microservice microserviceSelf = new Microservice();\n-\n-    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n-\n-    public static synchronized void init(){\n-        Runnable heartbeatRunnable = new Runnable() {\n-            @Override\n-            public void run() {\n-                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n-                    // after first registration succeeds\n-                    try {\n-                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n-                        MulticastSocket multicastSocket = new MulticastSocket();\n-                        multicastSocket.setLoopbackMode(false);\n-                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n-\n-                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n-                                InetAddress.getByName(GROUP), PORT);\n-\n-                        multicastSocket.send(instanceDataPacket);\n-                    } catch (Exception e) {\n-                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n-                    }\n-                }\n-            }\n-        };\n-        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n-    }\n-\n-    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n-                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n-        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n-\n-        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n-        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n-        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n-        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n-        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n-        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n-        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n-\n-        String hostName = microserviceInstance.getHostName();\n-        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n-\n-        // schema1$schema2\n-        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n-        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n-\n-        return Optional.of(serviceInstanceTextAttributesMap);\n-    }\n-\n-    private static String convertListToString (List<String> list){\n-        if (list != null && !list.isEmpty()){\n-            StringBuilder sb = new StringBuilder();\n-            for (String item : list) {\n-                sb.append(item + LIST_STRING_SPLITER);\n-            }\n-            // remove the last $\n-            return sb.toString().substring(0, sb.toString().length()-1);\n-        }\n-        return \"\";\n-    }\n-\n-    public static MicroserviceInstance convertToClientMicroserviceInstance(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        MicroserviceInstance microserviceInstance =  new MicroserviceInstance();\n-        microserviceInstance.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microserviceInstance.setInstanceId(serverMicroserviceInstance.getInstanceId());\n-        microserviceInstance.setHostName(serverMicroserviceInstance.getHostName());\n-        microserviceInstance.setEndpoints(serverMicroserviceInstance.getEndpoints());\n-        microserviceInstance.setStatus(MicroserviceInstanceStatus.valueOf(serverMicroserviceInstance.getStatus()));\n-        return microserviceInstance;\n-    }\n-\n-    public static Microservice convertToClientMicroservice(ServerMicroserviceInstance serverMicroserviceInstance) {\n-        Microservice microservice=  new Microservice();\n-        microservice.setAppId(serverMicroserviceInstance.getAppId());\n-        microservice.setServiceId(serverMicroserviceInstance.getServiceId());\n-        microservice.setServiceName(serverMicroserviceInstance.getServiceName());\n-        microservice.setVersion(serverMicroserviceInstance.getVersion());\n-        microservice.setStatus(serverMicroserviceInstance.getStatus());\n-        microservice.setSchemas(serverMicroserviceInstance.getSchemas());\n-        return microservice;\n-    }\n-\n-    public static String generateServiceId(Microservice microservice){\n-        String serviceIdStringIndex = String.join(SERVICE_ID_SPLITER, microservice.getAppId(),\n-                microservice.getServiceName(), microservice.getVersion());\n-        return UUID.nameUUIDFromBytes(serviceIdStringIndex.getBytes()).toString().split(UUID_SPLITER)[0];\n-    }\n-\n-    public static String generateServiceInstanceId(MicroserviceInstance microserviceInstance){\n-        return UUID.randomUUID().toString().split(UUID_SPLITER)[0];\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713594", "bodyText": "why schemaMap can be null?", "author": "wujimin", "createdAt": "2020-05-20T02:55:56Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgxMA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713810", "bodyText": "I relaized this too... can only be empy \ud83d\udc4d", "author": "jungan21", "createdAt": "2020-05-20T02:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 57%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..03643b3dc 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,29 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n-    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n-        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n-    }\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n+\n+  // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+  @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET)\n+  public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n+    Map<String, String> schemaMap = ClientUtil.getMicroserviceSelf().getSchemaMap();\n+    return schemaMap.get(schemaId);\n+  }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713824", "bodyText": "schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) \nwhat's the difference to schemaMap.get(schemaId)", "author": "wujimin", "createdAt": "2020-05-20T02:56:58Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n+        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;", "originalCommit": "bfeca6e794add76bc7216c490d93af6b20fe5931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNDMwMg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427714302", "bodyText": "will change this piece of code to the following:\n    Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n    return schemaMap.get(schemaId);", "author": "jungan21", "createdAt": "2020-05-20T02:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "d708cd13939d8fcae02511228266a41868cbf013", "chunk": "diff --git a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nsimilarity index 57%\nrename from service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\nrename to service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\nindex 0f66576a8..03643b3dc 100644\n--- a/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java\n+++ b/service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/SchemaContentEndpoint.java\n\n@@ -14,26 +14,29 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.servicecomb.serviceregistry;\n+package org.apache.servicecomb.zeroconfig;\n \n import org.apache.servicecomb.provider.rest.common.RestSchema;\n \n-import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.web.bind.annotation.RequestMapping;\n import org.springframework.web.bind.annotation.RequestMethod;\n import org.springframework.web.bind.annotation.RequestParam;\n import javax.ws.rs.core.MediaType;\n import java.util.Map;\n \n-import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n-\n-@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n-@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+@RestSchema(schemaId = \"schemaContentEndpoint\")\n+@RequestMapping(path = \"/schemaEndpoint\")\n public class SchemaContentEndpoint {\n-    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n-    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n-    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n-        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n-        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;\n-    }\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaContentEndpoint.class);\n+\n+  // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+  @RequestMapping(path = \"/schemas\", produces = MediaType.TEXT_PLAIN, method = RequestMethod.GET)\n+  public String getSchemaEndpoint(@RequestParam(name = \"schemaId\") String schemaId) {\n+    Map<String, String> schemaMap = ClientUtil.getMicroserviceSelf().getSchemaMap();\n+    return schemaMap.get(schemaId);\n+  }\n }\n\\ No newline at end of file\n"}}, {"oid": "d708cd13939d8fcae02511228266a41868cbf013", "url": "https://github.com/apache/servicecomb-java-chassis/commit/d708cd13939d8fcae02511228266a41868cbf013", "message": "[SCB-1922] implemented core logic of zero-config registry", "committedDate": "2020-05-20T03:56:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427824327", "bodyText": "It's better to use the same configuratioin mechansim, see: https://docs.servicecomb.io/java-chassis/zh_CN/config/general-config/\nand use a boolean value, e.g 'DynamicPropertyFacotry.getInstance().getBooleanProperty(\"servicecomb.zeroconfig.enabled\", true).get()`", "author": "liubao68", "createdAt": "2020-05-20T08:17:12Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNTYzNg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428705636", "bodyText": "Thanks for sharing . will take a look at this mechanism", "author": "jungan21", "createdAt": "2020-05-21T14:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODI3NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428718275", "bodyText": "just to be safe,I will set default value to false.... for now", "author": "jungan21", "createdAt": "2020-05-21T15:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829295", "bodyText": "This attrubite is set but never read", "author": "liubao68", "createdAt": "2020-05-20T08:25:12Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc2ODI2NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428768265", "bodyText": "will deleted private ApplicationContext applicationContext; variable", "author": "jungan21", "createdAt": "2020-05-21T16:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829833", "bodyText": "Why need this line of code?", "author": "liubao68", "createdAt": "2020-05-20T08:26:04Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);\n+    if (flag != null && flag.equals(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_ENABLE_FLAG)) {\n+      this.applicationContext = applicationContext;\n+      BeanUtils.setContext(applicationContext);", "originalCommit": "d708cd13939d8fcae02511228266a41868cbf013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNzUzMQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428707531", "bodyText": "it seems not necessary.. as we will st applicationContext in the  CseApplicationListener.  just to confirm, I will remove the following two lines:\n    this.applicationContext = applicationContext;\n     BeanUtils.setContext(applicationContext);", "author": "jungan21", "createdAt": "2020-05-21T14:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw=="}], "type": "inlineReview", "revised_code": null}]}