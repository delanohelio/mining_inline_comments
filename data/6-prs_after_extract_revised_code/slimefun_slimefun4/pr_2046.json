{"pr_number": 2046, "pr_title": "Enchantment Rune", "pr_createdAt": "2020-06-25T19:37:49Z", "pr_url": "https://github.com/Slimefun/Slimefun4/pull/2046", "timeline": [{"oid": "07224cc7d5a76493574eef4a57661dc57c1cbe32", "url": "https://github.com/Slimefun/Slimefun4/commit/07224cc7d5a76493574eef4a57661dc57c1cbe32", "message": "Added Enchantment Rune.\n\nAdded Enchantment Rune that applies a random enchantment on items.\nWorks similar to Soulbound Rune.", "committedDate": "2020-06-24T13:28:35Z", "type": "commit"}, {"oid": "e1fc23c265ced97b7d40dbf66e20a225c17513be", "url": "https://github.com/Slimefun/Slimefun4/commit/e1fc23c265ced97b7d40dbf66e20a225c17513be", "message": "Fixed an import dis-organisation.", "committedDate": "2020-06-24T18:27:27Z", "type": "commit"}, {"oid": "f54b2771110a7aa5ff36463a293130060f6f169c", "url": "https://github.com/Slimefun/Slimefun4/commit/f54b2771110a7aa5ff36463a293130060f6f169c", "message": "Merge branch 'master' of https://github.com/LinoxGH/Slimefun4 into EnchRune\n\n\u0001 Conflicts:\n\u0001\tsrc/main/java/io/github/thebusybiscuit/slimefun4/implementation/SlimefunItems.java\n\u0001\tsrc/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java\n\u0001\tsrc/main/resources/languages/researches_en.yml", "committedDate": "2020-06-25T19:35:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0ODM3NQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446048375", "bodyText": "This is a rather bad approach to this. It would be much better to loop through all Enchantments and split them based on the .canEnchant() method or so to sort it based on items.", "author": "TheBusyBiscuit", "createdAt": "2020-06-26T08:38:15Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+\n+    private static final Enchantment[] helmEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.OXYGEN, Enchantment.WATER_WORKER, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+    private static final Enchantment[] chestLeggingsEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+    private static final Enchantment[] bootsEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.FROST_WALKER, Enchantment.PROTECTION_FALL, Enchantment.DEPTH_STRIDER, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+\n+    private static final Enchantment[] swordEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.FIRE_ASPECT, Enchantment.LOOT_BONUS_MOBS, Enchantment.KNOCKBACK, Enchantment.SWEEPING_EDGE, Enchantment.DAMAGE_ALL, Enchantment.DAMAGE_ARTHROPODS, Enchantment.DAMAGE_UNDEAD};\n+    private static final Enchantment[] tridentEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.IMPALING, Enchantment.CHANNELING, Enchantment.LOYALTY, Enchantment.RIPTIDE};\n+    private static Enchantment[] crossbowEnch;\n+    private static final Enchantment[] bowEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.ARROW_DAMAGE, Enchantment.ARROW_FIRE, Enchantment.ARROW_INFINITE, Enchantment.ARROW_KNOCKBACK};\n+\n+    private static final Enchantment[] axeEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED, Enchantment.LOOT_BONUS_BLOCKS, Enchantment.SILK_TOUCH, Enchantment.DAMAGE_ALL, Enchantment.DAMAGE_UNDEAD, Enchantment.DAMAGE_ARTHROPODS};\n+    private static final Enchantment[] toolEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED, Enchantment.LOOT_BONUS_BLOCKS, Enchantment.SILK_TOUCH};\n+    private static final Enchantment[] shearEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED};\n+    private static final Enchantment[] fishRodEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.LURE, Enchantment.LUCK};\n+    private static final Enchantment[] otherItemsEnch = {Enchantment.MENDING, Enchantment.DURABILITY};", "originalCommit": "f54b2771110a7aa5ff36463a293130060f6f169c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NzgzMA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446097830", "bodyText": "oh I forgot about that method lol", "author": "LinoxGH", "createdAt": "2020-06-26T10:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0ODM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 83a46b521..c166b4303 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,7 +1,10 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Optional;\n+import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"oid": "9176d795c88a404f5dd87a59ab73ac10c9d8fff3", "url": "https://github.com/Slimefun/Slimefun4/commit/9176d795c88a404f5dd87a59ab73ac10c9d8fff3", "message": "Merge branch 'master' of https://github.com/TheBusyBiscuit/Slimefun4 into EnchRune", "committedDate": "2020-06-26T10:28:45Z", "type": "commit"}, {"oid": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "url": "https://github.com/Slimefun/Slimefun4/commit/eb2bbae0c986691229fd0fcb069af8f3737d4151", "message": "Did the requested changes.", "committedDate": "2020-06-26T10:31:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTM4MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679380", "bodyText": "I wouldn't really have a seperate research for this, these two can easily share the same research.\nBesides... why glass anyway?", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:55:46Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java", "diffHunk": "@@ -267,6 +267,8 @@ public static void setupResearches() {\n         register(\"advanced_industrial_miner\", 98, \"Better Mining\", 36, SlimefunItems.ADVANCED_INDUSTRIAL_MINER);\n         register(\"magical_zombie_pills\", 257, \"De-Zombification\", 22, SlimefunItems.MAGICAL_ZOMBIE_PILLS);\n         register(\"auto_brewer\", 258, \"Industrial Brewery\", 30, SlimefunItems.AUTO_BREWER);\n+        register(\"enchantment_rune\", 259, \"Ancient Enchanting\", 24, SlimefunItems.ENCHANTMENT_RUNE);\n+        register(\"magical_glass\", 260, \"Magical See-Through\", 5, SlimefunItems.MAGICAL_GLASS);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4MDQ3Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446680473", "bodyText": "I wanted players to spend some xp using flask of knowledges but even 9 wouldn't be enough so I added this.", "author": "LinoxGH", "createdAt": "2020-06-28T18:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java\nindex 5590c31db..9b480651e 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java\n\n@@ -267,8 +267,7 @@ public final class ResearchSetup {\n         register(\"advanced_industrial_miner\", 98, \"Better Mining\", 36, SlimefunItems.ADVANCED_INDUSTRIAL_MINER);\n         register(\"magical_zombie_pills\", 257, \"De-Zombification\", 22, SlimefunItems.MAGICAL_ZOMBIE_PILLS);\n         register(\"auto_brewer\", 258, \"Industrial Brewery\", 30, SlimefunItems.AUTO_BREWER);\n-        register(\"enchantment_rune\", 259, \"Ancient Enchanting\", 24, SlimefunItems.ENCHANTMENT_RUNE);\n-        register(\"magical_glass\", 260, \"Magical See-Through\", 5, SlimefunItems.MAGICAL_GLASS);\n+        register(\"enchantment_rune\", 259, \"Ancient Enchanting\", 24, SlimefunItems.MAGICAL_GLASS, SlimefunItems.ENCHANTMENT_RUNE);\n     }\n \n     private static void register(String key, int id, String name, int defaultCost, ItemStack... items) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTQ5Ng==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679496", "bodyText": "Please do not use abbreviations like this.\nThis is a nightmare maintenance-wise. Name your methods accordingly, like getApplicableEnchantments.\nAnd not findEnchArr...", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:57:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTUzMw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679533", "bodyText": "This can (and probably should) be done using a ternary operator.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:57:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {\n+        Enchantment[] enchArr = applicableEnchs.get(type);\n+        if (enchArr == null) enchArr = new Enchantment[0];\n+        return enchArr;", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTU5MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679591", "bodyText": "Please write out your variable names...\nAbbreviations make it hard to maintain later down the line.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:09Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTYxNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679617", "bodyText": "This should be an EnumMap, not a HashMap.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:31Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTYyNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679627", "bodyText": "All of this can be reduced to a single line:\ngetOrDefault", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:47Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {\n+        Enchantment[] enchArr = applicableEnchs.get(type);\n+        if (enchArr == null) enchArr = new Enchantment[0];\n+        return enchArr;", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTc2NQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679765", "bodyText": "Why are you storing this as a variable here? I don't see this index used anywhere else.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:00:09Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTg0NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679844", "bodyText": "Should probably choose a little more magical sound effect and visual than a quote: GENERIC_SPLODE...", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:00:57Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTkyOA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679928", "bodyText": "Should also check for conflicts, since you wouldn't want to enchant a Silk Touch with Fortune.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:01:49Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTk1MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679951", "bodyText": "Also always declare with base types, Map.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:02:13Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex c166b4303..f650cad7b 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,14 +1,18 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n+import java.util.EnumMap;\n import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n import org.bukkit.enchantments.Enchantment;\n import org.bukkit.entity.Entity;\n"}}, {"oid": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "url": "https://github.com/Slimefun/Slimefun4/commit/e55e2690e78067bf2615ec5926f5878c6ed1317b", "message": "Did the requested changes.", "committedDate": "2020-06-28T19:06:35Z", "type": "commit"}, {"oid": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "url": "https://github.com/Slimefun/Slimefun4/commit/27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "message": "Fixed a little bug.", "committedDate": "2020-06-28T19:09:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODc0MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688741", "bodyText": "No need for the rather unncessary and expensive call with the ItemStack here, you can just use this here.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:30:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex aed5ce6b6..65f22d345 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,13 +1,11 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n-import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.EnumMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODkwMw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688903", "bodyText": "You could save yourself this Array to ArrayList conversion if you directly stored a List in your Map", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:31:35Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex aed5ce6b6..65f22d345 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,13 +1,11 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n-import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.EnumMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODkzNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688937", "bodyText": "You should use .isEmpty() here", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:31:57Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex aed5ce6b6..65f22d345 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,13 +1,11 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n-import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.EnumMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTA2NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446689064", "bodyText": "This would result in concurrent modification. Use an Iterator instead.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:33:14Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            for (Enchantment enchantment : enchantmentSet) {\n+                for (Enchantment itemEnchantment : target.getEnchantments().keySet()) {\n+                    if (enchantment == itemEnchantment) enchantmentSet.remove(enchantment);", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex aed5ce6b6..65f22d345 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,13 +1,11 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n-import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.EnumMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTE4OA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446689188", "bodyText": "Also you are missing conflicting enchantments", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:34:29Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            for (Enchantment enchantment : enchantmentSet) {", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex aed5ce6b6..65f22d345 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -1,13 +1,11 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n \n-import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.EnumMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n \n import org.bukkit.Location;\n"}}, {"oid": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "url": "https://github.com/Slimefun/Slimefun4/commit/5c7accbbe8a4d3377ae9bada48de126e189d2202", "message": "Did the requested changes + a fix.", "committedDate": "2020-06-28T20:46:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5NjU3MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696571", "bodyText": "This will remove it from the actual List stored inside your Map, so you should copy the List before modifying it in any way.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:49:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 65f22d345..e1ba3df4a 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -87,7 +87,7 @@ public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n             Item entity = (Item) optional.get();\n             ItemStack target = entity.getItemStack();\n \n-            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            List<Enchantment> enchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n             if (enchantmentList.isEmpty()) return;\n \n             //Removing the enchantments that the item already has from enchantmentSet\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5NjY3Mg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696672", "bodyText": "Hmmm, well you are returning anyway when the list is empty...\nSo you could just do a simple get and do a null check instead of creating a new ArrayList and then immediately discarding it.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:50:32Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 65f22d345..e1ba3df4a 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -87,7 +87,7 @@ public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n             Item entity = (Item) optional.get();\n             ItemStack target = entity.getItemStack();\n \n-            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            List<Enchantment> enchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n             if (enchantmentList.isEmpty()) return;\n \n             //Removing the enchantments that the item already has from enchantmentSet\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc1NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696754", "bodyText": "Should probably also send a failure message if no enchantment was applicable.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:51:19Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));\n+            if (enchantmentList.isEmpty()) return;", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 65f22d345..e1ba3df4a 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -87,7 +87,7 @@ public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n             Item entity = (Item) optional.get();\n             ItemStack target = entity.getItemStack();\n \n-            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            List<Enchantment> enchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n             if (enchantmentList.isEmpty()) return;\n \n             //Removing the enchantments that the item already has from enchantmentSet\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696780", "bodyText": "Also still missing the conflict check.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:51:38Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcwMzk2OQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446703969", "bodyText": "I don't understand ehat you mean by conflict check.", "author": "LinoxGH", "createdAt": "2020-06-28T22:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcwOTgyNA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446709824", "bodyText": "Enchantments can have conflicts, like I explained earlier.\nSilk Touch and Fortune are incompatible for example, there is also a method to check for this: Enchantment#conflictsWith(...)", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T23:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 65f22d345..e1ba3df4a 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -87,7 +87,7 @@ public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n             Item entity = (Item) optional.get();\n             ItemStack target = entity.getItemStack();\n \n-            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            List<Enchantment> enchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n             if (enchantmentList.isEmpty()) return;\n \n             //Removing the enchantments that the item already has from enchantmentSet\n"}}, {"oid": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "url": "https://github.com/Slimefun/Slimefun4/commit/28b5d545da8f958ceaa9949e5eef9a92564be3f2", "message": "Did some requested change.", "committedDate": "2020-06-28T21:56:38Z", "type": "commit"}, {"oid": "833b2d3943b1f843ab26b51bbf6d145f85951ec3", "url": "https://github.com/Slimefun/Slimefun4/commit/833b2d3943b1f843ab26b51bbf6d145f85951ec3", "message": "Did another requested change.", "committedDate": "2020-06-28T22:11:01Z", "type": "commit"}, {"oid": "942bf436bbbb934a7975eb923b604286f9458499", "url": "https://github.com/Slimefun/Slimefun4/commit/942bf436bbbb934a7975eb923b604286f9458499", "message": "Did another requested change.", "committedDate": "2020-06-29T07:02:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg4Mjk5NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446882994", "bodyText": "You are creating two new ArrayLists here.\nPlease only use .get(), do a null check and then copy. Otherwise you are just creating a wasteful List, which you then copy and then discard both. This is really inefficient.", "author": "TheBusyBiscuit", "createdAt": "2020-06-29T10:09:56Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> applicableEnchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n+            if (applicableEnchantmentList.isEmpty()) {", "originalCommit": "942bf436bbbb934a7975eb923b604286f9458499", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b6112e272867516383c48831fa1dd9990b45c97b", "chunk": "diff --git a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\nindex 5dfc4cba6..658a215b4 100644\n--- a/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n+++ b/src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java\n\n@@ -88,10 +88,12 @@ public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n             Item entity = (Item) optional.get();\n             ItemStack target = entity.getItemStack();\n \n-            List<Enchantment> applicableEnchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n-            if (applicableEnchantmentList.isEmpty()) {\n+            List<Enchantment> applicableEnchantmentList = applicableEnchantments.get(target.getType());\n+            if (applicableEnchantmentList == null) {\n                 SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n                 return;\n+            } else {\n+                applicableEnchantmentList = new ArrayList<>(applicableEnchantmentList);\n             }\n \n             //Removing the enchantments that the item already has from enchantmentSet\n"}}, {"oid": "b6112e272867516383c48831fa1dd9990b45c97b", "url": "https://github.com/Slimefun/Slimefun4/commit/b6112e272867516383c48831fa1dd9990b45c97b", "message": "Did a requested change.", "committedDate": "2020-06-29T11:45:27Z", "type": "commit"}]}