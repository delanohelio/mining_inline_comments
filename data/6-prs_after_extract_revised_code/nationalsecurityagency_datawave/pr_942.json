{"pr_number": 942, "pr_title": "Fixed!  Added a flatten step to EdgeQueryLogic.configureRanges to showcase te\u2026", "pr_createdAt": "2020-10-15T00:09:08Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/942", "timeline": [{"oid": "d600ac8b9f49ca1b212d40df13558835f33e60ee", "url": "https://github.com/NationalSecurityAgency/datawave/commit/d600ac8b9f49ca1b212d40df13558835f33e60ee", "message": "Added a flatten step to EdgeQueryLogic.configureRanges to showcase test errors in ExtendedEdgeQueryLogicTest and EdgeQueryFunctionalTest.  The test failures occur because EdgeTableRangeBuildingVisitor cannot handle a flattened tree.", "committedDate": "2020-10-15T00:07:27Z", "type": "commit"}, {"oid": "faa333a3df39777411f16c212afe524c5e34bdc8", "url": "https://github.com/NationalSecurityAgency/datawave/commit/faa333a3df39777411f16c212afe524c5e34bdc8", "message": "Updated the EdgeTableRangeBuildingVisitor to be able to operate on a flattened query tree.", "committedDate": "2020-10-15T02:41:30Z", "type": "commit"}, {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2", "url": "https://github.com/NationalSecurityAgency/datawave/commit/64bc7815015e48756bf4ab4b521d5065539615e2", "message": "oops", "committedDate": "2020-10-15T04:12:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODA4Nw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818087", "bodyText": "need a continue here", "author": "ivakegg", "createdAt": "2020-10-15T20:26:25Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                    continue;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n                 }", "originalCommit": "64bc7815015e48756bf4ab4b521d5065539615e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66148dd369deaf3e5978aa0dd710c0c36261743c", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\nindex 835264f16..d25a90f2a 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\n\n@@ -232,7 +232,6 @@ public class EdgeTableRangeBuildingVisitor extends BaseVisitor implements EdgeMo\n                         }\n                     }\n                     mergedContext = childContext;\n-                    continue;\n                 } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n                     for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n                         if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODU3Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818576", "bodyText": "how about set \"processed = true\" as well and then test it at the error message below.", "author": "ivakegg", "createdAt": "2020-10-15T20:27:23Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;", "originalCommit": "64bc7815015e48756bf4ab4b521d5065539615e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMzI3MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505833271", "bodyText": "Check out my latest commit.  I think that by putting the thrown exception in an else statement we fix the issue and preserve the original functionality.", "author": "jwomeara", "createdAt": "2020-10-15T20:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "66148dd369deaf3e5978aa0dd710c0c36261743c", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\nindex 835264f16..d25a90f2a 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java\n\n@@ -232,7 +232,6 @@ public class EdgeTableRangeBuildingVisitor extends BaseVisitor implements EdgeMo\n                         }\n                     }\n                     mergedContext = childContext;\n-                    continue;\n                 } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n                     for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n                         if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n"}}, {"oid": "66148dd369deaf3e5978aa0dd710c0c36261743c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/66148dd369deaf3e5978aa0dd710c0c36261743c", "message": "oops again", "committedDate": "2020-10-15T20:43:27Z", "type": "commit"}, {"oid": "a3ef07fadde51f16780336447c69d7088222c6ee", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a3ef07fadde51f16780336447c69d7088222c6ee", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow", "committedDate": "2020-10-16T18:01:09Z", "type": "commit"}, {"oid": "ded9518ad3648d135807cb7ca922da4969905c66", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ded9518ad3648d135807cb7ca922da4969905c66", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow", "committedDate": "2020-10-19T18:18:28Z", "type": "commit"}, {"oid": "4582481816bab297685d0726e52220fceb6d3b9d", "url": "https://github.com/NationalSecurityAgency/datawave/commit/4582481816bab297685d0726e52220fceb6d3b9d", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow", "committedDate": "2020-10-19T18:44:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NTI1OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r507985258", "bodyText": "Instead of repeating the message Error: problem with query syntax everywhere, could we give any additional information that may allow the receiver of this error to troubleshoot the problem", "author": "drewfarris", "createdAt": "2020-10-19T18:48:01Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n+                } else {\n+                    log.error(\"Problem parsing query\");\n+                    throw new IllegalArgumentException(\"Error: problem with query syntax\");\n                 }\n-                return contexts2;\n+            } else {\n+                \n+                log.error(\"And node had unexpected return type\");\n+                throw new IllegalArgumentException(\"Error: problem with query syntax\");", "originalCommit": "4582481816bab297685d0726e52220fceb6d3b9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAwNzU4MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r508007581", "bodyText": "This is what was there before.....", "author": "ivakegg", "createdAt": "2020-10-19T19:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NTI1OA=="}], "type": "inlineReview", "revised_code": null}]}