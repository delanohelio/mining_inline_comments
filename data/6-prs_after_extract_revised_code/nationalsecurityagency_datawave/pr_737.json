{"pr_number": 737, "pr_title": "Fixes #703 - Created query wizard in Quickstart WebUI", "pr_createdAt": "2020-02-04T20:09:49Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/737", "timeline": [{"oid": "a913a88bd1e219150d579fe1e5d3b2fdffa2ac44", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a913a88bd1e219150d579fe1e5d3b2fdffa2ac44", "message": "Created query form page for all query types in Quickstart WebUI", "committedDate": "2020-02-04T17:27:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4MTUyMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r374981522", "bodyText": "When I ran this, I got a \"Datawave could not generate a plan for the query\" message when I tried ContentQuery logic type, which makes sense, because non-ShardQueryLogic types like ContentQuery typically won't have a planner involved. But in this case, you get stuck on the /showQueryWizardStep3 page with no way to retrieve the content result.\nTo replicate, do an EventQuery to pull back wikipedia records (e.g., \"anarchy\" unfielded should work, if you have the default data loaded), copy the RECORD_ID field's value (e.g., 20130305_0/enwiki/ibrtlu.qead3h.uz468c), then just plug that value into the query field for a ContentQuery", "author": "keith-ratcliffe", "createdAt": "2020-02-04T23:25:26Z", "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        GenericResponse<String> planResponse;\n+        try {\n+            planResponse = queryExecutor.plan(queryId);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }", "originalCommit": "a913a88bd1e219150d579fe1e5d3b2fdffa2ac44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4NzgwMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r374987800", "bodyText": "I think in all cases you should have a Query ID though, so it'd be good to display that on the step3 page. E.g., its extremely handy to plug that value into a QueryMetricsQuery to troubleshoot queries as needed", "author": "keith-ratcliffe", "createdAt": "2020-02-04T23:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4MTUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMxMzExMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r375313111", "bodyText": "@keith-ratcliffe ,  initially this is working well and was tested mainly with EdgeQuery and EventQuery with the examples from the QuickStart guide since I have limited experience.\nThe queries I used were:\nEventQuery    GENRES:action OR GENRES:adv*   (LUCENE)\nEdgeQuery    SOURCE == 'kevin bacon' && TYPE == 'TV_COSTARS'   (JEXL)\n@keith-ratcliffe ,   I just pushed those requested changes.", "author": "jzgithub1", "createdAt": "2020-02-05T15:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4MTUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "0ea81610429b40946aba323acd74388f92dafe18", "chunk": "diff --git a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\nindex 99077dda2..e9461d94f 100644\n--- a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n+++ b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n\n@@ -325,22 +325,26 @@ public class BasicQueryBean {\n         String queryId = createResponse.getResult();\n         CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n         queryWizardStep3Response.setQueryId(queryId);\n-        GenericResponse<String> planResponse;\n-        try {\n-            planResponse = queryExecutor.plan(queryId);\n-        } catch (Exception e) {\n-            queryWizardStep3Response.setErrorMessage(e.getMessage());\n-            return queryWizardStep3Response;\n-        }\n         \n-        queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        if (!logicName.equals(\"ContentQuery\")) {\n+            GenericResponse<String> planResponse;\n+            try {\n+                planResponse = queryExecutor.plan(queryId);\n+            } catch (Exception e) {\n+                queryWizardStep3Response.setErrorMessage(e.getMessage());\n+                return queryWizardStep3Response;\n+            }\n+            \n+            queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        } else\n+            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");\n         \n         return queryWizardStep3Response;\n     }\n     \n     /**\n      * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n-     * response object type is dynamic, see the listQueryLogic operation to determine what the response type object will be.\n+     * response object type is dynamic, see the listQueryLogic operation to determi\"ne what the response type object will be.\n      *\n      * @param id\n      *            - (@Required)\n"}}, {"oid": "0ea81610429b40946aba323acd74388f92dafe18", "url": "https://github.com/NationalSecurityAgency/datawave/commit/0ea81610429b40946aba323acd74388f92dafe18", "message": "ContentQuery improvements", "committedDate": "2020-02-05T15:50:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDIyNg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r377960226", "bodyText": "Sorry, finally getting back to reviewing this. For the comparison here, it would be better to use your queryLogicFactory instance to get the logicClass, rather than use the logicName. The name is subject to change based on user preference. For example, the user might decide they like the name \"ContentLookup\" better and reconfigure QLF.xml. But if we rename datawave.query.tables.content.ContentQueryTable that'd at least get caught by the compiler here\nSecond issue: I did try out the update, and I did get past the original issue that I reported, but I then noticed the ContentQuery response fields get truncated to just a few visible chars in the results view. However, the d-column entries in this case are not well-suited for row/col table viewing anyway....because they can be huge, they're base64 encoded, etc. So, I think I'm fine with leaving that problem for another release down the road", "author": "keith-ratcliffe", "createdAt": "2020-02-11T23:26:03Z", "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,388 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        if (!logicName.equals(\"ContentQuery\")) {", "originalCommit": "0ea81610429b40946aba323acd74388f92dafe18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NDQwNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r378364404", "bodyText": "Thank you @keith-ratcliffe.  I will get these changes made soon.", "author": "jzgithub1", "createdAt": "2020-02-12T16:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzYwMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381553601", "bodyText": "@keith-ratcliffe , I am testing a solution to the logic name issue you mention above.   Basically I get the query logic class from the queryLogicFactory bean.  The problem is that I have to string match the object's class name against \"datawave.query.tables.content.ContentQueryTable\" which will be detected at runtime, not compile time.  I could do an \"instanceof\" comparison with ContentQueryTable but that will cause a circular dependency issue with datawave-query-core and datawave-ws-query (by having to import ContentQueryTable in my bean) .  I will push the code for you to review.", "author": "jzgithub1", "createdAt": "2020-02-19T21:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3ODU4NQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381578585", "bodyText": "Thanks @jzgithub1. I think string compare on the class name is a reasonable tradeoff, since it's not likely to be changed. I haven't tested all the query logics with this yet, but I'm thinking there are probably others like contentquery though. Maybe we could just have a static final List<String> NO_PLAN_REQUIRED = ... (or whatever) for this, and do a \"contains\" test on the incoming class name instead. Could add classnames to that list later on, if we need to (?)", "author": "keith-ratcliffe", "createdAt": "2020-02-19T22:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "3460462429b47c9da9329d64acd4d9961588679b", "chunk": "diff --git a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\nindex e9461d94f..363c5ca08 100644\n--- a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n+++ b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n\n@@ -11,6 +11,7 @@ import datawave.security.authorization.DatawavePrincipal;\n import datawave.webservice.query.Query;\n import datawave.webservice.query.QueryImpl;\n import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.BaseQueryLogic;\n import datawave.webservice.query.logic.QueryLogic;\n import datawave.webservice.query.logic.QueryLogicFactory;\n import datawave.webservice.query.result.logic.QueryLogicDescription;\n"}}, {"oid": "3460462429b47c9da9329d64acd4d9961588679b", "url": "https://github.com/NationalSecurityAgency/datawave/commit/3460462429b47c9da9329d64acd4d9961588679b", "message": "Fixes #703 - Compare against BasicQueryLogic classname during query planning", "committedDate": "2020-02-19T21:35:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4MDcyMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381580722", "bodyText": "Change to:\nqueryWizardStep3Response.setQueryPlan(\"No plan required for this query\");", "author": "keith-ratcliffe", "createdAt": "2020-02-19T22:22:51Z", "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,408 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.BaseQueryLogic;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        BaseQueryLogic logic = getQueryLogic(logicName);\n+        if (logic != null && !(logic.getClass().getName().equals(\"datawave.query.tables.content.ContentQueryTable\"))) {\n+            GenericResponse<String> planResponse;\n+            try {\n+                planResponse = queryExecutor.plan(queryId);\n+            } catch (Exception e) {\n+                queryWizardStep3Response.setErrorMessage(e.getMessage());\n+                return queryWizardStep3Response;\n+            }\n+            \n+            queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        } else\n+            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");", "originalCommit": "3460462429b47c9da9329d64acd4d9961588679b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "chunk": "diff --git a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\nindex 363c5ca08..44614edf8 100644\n--- a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n+++ b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n\n@@ -339,14 +339,14 @@ public class BasicQueryBean {\n             \n             queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n         } else\n-            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");\n+            queryWizardStep3Response.setQueryPlan(\"No plan required for this query\");\n         \n         return queryWizardStep3Response;\n     }\n     \n     /**\n      * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n-     * response object type is dynamic, see the listQueryLogic operation to determi\"ne what the response type object will be.\n+     * response object type is dynamic, see the listQueryLogic operation to determine what the response type object will be.\n      *\n      * @param id\n      *            - (@Required)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4MjAzOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381582038", "bodyText": "Typo: determi\"ne", "author": "keith-ratcliffe", "createdAt": "2020-02-19T22:25:46Z", "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,408 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.BaseQueryLogic;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        BaseQueryLogic logic = getQueryLogic(logicName);\n+        if (logic != null && !(logic.getClass().getName().equals(\"datawave.query.tables.content.ContentQueryTable\"))) {\n+            GenericResponse<String> planResponse;\n+            try {\n+                planResponse = queryExecutor.plan(queryId);\n+            } catch (Exception e) {\n+                queryWizardStep3Response.setErrorMessage(e.getMessage());\n+                return queryWizardStep3Response;\n+            }\n+            \n+            queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        } else\n+            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");\n+        \n+        return queryWizardStep3Response;\n+    }\n+    \n+    /**\n+     * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n+     * response object type is dynamic, see the listQueryLogic operation to determi\"ne what the response type object will be.", "originalCommit": "3460462429b47c9da9329d64acd4d9961588679b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "chunk": "diff --git a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\nindex 363c5ca08..44614edf8 100644\n--- a/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n+++ b/web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java\n\n@@ -339,14 +339,14 @@ public class BasicQueryBean {\n             \n             queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n         } else\n-            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");\n+            queryWizardStep3Response.setQueryPlan(\"No plan required for this query\");\n         \n         return queryWizardStep3Response;\n     }\n     \n     /**\n      * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n-     * response object type is dynamic, see the listQueryLogic operation to determi\"ne what the response type object will be.\n+     * response object type is dynamic, see the listQueryLogic operation to determine what the response type object will be.\n      *\n      * @param id\n      *            - (@Required)\n"}}, {"oid": "da99ca296b50a92e4c8dc720185af0e84469f973", "url": "https://github.com/NationalSecurityAgency/datawave/commit/da99ca296b50a92e4c8dc720185af0e84469f973", "message": "Merge branch 'master' into datawave-703-final", "committedDate": "2020-02-20T15:18:55Z", "type": "commit"}, {"oid": "24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "url": "https://github.com/NationalSecurityAgency/datawave/commit/24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "message": "Fixed some strings", "committedDate": "2020-02-20T15:34:09Z", "type": "commit"}, {"oid": "9646d29cb80c37ebfbba839ac47e4ef84621b742", "url": "https://github.com/NationalSecurityAgency/datawave/commit/9646d29cb80c37ebfbba839ac47e4ef84621b742", "message": "Added NO_PLAN_REQUIRED string list that can be appended to later on", "committedDate": "2020-02-20T17:56:50Z", "type": "commit"}]}