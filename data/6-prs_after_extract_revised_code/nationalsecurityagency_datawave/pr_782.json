{"pr_number": 782, "pr_title": "FieldConfigurationHelper updates: interface and index-only fields", "pr_createdAt": "2020-03-16T15:48:13Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/782", "timeline": [{"oid": "ccd6b634e9ec017b35e1bc1df18b9a19dd75ad29", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ccd6b634e9ec017b35e1bc1df18b9a19dd75ad29", "message": "FieldConfigurationHelper updates: interface and index-only fields\n\n . Extracted FieldConfigHelper interface\n . Implementation of FieldConfigurationHelper is XMLFieldConfigHelper\n . FieldConfigHelper now used to configure index-only fields.\n . index-only fields are store=false and indexed=true", "committedDate": "2020-03-16T15:43:28Z", "type": "commit"}, {"oid": "58426f4f3cc548ecfb29da29e34e33c35ab5384c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/58426f4f3cc548ecfb29da29e34e33c35ab5384c", "message": "Fixed unit test formatting", "committedDate": "2020-03-16T16:10:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3NjEyMA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/782#discussion_r393176120", "bodyText": "This refactor looks good to me. WRT our recent conversation, I'm guessing that the given XML schema could support multiple normalizers for a single field by just making the indexType attribute a comma-delimited list(?) The updateDatawaveTypes method will parse your fieldType var that way at least. I guess a new junit in XMLFieldConfigHelperTest could test that hypothesis, if multiple normalizers per-field is something we need to continue to support", "author": "keith-ratcliffe", "createdAt": "2020-03-16T17:01:51Z", "path": "warehouse/ingest-core/src/main/java/datawave/ingest/data/config/XMLFieldConfigHelper.java", "diffHunk": "@@ -0,0 +1,567 @@\n+package datawave.ingest.data.config;\n+\n+import com.google.common.collect.ImmutableSet;\n+import datawave.data.type.LcNoDiacriticsType;\n+import datawave.ingest.data.config.ingest.BaseIngestHelper;\n+import org.apache.log4j.Logger;\n+import org.apache.xerces.jaxp.SAXParserFactoryImpl;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.DefaultHandler;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+\n+/** Helper class to read XML based Field Configurations */\n+public final class XMLFieldConfigHelper implements FieldConfigHelper {\n+    \n+    private static final Logger log = Logger.getLogger(XMLFieldConfigHelper.class);\n+    \n+    /** be explicit and use Apache Xerces-J here instead of relying on java to plug in the proper parser */\n+    private static final SAXParserFactory parserFactory = SAXParserFactoryImpl.newInstance();\n+    \n+    private boolean noMatchStored = true;\n+    private boolean noMatchIndexed = false;\n+    private boolean noMatchReverseIndexed = false;\n+    private boolean noMatchTokenized = false;\n+    private boolean noMatchReverseTokenized = false;\n+    private String noMatchFieldType = null;\n+    \n+    private final Set<String> knownFields = new HashSet<>();\n+    \n+    private final Set<String> storedFields = new HashSet<>();\n+    private final Set<String> indexedFields = new HashSet<>();\n+    private final Set<String> reverseIndexedFields = new HashSet<>();\n+    private final Set<String> tokenizedFields = new HashSet<>();\n+    private final Set<String> reverseTokenizedFields = new HashSet<>();\n+    \n+    private final Set<Matcher> storedFieldPatterns = new HashSet<>();\n+    private final Set<Matcher> indexedFieldPatterns = new HashSet<>();\n+    private final Set<Matcher> reverseIndexedFieldPatterns = new HashSet<>();\n+    private final Set<Matcher> tokenizedFieldPatterns = new HashSet<>();\n+    private final Set<Matcher> reverseTokenizedFieldPatterns = new HashSet<>();\n+    \n+    /**\n+     * Attempt to load the field config fieldHelper from the specified file, which is expected to be found on the classpath.\n+     * \n+     * @param fieldConfigFile\n+     * @throws IllegalArgumentException\n+     *             if the file can't be found or an exception occurs when reading the file.\n+     * @return null if no a null value was specified for fieldConfigFile - or a populated FieldConfigHelper.\n+     */\n+    public static XMLFieldConfigHelper load(String fieldConfigFile, BaseIngestHelper baseIngestHelper) {\n+        if (fieldConfigFile == null) {\n+            return null;\n+        }\n+        \n+        try (InputStream in = getAsStream(fieldConfigFile)) {\n+            if (in != null) {\n+                log.info(\"Loading field configuration from configuration file: \" + fieldConfigFile);\n+                return new XMLFieldConfigHelper(in, baseIngestHelper);\n+            } else {\n+                throw new IllegalArgumentException(\"Field config file '\" + fieldConfigFile + \"' not found!\");\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Exception reading field config file '\" + fieldConfigFile + \"': \" + e.getMessage(), e);\n+        }\n+        \n+    }\n+    \n+    /*\n+     * Opens a configuration path as an InputStream. If no scheme is given (e.g. http://), then the classpath is assumed.\n+     */\n+    private static InputStream getAsStream(String fieldConfigPath) {\n+        URI uri = URI.create(fieldConfigPath);\n+        \n+        if (uri.getScheme() == null) {\n+            return XMLFieldConfigHelper.class.getClassLoader().getResourceAsStream(fieldConfigPath);\n+        } else {\n+            try {\n+                return uri.toURL().openStream();\n+            } catch (IOException e) {\n+                log.error(\"Could not open config location: \" + fieldConfigPath, e);\n+                return null;\n+            }\n+        }\n+    }\n+    \n+    public String toString() {\n+        return \"[FieldConfigHelper: \" + knownFields.size() + \" known fields, \" + storedFields.size() + \" stored fields, \" + indexedFields.size()\n+                        + \" indexed fields, \" + reverseIndexedFields.size() + \" reverse indexed fields, \" + tokenizedFields.size() + \" tokenized fields, \"\n+                        + reverseTokenizedFields.size() + \" reverse tokenized fields; \" + \"nomatch, indexed:\" + noMatchIndexed + \" reverseIndexed:\"\n+                        + noMatchReverseIndexed + \" tokenized:\" + noMatchTokenized + \" reverseTokenized:\" + noMatchReverseTokenized + \"]\";\n+        \n+    }\n+    \n+    public XMLFieldConfigHelper(InputStream in, BaseIngestHelper helper) throws ParserConfigurationException, SAXException, IOException {\n+        final FieldConfigHandler handler = new FieldConfigHandler(this, helper);\n+        SAXParser parser = parserFactory.newSAXParser();\n+        parser.parse(in, handler);\n+        \n+        log.info(\"Loaded FieldConfigHelper: \" + this);\n+    }\n+    \n+    public boolean addKnownField(String fieldName) {\n+        // must track the fields we've seen so we can properly apply default rules.\n+        return knownFields.add(fieldName);\n+    }\n+    \n+    public void setNoMatchFieldType(String fieldType) {\n+        this.noMatchFieldType = fieldType;\n+    }\n+    \n+    @Override\n+    public boolean isStoredField(String fieldName) {\n+        if (knownFields.contains(fieldName)) {\n+            return this.storedFields.contains(fieldName);\n+        }\n+        \n+        if (findMatchingPattern(fieldName, this.storedFieldPatterns)) {\n+            return true;\n+        }\n+        \n+        return isNoMatchStored();\n+    }\n+    \n+    public void addStoredField(String fieldName) {\n+        this.storedFields.add(fieldName);\n+    }\n+    \n+    public void addStoredFieldPattern(String pattern) {\n+        this.storedFieldPatterns.add(BaseIngestHelper.compileFieldNamePattern(pattern));\n+    }\n+    \n+    @Override\n+    public boolean isIndexedField(String fieldName) {\n+        if (knownFields.contains(fieldName)) {\n+            return this.indexedFields.contains(fieldName);\n+        }\n+        \n+        if (findMatchingPattern(fieldName, this.indexedFieldPatterns)) {\n+            return true;\n+        }\n+        \n+        return isNoMatchIndexed();\n+    }\n+    \n+    @Override\n+    public boolean isIndexOnlyField(String fieldName) {\n+        return isIndexedField(fieldName) && !isStoredField(fieldName);\n+    }\n+    \n+    public void addIndexedField(String fieldName) {\n+        this.indexedFields.add(fieldName);\n+    }\n+    \n+    public void addIndexedFieldPattern(String pattern) {\n+        this.indexedFieldPatterns.add(BaseIngestHelper.compileFieldNamePattern(pattern));\n+    }\n+    \n+    @Override\n+    public boolean isReverseIndexedField(String fieldName) {\n+        if (knownFields.contains(fieldName)) {\n+            return this.reverseIndexedFields.contains(fieldName);\n+        }\n+        \n+        if (findMatchingPattern(fieldName, this.reverseIndexedFieldPatterns)) {\n+            return true;\n+        }\n+        \n+        return isNoMatchReverseIndexed();\n+    }\n+    \n+    public void addReverseIndexedField(String fieldName) {\n+        this.reverseIndexedFields.add(fieldName);\n+    }\n+    \n+    public void addReverseIndexedFieldPattern(String pattern) {\n+        this.reverseIndexedFieldPatterns.add(BaseIngestHelper.compileFieldNamePattern(pattern));\n+    }\n+    \n+    @Override\n+    public boolean isTokenizedField(String fieldName) {\n+        if (knownFields.contains(fieldName)) {\n+            return this.tokenizedFields.contains(fieldName);\n+        }\n+        \n+        if (findMatchingPattern(fieldName, this.tokenizedFieldPatterns)) {\n+            return true;\n+        }\n+        \n+        return isNoMatchTokenized();\n+    }\n+    \n+    public void addTokenizedField(String fieldName) {\n+        this.tokenizedFields.add(fieldName);\n+    }\n+    \n+    public void addTokenizedFieldPattern(String pattern) {\n+        this.tokenizedFieldPatterns.add(BaseIngestHelper.compileFieldNamePattern(pattern));\n+    }\n+    \n+    @Override\n+    public boolean isReverseTokenizedField(String fieldName) {\n+        if (knownFields.contains(fieldName)) {\n+            return this.reverseTokenizedFields.contains(fieldName);\n+        }\n+        \n+        if (findMatchingPattern(fieldName, this.reverseTokenizedFieldPatterns)) {\n+            return true;\n+        }\n+        \n+        return isNoMatchReverseTokenized();\n+    }\n+    \n+    public void addReverseTokenizedField(String fieldName) {\n+        this.reverseTokenizedFields.add(fieldName);\n+    }\n+    \n+    public void addReverseTokenizedFieldPattern(String pattern) {\n+        this.reverseTokenizedFieldPatterns.add(BaseIngestHelper.compileFieldNamePattern(pattern));\n+    }\n+    \n+    public boolean isNoMatchStored() {\n+        return noMatchStored;\n+    }\n+    \n+    public void setNoMatchStored(boolean noMatchStored) {\n+        this.noMatchStored = noMatchStored;\n+    }\n+    \n+    public boolean isNoMatchIndexed() {\n+        return noMatchIndexed;\n+    }\n+    \n+    public void setNoMatchIndexed(boolean noMatchIndexed) {\n+        this.noMatchIndexed = noMatchIndexed;\n+    }\n+    \n+    public boolean isNoMatchReverseIndexed() {\n+        return noMatchReverseIndexed;\n+    }\n+    \n+    public void setNoMatchReverseIndexed(boolean noMatchReverseIndexed) {\n+        this.noMatchReverseIndexed = noMatchReverseIndexed;\n+    }\n+    \n+    public boolean isNoMatchTokenized() {\n+        return noMatchTokenized;\n+    }\n+    \n+    public void setNoMatchTokenized(boolean noMatchTokenized) {\n+        this.noMatchTokenized = noMatchTokenized;\n+    }\n+    \n+    public boolean isNoMatchReverseTokenized() {\n+        return noMatchReverseTokenized;\n+    }\n+    \n+    public void setNoMatchReverseTokenized(boolean noMatchReverseTokenized) {\n+        this.noMatchReverseTokenized = noMatchReverseTokenized;\n+    }\n+    \n+    /** Return true if any of the specified patterns matches the field name provided */\n+    private boolean findMatchingPattern(String fieldName, Collection<Matcher> patterns) {\n+        for (Matcher m : patterns) {\n+            if (m.reset(fieldName).matches()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    static final class FieldConfigHandler extends DefaultHandler {\n+        public static final String STORED = \"stored\";\n+        public static final String INDEXED = \"indexed\";\n+        public static final String REVERSE_INDEXED = \"reverseIndexed\";\n+        public static final String INDEX_TYPE = \"indexType\";\n+        public static final String TOKENIZED = \"tokenized\";\n+        public static final String REVERSE_TOKENIZED = \"reverseTokenized\";\n+        \n+        static final Set<String> expectedDefaultAttributes;\n+        static final Set<String> expectedNoMatchAttributes;\n+        \n+        static {\n+            Set<String> attr = new HashSet<>();\n+            attr.add(STORED);\n+            attr.add(INDEXED);\n+            attr.add(REVERSE_INDEXED);\n+            attr.add(TOKENIZED);\n+            attr.add(REVERSE_TOKENIZED);\n+            attr.add(INDEX_TYPE);\n+            expectedDefaultAttributes = ImmutableSet.copyOf(attr);\n+            expectedNoMatchAttributes = ImmutableSet.copyOf(attr);\n+        }\n+        \n+        private final XMLFieldConfigHelper fieldHelper;\n+        private final BaseIngestHelper ingestHelper;\n+        \n+        boolean defaultsComplete = false;\n+        \n+        boolean defaultStored = true;\n+        boolean defaultIndexed = false;\n+        boolean defaultReverseIndexed = false;\n+        boolean defaultTokenized = false;\n+        boolean defaultReverseTokenized = false;\n+        \n+        String defaultFieldType = LcNoDiacriticsType.class.getCanonicalName();\n+        \n+        FieldConfigHandler(XMLFieldConfigHelper fieldHelper, BaseIngestHelper ingestHelper) {\n+            this.fieldHelper = fieldHelper;\n+            this.ingestHelper = ingestHelper;\n+        }\n+        \n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            if (\"default\".equals(qName)) {\n+                startDefault(uri, localName, qName, attributes);\n+            } else if (\"nomatch\".equals(qName)) {\n+                startNoMatch(uri, localName, qName, attributes);\n+            } else if (\"field\".equals(qName)) {\n+                startField(uri, localName, qName, attributes);\n+            } else if (\"fieldPattern\".equals(qName)) {\n+                startFieldPattern(uri, localName, qName, attributes);\n+            } else if (\"fieldConfig\".equals(qName)) {\n+                // structurral tag only, ignore for now, but allow.\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected element encounteded in: \" + uri + \": qName: '\" + qName + \"' localName: '\" + localName + \"'\");\n+            }\n+        }\n+        \n+        void startDefault(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            final int sz = attributes.getLength();\n+            final Set<String> seenAttr = new HashSet<>(expectedDefaultAttributes);\n+            \n+            for (int i = 0; i < sz; i++) {\n+                final String qn = attributes.getQName(i);\n+                final String lv = attributes.getValue(i);\n+                \n+                if (STORED.equals(qn)) {\n+                    this.defaultStored = Boolean.parseBoolean(lv);\n+                    seenAttr.remove(STORED);\n+                } else if (INDEXED.equals(qn)) {\n+                    this.defaultIndexed = Boolean.parseBoolean(lv);\n+                    seenAttr.remove(INDEXED);\n+                } else if (REVERSE_INDEXED.equals(qn)) {\n+                    this.defaultReverseIndexed = Boolean.parseBoolean(lv);\n+                    seenAttr.remove(REVERSE_INDEXED);\n+                } else if (TOKENIZED.equals(qn)) {\n+                    this.defaultTokenized = Boolean.parseBoolean(lv);\n+                    seenAttr.remove(TOKENIZED);\n+                } else if (REVERSE_TOKENIZED.equals(qn)) {\n+                    this.defaultReverseTokenized = Boolean.parseBoolean(lv);\n+                    seenAttr.remove(REVERSE_TOKENIZED);\n+                } else if (INDEX_TYPE.equals(qn)) {\n+                    this.defaultFieldType = lv;\n+                    seenAttr.remove(INDEX_TYPE);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected attribute encounteded in: \" + uri + \" in 'default' tag: '\" + qn + \"'\");\n+                }\n+            }\n+            \n+            if (!seenAttr.isEmpty()) {\n+                throw new IllegalArgumentException(\"default tag incomplete, '\" + seenAttr + \"' attributes were missing\");\n+            } else {\n+                defaultsComplete = true;\n+            }\n+        }\n+        \n+        void startNoMatch(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            final int sz = attributes.getLength();\n+            final Set<String> seenAttr = new HashSet<>(expectedDefaultAttributes);\n+            \n+            for (int i = 0; i < sz; i++) {\n+                final String qn = attributes.getQName(i);\n+                final String lv = attributes.getValue(i);\n+                \n+                if (STORED.equals(qn)) {\n+                    fieldHelper.setNoMatchStored(Boolean.parseBoolean(lv));\n+                    seenAttr.remove(STORED);\n+                } else if (INDEXED.equals(qn)) {\n+                    fieldHelper.setNoMatchIndexed(Boolean.parseBoolean(lv));\n+                    seenAttr.remove(INDEXED);\n+                } else if (REVERSE_INDEXED.equals(qn)) {\n+                    fieldHelper.setNoMatchReverseIndexed(Boolean.parseBoolean(lv));\n+                    seenAttr.remove(REVERSE_INDEXED);\n+                } else if (TOKENIZED.equals(qn)) {\n+                    fieldHelper.setNoMatchTokenized(Boolean.parseBoolean(lv));\n+                    seenAttr.remove(TOKENIZED);\n+                } else if (REVERSE_TOKENIZED.equals(qn)) {\n+                    fieldHelper.setNoMatchReverseTokenized(Boolean.parseBoolean(lv));\n+                    seenAttr.remove(REVERSE_TOKENIZED);\n+                } else if (INDEX_TYPE.equals(qn)) {\n+                    if (this.ingestHelper != null) {\n+                        this.ingestHelper.updateDatawaveTypes(null, lv);\n+                    } else {\n+                        log.warn(\"No BaseIngestHelper set, ignoring type information for nomatch in configuration file\");\n+                    }\n+                    seenAttr.remove(INDEX_TYPE);\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected attribute encounteded in: \" + uri + \" in 'nomatch' tag: '\" + qn + \"'\");\n+                }\n+            }\n+            \n+            if (!seenAttr.isEmpty()) {\n+                throw new IllegalArgumentException(\"nomatch tag incomplete, '\" + seenAttr + \"' attributes were missing\");\n+            }\n+        }\n+        \n+        void startField(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n+            \n+            if (!defaultsComplete) {\n+                throw new IllegalStateException(\"Can't define a field without defaults - expected default tag before field tag\");\n+            }\n+            \n+            final int sz = attributes.getLength();\n+            \n+            String name = null;\n+            boolean stored = this.defaultStored;\n+            boolean indexed = this.defaultIndexed;\n+            boolean reverseIndexed = this.defaultReverseIndexed;\n+            boolean tokenized = this.defaultTokenized;\n+            boolean reverseTokenized = this.defaultReverseTokenized;\n+            String fieldType = this.defaultFieldType;\n+            \n+            for (int i = 0; i < sz; i++) {\n+                final String qn = attributes.getQName(i);\n+                final String lv = attributes.getValue(i);\n+                \n+                if (STORED.equals(qn)) {\n+                    stored = Boolean.parseBoolean(lv);\n+                } else if (INDEXED.equals(qn)) {\n+                    indexed = Boolean.parseBoolean(lv);\n+                } else if (REVERSE_INDEXED.equals(qn)) {\n+                    reverseIndexed = Boolean.parseBoolean(lv);\n+                } else if (TOKENIZED.equals(qn)) {\n+                    tokenized = Boolean.parseBoolean(lv);\n+                } else if (REVERSE_TOKENIZED.equals(qn)) {\n+                    reverseTokenized = Boolean.parseBoolean(lv);\n+                } else if (\"name\".equals(qn)) {\n+                    name = lv;\n+                } else if (INDEX_TYPE.equals(qn)) {\n+                    fieldType = lv;\n+                } else {\n+                    throw new IllegalArgumentException(\"Unexpected attribute encounteded in: \" + uri + \" in 'field' tag: '\" + qn + \"'\");\n+                }\n+            }\n+            \n+            if (name == null) {\n+                throw new IllegalArgumentException(\"No field called 'name' specified\");\n+            } else if (!this.fieldHelper.addKnownField(name)) {\n+                throw new IllegalArgumentException(\"Field \" + name\n+                                + \" was already seen, check configuration file for duplicate entries (among fieldPattern, field tags)\");\n+            }\n+            \n+            if (stored) {\n+                this.fieldHelper.addStoredField(name);\n+            }\n+            \n+            if (indexed) {\n+                this.fieldHelper.addIndexedField(name);\n+            }\n+            \n+            if (reverseIndexed) {\n+                this.fieldHelper.addReverseIndexedField(name);\n+            }\n+            \n+            if (tokenized) {\n+                this.fieldHelper.addTokenizedField(name);\n+            }\n+            \n+            if (reverseTokenized) {\n+                this.fieldHelper.addReverseTokenizedField(name);\n+            }\n+            \n+            if (fieldType != null) {\n+                if (this.ingestHelper != null) {\n+                    this.ingestHelper.updateDatawaveTypes(name, fieldType);", "originalCommit": "58426f4f3cc548ecfb29da29e34e33c35ab5384c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNTYzNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/782#discussion_r393235634", "bodyText": "Agreed, I think I'll tackle this in a separate ticket.", "author": "drewfarris", "createdAt": "2020-03-16T18:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3NjEyMA=="}], "type": "inlineReview", "revised_code": null}]}