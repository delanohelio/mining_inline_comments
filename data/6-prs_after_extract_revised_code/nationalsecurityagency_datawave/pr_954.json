{"pr_number": 954, "pr_title": "Fix lineage for AllTermsIndexedVisitor", "pr_createdAt": "2020-10-20T18:08:44Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/954", "timeline": [{"oid": "1a42d16236dfd747439fc359bde546dc6be66c9c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/1a42d16236dfd747439fc359bde546dc6be66c9c", "message": "Fix lineage for AllTermsIndexedVisitor\n\nAllTermsIndexedVisitor did not return a query tree with a valid lineage.\nEnsure that lineage is properly established and add an assert for this\nin related tests.\n\nRelated to #880", "committedDate": "2020-10-20T17:55:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY1NTkwMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/954#discussion_r514655902", "bodyText": "This method is essentially the same as the copy method in the base RebuildingVisitor.  The exception to this is the filtering step where it drops AND or OR node without any children.  That shouldn't happen, and if it is happening that points to problems elsewhere in the code base.  So, if we assume that we won't encounter an AND or OR node without any children (which I think is a fairly safe bet) then we could just use the RebuildingVisitor's copy method.  Even if we DO encounter an AND or OR node with 0 children, the switch statement in the and/or node visitors will handle that by returning null, which gets dropped by the rebuilding visitor's copy method.\nSorry for the wall of text... I think that using the visit methods of the parent RebuildingVisitor is a little bit cleaner and simplifies the code a bit.  So, in each place where you call 'getCopyWithVisitedChildren' you can instead call super.visit(node, data) which calls RebuildingVisitor.copy, which visits the entire subtree and creates copies.", "author": "jwomeara", "createdAt": "2020-10-30T01:10:07Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/AllTermsIndexedVisitor.java", "diffHunk": "@@ -63,111 +73,56 @@ public AllTermsIndexedVisitor(ShardQueryConfiguration config, MetadataHelper hel\n     \n     @Override\n     public Object visit(ASTJexlScript node, Object data) {\n-        ASTJexlScript newNode = new ASTJexlScript(ParserTreeConstants.JJTJEXLSCRIPT);\n-        newNode.image = node.image;\n-        \n-        int newIndex = 0;\n-        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-            Node newChild = (Node) node.jjtGetChild(i).jjtAccept(this, data);\n-            \n-            if (newChild != null) {\n-                // When we have an AND or OR\n-                if ((newChild instanceof ASTOrNode || newChild instanceof ASTAndNode)) {\n-                    // Only add that node if it actually has children\n-                    if (0 < newChild.jjtGetNumChildren()) {\n-                        newNode.jjtAddChild(newChild, newIndex);\n-                        newIndex++;\n-                    }\n-                } else {\n-                    // Otherwise, we want to add the child regardless\n-                    newNode.jjtAddChild(newChild, newIndex);\n-                    newIndex++;\n-                }\n-            }\n-        }\n+        JexlNode copy = getCopyWithVisitedChildren(node, data);\n         \n-        if (newNode.jjtGetNumChildren() == 0) {\n+        if (copy.jjtGetNumChildren() == 0) {\n             NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.NO_ANYFIELD_EXPANSION_MATCH);\n             log.warn(qe);\n             throw new EmptyUnfieldedTermExpansionException(qe);\n         }\n         \n-        return newNode;\n+        return copy;\n     }\n     \n     @Override\n     public Object visit(ASTOrNode node, Object data) {\n-        ASTOrNode newNode = new ASTOrNode(ParserTreeConstants.JJTORNODE);\n-        newNode.image = node.image;\n-        \n-        int newIndex = 0;\n-        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-            Node newChild = (Node) node.jjtGetChild(i).jjtAccept(this, data);\n-            \n-            if (newChild != null) {\n-                // When we have an AND or OR\n-                if ((newChild instanceof ASTOrNode || newChild instanceof ASTAndNode)) {\n-                    // Only add that node if it actually has children\n-                    if (0 < newChild.jjtGetNumChildren()) {\n-                        newNode.jjtAddChild(newChild, newIndex);\n-                        newIndex++;\n-                    }\n-                } else {\n-                    // Otherwise, we want to add the child regardless\n-                    newNode.jjtAddChild(newChild, newIndex);\n-                    newIndex++;\n-                }\n-            }\n-        }\n-        \n-        switch (newNode.jjtGetNumChildren()) {\n-            case 0:\n-                return null;\n-            case 1:\n-                JexlNode child = newNode.jjtGetChild(0);\n-                JexlNodes.promote(newNode, child);\n-                return child;\n-            default:\n-                return newNode;\n-        }\n+        return visitJunctionNode(node, data);\n     }\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {\n-        ASTAndNode newNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-        newNode.image = node.image;\n+        return visitJunctionNode(node, data);\n+    }\n+    \n+    private Object visitJunctionNode(JexlNode node, Object data) {\n+        JexlNode copy = getCopyWithVisitedChildren(node, data);\n         \n-        int newIndex = 0;\n-        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-            Node newChild = (Node) node.jjtGetChild(i).jjtAccept(this, data);\n-            \n-            if (newChild != null) {\n-                // When we have an AND or OR\n-                if ((newChild instanceof ASTOrNode || newChild instanceof ASTAndNode)) {\n-                    // Only add that node if it actually has children\n-                    if (0 < newChild.jjtGetNumChildren()) {\n-                        newNode.jjtAddChild(newChild, newIndex);\n-                        newIndex++;\n-                    }\n-                } else {\n-                    // Otherwise, we want to add the child regardless\n-                    newNode.jjtAddChild(newChild, newIndex);\n-                    newIndex++;\n-                }\n-            }\n-        }\n-        switch (newNode.jjtGetNumChildren()) {\n+        switch (copy.jjtGetNumChildren()) {\n             case 0:\n                 return null;\n             case 1:\n-                JexlNode child = newNode.jjtGetChild(0);\n-                JexlNodes.promote(newNode, child);\n+                JexlNode child = copy.jjtGetChild(0);\n+                promote(copy, child);\n                 return child;\n             default:\n-                return newNode;\n+                return copy;\n         }\n     }\n     \n+    private JexlNode getCopyWithVisitedChildren(JexlNode node, Object data) {\n+        // @formatter:off\n+        JexlNode[] children = Arrays.stream(JexlNodes.children(node))\n+                        .map(n -> (JexlNode) n.jjtAccept(this, data)) // Visit the node.\n+                        .filter(Objects::nonNull) // Remove null nodes.\n+                        .filter(n -> (!(n instanceof ASTAndNode) && !(n instanceof ASTOrNode)) || JexlNodes.isNotChildless(n)) // Remove empty junction nodes.\n+                        .toArray(JexlNode[]::new);\n+        // @formatter:on\n+        JexlNode copy = JexlNodes.newInstanceOfType(node);\n+        copy.image = node.image;\n+        JexlNodes.children(copy, children);\n+        return copy;\n+    }", "originalCommit": "1a42d16236dfd747439fc359bde546dc6be66c9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjI3NA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/954#discussion_r516822274", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-11-03T17:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY1NTkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "e78806239b34d73298e189ea8761c9bdd525fb21", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/AllTermsIndexedVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/AllTermsIndexedVisitor.java\nindex a9e212c1f..72820d215 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/AllTermsIndexedVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/AllTermsIndexedVisitor.java\n\n@@ -73,7 +70,7 @@ public class AllTermsIndexedVisitor extends RebuildingVisitor {\n     \n     @Override\n     public Object visit(ASTJexlScript node, Object data) {\n-        JexlNode copy = getCopyWithVisitedChildren(node, data);\n+        JexlNode copy = (JexlNode) super.visit(node, data);\n         \n         if (copy.jjtGetNumChildren() == 0) {\n             NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.NO_ANYFIELD_EXPANSION_MATCH);\n"}}, {"oid": "e78806239b34d73298e189ea8761c9bdd525fb21", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e78806239b34d73298e189ea8761c9bdd525fb21", "message": "Remove getCopyWithVisitedChildren()", "committedDate": "2020-11-03T17:03:09Z", "type": "commit"}, {"oid": "93a541c43a37e2b1b05dc4c79668e29d2adb272a", "url": "https://github.com/NationalSecurityAgency/datawave/commit/93a541c43a37e2b1b05dc4c79668e29d2adb272a", "message": "Merge branch 'master' into 880-AllTermsIndexedVisitor", "committedDate": "2020-11-03T17:22:42Z", "type": "commit"}, {"oid": "4efc5340780a3444dbd69d11672d6b855fc7ca17", "url": "https://github.com/NationalSecurityAgency/datawave/commit/4efc5340780a3444dbd69d11672d6b855fc7ca17", "message": "Merge branch 'release/version3.0' into 880-AllTermsIndexedVisitor", "committedDate": "2020-12-11T16:28:35Z", "type": "commit"}]}