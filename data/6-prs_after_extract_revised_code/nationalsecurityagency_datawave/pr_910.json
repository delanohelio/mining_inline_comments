{"pr_number": 910, "pr_title": "Remove redundant conjunctions and disjunctions from query", "pr_createdAt": "2020-09-01T03:16:35Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/910", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMzk1MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481033951", "bodyText": "This should be able to handle any number of terms within an OrNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:21:22Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA5OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912099", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMzk1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\nindex 0fbfced2d..4be286ee1 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNTM5MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481035390", "bodyText": "otherScript -> otherNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:24:10Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTA0MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171040", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNTM5MA=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\nindex 0fbfced2d..4be286ee1 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNzc2NQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481037765", "bodyText": "Something like..?\n// Returns true if the conjunction contains a duplicate of the provided node", "author": "apmoriarty", "createdAt": "2020-09-01T10:28:47Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTIyNQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171225", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzNzc2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\nindex 0fbfced2d..4be286ee1 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049434", "bodyText": "I'm disliking that for each equivalence check we build a string, parse it, then wrap it in a ASTJexlScript to run the equality visitor. However, hacking in another TreeEqualityVisitor.isEqual() method that accepts jexl nodes instead of scripts doesn't play nicely with reference expressions.\nIn a perfect world the TreeEqualityVisitor would support evaluation of two jexl nodes that may or may not represent subtrees, with an option to descend into reference expressions. It should not force you into evaluation two jexl scripts.\nTo be clear, you are doing the correct thing here -- I'm complaining about exiting code.", "author": "apmoriarty", "createdAt": "2020-09-01T10:51:33Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(ConjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        ConjunctionEliminationVisitor visitor = new ConjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTOrNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isConjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isConjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an AND.\n+    private boolean isConjunction(JexlNode node) {\n+        return node instanceof ASTAndNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {\n+        int totalChildren = conjunction.jjtGetNumChildren();\n+        ASTJexlScript script = getScript(otherScript);\n+        for (int i = 0; i < totalChildren; i++) {\n+            JexlNode child = conjunction.jjtGetChild(i);\n+            if (isEquivalent(child, script)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    // Copy the child node and replace the original node with it in the original node's parent.\n+    private JexlNode copyChildAndUpdateParent(JexlNode original, JexlNode child) {\n+        JexlNode copy = copy(child);\n+        copy.image = original.image;\n+        replaceChild(original.jjtGetParent(), original, copy);\n+        return copy;\n+    }\n+    \n+    // Return whether or not the two JEXL queries are equivalent.\n+    private boolean isEquivalent(JexlNode node, ASTJexlScript script) throws ParseException {\n+        ASTJexlScript nodeScript = getScript(node);\n+        return TreeEqualityVisitor.isEqual(nodeScript, script, new TreeEqualityVisitor.Reason());", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NTA2Ng==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481175066", "bodyText": "I thought about comparing the query strings similar to UniqueExpressionTermsVisitor, but I found that didn't handle the case where duplicate ANDs/ORs with sub-terms in differing order. It might be worth creating a ticket to come up with a more efficient way to check equivalency between two JexlNodes so that someone can eventually tackle that.", "author": "lbschanno", "createdAt": "2020-09-01T14:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0MDU3OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r485740579", "bodyText": "Not a bad idea. Opened issue here #914", "author": "apmoriarty", "createdAt": "2020-09-09T16:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\nindex 0fbfced2d..4be286ee1 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class ConjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTYwOQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049609", "bodyText": "disjunctions?", "author": "apmoriarty", "createdAt": "2020-09-01T10:51:51Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(DisjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTY2Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171663", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\nindex 2d69b54aa..ec398549d 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTgyMQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481049821", "bodyText": "otherScript -> otherNode", "author": "apmoriarty", "createdAt": "2020-09-01T10:52:18Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ASTOrNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.ASTReferenceExpression;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.apache.log4j.Logger;\n+\n+import static org.apache.commons.jexl2.parser.JexlNodes.replaceChild;\n+\n+public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n+    \n+    private static final Logger log = Logger.getLogger(DisjunctionEliminationVisitor.class);\n+    \n+    /**\n+     * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n+     *\n+     * @param node\n+     *            a query node\n+     * @return a re-written query tree for the node\n+     */\n+    public static <T extends JexlNode> T optimize(T node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        \n+        // Operate on copy of query tree.\n+        T copy = (T) copy(node);\n+        \n+        // Visit and enforce collapsing redundant nodes within expression.\n+        DisjunctionEliminationVisitor visitor = new DisjunctionEliminationVisitor();\n+        copy.jjtAccept(visitor, null);\n+        \n+        return copy;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTAndNode node, Object data) {\n+        JexlNode left = getFirstNonASTReference(node.jjtGetChild(0));\n+        JexlNode right = getFirstNonASTReference(node.jjtGetChild(1));\n+        try {\n+            if (isDisjunction(left) && hasDuplicate(left, right)) {\n+                return copyChildAndUpdateParent(node, right);\n+            }\n+            if (isDisjunction(right) && hasDuplicate(right, left)) {\n+                return copyChildAndUpdateParent(node, left);\n+            }\n+        } catch (ParseException e) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Failed to parse child node to check for equivalency\", e);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    // Return the first non-wrapped node.\n+    private JexlNode getFirstNonASTReference(JexlNode node) {\n+        if (node instanceof ASTReference || node instanceof ASTReferenceExpression) {\n+            return getFirstNonASTReference(node.jjtGetChild(0));\n+        } else {\n+            return node;\n+        }\n+    }\n+    \n+    // Return whether or not the given node is an OR.\n+    private boolean isDisjunction(JexlNode node) {\n+        return node instanceof ASTOrNode;\n+    }\n+    \n+    // Return true if the conjunction node\n+    private boolean hasDuplicate(JexlNode conjunction, JexlNode otherScript) throws ParseException {", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTc2Nw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171767", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0OTgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\nindex 2d69b54aa..ec398549d 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/DisjunctionEliminationVisitor.java\n\n@@ -19,8 +19,7 @@ public class DisjunctionEliminationVisitor extends RebuildingVisitor {\n     /**\n      * Given a JexlNode, determine if any duplicate conjunctions in the node can be removed.\n      *\n-     * @param node\n-     *            a query node\n+     * @param node a query node\n      * @return a re-written query tree for the node\n      */\n     public static <T extends JexlNode> T optimize(T node) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MDA4OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481050088", "bodyText": "Don't need this class level annotation, same comment with other test.", "author": "apmoriarty", "createdAt": "2020-09-01T10:52:50Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MTg2OQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481171869", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-01T14:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MDA4OA=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\nindex 6e684b437..ab4a7aefc 100644\n--- a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n+++ b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n\n@@ -90,7 +90,7 @@ public class ConjunctionEliminationVisitorTest {\n     private void visitAndValidate(String original, String expected) throws ParseException {\n         ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n         ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n-        \n+    \n         // Remove duplicate terms from within expressions.\n         ASTJexlScript visitedScript = ConjunctionEliminationVisitor.optimize(originalScript);\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTIzMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481051233", "bodyText": "A test with more than 2 top level nodes will fail, in this case the node PET == 'fluffy' was added.\n@Test\npublic void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction_threeTopLevelTerms() throws ParseException {\n    String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || PET == 'fluffy' || FOO == 'bar'\";\n    String expected = \"PET == 'fluffy' || FOO == 'bar'\";\n    visitAndValidate(original, expected);\n}", "author": "apmoriarty", "createdAt": "2020-09-01T10:55:05Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)\n+public class ConjunctionEliminationVisitorTest {\n+    \n+    @Test\n+    public void testSingleTerm() throws ParseException {\n+        String original = \"FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testUniqueConjunctionInTopLevelDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'zoo'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateInNestedConjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'bar')\";\n+        String expected = \"(FOO == 'bar')\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDifferentlyOrderedDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'zoo' && FOO == 'baz')\";\n+        String expected = \"FOO == 'zoo' && FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithUniqueNestedDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'zoo') || FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA1OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912058", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTIzMw=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\nindex 6e684b437..ab4a7aefc 100644\n--- a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n+++ b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n\n@@ -90,7 +90,7 @@ public class ConjunctionEliminationVisitorTest {\n     private void visitAndValidate(String original, String expected) throws ParseException {\n         ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n         ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n-        \n+    \n         // Remove duplicate terms from within expressions.\n         ASTJexlScript visitedScript = ConjunctionEliminationVisitor.optimize(originalScript);\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTYwOA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r481051608", "bodyText": "If the original script is flattened a few test cases fail. Same comment with other test class.\noriginalScript = TreeFlatteningRebuilder.flatten(originalScript);", "author": "apmoriarty", "createdAt": "2020-09-01T10:55:57Z", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import org.apache.commons.jexl2.parser.ASTJexlScript;\n+import org.apache.commons.jexl2.parser.ParseException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(JUnit4.class)\n+public class ConjunctionEliminationVisitorTest {\n+    \n+    @Test\n+    public void testSingleTerm() throws ParseException {\n+        String original = \"FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testUniqueConjunctionInTopLevelDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'zoo'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateInNestedConjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && FOO == 'baz') || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'bar')\";\n+        String expected = \"(FOO == 'bar')\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateNestedConjunctionInWrappedTopLevelDisjunction() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && FOO == 'bar') || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'baz' && FOO == 'zoo')\";\n+        String expected = \"FOO == 'baz' && FOO == 'zoo'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testMultipleNestedConjunctionsWithDifferentlyOrderedDuplicate() throws ParseException {\n+        String original = \"((FOO == 'baz' && FOO == 'zoo') && (FOO == 'bar' && FOO == 'dab')) || (FOO == 'zoo' && FOO == 'baz')\";\n+        String expected = \"FOO == 'zoo' && FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithUniqueNestedDisjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' && FOO == 'baz') || FOO == 'zoo') || FOO == 'bar'\";\n+        visitAndValidate(original, original);\n+    }\n+    \n+    @Test\n+    public void testDuplicateConjunctionWithWrappedUniqueNestedDisjunction() throws ParseException {\n+        String original = \"(FOO == 'bar' && (FOO == 'baz' || FOO == 'zoo')) || FOO == 'bar'\";\n+        String expected = \"FOO == 'bar'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    @Test\n+    public void testDuplicateDisjunctionInNestedConjunction() throws ParseException {\n+        String original = \"((FOO == 'bar' || FOO == 'baz') && FOO == 'zoo') || (FOO == 'bar' || FOO == 'baz')\";\n+        String expected = \"FOO == 'bar' || FOO == 'baz'\";\n+        visitAndValidate(original, expected);\n+    }\n+    \n+    private void visitAndValidate(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);", "originalCommit": "c89b6522440c589092f57de13bb0a3d8f8bbdcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxMjA2Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/910#discussion_r483912062", "bodyText": "Fixed.", "author": "lbschanno", "createdAt": "2020-09-05T05:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA1MTYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "969e27568c0fd52449cbd394569590027b0dbfad", "chunk": "diff --git a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\nindex 6e684b437..ab4a7aefc 100644\n--- a/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n+++ b/warehouse/query-core/src/test/java/datawave/query/jexl/visitors/ConjunctionEliminationVisitorTest.java\n\n@@ -90,7 +90,7 @@ public class ConjunctionEliminationVisitorTest {\n     private void visitAndValidate(String original, String expected) throws ParseException {\n         ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n         ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n-        \n+    \n         // Remove duplicate terms from within expressions.\n         ASTJexlScript visitedScript = ConjunctionEliminationVisitor.optimize(originalScript);\n         \n"}}, {"oid": "969e27568c0fd52449cbd394569590027b0dbfad", "url": "https://github.com/NationalSecurityAgency/datawave/commit/969e27568c0fd52449cbd394569590027b0dbfad", "message": "Remove redundant conjunctions and disjunctions from query\n\nRemove duplicate terms that are distributed through AND and OR nodes.\nFor example:\n\nCase 1: (A && B) || A should be reduced to A.\nCase 2: (A || B) && A should be reduced to A.\n\nCreate ConjunctionEliminationVisitor to handle case 1.\nCreate DisjunctionEliminationVisitor to handle case 2.\n\nFixes #883", "committedDate": "2020-12-15T18:08:25Z", "type": "commit"}, {"oid": "e6c72136cfc0255764b442effaa953aae01140a2", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e6c72136cfc0255764b442effaa953aae01140a2", "message": "Fix checkstyle violations", "committedDate": "2020-12-15T18:08:25Z", "type": "commit"}, {"oid": "9cc9b5313feb5ba5f73744ff55e70c941c9b274c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/9cc9b5313feb5ba5f73744ff55e70c941c9b274c", "message": "Apply changes requested in review", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "3880761e8219037cb429da1c5e1b88ac948c09cb", "url": "https://github.com/NationalSecurityAgency/datawave/commit/3880761e8219037cb429da1c5e1b88ac948c09cb", "message": "Add visitor toggles to ShardQueryConfiguration", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "6baf42bb4853207a8b4fd8f72f943e40762ac9f5", "url": "https://github.com/NationalSecurityAgency/datawave/commit/6baf42bb4853207a8b4fd8f72f943e40762ac9f5", "message": "Handle flattening and multiple top-level terms", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "6b244b5891d3a320cb12d34000c00c29cb3e87c7", "url": "https://github.com/NationalSecurityAgency/datawave/commit/6b244b5891d3a320cb12d34000c00c29cb3e87c7", "message": "Fix expected number of additions", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "56773e780f1be7404617125ef189c6e14787e26c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/56773e780f1be7404617125ef189c6e14787e26c", "message": "Fix Javadoc issues", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "cae05a76f8bc244ed492342c00219454e17242b5", "url": "https://github.com/NationalSecurityAgency/datawave/commit/cae05a76f8bc244ed492342c00219454e17242b5", "message": "Ensure both visitors maintain a valid lineage", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "145ff2f2bf3f63c102d2c46a13b18537bbf1f008", "url": "https://github.com/NationalSecurityAgency/datawave/commit/145ff2f2bf3f63c102d2c46a13b18537bbf1f008", "message": "Fix code formatting", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "message": "Remove unnecessary traversal", "committedDate": "2020-12-15T18:08:26Z", "type": "commit"}, {"oid": "ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ed4edd767b5caf6be04bc8f039bb0a4c705f75bf", "message": "Remove unnecessary traversal", "committedDate": "2020-12-15T18:08:26Z", "type": "forcePushed"}, {"oid": "81c99b74aaaea52f2b15956a786f5d440f76404c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/81c99b74aaaea52f2b15956a786f5d440f76404c", "message": "Merge remote-tracking branch 'upstream/release/version3.1' into redundant-query", "committedDate": "2020-12-29T17:12:32Z", "type": "commit"}, {"oid": "19b2bb6d194946606ee73cc3ec0572166b4922c7", "url": "https://github.com/NationalSecurityAgency/datawave/commit/19b2bb6d194946606ee73cc3ec0572166b4922c7", "message": "Merge branch 'release/version3.2' into redundant-query", "committedDate": "2021-02-23T17:16:32Z", "type": "commit"}, {"oid": "acb16ff62bcb4f2e03e9d8c2c8f87ff7c1d301c1", "url": "https://github.com/NationalSecurityAgency/datawave/commit/acb16ff62bcb4f2e03e9d8c2c8f87ff7c1d301c1", "message": "Merge branch 'release/version3.2' into redundant-query", "committedDate": "2021-03-05T16:53:15Z", "type": "commit"}]}