{"pr_number": 2909, "pr_title": "[GEOT-6578] equalTo support for matchAction and postgis optimization", "pr_createdAt": "2020-04-30T16:04:44Z", "pr_url": "https://github.com/geotools/geotools/pull/2909", "timeline": [{"oid": "f18f0997a117f0946e51782b5a86b1adcb907d24", "url": "https://github.com/geotools/geotools/commit/f18f0997a117f0946e51782b5a86b1adcb907d24", "message": "[GEOT-6578] equalTo function support for matchAction and postgis optmization to overlap for array ANY match", "committedDate": "2020-04-30T15:35:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NDIzMA==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418364230", "bodyText": "I call these methods \"toCollection( obj )\" as they are format shifting rather than accessing content.", "author": "jodygarnett", "createdAt": "2020-05-01T00:36:43Z", "path": "modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java", "diffHunk": "@@ -54,21 +55,34 @@ public MatchAction getMatchAction() {\n         return matchAction;\n     }\n \n+    private Collection<Object> getCollection(Object obj) {", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\nindex d9b55865e7..155b78cc96 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n\n@@ -55,22 +55,15 @@ public abstract class MultiCompareFilterImpl extends CompareFilterImpl {\n         return matchAction;\n     }\n \n-    private Collection<Object> getCollection(Object obj) {\n-        if (obj instanceof Collection) {\n-            return (Collection<Object>) obj;\n-        }\n-        if (obj != null && obj.getClass().isArray()) {\n-            return Arrays.asList((Object[]) obj);\n-        }\n-        return null;\n-    }\n-\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        Collection<Object> collection1 = getCollection(object1);\n-        Collection<Object> collection2 = getCollection(object2);\n+        /** Check if any expression can be evaluated to a collection. */\n+        final Collection<Object> collection1 =\n+                (Collection<Object>) expression1.evaluate(feature, List.class);\n+        final Collection<Object> collection2 =\n+                (Collection<Object>) expression2.evaluate(feature, List.class);\n \n         if (collection1 == null && collection2 == null) {\n             return evaluateInternal(object1, object2);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NTAyMQ==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418365021", "bodyText": "I try and stay away from this kind of logic (assuming the value is useful as provided and making methods to cast). Would the following work?\nfinal Collection<Object> collection1 = expression1.evaulate( feature, Collection.class )\nfinal Collection<Object> collection2 = expression2.evaulate( feature, Collection.class )", "author": "jodygarnett", "createdAt": "2020-05-01T00:39:42Z", "path": "modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java", "diffHunk": "@@ -54,21 +55,34 @@ public MatchAction getMatchAction() {\n         return matchAction;\n     }\n \n+    private Collection<Object> getCollection(Object obj) {\n+        if (obj instanceof Collection) {\n+            return (Collection<Object>) obj;\n+        }\n+        if (obj != null && obj.getClass().isArray()) {\n+            return Arrays.asList((Object[]) obj);\n+        }\n+        return null;\n+    }\n+\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        if (!(object1 instanceof Collection) && !(object2 instanceof Collection)) {\n+        Collection<Object> collection1 = getCollection(object1);\n+        Collection<Object> collection2 = getCollection(object2);", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\nindex d9b55865e7..155b78cc96 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n\n@@ -55,22 +55,15 @@ public abstract class MultiCompareFilterImpl extends CompareFilterImpl {\n         return matchAction;\n     }\n \n-    private Collection<Object> getCollection(Object obj) {\n-        if (obj instanceof Collection) {\n-            return (Collection<Object>) obj;\n-        }\n-        if (obj != null && obj.getClass().isArray()) {\n-            return Arrays.asList((Object[]) obj);\n-        }\n-        return null;\n-    }\n-\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        Collection<Object> collection1 = getCollection(object1);\n-        Collection<Object> collection2 = getCollection(object2);\n+        /** Check if any expression can be evaluated to a collection. */\n+        final Collection<Object> collection1 =\n+                (Collection<Object>) expression1.evaluate(feature, List.class);\n+        final Collection<Object> collection2 =\n+                (Collection<Object>) expression2.evaluate(feature, List.class);\n \n         if (collection1 == null && collection2 == null) {\n             return evaluateInternal(object1, object2);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NjAzMg==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418366032", "bodyText": "I am not sure how well this would work with a primitive array like int[]", "author": "jodygarnett", "createdAt": "2020-05-01T00:43:46Z", "path": "modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java", "diffHunk": "@@ -54,21 +55,34 @@ public MatchAction getMatchAction() {\n         return matchAction;\n     }\n \n+    private Collection<Object> getCollection(Object obj) {\n+        if (obj instanceof Collection) {\n+            return (Collection<Object>) obj;\n+        }\n+        if (obj != null && obj.getClass().isArray()) {\n+            return Arrays.asList((Object[]) obj);", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\nindex d9b55865e7..155b78cc96 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n\n@@ -55,22 +55,15 @@ public abstract class MultiCompareFilterImpl extends CompareFilterImpl {\n         return matchAction;\n     }\n \n-    private Collection<Object> getCollection(Object obj) {\n-        if (obj instanceof Collection) {\n-            return (Collection<Object>) obj;\n-        }\n-        if (obj != null && obj.getClass().isArray()) {\n-            return Arrays.asList((Object[]) obj);\n-        }\n-        return null;\n-    }\n-\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        Collection<Object> collection1 = getCollection(object1);\n-        Collection<Object> collection2 = getCollection(object2);\n+        /** Check if any expression can be evaluated to a collection. */\n+        final Collection<Object> collection1 =\n+                (Collection<Object>) expression1.evaluate(feature, List.class);\n+        final Collection<Object> collection2 =\n+                (Collection<Object>) expression2.evaluate(feature, List.class);\n \n         if (collection1 == null && collection2 == null) {\n             return evaluateInternal(object1, object2);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NjczMg==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418366732", "bodyText": "Where is expression3 evacuated? That could be a dynamic expression rather than a constant ...\nMatchAction matchAction = expression3.evaluate( feature, MatchAction.class)", "author": "jodygarnett", "createdAt": "2020-05-01T00:46:45Z", "path": "modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java", "diffHunk": "@@ -54,21 +55,34 @@ public MatchAction getMatchAction() {\n         return matchAction;\n     }\n \n+    private Collection<Object> getCollection(Object obj) {\n+        if (obj instanceof Collection) {\n+            return (Collection<Object>) obj;\n+        }\n+        if (obj != null && obj.getClass().isArray()) {\n+            return Arrays.asList((Object[]) obj);\n+        }\n+        return null;\n+    }\n+\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        if (!(object1 instanceof Collection) && !(object2 instanceof Collection)) {\n+        Collection<Object> collection1 = getCollection(object1);\n+        Collection<Object> collection2 = getCollection(object2);\n+\n+        if (collection1 == null && collection2 == null) {\n             return evaluateInternal(object1, object2);\n         }\n \n         Collection<Object> leftValues =\n-                object1 instanceof Collection\n-                        ? (Collection<Object>) object1\n+                collection1 instanceof Collection\n+                        ? collection1\n                         : Collections.<Object>singletonList(object1);\n         Collection<Object> rightValues =\n-                object2 instanceof Collection\n-                        ? (Collection<Object>) object2\n+                collection2 instanceof Collection\n+                        ? collection2\n                         : Collections.<Object>singletonList(object2);\n ", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\nindex d9b55865e7..155b78cc96 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/MultiCompareFilterImpl.java\n\n@@ -55,22 +55,15 @@ public abstract class MultiCompareFilterImpl extends CompareFilterImpl {\n         return matchAction;\n     }\n \n-    private Collection<Object> getCollection(Object obj) {\n-        if (obj instanceof Collection) {\n-            return (Collection<Object>) obj;\n-        }\n-        if (obj != null && obj.getClass().isArray()) {\n-            return Arrays.asList((Object[]) obj);\n-        }\n-        return null;\n-    }\n-\n     public final boolean evaluate(Object feature) {\n         final Object object1 = eval(expression1, feature);\n         final Object object2 = eval(expression2, feature);\n \n-        Collection<Object> collection1 = getCollection(object1);\n-        Collection<Object> collection2 = getCollection(object2);\n+        /** Check if any expression can be evaluated to a collection. */\n+        final Collection<Object> collection1 =\n+                (Collection<Object>) expression1.evaluate(feature, List.class);\n+        final Collection<Object> collection2 =\n+                (Collection<Object>) expression2.evaluate(feature, List.class);\n \n         if (collection1 == null && collection2 == null) {\n             return evaluateInternal(object1, object2);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NzEzNA==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418367134", "bodyText": "getExpression(2).evaualte( feature, MatchAction.class ) should work (there should be a converter that can convert from a string to an enum as required).", "author": "jodygarnett", "createdAt": "2020-05-01T00:48:43Z", "path": "modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java", "diffHunk": "@@ -68,7 +71,16 @@ public Object evaluate(Object feature) {\n             throw new IllegalArgumentException(\n                     \"Filter Function problem for function equalTo argument #1 - expected type Object\");\n         }\n+        if (getParameters().size() > 2) {\n+            try { // attempt to get value and perform conversion\n+                matchAction = MatchAction.valueOf((String) getExpression(2).evaluate(feature));", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\nindex 7247e7b75b..4428f01c63 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n\n@@ -73,14 +84,19 @@ public class FilterFunction_equalTo extends FunctionExpressionImpl {\n         }\n         if (getParameters().size() > 2) {\n             try { // attempt to get value and perform conversion\n-                matchAction = MatchAction.valueOf((String) getExpression(2).evaluate(feature));\n+                matchAction = (MatchAction) getExpression(2).evaluate(feature, MatchAction.class);\n             } catch (Exception e) // probably a type error\n             {\n                 throw new IllegalArgumentException(\n                         \"Filter Function problem for function equalTo argument #2 - expected one of ANY, ONE or ALL\");\n             }\n         }\n+        Filter equalTo =\n+                matchAction == null\n+                        ? getFilterFactory2().equal(ff.literal(arg0), ff.literal(arg1), false)\n+                        : getFilterFactory2()\n+                                .equal(ff.literal(arg0), ff.literal(arg1), false, matchAction);\n \n-        return Boolean.valueOf(StaticGeometry.equalTo(arg0, arg1, matchAction));\n+        return equalTo.evaluate(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2NzYxNA==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r418367614", "bodyText": "Yeah this function is far weaker than the filter, compare:\n\nStaticGeometry.equalTo\nIsEqualsTo\n\nYou could consider just calling the filter so we have consistent handling:\nFilter equalsTo = ff.equalsTo( expression1, expression2);\nreturn equalsTo.evaualte( feature );\n\nIt would be easier to maintain and a stronger implementation, and if you play your cards right it could handle the matchAction for you.", "author": "jodygarnett", "createdAt": "2020-05-01T00:50:47Z", "path": "modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java", "diffHunk": "@@ -68,7 +71,16 @@ public Object evaluate(Object feature) {\n             throw new IllegalArgumentException(\n                     \"Filter Function problem for function equalTo argument #1 - expected type Object\");\n         }\n+        if (getParameters().size() > 2) {\n+            try { // attempt to get value and perform conversion\n+                matchAction = MatchAction.valueOf((String) getExpression(2).evaluate(feature));\n+            } catch (Exception e) // probably a type error\n+            {\n+                throw new IllegalArgumentException(\n+                        \"Filter Function problem for function equalTo argument #2 - expected one of ANY, ONE or ALL\");\n+            }\n+        }\n \n-        return Boolean.valueOf(StaticGeometry.equalTo(arg0, arg1));\n+        return Boolean.valueOf(StaticGeometry.equalTo(arg0, arg1, matchAction));", "originalCommit": "f18f0997a117f0946e51782b5a86b1adcb907d24", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\nindex 7247e7b75b..4428f01c63 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n\n@@ -73,14 +84,19 @@ public class FilterFunction_equalTo extends FunctionExpressionImpl {\n         }\n         if (getParameters().size() > 2) {\n             try { // attempt to get value and perform conversion\n-                matchAction = MatchAction.valueOf((String) getExpression(2).evaluate(feature));\n+                matchAction = (MatchAction) getExpression(2).evaluate(feature, MatchAction.class);\n             } catch (Exception e) // probably a type error\n             {\n                 throw new IllegalArgumentException(\n                         \"Filter Function problem for function equalTo argument #2 - expected one of ANY, ONE or ALL\");\n             }\n         }\n+        Filter equalTo =\n+                matchAction == null\n+                        ? getFilterFactory2().equal(ff.literal(arg0), ff.literal(arg1), false)\n+                        : getFilterFactory2()\n+                                .equal(ff.literal(arg0), ff.literal(arg1), false, matchAction);\n \n-        return Boolean.valueOf(StaticGeometry.equalTo(arg0, arg1, matchAction));\n+        return equalTo.evaluate(null);\n     }\n }\n"}}, {"oid": "bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "url": "https://github.com/geotools/geotools/commit/bc7d53d5170ce327fed6ed139ee8ce27aac12f8a", "message": "[GEOT-6578] some cleanup, and tested support for array of primitives", "committedDate": "2020-05-04T07:41:56Z", "type": "commit"}, {"oid": "4c9db291735214f95a5c78e8b9e94bbad8f44c6d", "url": "https://github.com/geotools/geotools/commit/4c9db291735214f95a5c78e8b9e94bbad8f44c6d", "message": "[GEOT-6578]: fix for regression in MultiCompareFilterImpl", "committedDate": "2020-05-04T08:36:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwNzQwOA==", "url": "https://github.com/geotools/geotools/pull/2909#discussion_r419907408", "bodyText": "This is so much cleaner!\nIf you would like to be slightly more lazy there is no need to evaulate arg0 and arg1, only to wrap them up as a literal again, if you replace this line with:\nreturn equalTo.evaualte(feature)", "author": "jodygarnett", "createdAt": "2020-05-05T07:15:58Z", "path": "modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java", "diffHunk": "@@ -68,7 +82,21 @@ public Object evaluate(Object feature) {\n             throw new IllegalArgumentException(\n                     \"Filter Function problem for function equalTo argument #1 - expected type Object\");\n         }\n+        if (getParameters().size() > 2) {\n+            try { // attempt to get value and perform conversion\n+                matchAction = (MatchAction) getExpression(2).evaluate(feature, MatchAction.class);\n+            } catch (Exception e) // probably a type error\n+            {\n+                throw new IllegalArgumentException(\n+                        \"Filter Function problem for function equalTo argument #2 - expected one of ANY, ONE or ALL\");\n+            }\n+        }\n+        Filter equalTo =\n+                matchAction == null\n+                        ? getFilterFactory2().equal(ff.literal(arg0), ff.literal(arg1), false)\n+                        : getFilterFactory2()\n+                                .equal(ff.literal(arg0), ff.literal(arg1), false, matchAction);\n \n-        return Boolean.valueOf(StaticGeometry.equalTo(arg0, arg1));\n+        return equalTo.evaluate(null);", "originalCommit": "4c9db291735214f95a5c78e8b9e94bbad8f44c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308664b1a0e89b9ebb966463179a50b765e61711", "chunk": "diff --git a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\nindex 4428f01c63..aedc83eb3a 100644\n--- a/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n+++ b/modules/library/main/src/main/java/org/geotools/filter/function/FilterFunction_equalTo.java\n\n@@ -63,25 +64,10 @@ public class FilterFunction_equalTo extends FunctionExpressionImpl {\n     }\n \n     public Object evaluate(Object feature) {\n-        Object arg0;\n-        Object arg1;\n+        Expression arg0 = getExpression(0);\n+        Expression arg1 = getExpression(1);\n         MatchAction matchAction = null;\n \n-        try { // attempt to get value and perform conversion\n-            arg0 = (Object) getExpression(0).evaluate(feature);\n-        } catch (Exception e) // probably a type error\n-        {\n-            throw new IllegalArgumentException(\n-                    \"Filter Function problem for function equalTo argument #0 - expected type Object\");\n-        }\n-\n-        try { // attempt to get value and perform conversion\n-            arg1 = (Object) getExpression(1).evaluate(feature);\n-        } catch (Exception e) // probably a type error\n-        {\n-            throw new IllegalArgumentException(\n-                    \"Filter Function problem for function equalTo argument #1 - expected type Object\");\n-        }\n         if (getParameters().size() > 2) {\n             try { // attempt to get value and perform conversion\n                 matchAction = (MatchAction) getExpression(2).evaluate(feature, MatchAction.class);\n"}}, {"oid": "308664b1a0e89b9ebb966463179a50b765e61711", "url": "https://github.com/geotools/geotools/commit/308664b1a0e89b9ebb966463179a50b765e61711", "message": "[GEOT-6578]: more simplification and additional test for property to array comparison", "committedDate": "2020-05-05T08:52:36Z", "type": "commit"}]}