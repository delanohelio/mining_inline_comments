{"pr_number": 2930, "pr_title": "Support mbstyle filter expressions [GEOT-6589] ", "pr_createdAt": "2020-05-13T04:59:27Z", "pr_url": "https://github.com/geotools/geotools/pull/2930", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzMyNA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177324", "bodyText": "@vickdw I was going to ask for your input here, this is my first looking into how expressions have been implemented and I wanted to take a consistent approach before changing anything substantially.\nThe above is based on the MBDecision.decisionNotEqual() which calls parse.string(json,1) as shown above. If I understand correctly the string method is willing to convert any literals (strings, numbers, booleans) to a string so we end up with a string equality check only. Rather than a numeric != numeric equality check.\nDoes this match with your understanding?", "author": "jodygarnett", "createdAt": "2020-05-13T05:16:06Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +468,59 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            // get the comparables\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);", "originalCommit": "922db222c01f88dd4f7b5e32e4d588b7109073ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTk1NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299955", "bodyText": "Yes, that is correct.", "author": "vickdw", "createdAt": "2020-05-14T17:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "cc24b65bb30889788a85e384a95019cd88ddb9fa", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex e07d36e7da..6d3d0e8296 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -390,82 +377,164 @@ public class MBFilter {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n             return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n             return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n+        }\n+    }\n+\n+    private Filter filterNone(JSONArray array) {\n+        List<Filter> none = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n+            } else {\n+                throw new MBFormatException(\n+                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(all);\n-        } else if (\"any\".equals(operator)) {\n-            List<Filter> any = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.and(none);\n+    }\n+\n+    private Filter filterAny(JSONArray array) {\n+        List<Filter> any = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.or(any);\n-        } else if (\"none\".equals(operator)) {\n-            List<Filter> none = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.or(any);\n+    }\n+\n+    private Filter filterAll(JSONArray array) {\n+        List<Filter> all = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(none);\n+        }\n+        return ff.and(all);\n+    }\n+\n+    private Filter filterIn(JSONArray array, boolean in) {\n+        String key = parse.get(array, 1);\n+        Expression[] args = new Expression[array.size() - 1];\n+        args[0] = ff.property(key);\n+        for (int i = 1; i < args.length; i++) {\n+            Expression expression = parse.string(array, i + 1);\n+            args[i] = expression;\n+        }\n+        Function function = ff.function(\"in\", args);\n+        return ff.equals(function, ff.literal(in));\n+    }\n+\n+    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n+        Set<FeatureId> fids = new HashSet<>();\n+        for (Object value : array.subList(2, array.size())) {\n+            if (value instanceof String) {\n+                String fid = (String) value;\n+                fids.add(ff.featureId(fid));\n+            }\n+        }\n+        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n+            return ff.id(fids);\n+        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n+            return ff.not(ff.id(fids));\n         } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n+            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n+        }\n+    }\n+\n+    private Filter filterByGeometryType(JSONArray json, String operator) {\n+        List<Filter> typeFilters = new ArrayList<>();\n+        List<?> types = json.subList(2, json.size());\n+        for (Object type : types) {\n+            Filter typeFilter = null;\n+            if (type instanceof String) {\n+                typeFilter = translateType((String) type);\n+            }\n+            if (typeFilter == null) {\n+                throw new MBFormatException(\n+                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n+            }\n+            typeFilters.add(typeFilter);\n+        }\n+        if (\"==\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n+            }\n+            return typeFilters.get(0);\n+        } else if (\"!=\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n+            }\n+            return ff.not(typeFilters.get(0));\n+        } else if (\"in\".equals(operator)) {\n+            return ff.or(typeFilters);\n+        } else if (\"!in\".equals(operator)) {\n+            return ff.not(ff.or(typeFilters));\n+        } else {\n+            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Nzc4MA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177780", "bodyText": "This blind conversion to a string incorrectly resulted in correctly generated Expressions being represented as strings. I suspect it should be removed!", "author": "jodygarnett", "createdAt": "2020-05-13T05:18:01Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -332,9 +332,10 @@ public String get(JSONArray json, int index) {\n         }\n         if (index < json.size() && json.get(index) instanceof String) {\n             return (String) json.get(index);\n-        }\n-        if (index < json.size() && json.get(index) instanceof JSONArray) {\n-            return MBExpression.transformExpression((JSONArray) json.get(index)).toString();\n+            //        }\n+            //        if (index < json.size() && json.get(index) instanceof JSONArray) {\n+            //            return MBExpression.transformExpression((JSONArray)\n+            // json.get(index)).toString();", "originalCommit": "922db222c01f88dd4f7b5e32e4d588b7109073ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTQyMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299423", "bodyText": "I agree, this looks like a good change.", "author": "vickdw", "createdAt": "2020-05-14T17:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Nzc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\nindex b244de041d..8ded77030a 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n\n@@ -332,10 +332,9 @@ public class MBObjectParser {\n         }\n         if (index < json.size() && json.get(index) instanceof String) {\n             return (String) json.get(index);\n-            //        }\n-            //        if (index < json.size() && json.get(index) instanceof JSONArray) {\n-            //            return MBExpression.transformExpression((JSONArray)\n-            // json.get(index)).toString();\n+        }\n+        if (index < json.size() && json.get(index) instanceof JSONArray) {\n+            return MBExpression.transformExpression((JSONArray) json.get(index)).toString();\n         } else {\n             throw new MBFormatException(\n                     context.getSimpleName() + \" requires [\" + index + \"] string\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4ODcwOA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425288708", "bodyText": "could you put some comments in the code here (maybe an example)?  it's hard to determine what all the json.size() == X mean.\nAlso, I think get requires one argument - [\"get\", \"propName\"]", "author": "davidblasby", "createdAt": "2020-05-14T16:54:48Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,16 +56,22 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {", "originalCommit": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5NjI5OQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425296299", "bodyText": "There is actually an option, documented in the javadoc above for three arguments.\n[ \"get\", key, object]\n\nThis can be used to pull out a specific value not from the feature, but from the results of another expression.  I was really smart I may be able to turn this into an propertyname with xpath - but I am not going to do premature optimization.\nFor the library we chose the geoapi approach of format shifting the specifrication into javadocs. So you do not have to look up everything each time to see what the code is trying to implement.", "author": "jodygarnett", "createdAt": "2020-05-14T17:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4ODcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\nindex 3410f72bec..1c5fef01fa 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\n\n@@ -56,14 +56,8 @@ public class MBLookup extends MBExpression {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {\n             if (json.size() == 2) {\n-                if (parse.isString(json, 1)) {\n-                    String propertyName = parse.get(json, 1);\n-                    return ff.property(propertyName);\n-                } else {\n-                    // it is unclear from specification if this is even allowed\n-                    Expression property = parse.string(json, 1);\n-                    return ff.function(\"property\", property);\n-                }\n+                Expression property = parse.string(json, 1);\n+                return ff.function(\"property\", property);\n             }\n             if (json.size() == 3) {\n                 Expression value = parse.string(json, 1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425289948", "bodyText": "looks like there is a lot of copy-and-paste code here and all the other functions.  They're all the same except the last line.", "author": "davidblasby", "createdAt": "2020-05-14T16:56:42Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +464,116 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2); // legacy filter restricted to literals\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);\n+        }\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {", "originalCommit": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5OTE3MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425299171", "bodyText": "Yes, i could probably be smarter on this one, but for now I was trying to exactly match the MBExpression logic. The use of string to evaluate expressions is a problem and I would like to have everything consistent before fixing expressions in another pull request.\nStill I may be able to factor out a expression1(json) and expression2(json) method and make this more readable.", "author": "jodygarnett", "createdAt": "2020-05-14T17:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NjM5Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425566392", "bodyText": "This has now been resolved, I think the code is easier to understand.", "author": "jodygarnett", "createdAt": "2020-05-15T04:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "cc24b65bb30889788a85e384a95019cd88ddb9fa", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex 7ecb18ca2f..6d3d0e8296 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -408,60 +394,147 @@ public class MBFilter {\n         }\n         // Set Membership Filters\n         else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1); // TODO: Allow for expressions in `in`\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1); // TODO: Allow for expressions in `!in`\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n+            return filterIn(json, false);\n         }\n         // Combining Filters\n         else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n+        }\n+    }\n+\n+    private Filter filterNone(JSONArray array) {\n+        List<Filter> none = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n+            } else {\n+                throw new MBFormatException(\n+                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(all);\n-        } else if (\"any\".equals(operator)) {\n-            List<Filter> any = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.and(none);\n+    }\n+\n+    private Filter filterAny(JSONArray array) {\n+        List<Filter> any = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.or(any);\n-        } else if (\"none\".equals(operator)) {\n-            List<Filter> none = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.or(any);\n+    }\n+\n+    private Filter filterAll(JSONArray array) {\n+        List<Filter> all = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n+            }\n+        }\n+        return ff.and(all);\n+    }\n+\n+    private Filter filterIn(JSONArray array, boolean in) {\n+        String key = parse.get(array, 1);\n+        Expression[] args = new Expression[array.size() - 1];\n+        args[0] = ff.property(key);\n+        for (int i = 1; i < args.length; i++) {\n+            Expression expression = parse.string(array, i + 1);\n+            args[i] = expression;\n+        }\n+        Function function = ff.function(\"in\", args);\n+        return ff.equals(function, ff.literal(in));\n+    }\n+\n+    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n+        Set<FeatureId> fids = new HashSet<>();\n+        for (Object value : array.subList(2, array.size())) {\n+            if (value instanceof String) {\n+                String fid = (String) value;\n+                fids.add(ff.featureId(fid));\n             }\n-            return ff.and(none);\n+        }\n+        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n+            return ff.id(fids);\n+        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n+            return ff.not(ff.id(fids));\n         } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n+            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n+        }\n+    }\n+\n+    private Filter filterByGeometryType(JSONArray json, String operator) {\n+        List<Filter> typeFilters = new ArrayList<>();\n+        List<?> types = json.subList(2, json.size());\n+        for (Object type : types) {\n+            Filter typeFilter = null;\n+            if (type instanceof String) {\n+                typeFilter = translateType((String) type);\n+            }\n+            if (typeFilter == null) {\n+                throw new MBFormatException(\n+                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n+            }\n+            typeFilters.add(typeFilter);\n+        }\n+        if (\"==\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n+            }\n+            return typeFilters.get(0);\n+        } else if (\"!=\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n+            }\n+            return ff.not(typeFilters.get(0));\n+        } else if (\"in\".equals(operator)) {\n+            return ff.or(typeFilters);\n+        } else if (\"!in\".equals(operator)) {\n+            return ff.not(ff.or(typeFilters));\n+        } else {\n+            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTY2Ng==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428955666", "bodyText": "You've managed to make the grammar worse here, either fix the tense in the rest of the comment or revert", "author": "tbarsballe", "createdAt": "2020-05-21T22:47:18Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -151,7 +183,7 @@ public MBFilter(JSONArray json, MBObjectParser parse, SemanticType semanticType)\n     /**\n      * Utility method to convert json to set of {@link SemanticType}.\n      *\n-     * <p>This method recursively calls itself to handle all and any operators.\n+     * <p>This method is recursively calls itself to handle all and any operators.", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex 6d3d0e8296..6a3730c710 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -183,7 +151,7 @@ public class MBFilter {\n     /**\n      * Utility method to convert json to set of {@link SemanticType}.\n      *\n-     * <p>This method is recursively calls itself to handle all and any operators.\n+     * <p>This method recursively calls itself to handle all and any operators.\n      *\n      * @param array JSON array defining filter\n      * @return SemanticTypes from provided json, may be nested\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428957175", "bodyText": "This doc could distinguish better between GeoTools Filters and Expressions, and Mapbox Filter Functions and Expressions. It is also unclear from this document whether or not gt-mbstyle still supports using the old syntax, or it is just included for posterity (and there's enough changes from the body of this class that I can't tell from looking at the code either - does the old syntax still function or has it actually been removed now?)", "author": "tbarsballe", "createdAt": "2020-05-21T22:52:20Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -38,7 +39,34 @@\n  *\n  * <p>This wrapper and {@link MBFunction} are a matched set handling dynamic data.\n  *\n- * <h2>About MapBox Filter</h2>\n+ * <h2>Expression: Decision</h2>\n+ *\n+ * <p>Implementation Note:The value for any filter may be specified as an expression. The result type of an expression in\n+ * the filter property must be boolean. See {@link org.geotools.mbstyle.expression.MBExpression} for details.\n+ *\n+ * <p>The expressions in this section can be used to add conditional logic to your styles. For example, the 'case' expression\n+ * provides \"if/then/else\" logic, and 'match' allows you to map specific values of an input expression to different\n+ * output expressions.\n+ * <ul>\n+ *     <li><code>[\"!\", boolean]: boolean</code></li>\n+ *     <li><code>[\"!=\", value, value]: boolean</code></li>\n+ *     <li><code>&lt;/code></li>\n+ *     <li><code>&lt;=</code></li>\n+ *     <li><code>==</code></li>\n+ *     <li><code>&gt;</code></li>\n+ *     <li><code>&gt;=</code></li>\n+ *     <li><code>all</code></li>\n+ *     <li><code>any</code></li>\n+ *     <li><code>case</code></li>\n+ *     <li><code>coalesce</code></li>\n+ *     <li><code>match</code></li>\n+ *     <li><code>within</code></li>\n+ * </ul>\n+ *\n+ * <h2>Filter Other</h2>\n+ *\n+ * <p>Implementation Note: In previous versions of the style specification, filters were defined using the deprecated\n+ * syntax documented here.", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4OTUzMQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r429089531", "bodyText": "Keeping support for the old syntax is very important, the freely available OpenMapTiles styles are based on it: https://github.com/openmaptiles/osm-bright-gl-style/blob/master/style.json#L44", "author": "aaime", "createdAt": "2020-05-22T07:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTQwOA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432791408", "bodyText": "It supports the old syntax, and the old test cases are preserved to ensure it stays that way.", "author": "jodygarnett", "createdAt": "2020-05-30T00:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NjY2Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432796662", "bodyText": "Changed note to:\n\nImplementation Note: GeoTools also supports the depreciated syntax documented here (provided by a previous versions of the Mapbox style specification).\n\nTo be clear the \"Other filter\" format being described is indeed supported by GeoTools.", "author": "jodygarnett", "createdAt": "2020-05-30T01:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2Njc0MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r434666741", "bodyText": "@aaime I am marking this conversation as unresolved, I updated the docs to make it clear the ongoing support for \"other filter\"", "author": "jodygarnett", "createdAt": "2020-06-03T15:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex 6d3d0e8296..6a3730c710 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -39,34 +38,7 @@ import org.opengis.style.SemanticType;\n  *\n  * <p>This wrapper and {@link MBFunction} are a matched set handling dynamic data.\n  *\n- * <h2>Expression: Decision</h2>\n- *\n- * <p>Implementation Note:The value for any filter may be specified as an expression. The result type of an expression in\n- * the filter property must be boolean. See {@link org.geotools.mbstyle.expression.MBExpression} for details.\n- *\n- * <p>The expressions in this section can be used to add conditional logic to your styles. For example, the 'case' expression\n- * provides \"if/then/else\" logic, and 'match' allows you to map specific values of an input expression to different\n- * output expressions.\n- * <ul>\n- *     <li><code>[\"!\", boolean]: boolean</code></li>\n- *     <li><code>[\"!=\", value, value]: boolean</code></li>\n- *     <li><code>&lt;/code></li>\n- *     <li><code>&lt;=</code></li>\n- *     <li><code>==</code></li>\n- *     <li><code>&gt;</code></li>\n- *     <li><code>&gt;=</code></li>\n- *     <li><code>all</code></li>\n- *     <li><code>any</code></li>\n- *     <li><code>case</code></li>\n- *     <li><code>coalesce</code></li>\n- *     <li><code>match</code></li>\n- *     <li><code>within</code></li>\n- * </ul>\n- *\n- * <h2>Filter Other</h2>\n- *\n- * <p>Implementation Note: In previous versions of the style specification, filters were defined using the deprecated\n- * syntax documented here.\n+ * <h2>About MapBox Filter</h2>\n  *\n  * <p>A filter selects specific features from a layer. A filter is an array of one of the following\n  * forms:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTM1MA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428959350", "bodyText": "Shouldn't this say \"Unsupported expression\" now, as the error message is from the perspective of the mapbox style?", "author": "tbarsballe", "createdAt": "2020-05-21T22:59:17Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NzA1Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432797053", "bodyText": "The code handles both cases, changing to \"Unsupported data expression or filter\"", "author": "jodygarnett", "createdAt": "2020-05-30T01:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex 6d3d0e8296..6a3730c710 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -377,269 +378,86 @@ public class MBFilter {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-        }\n-        // Comparison Filters\n-        else if (\"==\".equals(operator)) {\n-            return filterEqualTo(json);\n+            // Comparison Filters\n+        } else if (\"==\".equals(operator)) {\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n         } else if (\"!=\".equals(operator)) {\n-            return filterNotEqual(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n         } else if (\">\".equals(operator)) {\n-            return filterGreater(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.greater(ff.property(key), ff.literal(value), false);\n         } else if (\">=\".equals(operator)) {\n-            return filterGreaterOrEqual(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n         } else if (\"<\".equals(operator)) {\n-            return filterLess(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.less(ff.property(key), ff.literal(value), false);\n         } else if (\"<=\".equals(operator)) {\n-            return filterLessOrEqual(json);\n-        }\n-        // Set Membership Filters\n-        else if (\"in\".equals(operator)) {\n-            return filterIn(json, true);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n+            // Set Membership Filters\n+        } else if (\"in\".equals(operator)) {\n+            String key = parse.get(json, 1);\n+            Expression[] args = new Expression[json.size() - 1];\n+            args[0] = ff.property(key);\n+            for (int i = 1; i < args.length; i++) {\n+                Object value = parse.value(json, i + 1);\n+                args[i] = ff.literal(value);\n+            }\n+            Function in = ff.function(\"in\", args);\n+            return ff.equals(in, ff.literal(true));\n         } else if (\"!in\".equals(operator)) {\n-            return filterIn(json, false);\n-        }\n-        // Combining Filters\n-        else if (\"all\".equals(operator)) {\n-            return filterAll(json);\n-        } else if (\"any\".equals(operator)) {\n-            return filterAny(json);\n-        } else if (\"none\".equals(operator)) {\n-            return filterNone(json);\n-        }\n-        // MBExpression filters\n-        else if (\"case\".equals(operator)) {\n-            Expression caseExpr = MBExpression.transformExpression(json);\n-            return ff.equals(caseExpr, ff.literal(true));\n-        } else if (\"coalesce\".equals(operator)) {\n-            Expression coalesce = MBExpression.transformExpression(json);\n-            return ff.equals(coalesce, ff.literal(true));\n-        } else if (\"match\".equals(operator)) {\n-            Expression match = MBExpression.transformExpression(json);\n-            return ff.equals(match, ff.literal(true));\n-        } else if (\"within\".equals(operator)) {\n-            Expression within = MBExpression.transformExpression(json);\n-            return ff.equals(within, ff.literal(true));\n-        } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n-        }\n-    }\n-\n-    private Filter filterNone(JSONArray array) {\n-        List<Filter> none = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            String key = parse.get(json, 1);\n+            Expression[] args = new Expression[json.size() - 1];\n+            args[0] = ff.property(key);\n+            for (int i = 1; i < args.length; i++) {\n+                Object value = parse.value(json, i + 1);\n+                args[i] = ff.literal(value);\n+            }\n+            Function in = ff.function(\"in\", args);\n+            return ff.equals(in, ff.literal(false));\n+            // Combining Filters\n+        } else if (\"all\".equals(operator)) {\n+            List<Filter> all = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n-            } else {\n-                throw new MBFormatException(\n-                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.and(none);\n-    }\n-\n-    private Filter filterAny(JSONArray array) {\n-        List<Filter> any = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            return ff.and(all);\n+        } else if (\"any\".equals(operator)) {\n+            List<Filter> any = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n-            } else {\n-                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.or(any);\n-    }\n-\n-    private Filter filterAll(JSONArray array) {\n-        List<Filter> all = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            return ff.or(any);\n+        } else if (\"none\".equals(operator)) {\n+            List<Filter> none = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n-            } else {\n-                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.and(all);\n-    }\n-\n-    private Filter filterIn(JSONArray array, boolean in) {\n-        String key = parse.get(array, 1);\n-        Expression[] args = new Expression[array.size() - 1];\n-        args[0] = ff.property(key);\n-        for (int i = 1; i < args.length; i++) {\n-            Expression expression = parse.string(array, i + 1);\n-            args[i] = expression;\n-        }\n-        Function function = ff.function(\"in\", args);\n-        return ff.equals(function, ff.literal(in));\n-    }\n-\n-    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n-        Set<FeatureId> fids = new HashSet<>();\n-        for (Object value : array.subList(2, array.size())) {\n-            if (value instanceof String) {\n-                String fid = (String) value;\n-                fids.add(ff.featureId(fid));\n-            }\n-        }\n-        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n-            return ff.id(fids);\n-        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n-            return ff.not(ff.id(fids));\n-        } else {\n-            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n-        }\n-    }\n-\n-    private Filter filterByGeometryType(JSONArray json, String operator) {\n-        List<Filter> typeFilters = new ArrayList<>();\n-        List<?> types = json.subList(2, json.size());\n-        for (Object type : types) {\n-            Filter typeFilter = null;\n-            if (type instanceof String) {\n-                typeFilter = translateType((String) type);\n-            }\n-            if (typeFilter == null) {\n-                throw new MBFormatException(\n-                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n-            }\n-            typeFilters.add(typeFilter);\n-        }\n-        if (\"==\".equals(operator)) {\n-            if (typeFilters.size() != 1) {\n-                throw new MBFormatException(\n-                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n-            }\n-            return typeFilters.get(0);\n-        } else if (\"!=\".equals(operator)) {\n-            if (typeFilters.size() != 1) {\n-                throw new MBFormatException(\n-                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n-            }\n-            return ff.not(typeFilters.get(0));\n-        } else if (\"in\".equals(operator)) {\n-            return ff.or(typeFilters);\n-        } else if (\"!in\".equals(operator)) {\n-            return ff.not(ff.or(typeFilters));\n+            return ff.and(none);\n         } else {\n-            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n-        }\n-    }\n-\n-    /**\n-     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n-     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n-     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n-     *\n-     * @return equal to expression\n-     */\n-    private Filter filterEqualTo(JSONArray array) {\n-        if (array.size() != 3) {\n-            throwUnexpectedArgumentCount(\"==\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.equals(expression1, expression2);\n-    }\n-\n-    /**\n-     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n-     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n-     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n-     *\n-     * @return Not equals expression\n-     */\n-    private Filter filterNotEqual(JSONArray array) {\n-        if (array.size() != 3) {\n-            throwUnexpectedArgumentCount(\"!=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.notEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterLessOrEqual(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\"<=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.lessOrEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterLess(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\"<\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.less(expression1, expression2);\n-    }\n-\n-    private Filter filterGreaterOrEqual(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\">=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.greaterOrEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterGreater(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\">\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.greater(expression1, expression2);\n-    }\n-\n-    private void throwUnexpectedArgumentCount(String expression, int argCount)\n-            throws MBFormatException {\n-        throw new MBFormatException(\n-                String.format(\n-                        \"Expression \\\"%s\\\" should have exactly %d argument(s)\",\n-                        expression, argCount));\n-    }\n-\n-    /**\n-     * Comparison value1 defined as an expression (or legacy key reference).\n-     *\n-     * @param array JSON filter definition\n-     * @return Expression for comparison\n-     */\n-    private Expression comparisonExpression1(JSONArray array) {\n-        if (parse.isString(array, 1)) { // legacy filter syntax\n-            String key = parse.get(array, 1);\n-            return ff.property(key);\n-        } else {\n-            return parse.string(array, 1);\n-        }\n-    }\n-    /**\n-     * Comparison value1 defined as an expression (or legacy literal reference).\n-     *\n-     * @param array JSON filter definition\n-     * @return Expression for comparison\n-     */\n-    private Expression comparisonExpression2(JSONArray array) {\n-        if (parse.isString(array, 1)) { // legacy filter syntax\n-            Object value = parse.value(array, 2);\n-            return ff.literal(value);\n-        } else {\n-            return parse.string(array, 2);\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MTA0Ng==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428961046", "bodyText": "\"value2\" instead of \"value1\"?", "author": "tbarsballe", "createdAt": "2020-05-21T23:05:04Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n+        }\n+    }\n+\n+    private Filter filterNone(JSONArray array) {\n+        List<Filter> none = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n+            } else {\n+                throw new MBFormatException(\n+                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(all);\n-        } else if (\"any\".equals(operator)) {\n-            List<Filter> any = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.and(none);\n+    }\n+\n+    private Filter filterAny(JSONArray array) {\n+        List<Filter> any = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.or(any);\n-        } else if (\"none\".equals(operator)) {\n-            List<Filter> none = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.or(any);\n+    }\n+\n+    private Filter filterAll(JSONArray array) {\n+        List<Filter> all = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(none);\n+        }\n+        return ff.and(all);\n+    }\n+\n+    private Filter filterIn(JSONArray array, boolean in) {\n+        String key = parse.get(array, 1);\n+        Expression[] args = new Expression[array.size() - 1];\n+        args[0] = ff.property(key);\n+        for (int i = 1; i < args.length; i++) {\n+            Expression expression = parse.string(array, i + 1);\n+            args[i] = expression;\n+        }\n+        Function function = ff.function(\"in\", args);\n+        return ff.equals(function, ff.literal(in));\n+    }\n+\n+    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n+        Set<FeatureId> fids = new HashSet<>();\n+        for (Object value : array.subList(2, array.size())) {\n+            if (value instanceof String) {\n+                String fid = (String) value;\n+                fids.add(ff.featureId(fid));\n+            }\n+        }\n+        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n+            return ff.id(fids);\n+        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n+            return ff.not(ff.id(fids));\n         } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n+            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n+        }\n+    }\n+\n+    private Filter filterByGeometryType(JSONArray json, String operator) {\n+        List<Filter> typeFilters = new ArrayList<>();\n+        List<?> types = json.subList(2, json.size());\n+        for (Object type : types) {\n+            Filter typeFilter = null;\n+            if (type instanceof String) {\n+                typeFilter = translateType((String) type);\n+            }\n+            if (typeFilter == null) {\n+                throw new MBFormatException(\n+                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n+            }\n+            typeFilters.add(typeFilter);\n+        }\n+        if (\"==\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n+            }\n+            return typeFilters.get(0);\n+        } else if (\"!=\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n+            }\n+            return ff.not(typeFilters.get(0));\n+        } else if (\"in\".equals(operator)) {\n+            return ff.or(typeFilters);\n+        } else if (\"!in\".equals(operator)) {\n+            return ff.not(ff.or(typeFilters));\n+        } else {\n+            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.equals(expression1, expression2);\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.notEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.lessOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLess(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.less(expression1, expression2);\n+    }\n+\n+    private Filter filterGreaterOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greaterOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterGreater(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greater(expression1, expression2);\n+    }\n+\n+    private void throwUnexpectedArgumentCount(String expression, int argCount)\n+            throws MBFormatException {\n+        throw new MBFormatException(\n+                String.format(\n+                        \"Expression \\\"%s\\\" should have exactly %d argument(s)\",\n+                        expression, argCount));\n+    }\n+\n+    /**\n+     * Comparison value1 defined as an expression (or legacy key reference).\n+     *\n+     * @param array JSON filter definition\n+     * @return Expression for comparison\n+     */\n+    private Expression comparisonExpression1(JSONArray array) {\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            return ff.property(key);\n+        } else {\n+            return parse.string(array, 1);\n+        }\n+    }\n+    /**\n+     * Comparison value1 defined as an expression (or legacy literal reference).", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\nindex 6d3d0e8296..6a3730c710 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java\n\n@@ -377,269 +378,86 @@ public class MBFilter {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-        }\n-        // Comparison Filters\n-        else if (\"==\".equals(operator)) {\n-            return filterEqualTo(json);\n+            // Comparison Filters\n+        } else if (\"==\".equals(operator)) {\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n         } else if (\"!=\".equals(operator)) {\n-            return filterNotEqual(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n         } else if (\">\".equals(operator)) {\n-            return filterGreater(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.greater(ff.property(key), ff.literal(value), false);\n         } else if (\">=\".equals(operator)) {\n-            return filterGreaterOrEqual(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n         } else if (\"<\".equals(operator)) {\n-            return filterLess(json);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.less(ff.property(key), ff.literal(value), false);\n         } else if (\"<=\".equals(operator)) {\n-            return filterLessOrEqual(json);\n-        }\n-        // Set Membership Filters\n-        else if (\"in\".equals(operator)) {\n-            return filterIn(json, true);\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n+            // Set Membership Filters\n+        } else if (\"in\".equals(operator)) {\n+            String key = parse.get(json, 1);\n+            Expression[] args = new Expression[json.size() - 1];\n+            args[0] = ff.property(key);\n+            for (int i = 1; i < args.length; i++) {\n+                Object value = parse.value(json, i + 1);\n+                args[i] = ff.literal(value);\n+            }\n+            Function in = ff.function(\"in\", args);\n+            return ff.equals(in, ff.literal(true));\n         } else if (\"!in\".equals(operator)) {\n-            return filterIn(json, false);\n-        }\n-        // Combining Filters\n-        else if (\"all\".equals(operator)) {\n-            return filterAll(json);\n-        } else if (\"any\".equals(operator)) {\n-            return filterAny(json);\n-        } else if (\"none\".equals(operator)) {\n-            return filterNone(json);\n-        }\n-        // MBExpression filters\n-        else if (\"case\".equals(operator)) {\n-            Expression caseExpr = MBExpression.transformExpression(json);\n-            return ff.equals(caseExpr, ff.literal(true));\n-        } else if (\"coalesce\".equals(operator)) {\n-            Expression coalesce = MBExpression.transformExpression(json);\n-            return ff.equals(coalesce, ff.literal(true));\n-        } else if (\"match\".equals(operator)) {\n-            Expression match = MBExpression.transformExpression(json);\n-            return ff.equals(match, ff.literal(true));\n-        } else if (\"within\".equals(operator)) {\n-            Expression within = MBExpression.transformExpression(json);\n-            return ff.equals(within, ff.literal(true));\n-        } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n-        }\n-    }\n-\n-    private Filter filterNone(JSONArray array) {\n-        List<Filter> none = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            String key = parse.get(json, 1);\n+            Expression[] args = new Expression[json.size() - 1];\n+            args[0] = ff.property(key);\n+            for (int i = 1; i < args.length; i++) {\n+                Object value = parse.value(json, i + 1);\n+                args[i] = ff.literal(value);\n+            }\n+            Function in = ff.function(\"in\", args);\n+            return ff.equals(in, ff.literal(false));\n+            // Combining Filters\n+        } else if (\"all\".equals(operator)) {\n+            List<Filter> all = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n-            } else {\n-                throw new MBFormatException(\n-                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.and(none);\n-    }\n-\n-    private Filter filterAny(JSONArray array) {\n-        List<Filter> any = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            return ff.and(all);\n+        } else if (\"any\".equals(operator)) {\n+            List<Filter> any = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n-            } else {\n-                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.or(any);\n-    }\n-\n-    private Filter filterAll(JSONArray array) {\n-        List<Filter> all = new ArrayList<>();\n-        for (int i = 1; i < array.size(); i++) {\n-            if (parse.isArray(array, i)) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n+            return ff.or(any);\n+        } else if (\"none\".equals(operator)) {\n+            List<Filter> none = new ArrayList<>();\n+            for (int i = 1; i < json.size(); i++) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n-            } else {\n-                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-        }\n-        return ff.and(all);\n-    }\n-\n-    private Filter filterIn(JSONArray array, boolean in) {\n-        String key = parse.get(array, 1);\n-        Expression[] args = new Expression[array.size() - 1];\n-        args[0] = ff.property(key);\n-        for (int i = 1; i < args.length; i++) {\n-            Expression expression = parse.string(array, i + 1);\n-            args[i] = expression;\n-        }\n-        Function function = ff.function(\"in\", args);\n-        return ff.equals(function, ff.literal(in));\n-    }\n-\n-    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n-        Set<FeatureId> fids = new HashSet<>();\n-        for (Object value : array.subList(2, array.size())) {\n-            if (value instanceof String) {\n-                String fid = (String) value;\n-                fids.add(ff.featureId(fid));\n-            }\n-        }\n-        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n-            return ff.id(fids);\n-        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n-            return ff.not(ff.id(fids));\n-        } else {\n-            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n-        }\n-    }\n-\n-    private Filter filterByGeometryType(JSONArray json, String operator) {\n-        List<Filter> typeFilters = new ArrayList<>();\n-        List<?> types = json.subList(2, json.size());\n-        for (Object type : types) {\n-            Filter typeFilter = null;\n-            if (type instanceof String) {\n-                typeFilter = translateType((String) type);\n-            }\n-            if (typeFilter == null) {\n-                throw new MBFormatException(\n-                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n-            }\n-            typeFilters.add(typeFilter);\n-        }\n-        if (\"==\".equals(operator)) {\n-            if (typeFilters.size() != 1) {\n-                throw new MBFormatException(\n-                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n-            }\n-            return typeFilters.get(0);\n-        } else if (\"!=\".equals(operator)) {\n-            if (typeFilters.size() != 1) {\n-                throw new MBFormatException(\n-                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n-            }\n-            return ff.not(typeFilters.get(0));\n-        } else if (\"in\".equals(operator)) {\n-            return ff.or(typeFilters);\n-        } else if (\"!in\".equals(operator)) {\n-            return ff.not(ff.or(typeFilters));\n+            return ff.and(none);\n         } else {\n-            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n-        }\n-    }\n-\n-    /**\n-     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n-     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n-     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n-     *\n-     * @return equal to expression\n-     */\n-    private Filter filterEqualTo(JSONArray array) {\n-        if (array.size() != 3) {\n-            throwUnexpectedArgumentCount(\"==\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.equals(expression1, expression2);\n-    }\n-\n-    /**\n-     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n-     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n-     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n-     *\n-     * @return Not equals expression\n-     */\n-    private Filter filterNotEqual(JSONArray array) {\n-        if (array.size() != 3) {\n-            throwUnexpectedArgumentCount(\"!=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.notEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterLessOrEqual(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\"<=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.lessOrEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterLess(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\"<\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.less(expression1, expression2);\n-    }\n-\n-    private Filter filterGreaterOrEqual(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\">=\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.greaterOrEqual(expression1, expression2);\n-    }\n-\n-    private Filter filterGreater(JSONArray array) {\n-        if (json.size() != 3) {\n-            throwUnexpectedArgumentCount(\">\", 2);\n-        }\n-        Expression expression1 = comparisonExpression1(array);\n-        Expression expression2 = comparisonExpression2(array);\n-        return ff.greater(expression1, expression2);\n-    }\n-\n-    private void throwUnexpectedArgumentCount(String expression, int argCount)\n-            throws MBFormatException {\n-        throw new MBFormatException(\n-                String.format(\n-                        \"Expression \\\"%s\\\" should have exactly %d argument(s)\",\n-                        expression, argCount));\n-    }\n-\n-    /**\n-     * Comparison value1 defined as an expression (or legacy key reference).\n-     *\n-     * @param array JSON filter definition\n-     * @return Expression for comparison\n-     */\n-    private Expression comparisonExpression1(JSONArray array) {\n-        if (parse.isString(array, 1)) { // legacy filter syntax\n-            String key = parse.get(array, 1);\n-            return ff.property(key);\n-        } else {\n-            return parse.string(array, 1);\n-        }\n-    }\n-    /**\n-     * Comparison value1 defined as an expression (or legacy literal reference).\n-     *\n-     * @param array JSON filter definition\n-     * @return Expression for comparison\n-     */\n-    private Expression comparisonExpression2(JSONArray array) {\n-        if (parse.isString(array, 1)) { // legacy filter syntax\n-            Object value = parse.value(array, 2);\n-            return ff.literal(value);\n-        } else {\n-            return parse.string(array, 2);\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962033", "bodyText": "\"property expressions\" is not a term referenced anywhere in the MBStyle spec (I think the term you are looking for is data expressions - https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#data-expressions ), and you've referred to them as just \"expressions\" elsewhere.\nPlease stick with a consistent name. The distinction between GeoTools Expressions and MapBox expressions is already confusing enough without making up terms.", "author": "tbarsballe", "createdAt": "2020-05-21T23:08:37Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -35,7 +35,10 @@\n import org.opengis.filter.expression.Function;\n \n /**\n- * MBFunction json wrapper, allowing conversion to a GeoTools Expression.\n+ * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n+ *\n+ * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTU5MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432791591", "bodyText": "Okay so data expression for mapbox style, and GeoTools Expression elsewhere.", "author": "jodygarnett", "createdAt": "2020-05-30T00:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5Nzg3MQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432797871", "bodyText": "The https://docs.mapbox.com/mapbox-gl-js/style-spec/other/#function page uses:\n\nAs of v0.41.0, property expressions is the preferred method for styling features based on zoom level or the feature's properties. Zoom and property functions are still supported, but will be phased out in a future release.", "author": "jodygarnett", "createdAt": "2020-05-30T01:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwNjY0Mg==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432806642", "bodyText": "I had a run at consistently using:\n\n\"data expression\"\n\"GeoTools Expression\"\n\"name\" (rather than tag or propertyName)\n\"value\" for object vs \"element\" for array", "author": "jodygarnett", "createdAt": "2020-05-30T03:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\nindex 3943c89db1..f0f4a14459 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\n\n@@ -35,10 +35,7 @@ import org.opengis.filter.expression.Expression;\n import org.opengis.filter.expression.Function;\n \n /**\n- * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n- *\n- * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for\n- * dynamically styling features.\n+ * MBFunction json wrapper, allowing conversion to a GeoTools Expression.\n  *\n  * <p>Each function is evaluated according type: {@link FunctionType#IDENTITY}, {@link\n  * FunctionType#INTERVAL}, {@link FunctionType#CATEGORICAL}, {@link FunctionType#EXPONENTIAL}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mjg4Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962883", "bodyText": "\"... not a supported\" what? This error message seems worse then before.", "author": "tbarsballe", "createdAt": "2020-05-21T23:11:19Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1145,11 +1150,20 @@ public Expression string(JSONArray json, int index) {\n             MBFunction function = new MBFunction(this, (JSONObject) obj);\n             return function.function(String.class);\n         } else if (obj instanceof JSONArray) {\n-            if (((JSONArray) obj).get(0) instanceof String\n-                    && MBExpression.canCreate(((JSONArray) obj).get(0).toString())) {\n-                return MBExpression.transformExpression((JSONArray) obj);\n+            JSONArray array = (JSONArray) obj;\n+            if (isString(array, 0)) {\n+                String expressionName = get(array, 0);\n+                if (MBExpression.canCreate(expressionName)) {\n+                    return MBExpression.transformExpression(array);\n+                } else {\n+                    throw new MBFormatException(\n+                            context\n+                                    + \" string unavailable: expression' \"\n+                                    + expressionName\n+                                    + \"' not supported.\");\n+                }\n             } else {\n-                throw new MBFormatException(context + \" string from JSONArray not supported\");\n+                throw new MBFormatException(context + \" string from JSONArray not a supported\");", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\nindex f622d8ae14..8ded77030a 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n\n@@ -1150,20 +1145,11 @@ public class MBObjectParser {\n             MBFunction function = new MBFunction(this, (JSONObject) obj);\n             return function.function(String.class);\n         } else if (obj instanceof JSONArray) {\n-            JSONArray array = (JSONArray) obj;\n-            if (isString(array, 0)) {\n-                String expressionName = get(array, 0);\n-                if (MBExpression.canCreate(expressionName)) {\n-                    return MBExpression.transformExpression(array);\n-                } else {\n-                    throw new MBFormatException(\n-                            context\n-                                    + \" string unavailable: expression' \"\n-                                    + expressionName\n-                                    + \"' not supported.\");\n-                }\n+            if (((JSONArray) obj).get(0) instanceof String\n+                    && MBExpression.canCreate(((JSONArray) obj).get(0).toString())) {\n+                return MBExpression.transformExpression((JSONArray) obj);\n             } else {\n-                throw new MBFormatException(context + \" string from JSONArray not a supported\");\n+                throw new MBFormatException(context + \" string from JSONArray not supported\");\n             }\n         } else {\n             throw new IllegalArgumentException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mzc4OA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428963788", "bodyText": "This doesn't add anything - why do both this method and isDefined(JSONObject json, String propertyName) exist (I see you've overloaded isDefined below, but why didn't you just overload this method instead)?", "author": "tbarsballe", "createdAt": "2020-05-21T23:14:33Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTA5NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432799095", "bodyText": "I liked the way the isDefined( json, propertyName) method reads better, I should clean up references to this method.", "author": "jodygarnett", "createdAt": "2020-05-30T01:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mzc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\nindex f622d8ae14..8ded77030a 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n\n@@ -1443,71 +1429,72 @@ public class MBObjectParser {\n     //\n     // structure checks\n     //\n-    /** @return True if json has the provided property explicitly provided, False otherwise. */\n+    /**\n+     * @return True if json has the provided property explicitly provided, False otherwise.\n+     * @deprecated please use isDefined( json, propertyName)\n+     */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n-        return isDefined(json, propertyName);\n+        return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n     /** @return True if json has the property explicitly provided, False otherwise. */\n-    public boolean isDefined(JSONObject json, String propertyName) throws MBFormatException {\n+    public boolean isDefined(JSONObject json, String propertyName)\n+            throws MBFormatException {\n         return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n     /** @return True if array has the property explicitly provided, False otherwise. */\n-    public boolean isDefined(JSONArray json, int index) throws MBFormatException {\n+    public boolean isDefined(JSONArray json, int index)\n+            throws MBFormatException {\n         return index < json.size() && json.get(index) != null;\n     }\n     /** @return True if json has the string property explicitly provided, False otherwise. */\n-    public boolean isString(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof String;\n+    public boolean isString(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof String;\n     }\n     /** @return True if array has the string property explicitly provided, False otherwise. */\n-    public boolean isString(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof String;\n+    public boolean isString(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof String;\n     }\n     /** @return True if json has the number property explicitly provided, False otherwise. */\n-    public boolean isNumeric(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof Number;\n+    public boolean isNumeric(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof Number;\n     }\n     /** @return True if array has the number property explicitly provided, False otherwise. */\n-    public boolean isNumeric(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof Number;\n+    public boolean isNumeric(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof Number;\n     }\n     /** @return True if json has the boolean property explicitly provided, False otherwise. */\n-    public boolean isBoolean(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof Boolean;\n+    public boolean isBoolean(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof Boolean;\n     }\n     /** @return True if array has the boolean property explicitly provided, False otherwise. */\n-    public boolean isBoolean(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof Boolean;\n+    public boolean isBoolean(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof Boolean;\n     }\n     /** @return True if json has the array property explicitly provided, False otherwise. */\n-    public boolean isArray(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof JSONArray;\n+    public boolean isArray(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof JSONArray;\n     }\n     /** @return True if array has the array property explicitly provided, False otherwise. */\n-    public boolean isArray(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size()\n-                && json.get(index) != null\n-                && json.get(index) instanceof JSONArray;\n+    public boolean isArray(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof JSONArray;\n     }\n     /** @return True json has the object property explicitly provided, False otherwise. */\n-    public boolean isObject(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof JSONObject;\n+    public boolean isObject(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof JSONObject;\n     }\n     /** @return True if array has the object property explicitly provided, False otherwise. */\n-    public boolean isObject(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size()\n-                && json.get(index) != null\n-                && json.get(index) instanceof JSONObject;\n+    public boolean isObject(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof JSONObject;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NDg0NQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428964845", "bodyText": "All the int index versions of the is___ methods would benefit from a modified javadoc - arrays don't have properties, they have indices. Something like\n/** @return True if array has a value at the provided index, False otherwise. */\n\nWould make more sense", "author": "tbarsballe", "createdAt": "2020-05-21T23:18:27Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }\n+    /** @return True if json has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONObject json, String propertyName) throws MBFormatException {\n         return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n+    /** @return True if array has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONArray json, int index) throws MBFormatException {", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMzU2Mw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432803563", "bodyText": "Thanks, I have rewritten these.", "author": "jodygarnett", "createdAt": "2020-05-30T02:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NDg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\nindex f622d8ae14..8ded77030a 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java\n\n@@ -1443,71 +1429,72 @@ public class MBObjectParser {\n     //\n     // structure checks\n     //\n-    /** @return True if json has the provided property explicitly provided, False otherwise. */\n+    /**\n+     * @return True if json has the provided property explicitly provided, False otherwise.\n+     * @deprecated please use isDefined( json, propertyName)\n+     */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n-        return isDefined(json, propertyName);\n+        return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n     /** @return True if json has the property explicitly provided, False otherwise. */\n-    public boolean isDefined(JSONObject json, String propertyName) throws MBFormatException {\n+    public boolean isDefined(JSONObject json, String propertyName)\n+            throws MBFormatException {\n         return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n     /** @return True if array has the property explicitly provided, False otherwise. */\n-    public boolean isDefined(JSONArray json, int index) throws MBFormatException {\n+    public boolean isDefined(JSONArray json, int index)\n+            throws MBFormatException {\n         return index < json.size() && json.get(index) != null;\n     }\n     /** @return True if json has the string property explicitly provided, False otherwise. */\n-    public boolean isString(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof String;\n+    public boolean isString(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof String;\n     }\n     /** @return True if array has the string property explicitly provided, False otherwise. */\n-    public boolean isString(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof String;\n+    public boolean isString(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof String;\n     }\n     /** @return True if json has the number property explicitly provided, False otherwise. */\n-    public boolean isNumeric(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof Number;\n+    public boolean isNumeric(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof Number;\n     }\n     /** @return True if array has the number property explicitly provided, False otherwise. */\n-    public boolean isNumeric(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof Number;\n+    public boolean isNumeric(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof Number;\n     }\n     /** @return True if json has the boolean property explicitly provided, False otherwise. */\n-    public boolean isBoolean(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof Boolean;\n+    public boolean isBoolean(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof Boolean;\n     }\n     /** @return True if array has the boolean property explicitly provided, False otherwise. */\n-    public boolean isBoolean(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size() && json.get(index) != null && json.get(index) instanceof Boolean;\n+    public boolean isBoolean(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof Boolean;\n     }\n     /** @return True if json has the array property explicitly provided, False otherwise. */\n-    public boolean isArray(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof JSONArray;\n+    public boolean isArray(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof JSONArray;\n     }\n     /** @return True if array has the array property explicitly provided, False otherwise. */\n-    public boolean isArray(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size()\n-                && json.get(index) != null\n-                && json.get(index) instanceof JSONArray;\n+    public boolean isArray(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof JSONArray;\n     }\n     /** @return True json has the object property explicitly provided, False otherwise. */\n-    public boolean isObject(JSONObject json, String propertyName) throws MBFormatException {\n-        return json.containsKey(propertyName)\n-                && json.get(propertyName) != null\n-                && json.get(propertyName) instanceof JSONObject;\n+    public boolean isObject(JSONObject json, String propertyName)\n+            throws MBFormatException {\n+        return json.containsKey(propertyName) && json.get(propertyName) != null && json.get(propertyName) instanceof JSONObject;\n     }\n     /** @return True if array has the object property explicitly provided, False otherwise. */\n-    public boolean isObject(JSONArray json, int index) throws MBFormatException {\n-        return index < json.size()\n-                && json.get(index) != null\n-                && json.get(index) instanceof JSONObject;\n+    public boolean isObject(JSONArray json, int index)\n+            throws MBFormatException {\n+        return index < json.size() && json.get(index) != null &&  && json.get(index) instanceof JSONObject;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NzYwNw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428967607", "bodyText": "This change isn't much of an improvement, as either could be true.\nGiven that GT doesn't necessarily support the full set of expressions, this distinction is relevant, because the invalid and not supported have different fixes - and invalid expression is user error (most likely a misspelling), and should be simple to fix, whereas an expression that is not supported means they need to upgrade (or wait for) a version of geotools that supports the expression.\nUnfortunately I don't think there's much we can do about this - even if we maintained a list of expressions that GT didn't yet support, it would inevitably become outdated. Perhaps a more descriptive error message? Something like:\nExpression \\\"\" + name + \"\\\" invalid. It may be misspelled or not supported by this implementation\"", "author": "tbarsballe", "createdAt": "2020-05-21T23:28:42Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java", "diffHunk": "@@ -151,24 +162,25 @@ public static MBExpression create(JSONArray json) {\n             } else if (zoom.contains(name)) {\n                 return new MBZoom(json);\n             } else {\n-                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" invalid.\");\n+                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" not supported.\");", "originalCommit": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MjYyOQ==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r432792629", "bodyText": "Thanks, making the change you suggested.\nThe only positive improvement we could make here is to report the list of data expressions we do support; but that is likely to get long over time (and less useful as a result).", "author": "jodygarnett", "createdAt": "2020-05-30T00:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NzYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java\nindex bbb87df0cb..b2883ea093 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java\n\n@@ -162,25 +151,24 @@ public abstract class MBExpression extends FunctionImpl {\n             } else if (zoom.contains(name)) {\n                 return new MBZoom(json);\n             } else {\n-                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" not supported.\");\n+                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" invalid.\");\n             }\n         }\n         throw new MBFormatException(\"Requires a string name of the expression at position 0\");\n     }\n \n     public static boolean canCreate(final String name) {\n-        return name != null\n-                && (colors.contains(name)\n-                        || decisions.contains(name)\n-                        || featureData.contains(name)\n-                        || heatMap.contains(name)\n-                        || lookUp.contains(name)\n-                        || math.contains(name)\n-                        || ramps.contains(name)\n-                        || string.contains(name)\n-                        || types.contains(name)\n-                        || variableBindings.contains(name)\n-                        || zoom.contains(name));\n+        return colors.contains(name)\n+                || decisions.contains(name)\n+                || featureData.contains(name)\n+                || heatMap.contains(name)\n+                || lookUp.contains(name)\n+                || math.contains(name)\n+                || ramps.contains(name)\n+                || string.contains(name)\n+                || types.contains(name)\n+                || variableBindings.contains(name)\n+                || zoom.contains(name);\n     }\n \n     /** Determines which expression to use. */\n"}}, {"oid": "cc24b65bb30889788a85e384a95019cd88ddb9fa", "url": "https://github.com/geotools/geotools/commit/cc24b65bb30889788a85e384a95019cd88ddb9fa", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-05-30T00:36:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzODIzMw==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433338233", "bodyText": "\"data expessions are\"", "author": "tbarsballe", "createdAt": "2020-06-01T16:10:59Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -37,8 +37,8 @@\n /**\n  * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n  *\n- * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for\n- * dynamically styling features.\n+ * <p>As of v0.41.0, data expressions is the preferred method for styling features based on zoom", "originalCommit": "28adb9374b48562bedaea7a2081c4b242e9f7634", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\nindex 77db0cedad..f0f4a14459 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java\n\n@@ -35,10 +35,7 @@ import org.opengis.filter.expression.Expression;\n import org.opengis.filter.expression.Function;\n \n /**\n- * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n- *\n- * <p>As of v0.41.0, data expressions is the preferred method for styling features based on zoom\n- * level or the feature's properties.\n+ * MBFunction json wrapper, allowing conversion to a GeoTools Expression.\n  *\n  * <p>Each function is evaluated according type: {@link FunctionType#IDENTITY}, {@link\n  * FunctionType#INTERVAL}, {@link FunctionType#CATEGORICAL}, {@link FunctionType#EXPONENTIAL}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MDkzMA==", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433340930", "bodyText": "Pretty sure splitting the closing brace from the else violates the style guide (although Travis CI seems happy with it, so I guess not?). Not really important either way.", "author": "tbarsballe", "createdAt": "2020-06-01T16:16:15Z", "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,22 +56,26 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {\n             if (json.size() == 2) {\n+                // Example: [\"get\", \"propertyName\"]\n                 if (parse.isString(json, 1)) {\n                     String propertyName = parse.get(json, 1);\n                     return ff.property(propertyName);\n-                } else {\n+                }\n+                // Example: [\"get\", key]\n+                else {", "originalCommit": "28adb9374b48562bedaea7a2081c4b242e9f7634", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "chunk": "diff --git a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\nindex fa8e748526..1c5fef01fa 100644\n--- a/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\n+++ b/modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java\n\n@@ -56,26 +56,16 @@ public class MBLookup extends MBExpression {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {\n             if (json.size() == 2) {\n-                // Example: [\"get\", \"propertyName\"]\n-                if (parse.isString(json, 1)) {\n-                    String propertyName = parse.get(json, 1);\n-                    return ff.property(propertyName);\n-                }\n-                // Example: [\"get\", key]\n-                else {\n-                    // it is unclear from specification if this is even allowed\n-                    Expression property = parse.string(json, 1);\n-                    return ff.function(\"property\", property);\n-                }\n+                Expression property = parse.string(json, 1);\n+                return ff.function(\"property\", property);\n             }\n-            // Example: [\"get\", key, object]\n             if (json.size() == 3) {\n                 Expression value = parse.string(json, 1);\n                 Expression object = parse.string(json, 2);\n                 return ff.function(\"get\", value, object);\n             }\n         }\n-        throw new MBFormatException(\"Data expression \\\"get\\\" requires a maximum of 3 arguments.\");\n+        throw new MBFormatException(\"Expression \\\"get\\\" requires a maximum of 2 arguments.\");\n     }\n \n     /**\n"}}, {"oid": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "url": "https://github.com/geotools/geotools/commit/66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "message": "Additional MBObjectParser methods to check json object and array structure\n\nThis prevents code breaking out their own instance of checks\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "ac35e8868fddcc200b7048497f96dbc77a77c8d8", "url": "https://github.com/geotools/geotools/commit/ac35e8868fddcc200b7048497f96dbc77a77c8d8", "message": "MBExpression transformExpression incorrectly used to generate string\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "d864e0dc46a6666048eab4f5946a09354d8b6782", "url": "https://github.com/geotools/geotools/commit/d864e0dc46a6666048eab4f5946a09354d8b6782", "message": "Document Function stop approach as deprecated\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "7d099b39f9f27458c8f91a078fd48a0713fece9e", "url": "https://github.com/geotools/geotools/commit/7d099b39f9f27458c8f91a078fd48a0713fece9e", "message": "Experiment to show how MBFilter can support use of expressions\n\nThe deprecated syntax is preserved, and documented, for backwards compatibility.\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "9c0267a95ab980448a7a7c672039e87acc9b2a6e", "url": "https://github.com/geotools/geotools/commit/9c0267a95ab980448a7a7c672039e87acc9b2a6e", "message": "Cleanup to confirm existing tests still pass\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:36Z", "type": "commit"}, {"oid": "501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "url": "https://github.com/geotools/geotools/commit/501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "message": "document support for filter expressions\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "url": "https://github.com/geotools/geotools/commit/4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "message": "Generate PropertyName when literal key supplied\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "ac0f153faa99add803424747b4fddc142d80f352", "url": "https://github.com/geotools/geotools/commit/ac0f153faa99add803424747b4fddc142d80f352", "message": "confirm filter expressions work\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "url": "https://github.com/geotools/geotools/commit/5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "message": "improve notification if expression not supported\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "url": "https://github.com/geotools/geotools/commit/062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "message": "Test case now reporting the correct PropertyName reference\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "79eddf2949582978e69068c6f33f6c9efa810be8", "url": "https://github.com/geotools/geotools/commit/79eddf2949582978e69068c6f33f6c9efa810be8", "message": "refactor into private methods\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "8a607884335b7f6399329e0c15378cd2be12b0a2", "url": "https://github.com/geotools/geotools/commit/8a607884335b7f6399329e0c15378cd2be12b0a2", "message": "A better null pointer exception message when generating ECQL\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0981769fa07e445f31599be43e6ddf4ee11dfb7e", "url": "https://github.com/geotools/geotools/commit/0981769fa07e445f31599be43e6ddf4ee11dfb7e", "message": "Test that delegating to MBExpression is working as expected\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "5c55d4834bf99900d7b35fb7bea1755aec1558d9", "url": "https://github.com/geotools/geotools/commit/5c55d4834bf99900d7b35fb7bea1755aec1558d9", "message": "Avoid deprecation warnings\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "2dd047cec1eb8c3b8d157f04751bc8c488287242", "url": "https://github.com/geotools/geotools/commit/2dd047cec1eb8c3b8d157f04751bc8c488287242", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "commit"}, {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-14T21:05:37Z", "type": "forcePushed"}, {"oid": "7ed7c7dfc752912f81897402378fd201d09e03c7", "url": "https://github.com/geotools/geotools/commit/7ed7c7dfc752912f81897402378fd201d09e03c7", "message": "update based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>", "committedDate": "2020-07-15T05:57:07Z", "type": "commit"}]}