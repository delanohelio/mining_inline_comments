{"pr_number": 1831, "pr_title": "Refactor Device Connection AMQP endpoint not to use event bus", "pr_createdAt": "2020-03-12T10:13:48Z", "pr_url": "https://github.com/eclipse/hono/pull/1831", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MjI5OQ==", "url": "https://github.com/eclipse/hono/pull/1831#discussion_r391552299", "bodyText": "How about creating the span before parsing the payload - then that error can be logged in the trace span.\nSee also 8f2958f.", "author": "calohmn", "createdAt": "2020-03-12T11:15:45Z", "path": "service-base/src/main/java/org/eclipse/hono/service/deviceconnection/AbstractDeviceConnectionAmqpEndpoint.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.service.deviceconnection;\n+\n+import java.net.HttpURLConnection;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.config.ServiceConfigProperties;\n+import org.eclipse.hono.service.amqp.AbstractRequestResponseEndpoint;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * An {@code AmqpEndpoint} for managing device connection information.\n+ * <p>\n+ * This endpoint implements Hono's <a href=\"https://www.eclipse.org/hono/docs/api/device-connection/\">Device\n+ * Connection API</a>. It receives AMQP 1.0 messages representing requests and sends them to an address on the vertx\n+ * event bus for processing. The outcome is then returned to the peer in a response message.\n+ */\n+public abstract class AbstractDeviceConnectionAmqpEndpoint extends AbstractRequestResponseEndpoint<ServiceConfigProperties> {\n+\n+    private static final String SPAN_NAME_GET_LAST_GATEWAY = \"get last known gateway\";\n+    private static final String SPAN_NAME_SET_LAST_GATEWAY = \"set last known gateway\";\n+    private static final String SPAN_NAME_GET_CMD_HANDLING_ADAPTER_INSTANCES = \"get command handling adapter instances\";\n+    private static final String SPAN_NAME_SET_CMD_HANDLING_ADAPTER_INSTANCE = \"set command handling adapter instance\";\n+    private static final String SPAN_NAME_REMOVE_CMD_HANDLING_ADAPTER_INSTANCE = \"remove command handling adapter instance\";\n+\n+    /**\n+     * Creates a new credentials endpoint for a vertx instance.\n+     *\n+     * @param vertx The vertx instance to use.\n+     */\n+    public AbstractDeviceConnectionAmqpEndpoint(final Vertx vertx) {\n+        super(vertx);\n+    }\n+\n+    /**\n+     * The service to forward requests to.\n+     *\n+     * @return The service to bind to, must never return {@code null}.\n+     */\n+    protected abstract DeviceConnectionService getService();\n+\n+    @Override\n+    protected Future<Message> handleRequestMessage(final Message requestMessage, final ResourceIdentifier targetAddress) {\n+        Objects.requireNonNull(requestMessage);\n+\n+        switch (DeviceConnectionConstants.DeviceConnectionAction.from(requestMessage.getSubject())) {\n+        case GET_LAST_GATEWAY:\n+            return processGetLastGatewayRequest(requestMessage, targetAddress);\n+        case SET_LAST_GATEWAY:\n+            return processSetLastGatewayRequest(requestMessage, targetAddress);\n+        case GET_CMD_HANDLING_ADAPTER_INSTANCES:\n+            return processGetCmdHandlingAdapterInstances(requestMessage, targetAddress);\n+        case SET_CMD_HANDLING_ADAPTER_INSTANCE:\n+            return processSetCmdHandlingAdapterInstance(requestMessage, targetAddress);\n+        case REMOVE_CMD_HANDLING_ADAPTER_INSTANCE:\n+            return processRemoveCmdHandlingAdapterInstance(requestMessage, targetAddress);\n+        default:\n+            return processCustomOperationMessage(requestMessage);\n+        }\n+    }\n+\n+    /**\n+     * Processes a <em>get last known gateway</em> request message.\n+     *\n+     * @param request The request message.\n+     * @param targetAddress The address the message is sent to.\n+     * @return The response to send to the client via the event bus.\n+     */\n+    protected Future<Message> processGetLastGatewayRequest(final Message request, final ResourceIdentifier targetAddress) {\n+        final String tenantId = targetAddress.getTenantId();\n+        final String deviceId = MessageHelper.getDeviceId(request);\n+\n+        final Span span = TracingHelper.buildServerChildSpan(\n+                tracer,\n+                TracingHelper.extractSpanContext(tracer, request),\n+                SPAN_NAME_GET_LAST_GATEWAY,\n+                getClass().getSimpleName()\n+        ).start();\n+\n+        final Future<Message> resultFuture;\n+        if (tenantId == null || deviceId == null) {\n+            TracingHelper.logError(span, \"missing tenant and/or device\");\n+            resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            log.debug(\"getting last known gateway for tenant [{}], device [{}]\", tenantId, deviceId);\n+\n+            TracingHelper.TAG_TENANT_ID.set(span, tenantId);\n+            TracingHelper.TAG_DEVICE_ID.set(span, deviceId);\n+\n+            resultFuture = getService().getLastKnownGatewayForDevice(tenantId, deviceId, span)\n+                    .map(res -> DeviceConnectionConstants.getAmqpReply(\n+                            DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT,\n+                            tenantId,\n+                            request,\n+                            res)\n+                    );\n+        }\n+        return finishSpanOnFutureCompletion(span, resultFuture);\n+    }\n+\n+    /**\n+     * Processes a <em>set last known gateway</em> request message.\n+     *\n+     * @param request The request message.\n+     * @param targetAddress The address the message is sent to.\n+     * @return The response to send to the client via the event bus.\n+     */\n+    protected Future<Message> processSetLastGatewayRequest(final Message request, final ResourceIdentifier targetAddress) {\n+        final String tenantId = targetAddress.getTenantId();\n+        final String deviceId = MessageHelper.getDeviceId(request);\n+        final String gatewayId = MessageHelper.getGatewayId(request);\n+\n+        final Span span = TracingHelper.buildServerChildSpan(\n+                tracer,\n+                TracingHelper.extractSpanContext(tracer, request),\n+                SPAN_NAME_SET_LAST_GATEWAY,\n+                getClass().getSimpleName()\n+        ).start();\n+\n+        final Future<Message> resultFuture;\n+        if (tenantId == null || deviceId == null || gatewayId == null) {\n+            TracingHelper.logError(span, \"missing tenant, device and/or gateway\");\n+            resultFuture = Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            log.debug(\"setting last known gateway for tenant [{}], device [{}] to {}\", tenantId, deviceId, gatewayId);\n+\n+            TracingHelper.TAG_TENANT_ID.set(span, tenantId);\n+            TracingHelper.TAG_DEVICE_ID.set(span, deviceId);\n+            TracingHelper.TAG_GATEWAY_ID.set(span, gatewayId);\n+\n+            resultFuture = getService().setLastKnownGatewayForDevice(tenantId, deviceId, gatewayId, span)\n+                    .map(res -> DeviceConnectionConstants.getAmqpReply(\n+                            DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT,\n+                            tenantId,\n+                            request,\n+                            res)\n+                    );\n+        }\n+        return finishSpanOnFutureCompletion(span, resultFuture);\n+    }\n+\n+    /**\n+     * Processes a <em>get command handling protocol adapter instance</em> request message.\n+     *\n+     * @param request The request message.\n+     * @param targetAddress The address the message is sent to.\n+     * @return The response to send to the client via the event bus.\n+     */\n+    protected Future<Message> processGetCmdHandlingAdapterInstances(final Message request, final ResourceIdentifier targetAddress) {\n+        final String tenantId = targetAddress.getTenantId();\n+        final String deviceId = MessageHelper.getDeviceId(request);\n+\n+        JsonObject payload = null;\n+        try {\n+            payload = MessageHelper.getJsonPayload(request);\n+        } catch (DecodeException e) {\n+            logger.debug(\"failed to decode AMQP request message\", e);\n+            return Future.failedFuture(\n+                    new ClientErrorException(\n+                            HttpURLConnection.HTTP_BAD_REQUEST,\n+                            \"request message body contains malformed JSON\"));\n+        }\n+\n+        final Span span = TracingHelper.buildServerChildSpan(\n+                tracer,\n+                TracingHelper.extractSpanContext(tracer, request),\n+                SPAN_NAME_GET_CMD_HANDLING_ADAPTER_INSTANCES,\n+                getClass().getSimpleName()\n+        ).start();", "originalCommit": "8e3bcefc2313378ee851309efc77be0b96dbac69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2NzI3Ng==", "url": "https://github.com/eclipse/hono/pull/1831#discussion_r391567276", "bodyText": "@calohmn  Good catch. Fixed!", "author": "dejanb", "createdAt": "2020-03-12T11:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1MjI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4ccd99865ec877462802c193e43ec2e8f51c92da", "chunk": "diff --git a/service-base/src/main/java/org/eclipse/hono/service/deviceconnection/AbstractDeviceConnectionAmqpEndpoint.java b/service-base/src/main/java/org/eclipse/hono/service/deviceconnection/AbstractDeviceConnectionAmqpEndpoint.java\nindex a627a61cc..54327e1c8 100644\n--- a/service-base/src/main/java/org/eclipse/hono/service/deviceconnection/AbstractDeviceConnectionAmqpEndpoint.java\n+++ b/service-base/src/main/java/org/eclipse/hono/service/deviceconnection/AbstractDeviceConnectionAmqpEndpoint.java\n\n@@ -174,24 +174,24 @@ public abstract class AbstractDeviceConnectionAmqpEndpoint extends AbstractReque\n         final String tenantId = targetAddress.getTenantId();\n         final String deviceId = MessageHelper.getDeviceId(request);\n \n-        JsonObject payload = null;\n+        final Span span = TracingHelper.buildServerChildSpan(\n+                tracer,\n+                TracingHelper.extractSpanContext(tracer, request),\n+                SPAN_NAME_GET_CMD_HANDLING_ADAPTER_INSTANCES,\n+                getClass().getSimpleName()\n+        ).start();\n+\n+        final JsonObject payload;\n         try {\n             payload = MessageHelper.getJsonPayload(request);\n         } catch (DecodeException e) {\n             logger.debug(\"failed to decode AMQP request message\", e);\n-            return Future.failedFuture(\n+            return finishSpanOnFutureCompletion(span, Future.failedFuture(\n                     new ClientErrorException(\n                             HttpURLConnection.HTTP_BAD_REQUEST,\n-                            \"request message body contains malformed JSON\"));\n+                            \"request message body contains malformed JSON\")));\n         }\n \n-        final Span span = TracingHelper.buildServerChildSpan(\n-                tracer,\n-                TracingHelper.extractSpanContext(tracer, request),\n-                SPAN_NAME_GET_CMD_HANDLING_ADAPTER_INSTANCES,\n-                getClass().getSimpleName()\n-        ).start();\n-\n         final Future<Message> resultFuture;\n         if (tenantId == null || deviceId == null || payload == null) {\n             TracingHelper.logError(span, \"missing tenant, device and/or payload\");\n"}}, {"oid": "4ccd99865ec877462802c193e43ec2e8f51c92da", "url": "https://github.com/eclipse/hono/commit/4ccd99865ec877462802c193e43ec2e8f51c92da", "message": "Refactor Device Connection AMQP endpoint not to use event bus", "committedDate": "2020-03-12T11:47:02Z", "type": "commit"}, {"oid": "4ccd99865ec877462802c193e43ec2e8f51c92da", "url": "https://github.com/eclipse/hono/commit/4ccd99865ec877462802c193e43ec2e8f51c92da", "message": "Refactor Device Connection AMQP endpoint not to use event bus", "committedDate": "2020-03-12T11:47:02Z", "type": "forcePushed"}]}