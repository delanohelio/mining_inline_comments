{"pr_number": 1894, "pr_title": "[#1732] Use timeout to wait for disposition update", "pr_createdAt": "2020-04-13T12:33:49Z", "pr_url": "https://github.com/eclipse/hono/pull/1894", "timeline": [{"oid": "b8f1152fd80454488cfc6ccada580b55ec58d215", "url": "https://github.com/eclipse/hono/commit/b8f1152fd80454488cfc6ccada580b55ec58d215", "message": "[#1732] Use timeout to wait for disposition update\n\nAMQP adapter now uses timeout to wait for a disposition update\nin response to a command sent to the device.\n\nfixes #1732\n\nSigned-off-by: Alfusainey Jallow <alf.jallow@gmail.com>", "committedDate": "2020-04-13T12:28:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5MjM5OA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r407892398", "bodyText": "Wrong reference here.", "author": "calohmn", "createdAt": "2020-04-14T06:20:48Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java", "diffHunk": "@@ -137,4 +143,30 @@ public final void setIdleTimeout(final int timeout) {\n     public final int getIdleTimeout() {\n         return this.idleTimeout;\n     }\n+\n+    /**\n+     * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n+     * device is closed.\n+     * <p>\n+     * The default value of this property is {@link #DEFAULT_SEND_COMMAND_TIMEOUT}.", "originalCommit": "b8f1152fd80454488cfc6ccada580b55ec58d215", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\nindex 5d14b4306..305ebaba8 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n\n@@ -146,27 +146,27 @@ public class AmqpAdapterProperties extends ProtocolAdapterProperties {\n \n     /**\n      * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n-     * device is closed.\n+     * device is close.\n      * <p>\n-     * The default value of this property is {@link #DEFAULT_SEND_COMMAND_TIMEOUT}.\n+     * The default value of this property is {@link #sendMessageToDeviceTimeout}.\n      * \n      * @return The wait time in milliseconds.\n      */\n-    public long getDeliveryUpdateTimeout() {\n-        return this.deliveryUpdateTimeout;\n+    public long getSendMessageToDeviceTimeout() {\n+        return this.sendMessageToDeviceTimeout;\n     }\n \n     /**\n      * Sets the time to wait for a delivery update from a device before the AMQP sender link is closed.\n      * \n-     * @param deliveryUpdateTimeout The timeout value in milliseconds.\n+     * @param sendMessageToDeviceTimeout The timeout value in milliseconds.\n      * \n      * @throws IllegalArgumentException if the timeout value is negative.\n      */\n-    public final void setDeliveryUpdateTimeout(final long deliveryUpdateTimeout) {\n-        if (deliveryUpdateTimeout < 0) {\n+    public final void setSendMessageToDeviceTimeout(final long sendMessageToDeviceTimeout) {\n+        if (sendMessageToDeviceTimeout < 0) {\n             throw new IllegalArgumentException(\"timeout value must be >= 0\");\n         }\n-        this.deliveryUpdateTimeout = deliveryUpdateTimeout;\n+        this.sendMessageToDeviceTimeout = sendMessageToDeviceTimeout;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5MjgyOQ==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r407892829", "bodyText": "Comment can be removed.", "author": "calohmn", "createdAt": "2020-04-14T06:22:10Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java", "diffHunk": "@@ -892,7 +892,20 @@ protected void onCommandReceived(final TenantObject tenantObject, final ProtonSe\n         }\n \n         // TODO time out waiting for disposition update", "originalCommit": "b8f1152fd80454488cfc6ccada580b55ec58d215", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\nindex bd0a0706d..ad91f1aca 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n\n@@ -891,54 +892,66 @@ public final class VertxBasedAmqpProtocolAdapter extends AbstractProtocolAdapter\n             MessageHelper.addDeviceId(msg, command.getOriginalDeviceId());\n         }\n \n-        // TODO time out waiting for disposition update\n-        final Long timerId = vertx.setTimer(getConfig().getDeliveryUpdateTimeout(), tid -> {\n-            log.debug(\"waiting for delivery update timed out after \" + getConfig().getDeliveryUpdateTimeout() + \" ms\");\n-            final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n-                    \"timeout waiting for delivery update\");\n-            closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n-            // timeout expired -> release command\n-            commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n-            commandContext.release();\n+        final AtomicBoolean isCommandSettled = new AtomicBoolean(false);\n+\n+        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null :\n+            vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n+            log.debug(\"waiting for delivery update timed out after \" + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n+            if (isCommandSettled.compareAndSet(false, true)) {\n+                final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                        \"timeout waiting for delivery update\");\n+                closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+                // timeout expired -> release command\n+                commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+                commandContext.release();\n+            } else {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            }\n         });\n \n         sender.send(msg, delivery -> {\n-            // disposition received -> cancel timer\n-            vertx.cancelTimer(timerId);\n-\n-            // release the command message when the device either\n-            // rejects or does not settle the command request message.\n-            final DeliveryState remoteState = delivery.getRemoteState();\n-            ProcessingOutcome outcome = null;\n-            if (delivery.remotelySettled()) {\n-                commandContext.disposition(remoteState);\n-                if (Accepted.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.FORWARDED;\n-                } else if (Rejected.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.UNPROCESSABLE;\n-                } else if (Released.class.isInstance(remoteState)) {\n+\n+            if (timerId != null) {\n+                // disposition received -> cancel timer\n+                vertx.cancelTimer(timerId);\n+            }\n+            if (!isCommandSettled.compareAndSet(false, true)) {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            } else {\n+                // release the command message when the device either\n+                // rejects or does not settle the command request message.\n+                final DeliveryState remoteState = delivery.getRemoteState();\n+                ProcessingOutcome outcome = null;\n+                if (delivery.remotelySettled()) {\n+                    commandContext.disposition(remoteState);\n+                    if (Accepted.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.FORWARDED;\n+                    } else if (Rejected.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNPROCESSABLE;\n+                    } else if (Released.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNDELIVERABLE;\n+                    } else if (Modified.class.isInstance(remoteState)) {\n+                        final Modified modified = (Modified) remoteState;\n+                        outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n+                    }\n+                } else {\n+                    log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n+                            remoteState);\n+                    final Map<String, Object> logItems = new HashMap<>(2);\n+                    logItems.put(Fields.EVENT, \"device did not settle command\");\n+                    logItems.put(\"remote state\", remoteState);\n+                    commandContext.getCurrentSpan().log(logItems);\n+                    commandContext.release();\n                     outcome = ProcessingOutcome.UNDELIVERABLE;\n-                } else if (Modified.class.isInstance(remoteState)) {\n-                    final Modified modified = (Modified) remoteState;\n-                    outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n                 }\n-            } else {\n-                log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n-                        remoteState);\n-                final Map<String, Object> logItems = new HashMap<>(2);\n-                logItems.put(Fields.EVENT, \"device did not settle command\");\n-                logItems.put(\"remote state\", remoteState);\n-                commandContext.getCurrentSpan().log(logItems);\n-                commandContext.release();\n-                outcome = ProcessingOutcome.UNDELIVERABLE;\n+                metrics.reportCommand(\n+                        command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                        command.getTenant(),\n+                        tenantObject,\n+                        outcome,\n+                        command.getPayloadSize(),\n+                        getMicrometerSample(commandContext));\n             }\n-            metrics.reportCommand(\n-                    command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n-                    command.getTenant(),\n-                    tenantObject,\n-                    outcome,\n-                    command.getPayloadSize(),\n-                    getMicrometerSample(commandContext));\n         });\n \n         final Map<String, Object> items = new HashMap<>(4);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzIzNg==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r407897236", "bodyText": "The case that the deliveryUpdateTimeout  is 0 should be taken into account here. That would lead to an IllegalArgumentException in vertx.setTimer(). How about adding a check for that here and using null as timerId in that case (like it is done in AbstractSender.sendMessageAndWaitForOutcome) and further down adding a null check around vertx.cancelTimer(timerId);.", "author": "calohmn", "createdAt": "2020-04-14T06:34:01Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java", "diffHunk": "@@ -892,7 +892,20 @@ protected void onCommandReceived(final TenantObject tenantObject, final ProtonSe\n         }\n \n         // TODO time out waiting for disposition update\n+        final Long timerId = vertx.setTimer(getConfig().getDeliveryUpdateTimeout(), tid -> {", "originalCommit": "b8f1152fd80454488cfc6ccada580b55ec58d215", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwNjcwNA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408106704", "bodyText": "The case that the deliveryUpdateTimeout is 0 should be taken into account here\n\nhow about only allowing values > 0 for this config property?", "author": "Alfusainey", "createdAt": "2020-04-14T12:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTgyOA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408179828", "bodyText": "I would rather keep it in line with the handling of the sendMessageTimeout value (and e.g. connection requestTimeout) and allow 0 for an infinite timeout.", "author": "calohmn", "createdAt": "2020-04-14T14:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\nindex bd0a0706d..ad91f1aca 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n\n@@ -891,54 +892,66 @@ public final class VertxBasedAmqpProtocolAdapter extends AbstractProtocolAdapter\n             MessageHelper.addDeviceId(msg, command.getOriginalDeviceId());\n         }\n \n-        // TODO time out waiting for disposition update\n-        final Long timerId = vertx.setTimer(getConfig().getDeliveryUpdateTimeout(), tid -> {\n-            log.debug(\"waiting for delivery update timed out after \" + getConfig().getDeliveryUpdateTimeout() + \" ms\");\n-            final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n-                    \"timeout waiting for delivery update\");\n-            closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n-            // timeout expired -> release command\n-            commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n-            commandContext.release();\n+        final AtomicBoolean isCommandSettled = new AtomicBoolean(false);\n+\n+        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null :\n+            vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n+            log.debug(\"waiting for delivery update timed out after \" + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n+            if (isCommandSettled.compareAndSet(false, true)) {\n+                final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                        \"timeout waiting for delivery update\");\n+                closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+                // timeout expired -> release command\n+                commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+                commandContext.release();\n+            } else {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            }\n         });\n \n         sender.send(msg, delivery -> {\n-            // disposition received -> cancel timer\n-            vertx.cancelTimer(timerId);\n-\n-            // release the command message when the device either\n-            // rejects or does not settle the command request message.\n-            final DeliveryState remoteState = delivery.getRemoteState();\n-            ProcessingOutcome outcome = null;\n-            if (delivery.remotelySettled()) {\n-                commandContext.disposition(remoteState);\n-                if (Accepted.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.FORWARDED;\n-                } else if (Rejected.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.UNPROCESSABLE;\n-                } else if (Released.class.isInstance(remoteState)) {\n+\n+            if (timerId != null) {\n+                // disposition received -> cancel timer\n+                vertx.cancelTimer(timerId);\n+            }\n+            if (!isCommandSettled.compareAndSet(false, true)) {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            } else {\n+                // release the command message when the device either\n+                // rejects or does not settle the command request message.\n+                final DeliveryState remoteState = delivery.getRemoteState();\n+                ProcessingOutcome outcome = null;\n+                if (delivery.remotelySettled()) {\n+                    commandContext.disposition(remoteState);\n+                    if (Accepted.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.FORWARDED;\n+                    } else if (Rejected.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNPROCESSABLE;\n+                    } else if (Released.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNDELIVERABLE;\n+                    } else if (Modified.class.isInstance(remoteState)) {\n+                        final Modified modified = (Modified) remoteState;\n+                        outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n+                    }\n+                } else {\n+                    log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n+                            remoteState);\n+                    final Map<String, Object> logItems = new HashMap<>(2);\n+                    logItems.put(Fields.EVENT, \"device did not settle command\");\n+                    logItems.put(\"remote state\", remoteState);\n+                    commandContext.getCurrentSpan().log(logItems);\n+                    commandContext.release();\n                     outcome = ProcessingOutcome.UNDELIVERABLE;\n-                } else if (Modified.class.isInstance(remoteState)) {\n-                    final Modified modified = (Modified) remoteState;\n-                    outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n                 }\n-            } else {\n-                log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n-                        remoteState);\n-                final Map<String, Object> logItems = new HashMap<>(2);\n-                logItems.put(Fields.EVENT, \"device did not settle command\");\n-                logItems.put(\"remote state\", remoteState);\n-                commandContext.getCurrentSpan().log(logItems);\n-                commandContext.release();\n-                outcome = ProcessingOutcome.UNDELIVERABLE;\n+                metrics.reportCommand(\n+                        command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                        command.getTenant(),\n+                        tenantObject,\n+                        outcome,\n+                        command.getPayloadSize(),\n+                        getMicrometerSample(commandContext));\n             }\n-            metrics.reportCommand(\n-                    command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n-                    command.getTenant(),\n-                    tenantObject,\n-                    outcome,\n-                    command.getPayloadSize(),\n-                    getMicrometerSample(commandContext));\n         });\n \n         final Map<String, Object> items = new HashMap<>(4);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNjA2MA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r407906060", "bodyText": "I'm wondering whether the name of the property (deliveryUpdateTimeout) isn't a bit too technical here.\nThe corresponding property for waiting for a disposition update when the adapter sends a message downstream to the AMQP messaging network is called sendMessageTimeout.\nWhile I think it is indeed good to have a separate property for the other direction (adapter to device), maybe we could align the naming somewhat. Maybe sendMessageToDeviceTimeout?\nIn any case, the property should also be documented here:\nhttps://www.eclipse.org/hono/docs/admin-guide/amqp-adapter-config/#service-configuration", "author": "calohmn", "createdAt": "2020-04-14T06:55:31Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java", "diffHunk": "@@ -137,4 +143,30 @@ public final void setIdleTimeout(final int timeout) {\n     public final int getIdleTimeout() {\n         return this.idleTimeout;\n     }\n+\n+    /**\n+     * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n+     * device is closed.\n+     * <p>\n+     * The default value of this property is {@link #DEFAULT_SEND_COMMAND_TIMEOUT}.\n+     * \n+     * @return The wait time in milliseconds.\n+     */\n+    public long getDeliveryUpdateTimeout() {\n+        return this.deliveryUpdateTimeout;\n+    }\n+\n+    /**\n+     * Sets the time to wait for a delivery update from a device before the AMQP sender link is closed.\n+     * \n+     * @param deliveryUpdateTimeout The timeout value in milliseconds.\n+     * \n+     * @throws IllegalArgumentException if the timeout value is negative.\n+     */\n+    public final void setDeliveryUpdateTimeout(final long deliveryUpdateTimeout) {", "originalCommit": "b8f1152fd80454488cfc6ccada580b55ec58d215", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEwNzkzNA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408107934", "bodyText": "make sense to me \ud83d\udc4d", "author": "Alfusainey", "createdAt": "2020-04-14T12:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwNjA2MA=="}], "type": "inlineReview", "revised_code": {"commit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\nindex 5d14b4306..305ebaba8 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n\n@@ -146,27 +146,27 @@ public class AmqpAdapterProperties extends ProtocolAdapterProperties {\n \n     /**\n      * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n-     * device is closed.\n+     * device is close.\n      * <p>\n-     * The default value of this property is {@link #DEFAULT_SEND_COMMAND_TIMEOUT}.\n+     * The default value of this property is {@link #sendMessageToDeviceTimeout}.\n      * \n      * @return The wait time in milliseconds.\n      */\n-    public long getDeliveryUpdateTimeout() {\n-        return this.deliveryUpdateTimeout;\n+    public long getSendMessageToDeviceTimeout() {\n+        return this.sendMessageToDeviceTimeout;\n     }\n \n     /**\n      * Sets the time to wait for a delivery update from a device before the AMQP sender link is closed.\n      * \n-     * @param deliveryUpdateTimeout The timeout value in milliseconds.\n+     * @param sendMessageToDeviceTimeout The timeout value in milliseconds.\n      * \n      * @throws IllegalArgumentException if the timeout value is negative.\n      */\n-    public final void setDeliveryUpdateTimeout(final long deliveryUpdateTimeout) {\n-        if (deliveryUpdateTimeout < 0) {\n+    public final void setSendMessageToDeviceTimeout(final long sendMessageToDeviceTimeout) {\n+        if (sendMessageToDeviceTimeout < 0) {\n             throw new IllegalArgumentException(\"timeout value must be >= 0\");\n         }\n-        this.deliveryUpdateTimeout = deliveryUpdateTimeout;\n+        this.sendMessageToDeviceTimeout = sendMessageToDeviceTimeout;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwODcxOA==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r407908718", "bodyText": "A check is needed here whether the timeout has already occurred, skipping the delivery update handling below in that case.", "author": "calohmn", "createdAt": "2020-04-14T07:01:24Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java", "diffHunk": "@@ -892,7 +892,20 @@ protected void onCommandReceived(final TenantObject tenantObject, final ProtonSe\n         }\n \n         // TODO time out waiting for disposition update\n+        final Long timerId = vertx.setTimer(getConfig().getDeliveryUpdateTimeout(), tid -> {\n+            log.debug(\"waiting for delivery update timed out after \" + getConfig().getDeliveryUpdateTimeout() + \" ms\");\n+            final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                    \"timeout waiting for delivery update\");\n+            closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+            // timeout expired -> release command\n+            commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+            commandContext.release();\n+        });\n+\n         sender.send(msg, delivery -> {\n+            // disposition received -> cancel timer\n+            vertx.cancelTimer(timerId);\n+\n             // release the command message when the device either", "originalCommit": "b8f1152fd80454488cfc6ccada580b55ec58d215", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\nindex bd0a0706d..ad91f1aca 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n\n@@ -891,54 +892,66 @@ public final class VertxBasedAmqpProtocolAdapter extends AbstractProtocolAdapter\n             MessageHelper.addDeviceId(msg, command.getOriginalDeviceId());\n         }\n \n-        // TODO time out waiting for disposition update\n-        final Long timerId = vertx.setTimer(getConfig().getDeliveryUpdateTimeout(), tid -> {\n-            log.debug(\"waiting for delivery update timed out after \" + getConfig().getDeliveryUpdateTimeout() + \" ms\");\n-            final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n-                    \"timeout waiting for delivery update\");\n-            closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n-            // timeout expired -> release command\n-            commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n-            commandContext.release();\n+        final AtomicBoolean isCommandSettled = new AtomicBoolean(false);\n+\n+        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null :\n+            vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n+            log.debug(\"waiting for delivery update timed out after \" + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n+            if (isCommandSettled.compareAndSet(false, true)) {\n+                final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                        \"timeout waiting for delivery update\");\n+                closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+                // timeout expired -> release command\n+                commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+                commandContext.release();\n+            } else {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            }\n         });\n \n         sender.send(msg, delivery -> {\n-            // disposition received -> cancel timer\n-            vertx.cancelTimer(timerId);\n-\n-            // release the command message when the device either\n-            // rejects or does not settle the command request message.\n-            final DeliveryState remoteState = delivery.getRemoteState();\n-            ProcessingOutcome outcome = null;\n-            if (delivery.remotelySettled()) {\n-                commandContext.disposition(remoteState);\n-                if (Accepted.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.FORWARDED;\n-                } else if (Rejected.class.isInstance(remoteState)) {\n-                    outcome = ProcessingOutcome.UNPROCESSABLE;\n-                } else if (Released.class.isInstance(remoteState)) {\n+\n+            if (timerId != null) {\n+                // disposition received -> cancel timer\n+                vertx.cancelTimer(timerId);\n+            }\n+            if (!isCommandSettled.compareAndSet(false, true)) {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            } else {\n+                // release the command message when the device either\n+                // rejects or does not settle the command request message.\n+                final DeliveryState remoteState = delivery.getRemoteState();\n+                ProcessingOutcome outcome = null;\n+                if (delivery.remotelySettled()) {\n+                    commandContext.disposition(remoteState);\n+                    if (Accepted.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.FORWARDED;\n+                    } else if (Rejected.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNPROCESSABLE;\n+                    } else if (Released.class.isInstance(remoteState)) {\n+                        outcome = ProcessingOutcome.UNDELIVERABLE;\n+                    } else if (Modified.class.isInstance(remoteState)) {\n+                        final Modified modified = (Modified) remoteState;\n+                        outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n+                    }\n+                } else {\n+                    log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n+                            remoteState);\n+                    final Map<String, Object> logItems = new HashMap<>(2);\n+                    logItems.put(Fields.EVENT, \"device did not settle command\");\n+                    logItems.put(\"remote state\", remoteState);\n+                    commandContext.getCurrentSpan().log(logItems);\n+                    commandContext.release();\n                     outcome = ProcessingOutcome.UNDELIVERABLE;\n-                } else if (Modified.class.isInstance(remoteState)) {\n-                    final Modified modified = (Modified) remoteState;\n-                    outcome = modified.getUndeliverableHere() ? ProcessingOutcome.UNPROCESSABLE : ProcessingOutcome.UNDELIVERABLE;\n                 }\n-            } else {\n-                log.debug(\"device did not settle command message [command: {}, remote state: {}]\", command.getName(),\n-                        remoteState);\n-                final Map<String, Object> logItems = new HashMap<>(2);\n-                logItems.put(Fields.EVENT, \"device did not settle command\");\n-                logItems.put(\"remote state\", remoteState);\n-                commandContext.getCurrentSpan().log(logItems);\n-                commandContext.release();\n-                outcome = ProcessingOutcome.UNDELIVERABLE;\n+                metrics.reportCommand(\n+                        command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                        command.getTenant(),\n+                        tenantObject,\n+                        outcome,\n+                        command.getPayloadSize(),\n+                        getMicrometerSample(commandContext));\n             }\n-            metrics.reportCommand(\n-                    command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n-                    command.getTenant(),\n-                    tenantObject,\n-                    outcome,\n-                    command.getPayloadSize(),\n-                    getMicrometerSample(commandContext));\n         });\n \n         final Map<String, Object> items = new HashMap<>(4);\n"}}, {"oid": "235b32f6b2520a92cfa443e175713679a3cd6b53", "url": "https://github.com/eclipse/hono/commit/235b32f6b2520a92cfa443e175713679a3cd6b53", "message": "minor update\n\nSigned-off-by: Alfusainey Jallow <alf.jallow@gmail.com>", "committedDate": "2020-04-15T02:00:03Z", "type": "commit"}, {"oid": "235b32f6b2520a92cfa443e175713679a3cd6b53", "url": "https://github.com/eclipse/hono/commit/235b32f6b2520a92cfa443e175713679a3cd6b53", "message": "minor update\n\nSigned-off-by: Alfusainey Jallow <alf.jallow@gmail.com>", "committedDate": "2020-04-15T02:00:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1NzM3Mw==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408757373", "bodyText": "\"is closed\"", "author": "calohmn", "createdAt": "2020-04-15T11:01:10Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java", "diffHunk": "@@ -137,4 +143,30 @@ public final void setIdleTimeout(final int timeout) {\n     public final int getIdleTimeout() {\n         return this.idleTimeout;\n     }\n+\n+    /**\n+     * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n+     * device is close.", "originalCommit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8d64d6d410158fa7a274df18b528ec1dd1a20f4e", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\nindex 305ebaba8..cf551d47a 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n\n@@ -146,9 +146,9 @@ public class AmqpAdapterProperties extends ProtocolAdapterProperties {\n \n     /**\n      * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n-     * device is close.\n+     * device is closed.\n      * <p>\n-     * The default value of this property is {@link #sendMessageToDeviceTimeout}.\n+     * The default value of this property is {@link #DEFAULT_SEND_MESSAGE_TO_DEVICE_TIMEOUT}.\n      * \n      * @return The wait time in milliseconds.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1ODE0OQ==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408758149", "bodyText": "The link should probably go to DEFAULT_SEND_MESSAGE_TO_DEVICE_TIMEOUT.", "author": "calohmn", "createdAt": "2020-04-15T11:02:34Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java", "diffHunk": "@@ -137,4 +143,30 @@ public final void setIdleTimeout(final int timeout) {\n     public final int getIdleTimeout() {\n         return this.idleTimeout;\n     }\n+\n+    /**\n+     * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n+     * device is close.\n+     * <p>\n+     * The default value of this property is {@link #sendMessageToDeviceTimeout}.", "originalCommit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8d64d6d410158fa7a274df18b528ec1dd1a20f4e", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\nindex 305ebaba8..cf551d47a 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/AmqpAdapterProperties.java\n\n@@ -146,9 +146,9 @@ public class AmqpAdapterProperties extends ProtocolAdapterProperties {\n \n     /**\n      * Gets the time to wait for a delivery update from a device before the AMQP sender link to the\n-     * device is close.\n+     * device is closed.\n      * <p>\n-     * The default value of this property is {@link #sendMessageToDeviceTimeout}.\n+     * The default value of this property is {@link #DEFAULT_SEND_MESSAGE_TO_DEVICE_TIMEOUT}.\n      * \n      * @return The wait time in milliseconds.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc1OTI3OQ==", "url": "https://github.com/eclipse/hono/pull/1894#discussion_r408759279", "bodyText": "Can you run the code-formatter here? I think the code will be better readable then.", "author": "calohmn", "createdAt": "2020-04-15T11:04:45Z", "path": "adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java", "diffHunk": "@@ -891,42 +892,68 @@ protected void onCommandReceived(final TenantObject tenantObject, final ProtonSe\n             MessageHelper.addDeviceId(msg, command.getOriginalDeviceId());\n         }\n \n-        // TODO time out waiting for disposition update\n+        final AtomicBoolean isCommandSettled = new AtomicBoolean(false);\n+\n+        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null :\n+            vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n+            log.debug(\"waiting for delivery update timed out after \" + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n+            if (isCommandSettled.compareAndSet(false, true)) {\n+                final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                        \"timeout waiting for delivery update\");\n+                closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+                // timeout expired -> release command\n+                commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+                commandContext.release();\n+            } else {\n+                log.trace(\"command is already settled and downstream application notified\");\n+            }\n+        });", "originalCommit": "235b32f6b2520a92cfa443e175713679a3cd6b53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8d64d6d410158fa7a274df18b528ec1dd1a20f4e", "chunk": "diff --git a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\nindex ad91f1aca..b9dc25ac8 100644\n--- a/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n+++ b/adapters/amqp-vertx/src/main/java/org/eclipse/hono/adapter/amqp/impl/VertxBasedAmqpProtocolAdapter.java\n\n@@ -894,20 +894,21 @@ public final class VertxBasedAmqpProtocolAdapter extends AbstractProtocolAdapter\n \n         final AtomicBoolean isCommandSettled = new AtomicBoolean(false);\n \n-        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null :\n-            vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n-            log.debug(\"waiting for delivery update timed out after \" + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n-            if (isCommandSettled.compareAndSet(false, true)) {\n-                final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n-                        \"timeout waiting for delivery update\");\n-                closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n-                // timeout expired -> release command\n-                commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n-                commandContext.release();\n-            } else {\n-                log.trace(\"command is already settled and downstream application notified\");\n-            }\n-        });\n+        final Long timerId = getConfig().getSendMessageToDeviceTimeout() < 1 ? null\n+                : vertx.setTimer(getConfig().getSendMessageToDeviceTimeout(), tid -> {\n+                    log.debug(\"waiting for delivery update timed out after \"\n+                            + getConfig().getSendMessageToDeviceTimeout() + \" ms\");\n+                    if (isCommandSettled.compareAndSet(false, true)) {\n+                        final Exception ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,\n+                                \"timeout waiting for delivery update\");\n+                        closeLinkWithError(sender, ex, commandContext.getCurrentSpan());\n+                        // timeout expired -> release command\n+                        commandContext.getCurrentSpan().log(\"timeout waiting for delivery update from device\");\n+                        commandContext.release();\n+                    } else {\n+                        log.trace(\"command is already settled and downstream application notified\");\n+                    }\n+                });\n \n         sender.send(msg, delivery -> {\n \n"}}, {"oid": "8d64d6d410158fa7a274df18b528ec1dd1a20f4e", "url": "https://github.com/eclipse/hono/commit/8d64d6d410158fa7a274df18b528ec1dd1a20f4e", "message": "format timer handling + minor grammer fix according to feedback\n\nSigned-off-by: Alfusainey Jallow <alf.jallow@gmail.com>", "committedDate": "2020-04-15T11:53:22Z", "type": "commit"}]}