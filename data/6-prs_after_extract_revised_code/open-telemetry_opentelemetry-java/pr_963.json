{"pr_number": 963, "pr_title": "Prototype for JFR events using Context interceptor", "pr_createdAt": "2020-03-04T21:12:27Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/963", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5MzI3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401793274", "bodyText": "javadoc, please", "author": "jkwatson", "createdAt": "2020-04-01T17:39:25Z", "path": "contrib/jfr_events/src/main/java/io/grpc/override/AbstractSimpleContextStorageListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.override;\n+\n+import io.grpc.Context;\n+\n+public abstract class AbstractSimpleContextStorageListener implements ContextStorageListener {", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/grpc/override/AbstractSimpleContextStorageListener.java b/contrib/jfr_events/src/main/java/io/grpc/override/AbstractSimpleContextStorageListener.java\nindex 0b8809639..f9ff0dacb 100644\n--- a/contrib/jfr_events/src/main/java/io/grpc/override/AbstractSimpleContextStorageListener.java\n+++ b/contrib/jfr_events/src/main/java/io/grpc/override/AbstractSimpleContextStorageListener.java\n\n@@ -17,19 +17,29 @@\n package io.grpc.override;\n \n import io.grpc.Context;\n+import javax.annotation.Nullable;\n \n+/**\n+ * Simple storage listener abstract class that where all attached and detached calls go to\n+ * contextUpdated.\n+ */\n public abstract class AbstractSimpleContextStorageListener implements ContextStorageListener {\n \n   @Override\n-  public void attached(Context oldContext, Context newContext) {\n-    contextUpdated(oldContext, newContext);\n+  public void attached(Context toDetach, Context toRestore) {\n+    contextUpdated(toDetach, toRestore);\n   }\n \n   @Override\n-  public void detached(Context oldContext, Context newContext) {\n-    contextUpdated(oldContext, newContext);\n+  public void detached(Context toDetach, @Nullable Context toRestore) {\n+    contextUpdated(toDetach, toRestore);\n   }\n \n-  /** Method that is called every Context update. */\n-  public abstract void contextUpdated(Context oldContext, Context newContext);\n+  /**\n+   * Called on every context change.\n+   *\n+   * @param toDetach old context to be detached\n+   * @param toRestore new context to add\n+   */\n+  public abstract void contextUpdated(Context toDetach, @Nullable Context toRestore);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NzQ2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401797465", "bodyText": "javadoc, please", "author": "jkwatson", "createdAt": "2020-04-01T17:46:38Z", "path": "contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.grpc.Context;\n+import io.grpc.override.AbstractSimpleContextStorageListener;\n+import io.grpc.override.ContextStorageListener;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.unsafe.ContextUtils;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+public class JfrContextStorageListener implements ContextStorageListener.Provider {", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\nindex f76f7ccbf..e9b6f4a2f 100644\n--- a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\n+++ b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\n\n@@ -16,19 +16,19 @@\n \n package io.opentelemetry.contrib.jfr;\n \n-import static java.util.Objects.nonNull;\n-\n import io.grpc.Context;\n-import io.grpc.override.AbstractSimpleContextStorageListener;\n import io.grpc.override.ContextStorageListener;\n-import io.opentelemetry.trace.SpanContext;\n-import io.opentelemetry.trace.unsafe.ContextUtils;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.TracingContextUtils;\n import java.util.ArrayDeque;\n import java.util.Deque;\n+import javax.annotation.Nullable;\n \n+/** Context listener that creates JFR events for when a Scope for a Span is active. */\n public class JfrContextStorageListener implements ContextStorageListener.Provider {\n \n-  private final ThreadLocal<Deque<ScopeEvent>> tlEventStack =\n+  // Need to be able to track multiple scopes to correctly commit the JFR events on Scope close.\n+  private static final ThreadLocal<Deque<ScopeEvent>> threadLocalEventStack =\n       new ThreadLocal<>() {\n         @Override\n         protected Deque<ScopeEvent> initialValue() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5OTQ5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401799494", "bodyText": "would prefer not abbreviating here. Change to threadLocalEventStack", "author": "jkwatson", "createdAt": "2020-04-01T17:49:53Z", "path": "contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.grpc.Context;\n+import io.grpc.override.AbstractSimpleContextStorageListener;\n+import io.grpc.override.ContextStorageListener;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.unsafe.ContextUtils;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+public class JfrContextStorageListener implements ContextStorageListener.Provider {\n+\n+  private final ThreadLocal<Deque<ScopeEvent>> tlEventStack =", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\nindex f76f7ccbf..e9b6f4a2f 100644\n--- a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\n+++ b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListener.java\n\n@@ -16,19 +16,19 @@\n \n package io.opentelemetry.contrib.jfr;\n \n-import static java.util.Objects.nonNull;\n-\n import io.grpc.Context;\n-import io.grpc.override.AbstractSimpleContextStorageListener;\n import io.grpc.override.ContextStorageListener;\n-import io.opentelemetry.trace.SpanContext;\n-import io.opentelemetry.trace.unsafe.ContextUtils;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.TracingContextUtils;\n import java.util.ArrayDeque;\n import java.util.Deque;\n+import javax.annotation.Nullable;\n \n+/** Context listener that creates JFR events for when a Scope for a Span is active. */\n public class JfrContextStorageListener implements ContextStorageListener.Provider {\n \n-  private final ThreadLocal<Deque<ScopeEvent>> tlEventStack =\n+  // Need to be able to track multiple scopes to correctly commit the JFR events on Scope close.\n+  private static final ThreadLocal<Deque<ScopeEvent>> threadLocalEventStack =\n       new ThreadLocal<>() {\n         @Override\n         protected Deque<ScopeEvent> initialValue() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDE5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401800197", "bodyText": "javadoc, and what's with this name? What makes it \"new\"?", "author": "jkwatson", "createdAt": "2020-04-01T17:51:07Z", "path": "contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListenerNew.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.jfr;\n+\n+import io.grpc.Context;\n+import io.grpc.override.ContextStorageListener;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.unsafe.ContextUtils;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+public class JfrContextStorageListenerNew implements ContextStorageListener.Provider {", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4ODIxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r426088214", "bodyText": "Did some updates to Bogdan's code handling context to make implementation cleaner. Deleted the old one and only keeping the new one (and renamed)", "author": "sfriberg", "createdAt": "2020-05-15T23:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListenerNew.java b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListenerNew.java\ndeleted file mode 100644\nindex 1d7df2249..000000000\n--- a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrContextStorageListenerNew.java\n+++ /dev/null\n\n@@ -1,54 +0,0 @@\n-/*\n- * Copyright 2020, OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.contrib.jfr;\n-\n-import io.grpc.Context;\n-import io.grpc.override.ContextStorageListener;\n-import io.opentelemetry.trace.SpanContext;\n-import io.opentelemetry.trace.unsafe.ContextUtils;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-\n-public class JfrContextStorageListenerNew implements ContextStorageListener.Provider {\n-\n-  private static final ThreadLocal<Deque<ScopeEvent>> tlStack =\n-      new ThreadLocal<>() {\n-        @Override\n-        protected Deque<ScopeEvent> initialValue() {\n-          return new ArrayDeque<>();\n-        }\n-      };\n-\n-  @Override\n-  public ContextStorageListener create() {\n-    return new ContextStorageListener() {\n-\n-      @Override\n-      public void attached(Context oldContext, Context newContext) {\n-        SpanContext newSpanContext = ContextUtils.getValue(newContext).getContext();\n-        ScopeEvent event = new ScopeEvent(newSpanContext);\n-        event.begin();\n-        tlStack.get().push(event);\n-      }\n-\n-      @Override\n-      public void detached(Context oldContext, Context newContext) {\n-        tlStack.get().pop().commit();\n-      }\n-    };\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDI5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401800299", "bodyText": "javadoc", "author": "jkwatson", "createdAt": "2020-04-01T17:51:19Z", "path": "contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class JfrSpanProcessor implements SpanProcessor {", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrSpanProcessor.java b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrSpanProcessor.java\nindex a39a47c66..b42663e9f 100644\n--- a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrSpanProcessor.java\n+++ b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/JfrSpanProcessor.java\n\n@@ -16,16 +16,22 @@\n \n package io.opentelemetry.contrib.jfr;\n \n-import static java.util.Objects.nonNull;\n-\n import io.opentelemetry.sdk.trace.ReadableSpan;\n import io.opentelemetry.sdk.trace.SpanProcessor;\n import io.opentelemetry.trace.SpanContext;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n \n+/**\n+ * Span processor to create new JFR events for the Span as they are started, and commit on end.\n+ *\n+ * <p>NOTE: Processor must be running synchronously to ensure that duration is correctly captured.\n+ *\n+ * @author sfriberg\n+ */\n public class JfrSpanProcessor implements SpanProcessor {\n \n+  // Need to keep a state of all SpanEvents to be able to close them on end.\n   private final Map<SpanContext, SpanEvent> spanEvents = new ConcurrentHashMap<>();\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMTEwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r401801103", "bodyText": "should this be public? With the JFR streaming APIs is this going to be handed directly to the stream listeners?", "author": "jkwatson", "createdAt": "2020-04-01T17:52:37Z", "path": "contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/ScopeEvent.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.jfr;\n+\n+import io.opentelemetry.trace.SpanContext;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"io.opentelemetry.context.Scope\")\n+@Label(\"Scope\")\n+@Category(\"Open Telemetry Tracing\")\n+@Description(\n+    \"Open Telemetry trace event corresponding to the span currently \"\n+        + \"in scope/active on this thread.\")\n+class ScopeEvent extends Event {", "originalCommit": "7713df40715a577d0b6179799963c14f84ea1a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4ODM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r426088368", "bodyText": "Haven't done much with the JFR stream, but doubt you will get the actual event class and rather get a generic event type that you can look up name and fields on?", "author": "sfriberg", "createdAt": "2020-05-15T23:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMTEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "dc470f01fb7b7290b4de4c660fd663022170716f", "chunk": "diff --git a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/ScopeEvent.java b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/ScopeEvent.java\nindex 4030aee9e..07614bd7f 100644\n--- a/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/ScopeEvent.java\n+++ b/contrib/jfr_events/src/main/java/io/opentelemetry/contrib/jfr/ScopeEvent.java\n\n@@ -16,6 +16,7 @@\n \n package io.opentelemetry.contrib.jfr;\n \n+import io.opentelemetry.trace.Span;\n import io.opentelemetry.trace.SpanContext;\n import jdk.jfr.Category;\n import jdk.jfr.Description;\n"}}, {"oid": "dc470f01fb7b7290b4de4c660fd663022170716f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dc470f01fb7b7290b4de4c660fd663022170716f", "message": "Fix CR comments and fix issues after master merge", "committedDate": "2020-05-15T23:36:36Z", "type": "forcePushed"}, {"oid": "61ca3d935f8ac5efd03e1acb269a62423d7f4e08", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/61ca3d935f8ac5efd03e1acb269a62423d7f4e08", "message": "Rewritten for new context implementation", "committedDate": "2020-10-22T18:10:49Z", "type": "forcePushed"}, {"oid": "f5a1cb7c805a17c2289518538afc8e0a139d84fd", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f5a1cb7c805a17c2289518538afc8e0a139d84fd", "message": "Rewritten for new context implementation\n\nSigned-off-by: Staffan Friberg <sfriberg@kth.se>", "committedDate": "2020-10-22T18:39:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4OTA4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r510389087", "bodyText": "@jkwatson is this how I should do things to wrap the an existing ContextStorage?\nWhat would be the best way to have this provider detected and enabled as a wrapper when JAR is added on the classpath? Or should it be done through some configuration/code instead?", "author": "sfriberg", "createdAt": "2020-10-22T18:59:46Z", "path": "sdk_extensions/jfr_events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.ContextStorage;\n+import io.opentelemetry.context.ContextStorageProvider;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+\n+public class JfrContextStorageProvider implements ContextStorageProvider {\n+\n+  @Override\n+  public ContextStorage get() {\n+    ContextStorage parentStorage = ContextStorage.get();", "originalCommit": "7b7b70bdff625e8e1a410cdbaa4be4e7dc44125d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNTU2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r510405568", "bodyText": "hmm. I don't know if this is right. I don't think you want to return a new storage for each call, but the same storage. Take a look at the GrpcContextStorageProvider and BraveContextStorageProvider for examples. @anuraaga is definitely the expert here, if you have questions after looking at them.", "author": "jkwatson", "createdAt": "2020-10-22T19:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4OTA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzExOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r510477118", "bodyText": "thanks, will check them. I just quickly looked at the example that was in ContextStorage which was basically done this way", "author": "sfriberg", "createdAt": "2020-10-22T21:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4OTA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d871d2710092d1722dc543ad35729df952445730", "chunk": "diff --git a/sdk_extensions/jfr_events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageProvider.java b/sdk_extensions/jfr_events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageProvider.java\nindex f3f65869b..b4f1f38ac 100644\n--- a/sdk_extensions/jfr_events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageProvider.java\n+++ b/sdk_extensions/jfr_events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageProvider.java\n\n@@ -2,7 +2,6 @@\n  * Copyright The OpenTelemetry Authors\n  * SPDX-License-Identifier: Apache-2.0\n  */\n-\n package io.opentelemetry.sdk.extension.jfr;\n \n import io.opentelemetry.context.Context;\n"}}, {"oid": "d871d2710092d1722dc543ad35729df952445730", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d871d2710092d1722dc543ad35729df952445730", "message": "rewrite", "committedDate": "2020-10-23T15:46:07Z", "type": "forcePushed"}, {"oid": "f4ff9f9606c403d662b869b47374f0b055c5713b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f4ff9f9606c403d662b869b47374f0b055c5713b", "message": "Use new ContextStorageWrapper capabilities", "committedDate": "2020-11-13T23:22:01Z", "type": "forcePushed"}, {"oid": "2ec9749f2035011dc83d08ffe648a967d07cda47", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2ec9749f2035011dc83d08ffe648a967d07cda47", "message": "Rewritten for new context implementation\n\nSigned-off-by: Staffan Friberg <sfriberg@kth.se>", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "f67d52f6820b050a54b3d538c99f22489b859842", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f67d52f6820b050a54b3d538c99f22489b859842", "message": "remove nb file", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "b0b71f1f23410837f7b332c2eacb7c28bdfc779b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b0b71f1f23410837f7b332c2eacb7c28bdfc779b", "message": "animalsniffer", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "52e1a4250bca9c3c4bc3b4e30557d16f10a6f167", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/52e1a4250bca9c3c4bc3b4e30557d16f10a6f167", "message": "spotless", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "3c8f01755a2e9f1c4a94871702718ac93c36852a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3c8f01755a2e9f1c4a94871702718ac93c36852a", "message": "rewrite", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "d01fdc306b32656fac2e4531d035ff6380b00a02", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d01fdc306b32656fac2e4531d035ff6380b00a02", "message": "Use new ContextStorageWrapper capabilities", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "81a0357f2fc0ba553a2ea0257b5193251911a822", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/81a0357f2fc0ba553a2ea0257b5193251911a822", "message": "work-around JDK bug", "committedDate": "2020-11-23T20:47:41Z", "type": "commit"}, {"oid": "146c7ea0a7d328c192fad79fd40685bafeb231ae", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/146c7ea0a7d328c192fad79fd40685bafeb231ae", "message": "update junit", "committedDate": "2020-11-23T20:58:52Z", "type": "commit"}, {"oid": "146c7ea0a7d328c192fad79fd40685bafeb231ae", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/146c7ea0a7d328c192fad79fd40685bafeb231ae", "message": "update junit", "committedDate": "2020-11-23T20:58:52Z", "type": "forcePushed"}, {"oid": "84f9815138a4e3d98d47151454fe4102eb3aa14e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/84f9815138a4e3d98d47151454fe4102eb3aa14e", "message": "update readme", "committedDate": "2020-11-23T21:17:51Z", "type": "commit"}, {"oid": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/94da981b7eb63c7eced9d2a62f41efab528dc84f", "message": "Update build script", "committedDate": "2020-11-23T21:26:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTQ4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529195482", "bodyText": "Does this class need to be public?", "author": "anuraaga", "createdAt": "2020-11-24T04:31:21Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.ContextStorage;\n+import io.opentelemetry.context.Scope;\n+\n+public class JfrContextStorageWrapper implements ContextStorage {", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4OTk1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529589950", "bodyText": "yes, since it needs to be possible to register for any user.\nContextStorage.addWrapper(JfrContextStorageWrapper::new);", "author": "sfriberg", "createdAt": "2020-11-24T14:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\nindex 2f34022cc..8754259f1 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\n\n@@ -24,7 +24,9 @@ public class JfrContextStorageWrapper implements ContextStorage {\n     ScopeEvent event = new ScopeEvent(Span.fromContext(toAttach).getSpanContext());\n     event.begin();\n     return () -> {\n-      event.commit();\n+      if (event.shouldCommit()) {\n+        event.commit();\n+      }\n       scope.close();\n     };\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTc4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529195789", "bodyText": "What happens if the event is never committed? Is there a way to detect it in JFR? Then it looks like it could be a nice scope debugging mechanism.", "author": "anuraaga", "createdAt": "2020-11-24T04:32:16Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.context.ContextStorage;\n+import io.opentelemetry.context.Scope;\n+\n+public class JfrContextStorageWrapper implements ContextStorage {\n+\n+  private final ContextStorage wrapped;\n+\n+  public JfrContextStorageWrapper(ContextStorage wrapped) {\n+    this.wrapped = wrapped;\n+  }\n+\n+  @Override\n+  public Scope attach(Context toAttach) {\n+    Scope scope = wrapped.attach(toAttach);\n+    ScopeEvent event = new ScopeEvent(Span.fromContext(toAttach).getSpanContext());\n+    event.begin();\n+    return () -> {\n+      event.commit();", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5Mjk5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529592994", "bodyText": "No way to detect, it basically is just GC:ed never to be seen or heard from again :).", "author": "sfriberg", "createdAt": "2020-11-24T14:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NTc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\nindex 2f34022cc..8754259f1 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrContextStorageWrapper.java\n\n@@ -24,7 +24,9 @@ public class JfrContextStorageWrapper implements ContextStorage {\n     ScopeEvent event = new ScopeEvent(Span.fromContext(toAttach).getSpanContext());\n     event.begin();\n     return () -> {\n-      event.commit();\n+      if (event.shouldCommit()) {\n+        event.commit();\n+      }\n       scope.close();\n     };\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjA2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529196068", "bodyText": "I'm not sure what this comment is referring to (span processors are always synchronous I guess). Maybe we don't need it? Otherwise if you can clarify what I'm missing would be great :)", "author": "anuraaga", "createdAt": "2020-11-24T04:33:10Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.ReadWriteSpan;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Span processor to create new JFR events for the Span as they are started, and commit on end.\n+ *\n+ * <p>NOTE: JfrSpanProcessor must be running synchronously to ensure that duration is correctly", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMjIyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529632220", "bodyText": "We have the https://github.com/open-telemetry/opentelemetry-java/tree/master/sdk-extensions/async-processor which could batch things etc. so that the timing for the of JFR event which is handled in the processor would diverge from the timing of the Span itself.", "author": "sfriberg", "createdAt": "2020-11-24T15:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1NjUwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529656502", "bodyText": "I see - I forgot about that and think many readers would get more confusion than clarity. If we keep a message, making it more generic might make sense - \"JfrSpanProcessor measures the timing of events, so it doesn't make sense to wrap it with any other SpanProcessor which may affect timings. When possible, register it first before any other processors to allow best measurements.\" Maybe something like that?", "author": "anuraaga", "createdAt": "2020-11-24T15:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NjA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\nindex 25f129e65..657228908 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n\n@@ -7,14 +7,17 @@ package io.opentelemetry.sdk.extension.jfr;\n \n import static java.util.Objects.nonNull;\n \n+import com.google.common.collect.MapMaker;\n import io.opentelemetry.api.trace.SpanContext;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.sdk.common.CompletableResultCode;\n import io.opentelemetry.sdk.trace.ReadWriteSpan;\n import io.opentelemetry.sdk.trace.ReadableSpan;\n import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n \n /**\n  * Span processor to create new JFR events for the Span as they are started, and commit on end.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NzI5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529197290", "bodyText": "Should we use weak keys for this? It's bad for tracing if a bug means spans are never ended and leaked, but this would cause an actual memory leak I think.", "author": "anuraaga", "createdAt": "2020-11-24T04:37:16Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.ReadWriteSpan;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Span processor to create new JFR events for the Span as they are started, and commit on end.\n+ *\n+ * <p>NOTE: JfrSpanProcessor must be running synchronously to ensure that duration is correctly\n+ * captured.\n+ */\n+public class JfrSpanProcessor implements SpanProcessor {\n+\n+  private final Map<SpanContext, SpanEvent> spanEvents = new ConcurrentHashMap<>();", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NzQzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529197434", "bodyText": "By the way I've been thinking of shading in https://github.com/raphw/weak-lock-free/blob/master/src/main/java/com/blogspot/mydailyjava/weaklockfree/WeakConcurrentMap.java for our use for a different Context-related use case, if that'll help I can prioritize it :)", "author": "anuraaga", "createdAt": "2020-11-24T04:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NzI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxODUzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529618530", "bodyText": "Good catch. By using Guava there should be no need to shade another class", "author": "sfriberg", "createdAt": "2020-11-24T15:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NzI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\nindex 25f129e65..657228908 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n\n@@ -7,14 +7,17 @@ package io.opentelemetry.sdk.extension.jfr;\n \n import static java.util.Objects.nonNull;\n \n+import com.google.common.collect.MapMaker;\n import io.opentelemetry.api.trace.SpanContext;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.sdk.common.CompletableResultCode;\n import io.opentelemetry.sdk.trace.ReadWriteSpan;\n import io.opentelemetry.sdk.trace.ReadableSpan;\n import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n \n /**\n  * Span processor to create new JFR events for the Span as they are started, and commit on end.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjAwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529206001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (nonNull(event) && event.shouldCommit()) {\n          \n          \n            \n                if (event != null && event.shouldCommit()) {", "author": "anuraaga", "createdAt": "2020-11-24T05:08:09Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.ReadWriteSpan;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Span processor to create new JFR events for the Span as they are started, and commit on end.\n+ *\n+ * <p>NOTE: JfrSpanProcessor must be running synchronously to ensure that duration is correctly\n+ * captured.\n+ */\n+public class JfrSpanProcessor implements SpanProcessor {\n+\n+  private final Map<SpanContext, SpanEvent> spanEvents = new ConcurrentHashMap<>();\n+\n+  @Override\n+  public void onStart(Context parentContext, ReadWriteSpan span) {\n+    if (span.getSpanContext().isValid()) {\n+      SpanEvent event = new SpanEvent(span.toSpanData());\n+      event.begin();\n+      spanEvents.put(span.getSpanContext(), event);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan rs) {\n+    SpanEvent event = spanEvents.remove(rs.getSpanContext());\n+    if (nonNull(event) && event.shouldCommit()) {", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMDQ3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529610473", "bodyText": "nonNull is part of the standard JDK API any reason not to use it?", "author": "sfriberg", "createdAt": "2020-11-24T14:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNjE3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529626174", "bodyText": "Yeah there's a perfectly good literal in Java so we should stick to using it where possible (nonNull was added in 1.8, presumably to aid with streams but I don't consider it idiomatic for normal code).", "author": "anuraaga", "createdAt": "2020-11-24T15:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\nindex 25f129e65..657228908 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n\n@@ -7,14 +7,17 @@ package io.opentelemetry.sdk.extension.jfr;\n \n import static java.util.Objects.nonNull;\n \n+import com.google.common.collect.MapMaker;\n import io.opentelemetry.api.trace.SpanContext;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.sdk.common.CompletableResultCode;\n import io.opentelemetry.sdk.trace.ReadWriteSpan;\n import io.opentelemetry.sdk.trace.ReadableSpan;\n import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n \n /**\n  * Span processor to create new JFR events for the Span as they are started, and commit on end.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529206795", "bodyText": "Hmm - not really for this PR but this doesn't seem like how shutdown is supposed to work. For example, we would probably stop accepting spans, and wait for spans to end naturally in an exporter when it is shutting down I think. But can't think of any improvement here so just writing for reference.", "author": "anuraaga", "createdAt": "2020-11-24T05:10:55Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import static java.util.Objects.nonNull;\n+\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.context.Context;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.ReadWriteSpan;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Span processor to create new JFR events for the Span as they are started, and commit on end.\n+ *\n+ * <p>NOTE: JfrSpanProcessor must be running synchronously to ensure that duration is correctly\n+ * captured.\n+ */\n+public class JfrSpanProcessor implements SpanProcessor {\n+\n+  private final Map<SpanContext, SpanEvent> spanEvents = new ConcurrentHashMap<>();\n+\n+  @Override\n+  public void onStart(Context parentContext, ReadWriteSpan span) {\n+    if (span.getSpanContext().isValid()) {\n+      SpanEvent event = new SpanEvent(span.toSpanData());\n+      event.begin();\n+      spanEvents.put(span.getSpanContext(), event);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan rs) {\n+    SpanEvent event = spanEvents.remove(rs.getSpanContext());\n+    if (nonNull(event) && event.shouldCommit()) {\n+      event.commit();\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public CompletableResultCode shutdown() {\n+    spanEvents.forEach((id, event) -> event.commit());", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNzAyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529617026", "bodyText": "Probably would be good to improve the JavaDoc, not sure what 'not yet processed means'.\n\n\nProcesses all span events that have not yet been processed and closes used resources.\n\n\nSimilar for forceFlush\n\n\nProcesses all span events that have not yet been processed.\n\n\nSound more like this would be for finished spans rather than span that hasn't been closed yet.\nForce flush would commit any ready events, as would shutdown but that would also clear up all resources, which I would take as drop all non-completed spans. Once something is shutdown I wouldn't expect things to continue to flow, unless the CompleteResultCode would wait for all spans, but that would potentially be indefinite.\nwill remove the event.commit part as that feels wrong here", "author": "sfriberg", "createdAt": "2020-11-24T15:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2MTYyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529661624", "bodyText": "Agree we may need to improve docs, or otherwise expectations (maybe spec) for this (again not related to this PR). I would generally call this at the beginning of a graceful shutdown and expect pending requests, and exported spans, to complete before termination. /cc @jkwatson @Oberon00", "author": "anuraaga", "createdAt": "2020-11-24T15:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3Njg4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529676885", "bodyText": "what does \"pending requests\" mean here? Un-ended spans? Or just spans that were in the process of being sent off to exporters?", "author": "jkwatson", "createdAt": "2020-11-24T15:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\nindex 25f129e65..657228908 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n\n@@ -7,14 +7,17 @@ package io.opentelemetry.sdk.extension.jfr;\n \n import static java.util.Objects.nonNull;\n \n+import com.google.common.collect.MapMaker;\n import io.opentelemetry.api.trace.SpanContext;\n import io.opentelemetry.context.Context;\n import io.opentelemetry.sdk.common.CompletableResultCode;\n import io.opentelemetry.sdk.trace.ReadWriteSpan;\n import io.opentelemetry.sdk.trace.ReadableSpan;\n import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n \n /**\n  * Span processor to create new JFR events for the Span as they are started, and commit on end.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNjk0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529206943", "bodyText": "Does @Label work on methods? Very small nit, but tend to like putting annotations on public API where possible. Alternatively, if we annotate the fields maybe we don't need the getters.", "author": "anuraaga", "createdAt": "2020-11-24T05:11:23Z", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/ScopeEvent.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import io.opentelemetry.api.trace.SpanContext;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"io.opentelemetry.context.Scope\")\n+@Label(\"Scope\")\n+@Category(\"Open Telemetry Tracing\")\n+@Description(\n+    \"Open Telemetry trace event corresponding to the span currently \"\n+        + \"in scope/active on this thread.\")\n+class ScopeEvent extends Event {\n+\n+  @Label(\"Trace Id\")", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/ScopeEvent.java b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/ScopeEvent.java\nindex 6dc03d86d..cae0e8dc2 100644\n--- a/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/ScopeEvent.java\n+++ b/sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/ScopeEvent.java\n\n@@ -20,10 +20,7 @@ import jdk.jfr.Name;\n         + \"in scope/active on this thread.\")\n class ScopeEvent extends Event {\n \n-  @Label(\"Trace Id\")\n   private final String traceId;\n-\n-  @Label(\"Span Id\")\n   private final String spanId;\n \n   ScopeEvent(SpanContext spanContext) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwNzMyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/963#discussion_r529207324", "bodyText": "Since jupiter, let's remove public from class / methods", "author": "anuraaga", "createdAt": "2020-11-24T05:12:58Z", "path": "sdk-extensions/jfr-events/src/test/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessorTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.extension.jfr;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.Tracer;\n+import io.opentelemetry.context.ContextStorage;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import org.junit.jupiter.api.Test;\n+\n+public class JfrSpanProcessorTest {", "originalCommit": "94da981b7eb63c7eced9d2a62f41efab528dc84f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "chunk": "diff --git a/sdk-extensions/jfr-events/src/test/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessorTest.java b/sdk-extensions/jfr-events/src/test/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessorTest.java\nindex 9b25551c0..feeb34528 100644\n--- a/sdk-extensions/jfr-events/src/test/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessorTest.java\n+++ b/sdk-extensions/jfr-events/src/test/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessorTest.java\n\n@@ -22,7 +22,7 @@ import jdk.jfr.consumer.RecordedEvent;\n import jdk.jfr.consumer.RecordingFile;\n import org.junit.jupiter.api.Test;\n \n-public class JfrSpanProcessorTest {\n+class JfrSpanProcessorTest {\n \n   private static final String OPERATION_NAME = \"Test Span\";\n   private final Tracer tracer;\n"}}, {"oid": "9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9e6856945df1fb6d18ea287bd1fa82a9c2f931a9", "message": "PR comments", "committedDate": "2020-11-24T15:34:17Z", "type": "commit"}, {"oid": "97e8001e8d29b1605ef03be49542f4c5e38682f0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/97e8001e8d29b1605ef03be49542f4c5e38682f0", "message": "Update sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-11-24T15:36:59Z", "type": "commit"}, {"oid": "e5a88a766a5656acbbe8e39b6f4195855dfd78b9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e5a88a766a5656acbbe8e39b6f4195855dfd78b9", "message": "Update JfrSpanProcessor.java", "committedDate": "2020-11-24T15:37:30Z", "type": "commit"}, {"oid": "7eb048d1b08f3343e9c466a63e0b26eb50cb8a09", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7eb048d1b08f3343e9c466a63e0b26eb50cb8a09", "message": "Update comment", "committedDate": "2020-11-24T15:56:05Z", "type": "commit"}]}