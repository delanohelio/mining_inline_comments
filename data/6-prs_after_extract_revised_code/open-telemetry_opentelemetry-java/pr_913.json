{"pr_number": 913, "pr_title": "Block Disruptor until flush is performed", "pr_createdAt": "2020-02-24T11:49:53Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/913", "timeline": [{"oid": "b5a85778e8cce2359ddb024f01d5eabb38ecf9aa", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b5a85778e8cce2359ddb024f01d5eabb38ecf9aa", "message": "Block disruptor until flush is performed", "committedDate": "2020-02-24T11:39:12Z", "type": "commit"}, {"oid": "91b510f24c2d4565130f45bfd0bd10665463f013", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/91b510f24c2d4565130f45bfd0bd10665463f013", "message": "Fix format", "committedDate": "2020-02-24T11:45:48Z", "type": "commit"}, {"oid": "19c3375296dcf00ccebf170e8d7997e8264a2783", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/19c3375296dcf00ccebf170e8d7997e8264a2783", "message": "Fix test", "committedDate": "2020-02-24T11:49:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTk3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383221975", "bodyText": "@bogdandrutu is this correct?", "author": "thisthat", "createdAt": "2020-02-24T11:51:22Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -190,11 +247,13 @@ public void onEvent(DisruptorEvent event, long sequence, boolean endOfBatch) {\n             spanProcessor.onEnd(readableSpan);\n             break;\n           case ON_SHUTDOWN:\n+            spanProcessor.forceFlush();", "originalCommit": "19c3375296dcf00ccebf170e8d7997e8264a2783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MzkyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383443925", "bodyText": "It depends where do you want to have the shutdown logic implemented. If we just enqueue a shutdown type event then this is correct, if we do call explicitly shutdown from the thread that does queuing then this is not needed.", "author": "bogdandrutu", "createdAt": "2020-02-24T18:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 4324c59d0..48e38f479 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -258,7 +230,7 @@ final class DisruptorEventQueue {\n         }\n       } finally {\n         // Remove the reference to the previous entry to allow the memory to be gc'ed.\n-        event.setEntry(null, null);\n+        event.setEntry(null, null, null);\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNDk5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383424995", "bodyText": "I would change the order EventType, ReadableSpan, CDL", "author": "bogdandrutu", "createdAt": "2020-02-24T18:04:39Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -51,6 +52,20 @@ public void translateTo(\n               event.setEntry(arg0, arg1);\n             }\n           };\n+  private static final EventTranslatorThreeArg<\n+          DisruptorEvent, ReadableSpan, EventType, CountDownLatch>\n+      TRANSLATOR_THREE_ARG =\n+          new EventTranslatorThreeArg<DisruptorEvent, ReadableSpan, EventType, CountDownLatch>() {\n+            @Override\n+            public void translateTo(\n+                DisruptorEvent event,\n+                long sequence,\n+                ReadableSpan arg0,\n+                EventType arg1,\n+                CountDownLatch arg2) {\n+              event.setEntry(arg0, arg1, arg2);", "originalCommit": "19c3375296dcf00ccebf170e8d7997e8264a2783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4OTY0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383789642", "bodyText": "I kept the same order of the TWO_ARG event. Should we change also that one?\nI also prefer having EventType as first argument", "author": "thisthat", "createdAt": "2020-02-25T10:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNDM5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r384104399", "bodyText": "So then let's change to have EventType as the first argument then. I would change all calls :)", "author": "bogdandrutu", "createdAt": "2020-02-25T20:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNDk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 4324c59d0..48e38f479 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -43,25 +42,16 @@ import javax.annotation.concurrent.ThreadSafe;\n final class DisruptorEventQueue {\n   private static final Logger logger = Logger.getLogger(DisruptorEventQueue.class.getName());\n   private static final String WORKER_THREAD_NAME = \"DisruptorEventQueue_WorkerThread\";\n-  private static final EventTranslatorTwoArg<DisruptorEvent, ReadableSpan, EventType>\n-      TRANSLATOR_TWO_ARG =\n-          new EventTranslatorTwoArg<DisruptorEvent, ReadableSpan, EventType>() {\n-            @Override\n-            public void translateTo(\n-                DisruptorEvent event, long sequence, ReadableSpan arg0, EventType arg1) {\n-              event.setEntry(arg0, arg1);\n-            }\n-          };\n   private static final EventTranslatorThreeArg<\n-          DisruptorEvent, ReadableSpan, EventType, CountDownLatch>\n+          DisruptorEvent, EventType, ReadableSpan, CountDownLatch>\n       TRANSLATOR_THREE_ARG =\n-          new EventTranslatorThreeArg<DisruptorEvent, ReadableSpan, EventType, CountDownLatch>() {\n+          new EventTranslatorThreeArg<DisruptorEvent, EventType, ReadableSpan, CountDownLatch>() {\n             @Override\n             public void translateTo(\n                 DisruptorEvent event,\n                 long sequence,\n-                ReadableSpan arg0,\n-                EventType arg1,\n+                EventType arg0,\n+                ReadableSpan arg1,\n                 CountDownLatch arg2) {\n               event.setEntry(arg0, arg1, arg2);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyNTgzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383425836", "bodyText": "1 - represents the number of consumer threads, maybe make it a constant?", "author": "bogdandrutu", "createdAt": "2020-02-24T18:06:23Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -138,19 +170,38 @@ void forceFlush() {\n       if (isShutdown) {\n         return;\n       }\n-      enqueue(null, EventType.ON_FORCE_FLUSH);\n+      CountDownLatch flushLatch = new CountDownLatch(1);", "originalCommit": "19c3375296dcf00ccebf170e8d7997e8264a2783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "763fc82978f434e150dd929b819e0b82c6c29e7b", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 4324c59d0..aa69d7151 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -170,7 +167,7 @@ final class DisruptorEventQueue {\n       if (isShutdown) {\n         return;\n       }\n-      CountDownLatch flushLatch = new CountDownLatch(1);\n+      CountDownLatch flushLatch = new CountDownLatch(FLUSH_WAITER_COUNTER);\n       enqueue(null, EventType.ON_FORCE_FLUSH, flushLatch);\n       try {\n         flushLatch.await();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTIwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383441205", "bodyText": "Can shutdown be implemented as?\n\nSet shutdown variable;\nFlush and wait;\nCall shutdown for the SpanProcessor next;", "author": "bogdandrutu", "createdAt": "2020-02-24T18:37:30Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -138,19 +170,38 @@ void forceFlush() {\n       if (isShutdown) {\n         return;\n       }\n-      enqueue(null, EventType.ON_FORCE_FLUSH);\n+      CountDownLatch flushLatch = new CountDownLatch(1);\n+      enqueue(null, EventType.ON_FORCE_FLUSH, flushLatch);\n+      try {\n+        flushLatch.await();\n+      } catch (InterruptedException e) {\n+        // Preserve the interruption.\n+        Thread.currentThread().interrupt();\n+        logger.warning(\"Thread interrupted, shutdown may not finished.\");\n+      }", "originalCommit": "19c3375296dcf00ccebf170e8d7997e8264a2783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMDQxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383810418", "bodyText": "Since the SpanProcessor is only visible in the DisruptorEventHandler class, we need to:\n\nSet shutdown variable\nEnqueue a Shutdown event\nWait for Shutdown event to be processed", "author": "thisthat", "createdAt": "2020-02-25T11:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTIwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "763fc82978f434e150dd929b819e0b82c6c29e7b", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 4324c59d0..aa69d7151 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -170,7 +167,7 @@ final class DisruptorEventQueue {\n       if (isShutdown) {\n         return;\n       }\n-      CountDownLatch flushLatch = new CountDownLatch(1);\n+      CountDownLatch flushLatch = new CountDownLatch(FLUSH_WAITER_COUNTER);\n       enqueue(null, EventType.ON_FORCE_FLUSH, flushLatch);\n       try {\n         flushLatch.await();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjYxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r383442612", "bodyText": "Why do we have duplicate enqueue method?", "author": "bogdandrutu", "createdAt": "2020-02-24T18:40:17Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -109,6 +124,23 @@ void enqueue(ReadableSpan readableSpan, EventType eventType) {\n     }\n   }\n \n+  // Enqueues an event on the {@link DisruptorEventQueue}.\n+  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }\n+      return;\n+    }\n+\n+    if (blocking) {\n+      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, readableSpan, eventType, flushLatch);\n+    } else {\n+      // TODO: Record metrics if element not added.\n+      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, readableSpan, eventType, flushLatch);\n+    }\n+  }", "originalCommit": "19c3375296dcf00ccebf170e8d7997e8264a2783", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "763fc82978f434e150dd929b819e0b82c6c29e7b", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 4324c59d0..aa69d7151 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -107,21 +109,8 @@ final class DisruptorEventQueue {\n     this.blocking = blocking;\n   }\n \n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    if (isShutdown) {\n-      if (!loggedShutdownMessage.getAndSet(true)) {\n-        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n-      }\n-      return;\n-    }\n-\n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_TWO_ARG, readableSpan, eventType);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_TWO_ARG, readableSpan, eventType);\n-    }\n+  void enqueue(ReadableSpan readableSpan, EventType eventType){\n+    enqueue(readableSpan, eventType, null);\n   }\n \n   // Enqueues an event on the {@link DisruptorEventQueue}.\n"}}, {"oid": "763fc82978f434e150dd929b819e0b82c6c29e7b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/763fc82978f434e150dd929b819e0b82c6c29e7b", "message": "Single enqueue method", "committedDate": "2020-02-25T10:41:43Z", "type": "commit"}, {"oid": "549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "message": "General cleanup", "committedDate": "2020-02-25T10:58:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r384103368", "bodyText": "Now that we pass a CDL for flush I think we should do the same for the shutdown one and not have a special case for that one.", "author": "bogdandrutu", "createdAt": "2020-02-25T20:18:25Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -92,8 +99,12 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n   void enqueue(ReadableSpan readableSpan, EventType eventType) {\n+    enqueue(readableSpan, eventType, null);\n+  }\n+\n+  // Enqueues an event on the {@link DisruptorEventQueue}.\n+  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {", "originalCommit": "549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5Nzk2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r384297960", "bodyText": "Make sense!", "author": "thisthat", "createdAt": "2020-02-26T06:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "b735e2ff3d0f8749fd08b84c5427c7305f16c362", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 48e38f479..4780706b7 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -94,7 +97,7 @@ final class DisruptorEventQueue {\n             new ThreadFactoryWithName(WORKER_THREAD_NAME),\n             ProducerType.MULTI,\n             waitStrategy);\n-    disruptor.handleEventsWith(new DisruptorEventHandler(spanProcessor, shutdownCounter));\n+    disruptor.handleEventsWith(new DisruptorEventHandler(spanProcessor));\n     this.ringBuffer = disruptor.start();\n     this.blocking = blocking;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzgxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/913#discussion_r384103817", "bodyText": "s/FLUSH_WAITER_COUNTER/NUM_CONSUMERS?", "author": "bogdandrutu", "createdAt": "2020-02-25T20:19:22Z", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -67,6 +72,8 @@ public DisruptorEvent newInstance() {\n   private volatile boolean isShutdown = false;\n   private final boolean blocking;\n \n+  private static final byte FLUSH_WAITER_COUNTER = 1;", "originalCommit": "549760d411f56879b6b53fb09cf4ebeacbb7e0e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b735e2ff3d0f8749fd08b84c5427c7305f16c362", "chunk": "diff --git a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\nindex 48e38f479..4780706b7 100644\n--- a/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n+++ b/sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java\n\n@@ -68,11 +68,14 @@ final class DisruptorEventQueue {\n   private final Disruptor<DisruptorEvent> disruptor;\n   private final RingBuffer<DisruptorEvent> ringBuffer;\n   private final AtomicBoolean loggedShutdownMessage = new AtomicBoolean(false);\n-  private final CountDownLatch shutdownCounter = new CountDownLatch(1); // only one processor.\n   private volatile boolean isShutdown = false;\n   private final boolean blocking;\n \n-  private static final byte FLUSH_WAITER_COUNTER = 1;\n+  /**\n+   * Only one consumer for {@link DisruptorEventQueue#forceFlush()} and {@link\n+   * DisruptorEventQueue#shutdown()} invocation.\n+   */\n+  private static final byte NUM_CONSUMERS = 1;\n \n   enum EventType {\n     ON_START,\n"}}, {"oid": "b735e2ff3d0f8749fd08b84c5427c7305f16c362", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b735e2ff3d0f8749fd08b84c5427c7305f16c362", "message": "Refactor shutdown/forceFlush", "committedDate": "2020-02-26T06:53:05Z", "type": "commit"}]}