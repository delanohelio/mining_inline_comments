{"pr_number": 1106, "pr_title": "First cut at a Zipkin Span Exporter", "pr_createdAt": "2020-04-13T22:02:04Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797339", "bodyText": "UI and dependency linking checks for errors. This is a simplified change, but check first of there's already a tag named \"error\"?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n          \n          \n            \n                    spanBuilder.putTag(\"error\", status.getCanonicalCode().toString());", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:34:31Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNjk0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408236949", "bodyText": "I'm not sure I understand what you mean. Are you suggesting that if the user had already added an \"error\" tag, that we don't try to overwrite it?", "author": "jkwatson", "createdAt": "2020-04-14T15:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5OTc3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408499779", "bodyText": "yep that was what I meant", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3ODgxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408978818", "bodyText": "gotcha", "author": "jkwatson", "createdAt": "2020-04-15T16:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMjAxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409232014", "bodyText": "this is now implemented.", "author": "jkwatson", "createdAt": "2020-04-16T01:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797521", "bodyText": "Is there a chance this can be an HTTP code? or is this RPC only?", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:35:10Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NzM5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408247393", "bodyText": "the statuses are defined here:  \n  \n    \n      opentelemetry-java/api/src/main/java/io/opentelemetry/trace/Status.java\n    \n    \n         Line 38\n      in\n      c24e4a9\n    \n    \n    \n    \n\n        \n          \n           public final class Status {", "author": "jkwatson", "createdAt": "2020-04-14T15:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDA4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500080", "bodyText": "this appears RPC status, can you confirm HTTP is not mapped to this?", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTc4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525788", "bodyText": "Can confirm that HTTP is definitely mapped to these:  https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md#status", "author": "jkwatson", "createdAt": "2020-04-15T01:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5Nzg5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797895", "bodyText": "producer/consumer also? https://github.com/open-telemetry/opentelemetry-python/blob/master/ext/opentelemetry-ext-zipkin/src/opentelemetry/ext/zipkin/__init__.py#L80", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:36:37Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @javax.annotation.Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODE5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407798198", "bodyText": "is there any chance endTimestamp doesn't exist?", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:37:36Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyOTkzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408229930", "bodyText": "Currently, no. Only finished spans get sent to the exporters. There are a few issues/suggestions about consuming incomplete spans, but right now, it's a non-null field.", "author": "jkwatson", "createdAt": "2020-04-14T15:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODE5OA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5OTQ3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407799470", "bodyText": "Not quite sure yet if the below revision is useful or not.. We will have a RPC tag shortly, but I'm not sure this usage here is RPC only. Anyway here's a better link for HTTP\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n          \n          \n            \n              // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:42:12Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407800168", "bodyText": "one of these should test the whole thing works I think, ex using https://github.com/openzipkin/zipkin/tree/master/zipkin-junit", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:44:36Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinExporterConfiguration}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinExporterConfigurationTest {", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NzY3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408267672", "bodyText": "I'd like to have that as a separate PR. I'll add an issue to track it.", "author": "jkwatson", "createdAt": "2020-04-14T16:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408270368", "bodyText": "#1110", "author": "jkwatson", "createdAt": "2020-04-14T16:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java b/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java\ndeleted file mode 100644\nindex 0e643b876..000000000\n--- a/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java\n+++ /dev/null\n\n@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2020, OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.exporters.zipkin;\n-\n-import static com.google.common.truth.Truth.assertThat;\n-\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n-import org.mockito.junit.MockitoJUnitRunner;\n-import zipkin2.codec.SpanBytesEncoder;\n-import zipkin2.reporter.Sender;\n-\n-/** Unit tests for {@link ZipkinExporterConfiguration}. */\n-@RunWith(MockitoJUnitRunner.class)\n-public class ZipkinExporterConfigurationTest {\n-\n-  private static final String SERVICE = \"service\";\n-  private static final String END_POINT = \"endpoint\";\n-\n-  @Mock private Sender mockSender;\n-\n-  @Rule public final ExpectedException thrown = ExpectedException.none();\n-\n-  @Test\n-  public void updateConfigs() {\n-    ZipkinExporterConfiguration configuration =\n-        ZipkinExporterConfiguration.builder()\n-            .setServiceName(SERVICE)\n-            .setSender(mockSender)\n-            .setV2Url(END_POINT)\n-            .setEncoder(SpanBytesEncoder.PROTO3)\n-            .build();\n-    assertThat(configuration.getServiceName()).isEqualTo(SERVICE);\n-    assertThat(configuration.getV2Url()).isEqualTo(END_POINT);\n-    assertThat(configuration.getSender()).isEqualTo(mockSender);\n-    assertThat(configuration.getEncoder()).isEqualTo(SpanBytesEncoder.PROTO3);\n-  }\n-\n-  @Test\n-  public void needEitherUrlOrSender() {\n-    ZipkinExporterConfiguration.Builder builder =\n-        ZipkinExporterConfiguration.builder().setServiceName(SERVICE);\n-    thrown.expect(IllegalArgumentException.class);\n-    builder.build();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMTQ5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407801496", "bodyText": "add a test where there is no kind? I didn't see one..", "author": "codefromthecrypt", "createdAt": "2020-04-14T00:49:12Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))", "originalCommit": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMDk0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408230945", "bodyText": "kind is required in OpenTelemetry spans; you can't even create one without a kind set.", "author": "jkwatson", "createdAt": "2020-04-14T15:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMTQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex fce6ac3d1..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -41,12 +41,7 @@ import zipkin2.Span;\n import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n   // The naming follows Zipkin convention. As an example see:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDkzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500930", "bodyText": "probably not correct? either 0.3 (if adding in a patch) or the next releasable version?\nsame everywhere", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:51:21Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTg0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408935841", "bodyText": "yep, fixing to be 0.4.0 everywhere", "author": "jkwatson", "createdAt": "2020-04-15T15:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDkzMA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b85304e73..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408501324", "bodyText": "I'm guessing the project has rules that require filler javadoc statements? These don't seem to add value otherwise, except for maybe the version once it is correct. If you want better descriptions let me know.", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:52:40Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNDkwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408524902", "bodyText": "This was directly copied from the opencensus exporter. Better descriptions would be great!", "author": "jkwatson", "createdAt": "2020-04-15T01:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjIzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408936235", "bodyText": "And, I agree with you on the usefulness of much of the javadoc.", "author": "jkwatson", "createdAt": "2020-04-15T15:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMjg5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409202897", "bodyText": "in that case, is it within the rules of the project to remove them? Less fluff to write, and we can focus on single-sentence explanations. lemme know and then I'll respond accordingly.", "author": "codefromthecrypt", "createdAt": "2020-04-16T00:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMjMzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409232333", "bodyText": "I'll poke at this tomorrow. I'm not 100% sure of the rules, myself.", "author": "jkwatson", "createdAt": "2020-04-16T01:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwODM4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410408386", "bodyText": "Looks like javadoc is not required, but if it's there, it needs to be complete and well-formed.", "author": "jkwatson", "createdAt": "2020-04-17T18:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTI5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410521291", "bodyText": "ok I'll give you some text in another review round", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b85304e73..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408502079", "bodyText": "description is good here.. @return this. is silly and I'm guessing slave to javadoc or checkstyle?\nI would add @see for the actual methods on the type being built and do most of the describing there.", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:54:59Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNDk5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408524993", "bodyText": "again, direct copy from the opencensus version. :)", "author": "jkwatson", "createdAt": "2020-04-15T01:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNjM0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410406344", "bodyText": "going to leave this as-is for now. Follow-on PRs to clean this up can be made, as desired.", "author": "jkwatson", "createdAt": "2020-04-17T18:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b85304e73..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjQyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408502421", "bodyText": "maybe just grep since before you finish this PR", "author": "codefromthecrypt", "createdAt": "2020-04-14T23:56:00Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setEncoder(SpanBytesEncoder encoder);\n+\n+    abstract String getV2Url();\n+\n+    @Nullable\n+    abstract Sender getSender();\n+\n+    abstract ZipkinExporterConfiguration autoBuild();\n+\n+    /**\n+     * Builds a {@link ZipkinExporterConfiguration}.\n+     *\n+     * @return a {@code ZipkinExporterConfiguration}.\n+     * @since 0.22", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTA3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525070", "bodyText": "yeah, I missed this one in my pass through.", "author": "jkwatson", "createdAt": "2020-04-15T01:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b85304e73..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408508225", "bodyText": "I'm almost certain we wouldn't add 'otel' as a tag as that would just require re-mapping it back later.\nAs far as I can tell, this is an RPC code, and more specifically gRPC.\nI don't think we would waste indexing on the one called code either. so we should pick one.\nLet's drop \"otel.status_code\" and rename \"otel.status_description\" to \"grpc.status_code\",\nas it seems to be the same value as what we tag today.\nEx. today grpc only tags \"error\" \"grpc.status_code\", ex \"grpc.status_code\" -> \"UNIMPLEMENTED\" (not a numerical tag)\nThis trades short term conflation with portability with existing search and indexing especially as I doubt\nmany RPC frameworks except grpc are integrated with otel at the moment.\nYou can add a better comment which is that we are tentatively re-using grpc until a final decision is made on rpc tags openzipkin/brave#999\nIt may also be worth mentioning in the README that while the \"error\" tag is a zipkin tag, \"grpc.status_code\" is tentative. Adding the best tentative choice is better than blocking this work or introducing a non-existent tag that will add burden to existing sites as many don't have means to re-map tags (never needed to).", "author": "codefromthecrypt", "createdAt": "2020-04-15T00:14:54Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525654", "bodyText": "This is definitely not just grpc. Here are the official mappings for http status codes:  https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md#status\n@trask can comment as to whether those are being faithfully followed in the auto-instrumentation project or not.\nWith the naming of the tags...I just copied these from the opencensus version, and replaced \"opencensus\" with \"otel\". Happy to make them whatever is appropriate.", "author": "jkwatson", "createdAt": "2020-04-15T01:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyOTExMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408529113", "bodyText": "if there's nothing besides grpc and http defined, then check for \"http.status_code\" first? if that's missing, assume it isn't and set to \"otel.status_description\" -> \"grpc.status_code\".", "author": "codefromthecrypt", "createdAt": "2020-04-15T01:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1MTQxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408551416", "bodyText": "re: auto-instrumentation - for instrumentation other than http and grpc we're only using Status.OK/Status.UNKNOWN (to mark success/failure). hmm, even for http and grpc instrumentation, we're only using Status.OK/Status.UNKNOWN, but that needs to be fixed (heading over there to file an issue now...)", "author": "trask", "createdAt": "2020-04-15T02:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4Mzc1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408983752", "bodyText": "ok, I took a stab at this, @adriancole . Feedback welcome. Assuming grpc feels weird to me, but you're the boss!", "author": "jkwatson", "createdAt": "2020-04-15T16:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMjQ5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409202495", "bodyText": "feeling weird is good. this is the tension that leads to better decisions later. please do let me know if you find anything besides grpc that uses this (besides the somewhat arbitrary lossy conversion of http status). meanwhile probably by month end we'll have an rpc tag and replace this.", "author": "codefromthecrypt", "createdAt": "2020-04-16T00:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMTIxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409231216", "bodyText": "I guess my \"weird feeling\" might be assuaged if we removed the g and just said rpc, but maybe that's splitting hairs a bit.", "author": "jkwatson", "createdAt": "2020-04-16T01:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzNTc0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409235749", "bodyText": "the issue I referenced will solve this probably before 0.4 or 0.5 here, just it is better to use a tag that exists today vs create one only to change it. don't worry.. I've the same opinion!", "author": "codefromthecrypt", "createdAt": "2020-04-16T01:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzNjQwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409236403", "bodyText": "in other words, we (OpenZipkin) should be able to settle the name, usage and content of the tag \"grpc.status_code\", just we owe ourselves to check this vs other RPC frameworks etc. I don't think this has been done here either, yet, so happy to share when that occurs.", "author": "codefromthecrypt", "createdAt": "2020-04-16T02:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczMjAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409732010", "bodyText": "the comment above these values no longer makes sense. Do you have a better one to use until it gets settled?", "author": "jkwatson", "createdAt": "2020-04-16T17:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNjAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410406036", "bodyText": "fixed per conversation below", "author": "jkwatson", "createdAt": "2020-04-17T18:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex cc34c2068..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,6 +19,7 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408508711", "bodyText": "usually I add an assert false or similar as this is a bug I think. especially in the same repo there should never be an escape from enum switch (to degree it happens outside is avoidable version skew)", "author": "codefromthecrypt", "createdAt": "2020-04-15T00:16:51Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNjMwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408526303", "bodyText": "Probably makes sense to at least add a log message that there was an unknown attribute value type. And, there are array valued types coming...not sure what zipkin wants for array-valued attributes.", "author": "jkwatson", "createdAt": "2020-04-15T01:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyODU1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408528558", "bodyText": "join on comma if you support array values.\nI wouldn't log or if anything log once if there's a bug here on unmatched (avoid tight loops of logging). assert will catch it ideally.", "author": "codefromthecrypt", "createdAt": "2020-04-15T01:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0Mzg1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408943854", "bodyText": "This project doesn't use java assert, so I don't want to do that. I'd also rather not have the export fail if a new type gets added without the exporter being updated. (like if someone updates their SDK version, but doesn't update their exporter version).", "author": "jkwatson", "createdAt": "2020-04-15T15:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMDgyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409200825", "bodyText": "up to you. FYI we do it all the time. running assertions in prod isn't usual. but I just wanted to express my opinion and thanks for that. something like a log-once seems fine!", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMTQwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409201400", "bodyText": "ps the reason we do it is if you don't, and only log, the build won't break when something new is added.. and typically logs are ignored. if you think of a better way to handle this case, let me know as that's the only reason we do it (to make sure someone doesn't have to remember all the things that need to be updated)", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMTY3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409231670", "bodyText": "hmmm. if we make sure to have a test that iterates over all the values of the type enum, then we can guarantee the build fails by just having it throw an exception. Since this is a part of the main project, it will fail the build. I'll give this a try tomorrow!", "author": "jkwatson", "createdAt": "2020-04-16T01:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxMzkxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409613910", "bodyText": "I think we have static checks enabled and you fail to compile if we miss a value, no need to have tests for all the values to catch this bug (it is good to have tests for all the values to ensure correctness, but not for this particular problem). Hope I am not wrong, can you give a try?", "author": "bogdandrutu", "createdAt": "2020-04-16T14:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxNDY2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409614662", "bodyText": "The problem comes when we add a new type, and users will use the API with the new type and an old exporter package. That's when we may have troubles.", "author": "bogdandrutu", "createdAt": "2020-04-16T14:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyODI1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409728252", "bodyText": "fair enough!", "author": "jkwatson", "createdAt": "2020-04-16T17:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczMDE5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409730192", "bodyText": "I think we have static checks enabled and you fail to compile if we miss a value, no need to have tests for all the values to catch this bug (it is good to have tests for all the values to ensure correctness, but not for this particular problem). Hope I am not wrong, can you give a try?\n\nConfirmed. errorprone catches this and fails the build if you're missing an enum in your switch branches.", "author": "jkwatson", "createdAt": "2020-04-16T17:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2OTIwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410269202", "bodyText": "We can simply use throw if you want. No need to use assert", "author": "bogdandrutu", "createdAt": "2020-04-17T14:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNTgzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410405838", "bodyText": "changed to throw an exception for now.", "author": "jkwatson", "createdAt": "2020-04-17T18:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex cc34c2068..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,6 +19,7 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408509072", "bodyText": "URLConnection doesn't need to close on shutdown. However, the builder method that sets sender could warn the caller (in javadoc) that they are responsible to close the sender (a better choice than us closing it randomly)\nEventhough the calls here are synchronous, most senders will have resources open like kafka connections.", "author": "codefromthecrypt", "createdAt": "2020-04-15T00:18:02Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyOTc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408529758", "bodyText": "you don't think that we should close the sender in the shutdown? Shutdown is only called when the exporter will no longer be used.", "author": "jkwatson", "createdAt": "2020-04-15T01:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzMzIwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408533206", "bodyText": "I've always been of the opinion of \"you open it, you close it\" so, if someone hands you a resource (they opened) you don't close it, as that's their job. Ex if in spring a closeable bean is managed where it is defined and would be odd to have something else close it randomly.\nif you do close it, then make sure that's known in the javadoc etc, so that it doesn't feel random and people can wrap if they don't want it closed.", "author": "codefromthecrypt", "createdAt": "2020-04-15T01:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408945498", "bodyText": "Sender doesn't appear to have a shutdown method, so I guess this is moot.  :)", "author": "jkwatson", "createdAt": "2020-04-15T15:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTk1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408945953", "bodyText": "oh derp. it has a close(). nm me.", "author": "jkwatson", "createdAt": "2020-04-15T15:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODM5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408948391", "bodyText": "It's a little tricky, since if you use the configuration option that creates a Sender in the background, then the user doesn't have control over the lifecycle. I'll change this to close the Sender and add javadoc to the configuration to let people know it'll happen.", "author": "jkwatson", "createdAt": "2020-04-15T15:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMTg5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409201891", "bodyText": "makes sense! you'd have to either do that or register a shutdown hook. I know we have one scenario somewhere where we do similar to what you said.", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex cc34c2068..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,6 +19,7 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDE2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408510168", "bodyText": "sorry if I am blind, but definitely add something for the Kind that coerces to null?", "author": "codefromthecrypt", "createdAt": "2020-04-15T00:21:43Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.sdk.trace.export.SpanExporter.ResultCode;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.Call;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinSpanExporterTest}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinSpanExporterTest {\n+\n+  @Mock private Sender mockSender;\n+  @Mock private SpanBytesEncoder mockEncoder;\n+  @Mock private Call<Void> mockZipkinCall;\n+\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(\"tweetiebird\");\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  @Test\n+  public void generateSpan_remoteParent() {\n+    SpanData data = buildStandardSpan().build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ServerKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.SERVER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ClientKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CLIENT).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CLIENT, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ConsumeKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CONSUMER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CONSUMER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ProducerKind() {", "originalCommit": "83424a74e17dc5e440f20ad1bed804298166ac77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1MjM3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408952371", "bodyText": "ah, on the outbound side. Looks like INTERNAL ends up with null.  will do!", "author": "jkwatson", "createdAt": "2020-04-15T15:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java b/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java\nindex 19e2af3e3..7b75712b5 100644\n--- a/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java\n+++ b/exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java\n\n@@ -17,6 +17,8 @@\n package io.opentelemetry.exporters.zipkin;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.isA;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0NDQ4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409944482", "bodyText": "@jkwatson PS I was assuming grpc \"only\" sets status vs adding a different tag also like \"rpc.status\" or \"grpc.status\" attribute per https://github.com/open-telemetry/opentelemetry-specification/blob/bfb060b23113ba9af492f8c63dd89ecfc500810b/specification/trace/semantic_conventions/rpc.md#status\nIn this case, I think the logic below can be simplified.. only when the mandatory \"rpc.service\" attribute exists, set \"grpc.status_code\" as we aren't likely to use the status values for any other reason.\nThe follow-up comment can refer to openzipkin/brave#999 which is likely to have the outcome of setting a tag like \"rpc.status\" (not yet decided) when the status is not OK. That is assuming there's no heuristic way to identify if the service in otel is grpc or not.", "author": "codefromthecrypt", "createdAt": "2020-04-17T01:42:54Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"grpc.status_code\";", "originalCommit": "adf694a04807b55b64c55b98f214c9b32a238dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNTcyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410405720", "bodyText": "cool. I think I've got it in the right shape now!", "author": "jkwatson", "createdAt": "2020-04-17T18:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0NDQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex 212758745..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,13 +19,13 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import io.opentelemetry.trace.Span.Kind;\n import io.opentelemetry.trace.Status;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.NetworkInterface;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTY4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410521688", "bodyText": "delete need to expose this as it is conditional anyway by marking package private (delete javadoc)", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:12:09Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjE5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522195", "bodyText": "delete need to expose this as it is conditional anyway by marking package private (delete javadoc)", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:14:55Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522328", "bodyText": "is this actually nullable? or would this just be UrlSender by default?", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:15:40Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzAzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523034", "bodyText": "you can delete the javadoc by making this package private..", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjcwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411536705", "bodyText": "agreed. This isn't actually nullable.", "author": "jkwatson", "createdAt": "2020-04-20T16:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDY3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411554677", "bodyText": "BUT, autovalue needs it to be marked as such so that the builder will let me check to see if it's been set. \ud83e\udd26", "author": "jkwatson", "createdAt": "2020-04-20T17:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjUzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522536", "bodyText": "From brave. (PS you will very likely end up needing localIP override. implicit lookups are a nice default, but users set this to the well-known-address sometimes.\nhttps://github.com/openzipkin/brave/blob/master/brave/src/main/java/brave/Tracing.java#L163\n    /**\n     * Label of the remote node in the service graph, such as \"favstar\". Avoid names with variables\n     * or unique identifiers embedded. Defaults to \"unknown\".\n     *\n     * <p>This is a primary label for trace lookup and aggregation, so it should be intuitive and\n     * consistent. Many use a name from service discovery.\n     */", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:17:30Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522924", "bodyText": "consider adding a static factory method to simplify this.\nex\n  /**\n   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n   * \n   * @param endpoint See {@link Builder#setEndpoint(String)}, ex. \"http://zipkinhost:9411/api/v2/spans\".\n   */\n  public static ZipkinExporterConfiguration create(String endpoint) {\n... newbuilder.endpoint().build()", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:19:47Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNTk3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410525972", "bodyText": "In fact.. if you do this, you can probably get out of the complex statements in the builder. remove the \"endpoint\" variant, and require anyone using the builder to supply their own sender and encoder. SOOO much simpler.", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1MDAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411650036", "bodyText": "would you have an overload for the serviceName, or just require people who want to set that to use the builder directly?", "author": "jkwatson", "createdAt": "2020-04-20T19:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411660049", "bodyText": "I tried this out, including the serviceName option. Let me know what you think.", "author": "jkwatson", "createdAt": "2020-04-20T20:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5MjAwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411792006", "bodyText": "I guess the local service name is still not a otel concept right?", "author": "codefromthecrypt", "createdAt": "2020-04-21T00:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNjk5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411806993", "bodyText": "I think(?) this is the service.name resource attribute: https://github.com/open-telemetry/opentelemetry-specification/tree/master/specification/resource/semantic_conventions#service", "author": "trask", "createdAt": "2020-04-21T01:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTA4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411815083", "bodyText": "If this is the same thing as the Resource service.name, then that is a property that is available to the exporter via the Resource attached to the SpanData instance. It's not generally something you configure at the exporter level, at least not from what I've seen so far.", "author": "jkwatson", "createdAt": "2020-04-21T02:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzA3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523075", "bodyText": "same delete the javadoc by package private", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:20:42Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzI5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523292", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .setV2Url(\"\")\n          \n          \n            \n                    .setV2Url(\"\") // trick auto-value so that we can check if either this or the sender are set at build time", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:22:07Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzU0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523547", "bodyText": "you should probably rename this as v2 url has more to do with the encoding (v1 can be passed!)\nalmost everything in the wild says \"endpoint\" rename to endpoint?\nfrom zipkin-reporter-java\n    /**\n     * No default. The POST URL for zipkin's <a href=\"https://zipkin.io/zipkin-api/#/\">v2 api</a>,\n     * usually \"http://zipkinhost:9411/api/v2/spans\"\n     */\n    // customizable so that users can re-map /api/v2/spans ex for browser-originated traces\n\nhttps://github.com/openzipkin/zipkin-reporter-java/blob/master/urlconnection/src/main/java/zipkin2/reporter/urlconnection/URLConnectionSender.java#L68", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:23:33Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzY3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n          \n          \n            \n                 * <p>At least one of {@code V2Url} or {@code Sender} needs to be specified. If both {@code", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:24:03Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDAyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524021", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n          \n          \n            \n                 * <p>At least one of {@code V2Url} or {@code Sender} needs to be specified. If both {@code", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:26:37Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDM4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524385", "bodyText": "Implements the client side of the span transport. Defaults to {@link UrlConnectionSender}.", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:29:08Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDY3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524678", "bodyText": "change to BytesEncoder<Span> as otherwise you'll break non-zipkin formats like https://github.com/openzipkin/zipkin-gcp/blob/master/sender-stackdriver/src/main/java/zipkin2/reporter/stackdriver/StackdriverEncoder.java\n(ack that they would make their own exporter, but anyway no need to narrow the type)", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:31:12Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this Builder instance\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setEncoder(SpanBytesEncoder encoder);", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return this Builder instance\n          \n          \n            \n                 * @return this Builder instance\n          \n          \n            \n                 * @see SpanBytesEncoder", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:31:29Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this Builder instance", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDg3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524873", "bodyText": "Controls the format used by the {@link Sender}. Defaults to  {@link SpanBytesEncoder#JSON_V2}", "author": "codefromthecrypt", "createdAt": "2020-04-18T00:32:32Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.", "originalCommit": "e4d315f47740d5a71e4ff49ad1184ca20f569e89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex b6c63561d..626886591 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -17,7 +17,7 @@\n package io.opentelemetry.exporters.zipkin;\n \n import com.google.auto.value.AutoValue;\n-import io.opentelemetry.internal.Utils;\n+import com.google.common.base.Preconditions;\n import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n import zipkin2.codec.SpanBytesEncoder;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412584488", "bodyText": "please don't add an empty endpoint", "author": "codefromthecrypt", "createdAt": "2020-04-22T00:34:09Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;", "originalCommit": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwODMzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412608339", "bodyText": "The zipkin API just sets null when you pass in an empty one. Are you saying that if we can't make an endpoint, we shouldn't send spans?", "author": "jkwatson", "createdAt": "2020-04-22T01:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjA2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412612065", "bodyText": "it is distracting to set an empty endpoint for reasons including what you mentioned. that's the main point. just call the endpoint builder when you have one?", "author": "codefromthecrypt", "createdAt": "2020-04-22T01:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjk2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412612961", "bodyText": "the longer answer is that it would be easy for this code to drift to adding more data into the span for no reason. For example, if you change codec later, it would likely serialize \"localEndpoint\": {} which is useless overhead, plus adding empty is already confusing.\nhope this makes sense.", "author": "codefromthecrypt", "createdAt": "2020-04-22T01:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex 08dd7873f..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,60 +19,76 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import io.opentelemetry.trace.Span.Kind;\n import io.opentelemetry.trace.Status;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nullable;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n-  // The naming follows Zipkin convention. For http see here:\n-  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n-  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n-  // Note: these 3 fields are non-private for testing\n-  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n-  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n-  static final String STATUS_ERROR = \"error\";\n-\n-  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n \n-  private final BytesEncoder<Span> encoder;\n+  private final SpanBytesEncoder encoder;\n   private final Sender sender;\n+  private final Endpoint localEndpoint;\n \n-  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n     this.encoder = encoder;\n     this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n   }\n \n-  static Span generateSpan(SpanData spanData) {\n-    Endpoint endpoint = EMPTY_ENDPOINT;\n-    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();\n-    AttributeValue serviceNameValue = resourceAttributes.get(\"service.name\");\n-    if (serviceNameValue != null) {\n-      endpoint = Endpoint.newBuilder().serviceName(serviceNameValue.getStringValue()).build();\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n     }\n+    return builder.build();\n+  }\n \n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n     long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n \n     long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTE2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412585162", "bodyText": "use \n  \n    \n      opentelemetry-java/sdk/src/main/java/io/opentelemetry/sdk/resources/ResourceConstants.java\n    \n    \n         Line 32\n      in\n      6330901\n    \n    \n    \n    \n\n        \n          \n           public static final String SERVICE_NAME = \"service.name\"; \n        \n    \n  \n\n?", "author": "codefromthecrypt", "createdAt": "2020-04-22T00:36:24Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();\n+    AttributeValue serviceNameValue = resourceAttributes.get(\"service.name\");", "originalCommit": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex 08dd7873f..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,60 +19,76 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import io.opentelemetry.trace.Span.Kind;\n import io.opentelemetry.trace.Status;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nullable;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n-  // The naming follows Zipkin convention. For http see here:\n-  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n-  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n-  // Note: these 3 fields are non-private for testing\n-  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n-  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n-  static final String STATUS_ERROR = \"error\";\n-\n-  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n \n-  private final BytesEncoder<Span> encoder;\n+  private final SpanBytesEncoder encoder;\n   private final Sender sender;\n+  private final Endpoint localEndpoint;\n \n-  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n     this.encoder = encoder;\n     this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n   }\n \n-  static Span generateSpan(SpanData spanData) {\n-    Endpoint endpoint = EMPTY_ENDPOINT;\n-    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();\n-    AttributeValue serviceNameValue = resourceAttributes.get(\"service.name\");\n-    if (serviceNameValue != null) {\n-      endpoint = Endpoint.newBuilder().serviceName(serviceNameValue.getStringValue()).build();\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n     }\n+    return builder.build();\n+  }\n \n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n     long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n \n     long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412587937", "bodyText": "I understand where this is coming from and the discussions around it, but I still haven't heard any reason to believe \"service.name\" would be set by default. I suspect that's why the jaeger export was written to have a gear for this. \n  \n    \n      opentelemetry-java/exporters/jaeger/src/test/java/io/opentelemetry/exporters/jaeger/JaegerIntegrationTest.java\n    \n    \n         Line 85\n      in\n      c32c776\n    \n    \n    \n    \n\n        \n          \n           .setServiceName(SERVICE_NAME) \n        \n    \n  \n\n\nRecall the main thing we've done recently is dodge a 2 arg factory method. To make data unqueryable is a more bitter pill than just deleting that discussion and having no factory methods. Basically if this is all about the single arg factory method, it really isn't worth it to cause damage.\nA different point.. the whole thing started about the choice between endpoint and a different sender. This is not a complex enough problem to make us want to damage the data model by removing something more important for. If it is, simply remove the endpoint arg to \"buy us\" a service name one.\nIf it isn't a problem to have three methods (one for service, one for endpoint shortcut and one for the sender that uses) do an overload? Ex we do similarly in our okhttp sender (also autovalue)\n    /**\n     * No default. The POST URL for zipkin's <a href=\"https://zipkin.io/zipkin-api/#/\">v2 api</a>,\n     * usually \"http://zipkinhost:9411/api/v2/spans\"\n     */\n    // customizable so that users can re-map /api/v2/spans ex for browser-originated traces\n    public Builder endpoint(String endpoint) {\n      if (endpoint == null) throw new NullPointerException(\"endpoint == null\");\n      HttpUrl parsed = HttpUrl.parse(endpoint);\n      if (parsed == null) throw new IllegalArgumentException(\"invalid post url: \" + endpoint);\n      return endpoint(parsed);\n    }\nThe reason I'm so concerned basically is I cannot see anything in this repo that sets this and we know lack thereof results in unqueryable and unaggregatable data. Using a dummy name which cannot be set at a level people are likely to control will result in an unfairly bad experience vs jaeger who have a setting. This is not worth waiting for complaints about (which likely would dump into zipkin's channel)\nRegardless, if we want to suggest to prioritize the \"service.name\", knowing we have a fallback, both should be in the README. When there's a normalized way to set the \"service.name\" in the span resource above this tier, both jaeger and zipkin exporters can get a README update.", "author": "codefromthecrypt", "createdAt": "2020-04-22T00:44:42Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "originalCommit": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5MDc2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412590769", "bodyText": "my first stab at writing that comment was crap.. hopefully my rewording above is more coherent (coffee is setting in)", "author": "codefromthecrypt", "createdAt": "2020-04-22T00:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMDMxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412610314", "bodyText": "The idea, as I understand it, is that the person configuring the SDK will add the Resource to the TracerProvider once, at startup. It's not code that would exist in the SDK itself, but written by the SDK user.\nI'm not sure about that jaeger exporter, and why it might have been written that way. My guess is that it predates the semantic convention of putting service.name in the Resource.\nI'll put an exporter-level serviceName back and have it be the fallback.", "author": "jkwatson", "createdAt": "2020-04-22T01:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzOTAwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412639008", "bodyText": "There is an issue to use the resource for that in Jaeger", "author": "bogdandrutu", "createdAt": "2020-04-22T03:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MDA0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412640043", "bodyText": "cool maybe link to that in a TODO. regardless it seems a fallback is prudent.", "author": "codefromthecrypt", "createdAt": "2020-04-22T03:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjQzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412646433", "bodyText": "#978", "author": "bogdandrutu", "createdAt": "2020-04-22T03:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0Njg1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412646853", "bodyText": "There are some concerns that you also pointed. We should resolve both exporters when we do it.", "author": "bogdandrutu", "createdAt": "2020-04-22T03:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1MTk1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413051956", "bodyText": "Also we have this defined in specs as well:\nopen-telemetry/opentelemetry-specification#472\n@adriancole may want to confirm that it is what you expect :). Thanks", "author": "bogdandrutu", "createdAt": "2020-04-22T14:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTUxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413095517", "bodyText": "ok, I restored the serviceName option, but have it be superceded by the service.name set in the Resource, if it's there. Phew.\nIf this is an ok approach for now, then let's get this bad boy merged and see if it works!", "author": "jkwatson", "createdAt": "2020-04-22T15:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\nindex 08dd7873f..5ec804c36 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\n@@ -19,60 +19,76 @@ package io.opentelemetry.exporters.zipkin;\n import static java.util.concurrent.TimeUnit.MICROSECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n \n+import com.google.common.annotations.VisibleForTesting;\n import io.opentelemetry.common.AttributeValue;\n import io.opentelemetry.common.AttributeValue.Type;\n import io.opentelemetry.sdk.trace.data.SpanData;\n import io.opentelemetry.sdk.trace.export.SpanExporter;\n import io.opentelemetry.trace.Span.Kind;\n import io.opentelemetry.trace.Status;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nullable;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n import zipkin2.reporter.Sender;\n \n-/**\n- * This class was based on the OpenCensus zipkin exporter code at\n- * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n- */\n final class ZipkinSpanExporter implements SpanExporter {\n-\n   private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n \n-  // The naming follows Zipkin convention. For http see here:\n-  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n-  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n-  // Note: these 3 fields are non-private for testing\n-  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n-  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n-  static final String STATUS_ERROR = \"error\";\n-\n-  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n \n-  private final BytesEncoder<Span> encoder;\n+  private final SpanBytesEncoder encoder;\n   private final Sender sender;\n+  private final Endpoint localEndpoint;\n \n-  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n     this.encoder = encoder;\n     this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n   }\n \n-  static Span generateSpan(SpanData spanData) {\n-    Endpoint endpoint = EMPTY_ENDPOINT;\n-    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();\n-    AttributeValue serviceNameValue = resourceAttributes.get(\"service.name\");\n-    if (serviceNameValue != null) {\n-      endpoint = Endpoint.newBuilder().serviceName(serviceNameValue.getStringValue()).build();\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n     }\n+    return builder.build();\n+  }\n \n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n     long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n \n     long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n"}}, {"oid": "5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5a72b688691d5fb6f60d7f913a1c4c528c92ea41", "message": "basic zipkin span exporter with some unit tests", "committedDate": "2020-04-22T21:39:06Z", "type": "commit"}, {"oid": "3b3dc967c89f7b636cacc4414a0a479df345833d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3b3dc967c89f7b636cacc4414a0a479df345833d", "message": "add tests for the configuration class, hook up a create method and clean up other unit tests", "committedDate": "2020-04-22T21:39:06Z", "type": "commit"}, {"oid": "cb4cf5806032f65476340e2c31bce66e7cab19cb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/cb4cf5806032f65476340e2c31bce66e7cab19cb", "message": "add a README", "committedDate": "2020-04-22T21:39:06Z", "type": "commit"}, {"oid": "c827f4bd6dd769c3b663547a06d0a40345a416b1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c827f4bd6dd769c3b663547a06d0a40345a416b1", "message": "Update exporters/zipkin/README.md\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "e6524712cd40d39bbe34bdedcbce76c7ad3b6c2b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e6524712cd40d39bbe34bdedcbce76c7ad3b6c2b", "message": "Update exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "dd891b4ed2e48751795d1ec3bd7c3dc51d863885", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dd891b4ed2e48751795d1ec3bd7c3dc51d863885", "message": "Update exporters/zipkin/README.md\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "935a0b6fcf41cdd6d0acd79474a073ed341f9b17", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/935a0b6fcf41cdd6d0acd79474a073ed341f9b17", "message": "apply PR review comments", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "0fdc6ef4b7c5dda67a902a8f7ad814b69bbe13ac", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0fdc6ef4b7c5dda67a902a8f7ad814b69bbe13ac", "message": "Update build.gradle\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "61131bbaaabb31ef131f986037decddf58b33599", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/61131bbaaabb31ef131f986037decddf58b33599", "message": "a little bit of cleanup from PR review", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "1a72b234229f000552a696c9bb5f2de6a1c6b43f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1a72b234229f000552a696c9bb5f2de6a1c6b43f", "message": "implement shutdown and provide javadoc about the closing of the Sender", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "b6a3c6f1faf862dd582986e370dcb856b94c5c50", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b6a3c6f1faf862dd582986e370dcb856b94c5c50", "message": "don't set attributes if they're already set.", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "baee0086a8c405156da81e6eff21565157ff25f5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/baee0086a8c405156da81e6eff21565157ff25f5", "message": "formatting", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "4a45183543da0a8b0d5ccfc3ff8957ed35f249d5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4a45183543da0a8b0d5ccfc3ff8957ed35f249d5", "message": "grpc tweaks, and an exception thrown", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "ab0f7aa9c912e36293ed89f76d082e6d6f46d7ce", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ab0f7aa9c912e36293ed89f76d082e6d6f46d7ce", "message": "Update the comment to be a little more accurate.", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "16f09076a26687872ce98fd323af12ae50afad0f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/16f09076a26687872ce98fd323af12ae50afad0f", "message": "formatting", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "b5ede7975c3dd74e87f8181f3a9c618973be8e79", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b5ede7975c3dd74e87f8181f3a9c618973be8e79", "message": "Update exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "86a4f464971d302834fec250de8fe9e177e38e62", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/86a4f464971d302834fec250de8fe9e177e38e62", "message": "Update exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\nCo-Authored-By: Adrian Cole <adriancole@users.noreply.github.com>", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "5e4416c573c10c4e76f7c4c0795408411285582f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5e4416c573c10c4e76f7c4c0795408411285582f", "message": "doc/naming cleanup", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "24b7d2a26ea937bfe8f4535c26ae897915a93e18", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/24b7d2a26ea937bfe8f4535c26ae897915a93e18", "message": "simplify the builder, provide two simple factory methods", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "0c04e5c43e247d343ead9ed559376b1744c1b1f3", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0c04e5c43e247d343ead9ed559376b1744c1b1f3", "message": "strip out the endpoint logic and instead get it from the Resource", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "ca8d565b07593e71758b9dd75407d21b50dff35c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ca8d565b07593e71758b9dd75407d21b50dff35c", "message": "formatting", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "b1a7c3799ac0a17a14098e5e87531ec549292ab9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b1a7c3799ac0a17a14098e5e87531ec549292ab9", "message": "restore the serviceName option, but keep the Resource-based override.", "committedDate": "2020-04-22T21:39:07Z", "type": "commit"}, {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8112b7a6dbe4cdb634c917da13facae524b7f207", "message": "update for changes from master.", "committedDate": "2020-04-22T21:57:12Z", "type": "commit"}, {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8112b7a6dbe4cdb634c917da13facae524b7f207", "message": "update for changes from master.", "committedDate": "2020-04-22T21:57:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413410821", "bodyText": "I really don't like factory methods like this personally as two string args can be easily permuted, but I don't feel like holding you up on another round as it isn't important enough and people can figure it out.", "author": "codefromthecrypt", "createdAt": "2020-04-22T23:54:11Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {", "originalCommit": "8112b7a6dbe4cdb634c917da13facae524b7f207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0MTU1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413441554", "bodyText": "So... no factory methods, or just the one with a single arg? I have no strong opinion either way.", "author": "jkwatson", "createdAt": "2020-04-23T01:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0NTMxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413445310", "bodyText": "because of \"service.name\" isn't in a crystal clear state, I think it is better to use the builder similar to how jaeger does, and fail if a fallback service name isn't given. this forces folks to think about this, for example, there's often an application name property somewhere they can reach even if they can't affect instrumentation to affect \"service.name\" They can be told that if you don't know one set \"unknown\" but I feel it is better to let them see the importance of it via making the property required.\nex \"unknown\" makes a almost useless aggregation which can be hard to hunt down. We use this because we used to use it. It is true there's a slight amount of value as you can see bugs where people didn't set a value in one place, and \"unknown\" is better for people to punt with vs making up new words for \"unknown\".\nAll that said, many wouldn't even know to set this unless told to via a required property. I think using required as a means to help users who know a better value set one from config, is a better optimization than what would likely be the opposite, where folks only find out that they should have set it by looking at traces already in the system.", "author": "codefromthecrypt", "createdAt": "2020-04-23T01:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7ca4bf95496ce70046a0a53ccd283f58f79a0de0", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex 1be962942..138225e9f 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -49,32 +49,7 @@ public abstract class ZipkinExporterConfiguration {\n    * @since 0.4.0\n    */\n   public static Builder builder() {\n-    return new AutoValue_ZipkinExporterConfiguration.Builder()\n-        .setEncoder(SpanBytesEncoder.JSON_V2)\n-        .setServiceName(\"unknown\");\n-  }\n-\n-  /**\n-   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n-   *\n-   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n-   * @param serviceName The serviceName with which to identify Spans. See {@link\n-   *     Builder#setServiceName(String)} for details.\n-   */\n-  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {\n-    return ZipkinExporterConfiguration.builder()\n-        .setEndpoint(endpoint)\n-        .setServiceName(serviceName)\n-        .build();\n-  }\n-\n-  /**\n-   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n-   *\n-   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n-   */\n-  public static ZipkinExporterConfiguration create(String endpoint) {\n-    return create(endpoint, \"unknown\");\n+    return new AutoValue_ZipkinExporterConfiguration.Builder().setEncoder(SpanBytesEncoder.JSON_V2);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMTU0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413411548", "bodyText": "I feel it is better to have someone forced to be add their own \"unknown\" vs do it for them. Similar to previous comments I'm not sure the value in creating a new way to make \"unknown\" and I think these factory methods will do just that. personally I would delete them and just have usage similar to jaeger in README asking them to indicate a fallback (default) service name.", "author": "codefromthecrypt", "createdAt": "2020-04-22T23:56:03Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setEndpoint(endpoint)\n+        .setServiceName(serviceName)\n+        .build();\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint) {", "originalCommit": "8112b7a6dbe4cdb634c917da13facae524b7f207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNDQ5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413904490", "bodyText": "remove the \"unknown\" from the defaults; serviceName is now required.", "author": "jkwatson", "createdAt": "2020-04-23T15:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMTU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "7ca4bf95496ce70046a0a53ccd283f58f79a0de0", "chunk": "diff --git a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\nindex 1be962942..138225e9f 100644\n--- a/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n+++ b/exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java\n\n@@ -49,32 +49,7 @@ public abstract class ZipkinExporterConfiguration {\n    * @since 0.4.0\n    */\n   public static Builder builder() {\n-    return new AutoValue_ZipkinExporterConfiguration.Builder()\n-        .setEncoder(SpanBytesEncoder.JSON_V2)\n-        .setServiceName(\"unknown\");\n-  }\n-\n-  /**\n-   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n-   *\n-   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n-   * @param serviceName The serviceName with which to identify Spans. See {@link\n-   *     Builder#setServiceName(String)} for details.\n-   */\n-  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {\n-    return ZipkinExporterConfiguration.builder()\n-        .setEndpoint(endpoint)\n-        .setServiceName(serviceName)\n-        .build();\n-  }\n-\n-  /**\n-   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n-   *\n-   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n-   */\n-  public static ZipkinExporterConfiguration create(String endpoint) {\n-    return create(endpoint, \"unknown\");\n+    return new AutoValue_ZipkinExporterConfiguration.Builder().setEncoder(SpanBytesEncoder.JSON_V2);\n   }\n \n   /**\n"}}, {"oid": "7ca4bf95496ce70046a0a53ccd283f58f79a0de0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7ca4bf95496ce70046a0a53ccd283f58f79a0de0", "message": "remove factory methods on the configuration, and update the README", "committedDate": "2020-04-23T15:27:29Z", "type": "commit"}, {"oid": "5fee364ee4d14c5e740b817bd3d1ba91f6f4539c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5fee364ee4d14c5e740b817bd3d1ba91f6f4539c", "message": "update the docs to match the requirements", "committedDate": "2020-04-23T15:31:41Z", "type": "commit"}, {"oid": "c660d99d6b4dd1dba81192f4c87061d49f39a7af", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c660d99d6b4dd1dba81192f4c87061d49f39a7af", "message": "fix a typo", "committedDate": "2020-04-23T15:32:39Z", "type": "commit"}, {"oid": "813fb95bd0ca69eb28c22e58012fde6a63c08463", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/813fb95bd0ca69eb28c22e58012fde6a63c08463", "message": "tiny re-arrange of javadoc", "committedDate": "2020-04-23T22:23:23Z", "type": "commit"}, {"oid": "574542e777234743e5ad2a456b94258a41d05ef2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/574542e777234743e5ad2a456b94258a41d05ef2", "message": "Add zipkin to the top-level docs", "committedDate": "2020-04-24T17:51:29Z", "type": "commit"}]}