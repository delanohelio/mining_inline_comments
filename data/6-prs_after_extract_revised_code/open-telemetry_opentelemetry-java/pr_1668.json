{"pr_number": 1668, "pr_title": "Change built-in SpanProcessor implementations to ignore more than one shutdown call", "pr_createdAt": "2020-09-21T13:42:47Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1668", "timeline": [{"oid": "57d192d6a83236682ec96b5319b892b3c688e3f9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/57d192d6a83236682ec96b5319b892b3c688e3f9", "message": "Change built-in SpanProcessor implementations to ignore more than one shutdown call\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-21T13:42:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExODA3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1668#discussion_r492118070", "bodyText": "synchronized (this) is always a bad idea, as you open yourself for deadlock if somebody external decides to synchronise on this object instance. In this particular case I think AtomicBoolean is better than volatile+lock", "author": "iNikem", "createdAt": "2020-09-21T14:58:50Z", "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/MultiSpanProcessor.java", "diffHunk": "@@ -68,11 +69,17 @@ public boolean isEndRequired() {\n \n   @Override\n   public CompletableResultCode shutdown() {\n-    List<CompletableResultCode> results = new ArrayList<>(spanProcessorsAll.size());\n-    for (SpanProcessor spanProcessor : spanProcessorsAll) {\n-      results.add(spanProcessor.shutdown());\n+    synchronized (this) {", "originalCommit": "57d192d6a83236682ec96b5319b892b3c688e3f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE0MzEwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1668#discussion_r492143106", "bodyText": "updated", "author": "malafeev", "createdAt": "2020-09-21T15:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExODA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "cd3030f88eb68346771c9835dd00a234e4bcc690", "chunk": "diff --git a/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/MultiSpanProcessor.java b/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/MultiSpanProcessor.java\nindex 003bf7b6a..117c3f3a4 100644\n--- a/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/MultiSpanProcessor.java\n+++ b/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/MultiSpanProcessor.java\n\n@@ -69,17 +70,14 @@ public final class MultiSpanProcessor implements SpanProcessor {\n \n   @Override\n   public CompletableResultCode shutdown() {\n-    synchronized (this) {\n-      if (isShutdown) {\n-        return CompletableResultCode.ofSuccess();\n-      }\n-      isShutdown = true;\n-      List<CompletableResultCode> results = new ArrayList<>(spanProcessorsAll.size());\n-      for (SpanProcessor spanProcessor : spanProcessorsAll) {\n-        results.add(spanProcessor.shutdown());\n-      }\n-      return CompletableResultCode.ofAll(results);\n+    if (isShutdown.getAndSet(true)) {\n+      return CompletableResultCode.ofSuccess();\n+    }\n+    List<CompletableResultCode> results = new ArrayList<>(spanProcessorsAll.size());\n+    for (SpanProcessor spanProcessor : spanProcessorsAll) {\n+      results.add(spanProcessor.shutdown());\n     }\n+    return CompletableResultCode.ofAll(results);\n   }\n \n   @Override\n"}}, {"oid": "cd3030f88eb68346771c9835dd00a234e4bcc690", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/cd3030f88eb68346771c9835dd00a234e4bcc690", "message": "refactor with AtomicBoolean\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-09-21T15:20:34Z", "type": "commit"}]}