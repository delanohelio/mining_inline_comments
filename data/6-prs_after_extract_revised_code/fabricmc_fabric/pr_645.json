{"pr_number": 645, "pr_title": "Screen API v1", "pr_createdAt": "2020-05-29T07:09:55Z", "pr_url": "https://github.com/FabricMC/fabric/pull/645", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDI5Mg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r432300292", "bodyText": "scaledWidth and scaledHeight", "author": "shedaniel", "createdAt": "2020-05-29T07:21:15Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ScreenInitializeCallback {\n+\tEvent<ScreenInitializeCallback> EVENT = EventFactory.createArrayBacked(ScreenInitializeCallback.class, callbacks -> (screen, context, client, windowWidth, windowHeight) -> {\n+\t\tfor (ScreenInitializeCallback callback : callbacks) {\n+\t\t\tcallback.onInitialize(screen, context, client, windowWidth, windowHeight);\n+\t\t}\n+\t});\n+\n+\tvoid onInitialize(Screen screen, ScreenContext context, MinecraftClient client, int windowWidth, int windowHeight);", "originalCommit": "937ebb6424ea7fa4c1535fd109dee35981a3bbbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTQyMw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r432301423", "bodyText": "onInit preferably to match yarn", "author": "shedaniel", "createdAt": "2020-05-29T07:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2632d263dbcffe5e92a80dcc7078e4dc7e1be0ca", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\nsimilarity index 67%\nrename from fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java\nrename to fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\nindex b8fa138b..35e56598 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\n\n@@ -25,12 +25,12 @@ import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n @Environment(EnvType.CLIENT)\n-public interface ScreenInitializeCallback {\n-\tEvent<ScreenInitializeCallback> EVENT = EventFactory.createArrayBacked(ScreenInitializeCallback.class, callbacks -> (screen, context, client, windowWidth, windowHeight) -> {\n-\t\tfor (ScreenInitializeCallback callback : callbacks) {\n-\t\t\tcallback.onInitialize(screen, context, client, windowWidth, windowHeight);\n+public interface ScreenInitCallback {\n+\tEvent<ScreenInitCallback> EVENT = EventFactory.createArrayBacked(ScreenInitCallback.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (ScreenInitCallback callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\tvoid onInitialize(Screen screen, ScreenContext context, MinecraftClient client, int windowWidth, int windowHeight);\n+\tvoid onInit(MinecraftClient client, Screen screen, ScreenContext context, int scaledWidth, int scaledHeight);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDg3OA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r432300878", "bodyText": "ScreenInitializationCallback or ScreenInitCallback", "author": "shedaniel", "createdAt": "2020-05-29T07:22:30Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ScreenInitializeCallback {", "originalCommit": "937ebb6424ea7fa4c1535fd109dee35981a3bbbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1MzU4NA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r432353584", "bodyText": "I'm in favour of ScreenInitCallback. It's shorter, and helps mitigate the Murikanization of \"initialise\"", "author": "Sollace", "createdAt": "2020-05-29T09:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4OTMzNg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r432989336", "bodyText": "went for init", "author": "i509VCB", "createdAt": "2020-05-31T22:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "2632d263dbcffe5e92a80dcc7078e4dc7e1be0ca", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\nsimilarity index 67%\nrename from fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java\nrename to fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\nindex b8fa138b..35e56598 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitializeCallback.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenInitCallback.java\n\n@@ -25,12 +25,12 @@ import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n @Environment(EnvType.CLIENT)\n-public interface ScreenInitializeCallback {\n-\tEvent<ScreenInitializeCallback> EVENT = EventFactory.createArrayBacked(ScreenInitializeCallback.class, callbacks -> (screen, context, client, windowWidth, windowHeight) -> {\n-\t\tfor (ScreenInitializeCallback callback : callbacks) {\n-\t\t\tcallback.onInitialize(screen, context, client, windowWidth, windowHeight);\n+public interface ScreenInitCallback {\n+\tEvent<ScreenInitCallback> EVENT = EventFactory.createArrayBacked(ScreenInitCallback.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (ScreenInitCallback callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\tvoid onInitialize(Screen screen, ScreenContext context, MinecraftClient client, int windowWidth, int windowHeight);\n+\tvoid onInit(MinecraftClient client, Screen screen, ScreenContext context, int scaledWidth, int scaledHeight);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2ODIxNw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r447868217", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tLOGGER.info(String.format(\"Initializing %s\", screen.getClass().getName()));\n          \n          \n            \n            \t\tLOGGER.info(\"Initializing {}\", screen.getClass().getName());", "author": "Juuxel", "createdAt": "2020-06-30T17:44:21Z", "path": "fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/ScreenTests.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.screen;\n+\n+import java.util.Random;\n+\n+import com.mojang.blaze3d.systems.RenderSystem;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.DrawableHelper;\n+import net.minecraft.client.gui.hud.InGameHud;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.gui.screen.TitleScreen;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+\n+import net.fabricmc.api.ClientModInitializer;\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenContext;\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenInitCallback;\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenRenderCallback;\n+\n+public class ScreenTests implements ClientModInitializer {\n+\tpublic static final Random RANDOM = new Random();\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"FabricScreenApiTests\");\n+\n+\t@Override\n+\tpublic void onInitializeClient() {\n+\t\tLOGGER.info(\"Started Screen Testmod\");\n+\t\tScreenInitCallback.EVENT.register(this::onInit);\n+\t\tScreenRenderCallback.EVENT.register(this::onRender);\n+\t}\n+\n+\tprivate void onInit(MinecraftClient client, Screen screen, ScreenContext context, int windowWidth, int windowHeight) {\n+\t\tLOGGER.info(String.format(\"Initializing %s\", screen.getClass().getName()));", "originalCommit": "80969ca2a84e30d6f8fe9afba8730f78300c36a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2632d263dbcffe5e92a80dcc7078e4dc7e1be0ca", "chunk": "diff --git a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/ScreenTests.java b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/ScreenTests.java\nindex 64332273..4a1c4a01 100644\n--- a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/ScreenTests.java\n+++ b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/ScreenTests.java\n\n@@ -46,7 +46,7 @@ public class ScreenTests implements ClientModInitializer {\n \t}\n \n \tprivate void onInit(MinecraftClient client, Screen screen, ScreenContext context, int windowWidth, int windowHeight) {\n-\t\tLOGGER.info(String.format(\"Initializing %s\", screen.getClass().getName()));\n+\t\tLOGGER.info(\"Initializing {}\", screen.getClass().getName());\n \n \t\tif (screen instanceof TitleScreen) {\n \t\t\t// Shrink the realms button, should be the third button on the list\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTUzMw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r447869533", "bodyText": "Should make this method return an ioob exception than a message.", "author": "liach", "createdAt": "2020-06-30T17:46:39Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.client.screen;\n+\n+import java.util.AbstractList;\n+import java.util.List;\n+\n+import net.minecraft.client.gui.Element;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+\n+public final class ButtonList<T extends AbstractButtonWidget> extends AbstractList<T> {\n+\tprivate final List<T> buttons;\n+\tprivate final List<Element> children;\n+\n+\tpublic ButtonList(List<T> buttons, List<Element> children) {\n+\t\tthis.buttons = buttons;\n+\t\tthis.children = children;\n+\t}\n+\n+\t@Override\n+\tpublic T get(int index) {\n+\t\treturn this.buttons.get(index);\n+\t}\n+\n+\t@Override\n+\tpublic T set(int index, T element) {\n+\t\tthis.remove(element); // verify / ensure no duplicates\n+\n+\t\tfinal T existingButton = this.buttons.get(index);\n+\t\tint elementIndex = this.children.indexOf(existingButton);\n+\n+\t\tif (elementIndex > -1) {\n+\t\t\tthis.children.set(elementIndex, element);\n+\t\t}\n+\n+\t\treturn this.buttons.set(index, element);\n+\t}\n+\n+\t@Override\n+\tpublic void add(int index, T element) {\n+\t\tthis.rangeCheckForAdd(index); // verify index bounds\n+\t\tthis.remove(element); // ensure no duplicates\n+\n+\t\tthis.buttons.add(index, element);\n+\t\tthis.children.add(Math.min(this.children.size(), index), element);\n+\t}\n+\n+\t@Override\n+\tpublic T remove(int index) {\n+\t\tthis.rangeCheck(index); // verify index bounds\n+\n+\t\tfinal T removedButton = this.buttons.remove(index);\n+\t\tindex = this.children.indexOf(removedButton);\n+\n+\t\tif (index > -1) {\n+\t\t\tthis.children.remove(index);\n+\t\t}\n+\n+\t\treturn removedButton;\n+\t}\n+\n+\t@Override\n+\tpublic int size() {\n+\t\treturn this.buttons.size();\n+\t}\n+\n+\tprivate void rangeCheck(int index) {\n+\t\tif (index >= this.size()) {\n+\t\t\tthrow new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+\t\t}\n+\t}\n+\n+\tprivate void rangeCheckForAdd(int index) {\n+\t\tif (index > this.size() || index < 0) {\n+\t\t\tthrow new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+\t\t}\n+\t}\n+\n+\tprivate String outOfBoundsMsg(int index) {", "originalCommit": "80969ca2a84e30d6f8fe9afba8730f78300c36a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4958018e67c6013226e31669684bb8a1eec4ba03", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\nindex 2784f591..2e8af532 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n\n@@ -80,18 +80,18 @@ public final class ButtonList<T extends AbstractButtonWidget> extends AbstractLi\n \n \tprivate void rangeCheck(int index) {\n \t\tif (index >= this.size()) {\n-\t\t\tthrow new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+\t\t\tthrow createOutOfBoundsException(index);\n \t\t}\n \t}\n \n \tprivate void rangeCheckForAdd(int index) {\n \t\tif (index > this.size() || index < 0) {\n-\t\t\tthrow new IndexOutOfBoundsException(outOfBoundsMsg(index));\n+\t\t\tthrow createOutOfBoundsException(index);\n \t\t}\n \t}\n \n-\tprivate String outOfBoundsMsg(int index) {\n-\t\treturn \"Index: \" + index + \", Size: \"+ size();\n+\tprivate IndexOutOfBoundsException createOutOfBoundsException(int index) {\n+\t\treturn new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"+ this.size());\n \t}\n }\n \n"}}, {"oid": "2632d263dbcffe5e92a80dcc7078e4dc7e1be0ca", "url": "https://github.com/FabricMC/fabric/commit/2632d263dbcffe5e92a80dcc7078e4dc7e1be0ca", "message": "Implement screen api", "committedDate": "2020-07-01T21:45:07Z", "type": "forcePushed"}, {"oid": "e9f1219b54753bf6682d2adccaee575e336798e2", "url": "https://github.com/FabricMC/fabric/commit/e9f1219b54753bf6682d2adccaee575e336798e2", "message": "Implement screen api", "committedDate": "2020-07-01T21:47:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MDM4OA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448670388", "bodyText": "more like FabricScreen?", "author": "liach", "createdAt": "2020-07-01T23:40:13Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenContext.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+import net.minecraft.client.render.item.ItemRenderer;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+/**\n+ * Provides access to additional context a screen can hold.\n+ */\n+@Environment(EnvType.CLIENT)\n+public interface ScreenContext {", "originalCommit": "a50d955f3442bc6247104fc437cd7e1ef1537285", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcyMzk5OQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448723999", "bodyText": "Somewhat against FabricScreen. ScreenAccess is pretty bad for a name imo", "author": "i509VCB", "createdAt": "2020-07-02T03:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MDM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1OTc1Ng==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448759756", "bodyText": "\ud83d\udc4d for screen access over screen context", "author": "liach", "createdAt": "2020-07-02T05:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MDM4OA=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenContext.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\nsimilarity index 50%\nrename from fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenContext.java\nrename to fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\nindex e3bf8291..41bb8570 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenContext.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\n\n@@ -25,20 +25,21 @@ import net.minecraft.client.render.item.ItemRenderer;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n \n /**\n  * Provides access to additional context a screen can hold.\n  */\n @Environment(EnvType.CLIENT)\n-public interface ScreenContext {\n+public interface FabricScreen {\n \t/**\n-\t * Gets the screen's context.\n+\t * Gets the screen's additional info.\n \t *\n \t * @param screen the screen\n \t * @return the screen's context\n \t */\n-\tstatic ScreenContext from(Screen screen) {\n-\t\treturn (ScreenContext) screen;\n+\tstatic FabricScreen getInfo(Screen screen) {\n+\t\treturn (FabricScreen) screen;\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTA1OQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448671059", "bodyText": "need to change this to do actual captures.\nalso can you guarantee all screen implementations that override render calls super.render? otherwise this hook will just be skipped.\nSame below.", "author": "liach", "createdAt": "2020-07-01T23:42:37Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/GameRendererMixin.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.mixin.screen;\n+\n+import org.spongepowered.asm.mixin.Final;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenContext;\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenEvents;\n+\n+@Mixin(GameRenderer.class)\n+public abstract class GameRendererMixin {\n+\t@Shadow\n+\t@Final\n+\tprivate MinecraftClient client;\n+\n+\t@Inject(method = \"render\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/Screen;render(Lnet/minecraft/client/util/math/MatrixStack;IIF)V\"), locals = LocalCapture.PRINT)", "originalCommit": "a50d955f3442bc6247104fc437cd7e1ef1537285", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcyMzU5Mg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448723592", "bodyText": "This is the invocation of the actual render method.\nSame with tick methods except for the one odd case with loading screen.", "author": "i509VCB", "createdAt": "2020-07-02T03:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1OTY4Nw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448759687", "bodyText": "Then it should be safe.", "author": "liach", "createdAt": "2020-07-02T05:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/GameRendererMixin.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/GameRendererMixin.java\nindex b6fed301..a5701ce9 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/GameRendererMixin.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/GameRendererMixin.java\n\n@@ -19,6 +19,7 @@ package net.fabricmc.fabric.mixin.screen;\n import org.spongepowered.asm.mixin.Final;\n import org.spongepowered.asm.mixin.Mixin;\n import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.Unique;\n import org.spongepowered.asm.mixin.injection.At;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTM1Mw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448671353", "bodyText": "should fail hard. see no point of generating an exception stub.", "author": "liach", "createdAt": "2020-07-01T23:43:34Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/MinecraftClientMixin.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.mixin.screen;\n+\n+import java.util.function.Function;\n+\n+import com.mojang.datafixers.util.Function4;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Coerce;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.resource.DataPackSettings;\n+import net.minecraft.resource.ResourceManager;\n+import net.minecraft.util.registry.RegistryTracker;\n+import net.minecraft.world.SaveProperties;\n+import net.minecraft.world.level.storage.LevelStorage;\n+\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenContext;\n+import net.fabricmc.fabric.api.client.screen.v1.ScreenEvents;\n+\n+@Mixin(MinecraftClient.class)\n+public abstract class MinecraftClientMixin {\n+\t@Shadow\n+\tpublic Screen currentScreen;\n+\n+\t// These two should be caught by \"Screen#wrapScreenError\" if anything fails\n+\n+\t@Inject(method = \"method_1572\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/Screen;tick()V\"), locals = LocalCapture.CAPTURE_FAILEXCEPTION)", "originalCommit": "a50d955f3442bc6247104fc437cd7e1ef1537285", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MzIzNA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448673234", "bodyText": "It will hard fail, this just guarantees this is part of the screen crash log", "author": "i509VCB", "createdAt": "2020-07-01T23:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3NDgyNg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r448674826", "bodyText": "Not until now do I realize how trashy mixin is", "author": "liach", "createdAt": "2020-07-01T23:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3MTM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/MinecraftClientMixin.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/MinecraftClientMixin.java\nindex 5e676185..7b5e0ffa 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/MinecraftClientMixin.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/mixin/screen/MinecraftClientMixin.java\n\n@@ -21,51 +21,60 @@ import java.util.function.Function;\n import com.mojang.datafixers.util.Function4;\n import org.spongepowered.asm.mixin.Mixin;\n import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.Unique;\n import org.spongepowered.asm.mixin.injection.At;\n import org.spongepowered.asm.mixin.injection.Coerce;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n-import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n \n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.resource.DataPackSettings;\n import net.minecraft.resource.ResourceManager;\n-import net.minecraft.util.registry.RegistryTracker;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n import net.minecraft.world.SaveProperties;\n import net.minecraft.world.level.storage.LevelStorage;\n \n-import net.fabricmc.fabric.api.client.screen.v1.ScreenContext;\n-import net.fabricmc.fabric.api.client.screen.v1.ScreenEvents;\n+import net.fabricmc.fabric.api.client.screen.v1.FabricScreen;\n \n @Mixin(MinecraftClient.class)\n public abstract class MinecraftClientMixin {\n \t@Shadow\n \tpublic Screen currentScreen;\n \n-\t// These two should be caught by \"Screen#wrapScreenError\" if anything fails\n+\t@Unique\n+\tprivate FabricScreen tickingScreen;\n \n-\t@Inject(method = \"method_1572\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/Screen;tick()V\"), locals = LocalCapture.CAPTURE_FAILEXCEPTION)\n+\t// These two injections should be caught by \"Screen#wrapScreenError\" if anything fails in an event and then rethrown in the crash report\n+\t@Inject(method = \"method_1572\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/Screen;tick()V\"))\n \tprivate void beforeScreenTick(CallbackInfo ci) {\n-\t\tScreenEvents.BEFORE_TICK.invoker().beforeTick((MinecraftClient) (Object) this, this.currentScreen, (ScreenContext) this.currentScreen);\n+\t\t// Store the screen in a variable in case someone tries to change the screen during this before tick event.\n+\t\t// If someone changes the screen, the after tick event will likely have class cast exceptions or an NPE.\n+\t\tthis.tickingScreen = (FabricScreen) this.currentScreen;\n+\t\tthis.tickingScreen.getBeforeTickEvent().invoker().beforeTick((MinecraftClient) (Object) this, this.tickingScreen.getScreen(), this.tickingScreen);\n \t}\n \n-\t@Inject(method = \"method_1572\", at = @At(\"TAIL\"), locals = LocalCapture.CAPTURE_FAILEXCEPTION)\n+\t@Inject(method = \"method_1572\", at = @At(\"TAIL\"))\n \tprivate void afterScreenTick(CallbackInfo ci) {\n-\t\tScreenEvents.AFTER_TICK.invoker().afterTick((MinecraftClient) (Object) this, this.currentScreen, (ScreenContext) this.currentScreen);\n+\t\tthis.tickingScreen.getAfterTickEvent().invoker().afterTick((MinecraftClient) (Object) this, this.tickingScreen.getScreen(), this.tickingScreen);\n+\t\t// Finally set the currently ticking screen to null\n+\t\tthis.tickingScreen = null;\n \t}\n \n-\t// This is the odd screen that isn't ticked by the main tick loop, so we fire events for this screen.\n-\n-\t@Inject(method = \"startIntegratedServer(Ljava/lang/String;Lnet/minecraft/util/registry/RegistryTracker$Modifiable;Ljava/util/function/Function;Lcom/mojang/datafixers/util/Function4;ZLnet/minecraft/client/MinecraftClient$WorldLoadAction;)V\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/LevelLoadingScreen;tick()V\"))\n-\tprivate void beforeLoadingScreenTick(String worldName, RegistryTracker.Modifiable registryTracker, Function<LevelStorage.Session, DataPackSettings> function, Function4<LevelStorage.Session, RegistryTracker.Modifiable, ResourceManager, DataPackSettings, SaveProperties> function4, boolean safeMode, @Coerce Object worldLoadAction, CallbackInfo ci) {\n-\t\tfinal Screen currentScreen = this.currentScreen;\n-\t\tScreenEvents.BEFORE_TICK.invoker().beforeTick((MinecraftClient) (Object) this, currentScreen, (ScreenContext) currentScreen);\n+\t// The LevelLoadingScreen is the odd screen that isn't ticked by the main tick loop, so we fire events for this screen.\n+\t// We Coerce the package-private inner class representing the world load action so we don't need an access widener.\n+\t@Inject(method = \"startIntegratedServer(Ljava/lang/String;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;Ljava/util/function/Function;Lcom/mojang/datafixers/util/Function4;ZLnet/minecraft/client/MinecraftClient$WorldLoadAction;)V\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/gui/screen/LevelLoadingScreen;tick()V\"))\n+\tprivate void beforeLoadingScreenTick(String worldName, DynamicRegistryManager.Impl dynamicRegistryManager, Function<LevelStorage.Session, DataPackSettings> function, Function4<LevelStorage.Session, DynamicRegistryManager.Impl, ResourceManager, DataPackSettings, SaveProperties> function4, boolean safeMode, @Coerce Object worldLoadAction, CallbackInfo ci) {\n+\t\t// Store the screen in a variable in case someone tries to change the screen during this before tick event.\n+\t\t// If someone changes the screen, the after tick event will likely have class cast exceptions or an NPE.\n+\t\tthis.tickingScreen = (FabricScreen) this.currentScreen;\n+\t\tthis.tickingScreen.getBeforeTickEvent().invoker().beforeTick((MinecraftClient) (Object) this, this.tickingScreen.getScreen(), this.tickingScreen);\n \t}\n \n-\t@Inject(method = \"startIntegratedServer(Ljava/lang/String;Lnet/minecraft/util/registry/RegistryTracker$Modifiable;Ljava/util/function/Function;Lcom/mojang/datafixers/util/Function4;ZLnet/minecraft/client/MinecraftClient$WorldLoadAction;)V\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/MinecraftClient;render(Z)V\"))\n-\tprivate void afterLoadingScreenTick(String worldName, RegistryTracker.Modifiable registryTracker, Function<LevelStorage.Session, DataPackSettings> function, Function4<LevelStorage.Session, RegistryTracker.Modifiable, ResourceManager, DataPackSettings, SaveProperties> function4, boolean safeMode, @Coerce Object worldLoadAction, CallbackInfo ci) {\n-\t\tfinal Screen currentScreen = this.currentScreen;\n-\t\tScreenEvents.AFTER_TICK.invoker().afterTick((MinecraftClient) (Object) this, currentScreen, (ScreenContext) currentScreen);\n+\t@Inject(method = \"startIntegratedServer(Ljava/lang/String;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;Ljava/util/function/Function;Lcom/mojang/datafixers/util/Function4;ZLnet/minecraft/client/MinecraftClient$WorldLoadAction;)V\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/client/MinecraftClient;render(Z)V\"))\n+\tprivate void afterLoadingScreenTick(String worldName, DynamicRegistryManager.Impl dynamicRegistryManager, Function<LevelStorage.Session, DataPackSettings> function, Function4<LevelStorage.Session, DynamicRegistryManager.Impl, ResourceManager, DataPackSettings, SaveProperties> function4, boolean safeMode, @Coerce Object worldLoadAction, CallbackInfo ci) {\n+\t\tthis.tickingScreen.getAfterTickEvent().invoker().afterTick((MinecraftClient) (Object) this, this.tickingScreen.getScreen(), this.tickingScreen);\n+\t\t// Finally set the currently ticking screen to null\n+\t\tthis.tickingScreen = null;\n \t}\n }\n"}}, {"oid": "4958018e67c6013226e31669684bb8a1eec4ba03", "url": "https://github.com/FabricMC/fabric/commit/4958018e67c6013226e31669684bb8a1eec4ba03", "message": "Split render and tick events to before and after", "committedDate": "2020-07-26T02:48:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzIwMQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517201", "bodyText": "I wonder if there is a better name for this?", "author": "modmuss50", "createdAt": "2020-07-26T11:47:29Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+import net.minecraft.client.render.item.ItemRenderer;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+/**\n+ * Provides access to additional context a screen can hold.\n+ */\n+@Environment(EnvType.CLIENT)\n+public interface FabricScreen {", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU0NzA3Mg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460547072", "bodyText": "Originally this was ScreenContext a few commits ago.\nScreenInfo could work.", "author": "i509VCB", "createdAt": "2020-07-26T16:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU4MzA3MQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460583071", "bodyText": "This is really fabric screens as this is injected wholesale into screen class.", "author": "liach", "createdAt": "2020-07-26T22:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgyODkyNQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r480828925", "bodyText": "Decided on ScreenExtensions in the end.", "author": "i509VCB", "createdAt": "2020-09-01T05:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\nindex bdbf13ca..41bb8570 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/FabricScreen.java\n\n@@ -25,6 +25,7 @@ import net.minecraft.client.render.item.ItemRenderer;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n \n /**\n  * Provides access to additional context a screen can hold.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzMyNQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517325", "bodyText": "Yes, this is good!", "author": "modmuss50", "createdAt": "2020-07-26T11:48:41Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.client.screen;\n+\n+import java.util.AbstractList;\n+import java.util.List;\n+\n+import net.minecraft.client.gui.Element;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+\n+public final class ButtonList<T extends AbstractButtonWidget> extends AbstractList<T> {", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\nindex 2e8af532..a0c97fb7 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n\n@@ -64,11 +64,7 @@ public final class ButtonList<T extends AbstractButtonWidget> extends AbstractLi\n \t\tthis.rangeCheck(index); // verify index bounds\n \n \t\tfinal T removedButton = this.buttons.remove(index);\n-\t\tindex = this.children.indexOf(removedButton);\n-\n-\t\tif (index > -1) {\n-\t\t\tthis.children.remove(index);\n-\t\t}\n+\t\tthis.children.remove(removedButton);\n \n \t\treturn removedButton;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzcyNA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517724", "bodyText": "Whats the use case for the tick events?", "author": "modmuss50", "createdAt": "2020-07-26T11:52:20Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is rendered.\n+\t */\n+\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is ticked.\n+\t */\n+\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");\n+\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is ticked.\n+\t */\n+\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU0ODAxMA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460548010", "bodyText": "I'd argue it's nessecary if someone adds a widget to a screen that needs to be ticked.\nFor example if someone added a sort of chyron to the title screen showing news about the latest snapshots, they would need to tick that element of the screen to advance the position of text.", "author": "i509VCB", "createdAt": "2020-07-26T16:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU4MzE3Mw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460583173", "bodyText": "So in case a tick-needed widget added to a non-ticking screen?", "author": "liach", "createdAt": "2020-07-26T22:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU4MzY1MA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460583650", "bodyText": "All screens are ticking, but child elements of a screen are not automatically ticking (some screen impls do do that).\nOften the tick method of each element is called in the screen's tick method", "author": "i509VCB", "createdAt": "2020-07-26T22:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzc2Mg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517762", "bodyText": "should say is the before tick", "author": "modmuss50", "createdAt": "2020-07-26T11:52:41Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is rendered.\n+\t */\n+\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is ticked.\n+\t */\n+\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzc4Mg==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517782", "bodyText": "same here say its the after tick", "author": "modmuss50", "createdAt": "2020-07-26T11:52:53Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is rendered.\n+\t */\n+\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is ticked.\n+\t */\n+\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");\n+\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is ticked.\n+\t */\n+\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzc5Nw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517797", "bodyText": "again here, say its the after renderer", "author": "modmuss50", "createdAt": "2020-07-26T11:53:07Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is rendered.\n+\t */\n+\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzgwOA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517808", "bodyText": "and before", "author": "modmuss50", "createdAt": "2020-07-26T11:53:11Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzg1OQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460517859", "bodyText": "Would it be worth exanding the docs to say what can do be done here. For example adding or changing buttons.", "author": "modmuss50", "createdAt": "2020-07-26T11:53:49Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU0ODE3OA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460548178", "bodyText": "I'll add some docs to the class explaining those two cases.", "author": "i509VCB", "createdAt": "2020-07-26T16:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1Mzc5OA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460553798", "bodyText": "might want to mention that this is after the init", "author": "shedaniel", "createdAt": "2020-07-26T17:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNzg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjkwNA==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460552904", "bodyText": "just extend AbstractPressableButtonWidget instead of ButtonWidget so you don't pass a null", "author": "shedaniel", "createdAt": "2020-07-26T17:29:30Z", "path": "fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/SoundButton.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.screen;\n+\n+import java.util.Random;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.widget.ButtonWidget;\n+import net.minecraft.client.sound.PositionedSoundInstance;\n+import net.minecraft.sound.SoundEvent;\n+import net.minecraft.sound.SoundEvents;\n+import net.minecraft.text.Text;\n+import net.minecraft.util.registry.Registry;\n+\n+class SoundButton extends ButtonWidget {\n+\tprivate static final Random RANDOM = new Random();\n+\n+\tSoundButton(int x, int y, int width, int height) {\n+\t\tsuper(x, y, width, height, Text.method_30163(\"Sound Button\"), null);", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/SoundButton.java b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/SoundButton.java\nindex 758b1736..9a910757 100644\n--- a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/SoundButton.java\n+++ b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/SoundButton.java\n\n@@ -19,18 +19,18 @@ package net.fabricmc.fabric.test.screen;\n import java.util.Random;\n \n import net.minecraft.client.MinecraftClient;\n-import net.minecraft.client.gui.widget.ButtonWidget;\n+import net.minecraft.client.gui.widget.AbstractPressableButtonWidget;\n import net.minecraft.client.sound.PositionedSoundInstance;\n import net.minecraft.sound.SoundEvent;\n import net.minecraft.sound.SoundEvents;\n import net.minecraft.text.Text;\n import net.minecraft.util.registry.Registry;\n \n-class SoundButton extends ButtonWidget {\n+class SoundButton extends AbstractPressableButtonWidget {\n \tprivate static final Random RANDOM = new Random();\n \n \tSoundButton(int x, int y, int width, int height) {\n-\t\tsuper(x, y, width, height, Text.method_30163(\"Sound Button\"), null);\n+\t\tsuper(x, y, width, height, Text.method_30163(\"Sound Button\"));\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MzA3MQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460553071", "bodyText": "same here with the null", "author": "shedaniel", "createdAt": "2020-07-26T17:30:49Z", "path": "fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/StopSoundButton.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.test.screen;\n+\n+import com.mojang.blaze3d.systems.RenderSystem;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.DrawableHelper;\n+import net.minecraft.client.gui.hud.InGameHud;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.gui.widget.ButtonWidget;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.text.LiteralText;\n+import net.minecraft.text.Text;\n+\n+class StopSoundButton extends ButtonWidget {\n+\tprivate final Screen screen;\n+\n+\tStopSoundButton(Screen screen, int x, int y, int width, int height) {\n+\t\tsuper(x, y, width, height, Text.method_30163(\"\"), null);", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/StopSoundButton.java b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/StopSoundButton.java\nindex a85da74e..ee5dbd71 100644\n--- a/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/StopSoundButton.java\n+++ b/fabric-screen-api-v1/src/testmod/java/net/fabricmc/fabric/test/screen/StopSoundButton.java\n\n@@ -22,16 +22,16 @@ import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.DrawableHelper;\n import net.minecraft.client.gui.hud.InGameHud;\n import net.minecraft.client.gui.screen.Screen;\n-import net.minecraft.client.gui.widget.ButtonWidget;\n+import net.minecraft.client.gui.widget.AbstractPressableButtonWidget;\n import net.minecraft.client.util.math.MatrixStack;\n import net.minecraft.text.LiteralText;\n import net.minecraft.text.Text;\n \n-class StopSoundButton extends ButtonWidget {\n+class StopSoundButton extends AbstractPressableButtonWidget {\n \tprivate final Screen screen;\n \n \tStopSoundButton(Screen screen, int x, int y, int width, int height) {\n-\t\tsuper(x, y, width, height, Text.method_30163(\"\"), null);\n+\t\tsuper(x, y, width, height, Text.method_30163(\"\"));\n \t\tthis.screen = screen;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MzUxNw==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460553517", "bodyText": "is it possible to just this.children.remove(removedButton);", "author": "shedaniel", "createdAt": "2020-07-26T17:35:06Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.client.screen;\n+\n+import java.util.AbstractList;\n+import java.util.List;\n+\n+import net.minecraft.client.gui.Element;\n+import net.minecraft.client.gui.widget.AbstractButtonWidget;\n+\n+public final class ButtonList<T extends AbstractButtonWidget> extends AbstractList<T> {\n+\tprivate final List<T> buttons;\n+\tprivate final List<Element> children;\n+\n+\tpublic ButtonList(List<T> buttons, List<Element> children) {\n+\t\tthis.buttons = buttons;\n+\t\tthis.children = children;\n+\t}\n+\n+\t@Override\n+\tpublic T get(int index) {\n+\t\treturn this.buttons.get(index);\n+\t}\n+\n+\t@Override\n+\tpublic T set(int index, T element) {\n+\t\tthis.remove(element); // verify / ensure no duplicates\n+\n+\t\tfinal T existingButton = this.buttons.get(index);\n+\t\tint elementIndex = this.children.indexOf(existingButton);\n+\n+\t\tif (elementIndex > -1) {\n+\t\t\tthis.children.set(elementIndex, element);\n+\t\t}\n+\n+\t\treturn this.buttons.set(index, element);\n+\t}\n+\n+\t@Override\n+\tpublic void add(int index, T element) {\n+\t\tthis.rangeCheckForAdd(index); // verify index bounds\n+\t\tthis.remove(element); // ensure no duplicates\n+\n+\t\tthis.buttons.add(index, element);\n+\t\tthis.children.add(Math.min(this.children.size(), index), element);\n+\t}\n+\n+\t@Override\n+\tpublic T remove(int index) {\n+\t\tthis.rangeCheck(index); // verify index bounds\n+\n+\t\tfinal T removedButton = this.buttons.remove(index);\n+\t\tindex = this.children.indexOf(removedButton);", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\nindex 2e8af532..a0c97fb7 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/impl/client/screen/ButtonList.java\n\n@@ -64,11 +64,7 @@ public final class ButtonList<T extends AbstractButtonWidget> extends AbstractLi\n \t\tthis.rangeCheck(index); // verify index bounds\n \n \t\tfinal T removedButton = this.buttons.remove(index);\n-\t\tindex = this.children.indexOf(removedButton);\n-\n-\t\tif (index > -1) {\n-\t\t\tthis.children.remove(index);\n-\t\t}\n+\t\tthis.children.remove(removedButton);\n \n \t\treturn removedButton;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1Mzg2OQ==", "url": "https://github.com/FabricMC/fabric/pull/645#discussion_r460553869", "bodyText": "functional interface? seeing that you have another pr that does that", "author": "shedaniel", "createdAt": "2020-07-26T17:38:54Z", "path": "fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.screen.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gui.screen.Screen;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ScreenEvents {\n+\t/**\n+\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t */\n+\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n+\t\tfor (Init callback : callbacks) {\n+\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is rendered.\n+\t */\n+\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeRender callback : callbacks) {\n+\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is rendered.\n+\t */\n+\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricRenderScreen\");\n+\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (AfterRender callback : callbacks) {\n+\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called before a screen is ticked.\n+\t */\n+\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");\n+\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BeforeTick callback : callbacks) {\n+\t\t\t\tcallback.beforeTick(client, screen, context);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * An event that is called after a screen is ticked.\n+\t */\n+\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricScreenTick\");\n+\n+\t\t\tfor (AfterTick callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.afterTick(client, screen, context);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (AfterTick callback : callbacks) {\n+\t\t\t\tcallback.afterTick(client, screen, context);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic interface Init {\n+\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t}\n+\n+\tpublic interface BeforeRender {\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t}\n+\n+\tpublic interface AfterRender {\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t}\n+\n+\tpublic interface BeforeTick {\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t}\n+\n+\tpublic interface AfterTick {", "originalCommit": "2793731b822f69913cda29a579abccfe4aeec903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "185123611a9d881425c647543ee0cf10b3495a15", "chunk": "diff --git a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\nindex e43a296b..f5e047e3 100644\n--- a/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n+++ b/fabric-screen-api-v1/src/main/java/net/fabricmc/fabric/api/client/screen/v1/ScreenEvents.java\n\n@@ -19,130 +19,156 @@ package net.fabricmc.fabric.api.client.screen.v1;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.gui.screen.Screen;\n import net.minecraft.client.util.math.MatrixStack;\n-import net.minecraft.util.profiler.Profiler;\n \n import net.fabricmc.api.EnvType;\n import net.fabricmc.api.Environment;\n import net.fabricmc.fabric.api.event.Event;\n import net.fabricmc.fabric.api.event.EventFactory;\n \n+// TODO:\n+// Char typed\n+// Add Child\n+// Add button\n+// Change ButtonList to fire add child and button events\n @Environment(EnvType.CLIENT)\n public final class ScreenEvents {\n \t/**\n-\t * An event that is called when a {@link Screen#init(MinecraftClient, int, int) screen is initialized}.\n+\t * An event that is called before a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * It should be noted many of the methods in {@link FabricScreen} such as the screen's text renderer may not be initialized yet, and as such their use is discouraged.\n+\t *\n+\t * <p>Typically this event is used to register screen events such as listening to when child elements are added to the screen.\n+\t * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.\n+\t *\n+\t * <p>The {@link FabricScreen} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).\n+\t * For example, to register an event on inventory like screens after render, the following code could be used:\n+\t * <blockquote><pre>\n+\t * &#64;Override\n+\t * public void onInitializeClient() {\n+\t * \tScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \t\tif (screen instanceof AbstractInventoryScreen) {\n+\t * \t\t\tinfo.getAfterRenderEvent().register(this::onRenderInventoryScreen);\n+\t * \t\t}\n+\t * \t});\n+\t * }\n+\t *\n+\t * private void onRenderInventoryScreen(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta) {\n+\t * \t...\n+\t * }\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event indicates a screen has been resized, and therefore is being re-initialized.\n+\t * This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#AFTER_INIT\n \t */\n-\tpublic static final Event<Init> INIT = EventFactory.createArrayBacked(Init.class, callbacks -> (client, screen, context, scaledWidth, scaledHeight) -> {\n-\t\tfor (Init callback : callbacks) {\n-\t\t\tcallback.onInit(client, screen, context, scaledWidth, scaledHeight);\n+\tpublic static final Event<ScreenEvents.BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(ScreenEvents.BeforeInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (BeforeInit callback : callbacks) {\n+\t\t\tcallback.beforeInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n \t/**\n-\t * An event that is called before a screen is rendered.\n+\t * An event that is called after a {@link Screen#init(MinecraftClient, int, int) screen is initialized} to it's default state.\n+\t * Since this event is fired after a screen has been initialized,\n+\t *\n+\t * <p>Typically this event is used to modify a screen after the screen has been initialized.\n+\t * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this callback.\n+\t *\n+\t * <p>For example, to add a button to the title screen, the following code could be used:\n+\t * <blockquote><pre>\n+\t * ScreenEvents.AFTER_INIT.register((client, screen, info, scaledWidth, scaledHeight) -> {\n+\t * \tif (screen instanceof TitleScreen) {\n+\t * \t\tcontext.getButtons().add(new ButtonWidget(...));\n+\t * \t}\n+\t * });\n+\t * </pre></blockquote>\n+\t *\n+\t * <p>This event can also indicate that the previous screen has been closed.\n+\t * @see ScreenEvents#BEFORE_INIT\n \t */\n-\tpublic static final Event<BeforeRender> BEFORE_RENDER = EventFactory.createArrayBacked(BeforeRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeRender callback : callbacks) {\n-\t\t\t\tcallback.beforeRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n+\tpublic static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, info, scaledWidth, scaledHeight) -> {\n+\t\tfor (AfterInit callback : callbacks) {\n+\t\t\tcallback.afterInit(client, screen, info, scaledWidth, scaledHeight);\n \t\t}\n \t});\n \n-\t/**\n-\t * An event that is called after a screen is rendered.\n-\t */\n-\tpublic static final Event<AfterRender> AFTER_RENDER = EventFactory.createArrayBacked(AfterRender.class, callbacks -> (client, matrices, screen, context, mouseX, mouseY, tickDelta) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricRenderScreen\");\n-\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterRender callback : callbacks) {\n-\t\t\t\tcallback.afterRender(client, matrices, screen, context, mouseX, mouseY, tickDelta);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called before a screen is ticked.\n-\t */\n-\tpublic static final Event<BeforeTick> BEFORE_TICK = EventFactory.createArrayBacked(BeforeTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (BeforeTick callback : callbacks) {\n-\t\t\t\tcallback.beforeTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * An event that is called after a screen is ticked.\n-\t */\n-\tpublic static final Event<AfterTick> AFTER_TICK = EventFactory.createArrayBacked(AfterTick.class, callbacks -> (client, screen, context) -> {\n-\t\tif (EventFactory.isProfilingEnabled()) {\n-\t\t\tfinal Profiler profiler = client.getProfiler();\n-\t\t\tprofiler.push(\"fabricScreenTick\");\n-\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t\tprofiler.pop();\n-\t\t\t}\n-\n-\t\t\tprofiler.pop();\n-\t\t} else {\n-\t\t\tfor (AfterTick callback : callbacks) {\n-\t\t\t\tcallback.afterTick(client, screen, context);\n-\t\t\t}\n-\t\t}\n-\t});\n+\t@FunctionalInterface\n+\tpublic interface BeforeInit {\n+\t\tvoid beforeInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n+\t}\n \n-\tpublic interface Init {\n-\t\tvoid onInit(MinecraftClient client, Screen screen, FabricScreen context, int scaledWidth, int scaledHeight);\n+\t@FunctionalInterface\n+\tpublic interface AfterInit {\n+\t\tvoid afterInit(MinecraftClient client, Screen screen, FabricScreen info, int scaledWidth, int scaledHeight);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeRender {\n-\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid beforeRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterRender {\n-\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen context, int mouseX, int mouseY, float tickDelta);\n+\t\tvoid afterRender(MinecraftClient client, MatrixStack matrices, Screen screen, FabricScreen info, int mouseX, int mouseY, float tickDelta);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface BeforeTick {\n-\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid beforeTick(MinecraftClient client, Screen screen, FabricScreen info);\n \t}\n \n+\t@FunctionalInterface\n \tpublic interface AfterTick {\n-\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen context);\n+\t\tvoid afterTick(MinecraftClient client, Screen screen, FabricScreen info);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyPressed {\n+\t\tboolean beforeKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyPressed {\n+\t\tvoid afterKeyPress(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeKeyReleased {\n+\t\tboolean beforeKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterKeyReleased {\n+\t\tvoid afterKeyReleased(MinecraftClient client, Screen screen, FabricScreen info, int key, int scancode, int modifiers);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseClicked {\n+\t\tboolean beforeMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseClicked {\n+\t\tvoid afterMouseClicked(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseReleased {\n+\t\tboolean beforeMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseReleased {\n+\t\tvoid afterMouseReleased(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, int button);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface BeforeMouseScrolled {\n+\t\tboolean beforeMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n+\t}\n+\n+\t@FunctionalInterface\n+\tpublic interface AfterMouseScrolled {\n+\t\tvoid afterMouseScrolled(MinecraftClient client, Screen screen, FabricScreen info, double mouseX, double mouseY, double horizontalAmount, double verticalAmount);\n \t}\n \n \tprivate ScreenEvents() {\n"}}, {"oid": "185123611a9d881425c647543ee0cf10b3495a15", "url": "https://github.com/FabricMC/fabric/commit/185123611a9d881425c647543ee0cf10b3495a15", "message": "Before init is nessecary to listen to addition/removal of child elements", "committedDate": "2020-08-07T04:53:34Z", "type": "forcePushed"}, {"oid": "126413bc8db08dbfbe8c0fd6f8fd6eff8e606731", "url": "https://github.com/FabricMC/fabric/commit/126413bc8db08dbfbe8c0fd6f8fd6eff8e606731", "message": "Before init is nessecary to listen to addition/removal of child elements", "committedDate": "2020-09-01T04:55:29Z", "type": "forcePushed"}, {"oid": "3ccacc14c7856191ec2d2381d39bef189aadee67", "url": "https://github.com/FabricMC/fabric/commit/3ccacc14c7856191ec2d2381d39bef189aadee67", "message": "Mappings updates on testmod", "committedDate": "2020-10-02T00:54:05Z", "type": "forcePushed"}, {"oid": "56a0dbd1e0ab32c708a70eb8dc3343b5c9f80e68", "url": "https://github.com/FabricMC/fabric/commit/56a0dbd1e0ab32c708a70eb8dc3343b5c9f80e68", "message": "javadoc formatting again", "committedDate": "2020-10-28T02:13:57Z", "type": "forcePushed"}, {"oid": "fad33ba4ffb7b494e2b65e219c15375777207055", "url": "https://github.com/FabricMC/fabric/commit/fad33ba4ffb7b494e2b65e219c15375777207055", "message": "javadoc formatting again", "committedDate": "2020-11-20T04:06:22Z", "type": "forcePushed"}, {"oid": "27d99857051c1e10db88aaee7038d0a2ffe978ba", "url": "https://github.com/FabricMC/fabric/commit/27d99857051c1e10db88aaee7038d0a2ffe978ba", "message": "Module dependencies", "committedDate": "2020-11-22T09:25:00Z", "type": "forcePushed"}, {"oid": "d881c61353d65b65b2eb36c884dc918d46d5f571", "url": "https://github.com/FabricMC/fabric/commit/d881c61353d65b65b2eb36c884dc918d46d5f571", "message": "Implement screen api", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "585ede1f279ff0e5803088172422f59f0123e4f4", "url": "https://github.com/FabricMC/fabric/commit/585ede1f279ff0e5803088172422f59f0123e4f4", "message": "Actually update to 20w27a", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "ade900474066bcb629f695e9f8b88daf30fdd179", "url": "https://github.com/FabricMC/fabric/commit/ade900474066bcb629f695e9f8b88daf30fdd179", "message": "Split render and tick events to before and after", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "a4da197d3e46b3a28a3476ff27275edf10e6bb52", "url": "https://github.com/FabricMC/fabric/commit/a4da197d3e46b3a28a3476ff27275edf10e6bb52", "message": "Rename and update", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "ff4765c1596c979b1c57c01f636ddba2614166ab", "url": "https://github.com/FabricMC/fabric/commit/ff4765c1596c979b1c57c01f636ddba2614166ab", "message": "A bit of javadoc and profiler name fixes", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "cd890185674ec10edfc12dd733b6d15240f38c3b", "url": "https://github.com/FabricMC/fabric/commit/cd890185674ec10edfc12dd733b6d15240f38c3b", "message": "Add functional interface annotations, move render and ticking events to actual FabricScreen instance.", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "26d6e095dd4bbdf45e40837d8904e4a70d5b3f83", "url": "https://github.com/FabricMC/fabric/commit/26d6e095dd4bbdf45e40837d8904e4a70d5b3f83", "message": "Add after screen resize event", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "251079d642840b1b3f436982554adf5596084cc0", "url": "https://github.com/FabricMC/fabric/commit/251079d642840b1b3f436982554adf5596084cc0", "message": "Implement key and mouse click/press and release events.", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "1fb9dcd404309f86f7c0893e9bceb52d404bd413", "url": "https://github.com/FabricMC/fabric/commit/1fb9dcd404309f86f7c0893e9bceb52d404bd413", "message": "Move keyboard and mouse events to their own pojos", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "ed17f6bcc330e4695f01ae39f20236d16c7d7de8", "url": "https://github.com/FabricMC/fabric/commit/ed17f6bcc330e4695f01ae39f20236d16c7d7de8", "message": "Init and resize are the same thing. Maybe Screen#init needs a rename", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "4beaf04abd414d702bbe1454ac1a2d2740885694", "url": "https://github.com/FabricMC/fabric/commit/4beaf04abd414d702bbe1454ac1a2d2740885694", "message": "Add mouse scroll events", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "5c78e1f1559251954182e88b9412ee00fe79322d", "url": "https://github.com/FabricMC/fabric/commit/5c78e1f1559251954182e88b9412ee00fe79322d", "message": "checkstyle", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "22d1bf054d654b7954b58f505c2cabe72fc7b13f", "url": "https://github.com/FabricMC/fabric/commit/22d1bf054d654b7954b58f505c2cabe72fc7b13f", "message": "Refresh event instances after init", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "65d008c89b3e930674d1d126a226fb5d1b1a4e41", "url": "https://github.com/FabricMC/fabric/commit/65d008c89b3e930674d1d126a226fb5d1b1a4e41", "message": "Before init is nessecary to listen to addition/removal of child elements", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "c40779f62040ca0bb777ce072073fa1e87799146", "url": "https://github.com/FabricMC/fabric/commit/c40779f62040ca0bb777ce072073fa1e87799146", "message": "Polish up the javadoc and do a rename to the public api interface.", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "110669020a3f2eb2ad980bb5004dbdf0b8562483", "url": "https://github.com/FabricMC/fabric/commit/110669020a3f2eb2ad980bb5004dbdf0b8562483", "message": "Mappings updates on testmod", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "bd7fa98ad5836abd8ed8dba64eb14824c0c450f7", "url": "https://github.com/FabricMC/fabric/commit/bd7fa98ad5836abd8ed8dba64eb14824c0c450f7", "message": "javadoc formatting again", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "787f48725d2665d22b493ea987ac282bbd0cd4bd", "url": "https://github.com/FabricMC/fabric/commit/787f48725d2665d22b493ea987ac282bbd0cd4bd", "message": "Rework screen api design to be more ergonomic.", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "e6a01147b87772dc2bcba739d26480b413992c1a", "url": "https://github.com/FabricMC/fabric/commit/e6a01147b87772dc2bcba739d26480b413992c1a", "message": "Add remove event, some javadoc", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "d01613d6d1daae0a579545765d43ce7384e3beb5", "url": "https://github.com/FabricMC/fabric/commit/d01613d6d1daae0a579545765d43ce7384e3beb5", "message": "Add allow phase", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "ac28de50761b962f24e8749fbc1c727f03d7e044", "url": "https://github.com/FabricMC/fabric/commit/ac28de50761b962f24e8749fbc1c727f03d7e044", "message": "Module dependencies", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "610bd6ddcd28f23a8920f008e9f6256c18cda9c0", "url": "https://github.com/FabricMC/fabric/commit/610bd6ddcd28f23a8920f008e9f6256c18cda9c0", "message": "Fix null ticking when no screen is open", "committedDate": "2020-12-12T21:52:09Z", "type": "commit"}, {"oid": "47de7ec9b0ea945d2ddafed1443f2d8634fc1845", "url": "https://github.com/FabricMC/fabric/commit/47de7ec9b0ea945d2ddafed1443f2d8634fc1845", "message": "Refer to GLFW constants in mouse click/release events", "committedDate": "2020-12-12T22:24:58Z", "type": "commit"}, {"oid": "47de7ec9b0ea945d2ddafed1443f2d8634fc1845", "url": "https://github.com/FabricMC/fabric/commit/47de7ec9b0ea945d2ddafed1443f2d8634fc1845", "message": "Refer to GLFW constants in mouse click/release events", "committedDate": "2020-12-12T22:24:58Z", "type": "forcePushed"}, {"oid": "f9d2b942a3ba75ac69b4dc4cee855c8dc6a78499", "url": "https://github.com/FabricMC/fabric/commit/f9d2b942a3ba75ac69b4dc4cee855c8dc6a78499", "message": "Keyboard event GLFW constant javadoc", "committedDate": "2020-12-13T23:11:07Z", "type": "commit"}, {"oid": "9688302b8638e4c1f523f5917a9d1522ca681135", "url": "https://github.com/FabricMC/fabric/commit/9688302b8638e4c1f523f5917a9d1522ca681135", "message": "Remove redundant qualifier", "committedDate": "2020-12-24T22:22:36Z", "type": "commit"}, {"oid": "80a86c77d696b8f0824d9237d75a230ba6ed7d38", "url": "https://github.com/FabricMC/fabric/commit/80a86c77d696b8f0824d9237d75a230ba6ed7d38", "message": "Some docs, degetterifying", "committedDate": "2021-01-18T04:39:35Z", "type": "commit"}, {"oid": "3171d32e55485fe6ef9a7bbddb5a0866f6809204", "url": "https://github.com/FabricMC/fabric/commit/3171d32e55485fe6ef9a7bbddb5a0866f6809204", "message": "Because global go brr add screen params back around", "committedDate": "2021-01-18T05:25:24Z", "type": "commit"}, {"oid": "165d3e3e2e36414241cae113990520cf92d4bdb8", "url": "https://github.com/FabricMC/fabric/commit/165d3e3e2e36414241cae113990520cf92d4bdb8", "message": "Add module lifecycle to FMJ", "committedDate": "2021-01-19T02:41:54Z", "type": "commit"}]}