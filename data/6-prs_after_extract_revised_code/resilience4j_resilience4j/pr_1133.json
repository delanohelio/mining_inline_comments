{"pr_number": 1133, "pr_title": "Fix ConcurrentModificationException in EventProcessor.", "pr_createdAt": "2020-08-19T20:20:42Z", "pr_url": "https://github.com/resilience4j/resilience4j/pull/1133", "timeline": [{"oid": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6", "url": "https://github.com/resilience4j/resilience4j/commit/c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6", "message": "Changes to fix ConcurrentModificationException.", "committedDate": "2020-08-19T20:19:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgyMDM3NQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1133#discussion_r473820375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testOnEventParallel() throws ExecutionException {\n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        // Artificial delay in a listener's code\n          \n          \n            \n                        System.out.println(\"1\" + \"start\" + event.toString());\n          \n          \n            \n                        try {\n          \n          \n            \n                            Thread.sleep(10 * 1000L);\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            e.printStackTrace();\n          \n          \n            \n                        }\n          \n          \n            \n                        System.out.println(\"1\" + \"end\" + event.toString());\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        Thread.sleep(1 * 1000L);\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    try {\n          \n          \n            \n                        future.get();\n          \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                    } catch (ExecutionException e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        throw e;\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                public void testOnEventParallel() throws ExecutionException, InterruptedException {\n          \n          \n            \n                    CountDownLatch eventConsumed = new CountDownLatch(1);\n          \n          \n            \n                    CountDownLatch waitForConsumerRegistration = new CountDownLatch(1);\n          \n          \n            \n            \n          \n          \n            \n                    EventProcessor<Number> eventProcessor = new EventProcessor<>();\n          \n          \n            \n                    EventConsumer<Integer> eventConsumer1 = event -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            eventConsumed.countDown();\n          \n          \n            \n                            waitForConsumerRegistration.await(5, TimeUnit.SECONDS);\n          \n          \n            \n                            logger.info(event.toString());\n          \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                            fail(\"Must not happen\");\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n            \n          \n          \n            \n                    EventConsumer<Integer> eventConsumer2 = event -> logger.info(event.toString());\n          \n          \n            \n            \n          \n          \n            \n                    // 1st consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n          \n          \n            \n            \n          \n          \n            \n                    // process first event in a separate thread to create a race condition\n          \n          \n            \n                    CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n          \n          \n            \n                        eventProcessor.processEvent(1); // blocks because of the count down latch\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                    eventConsumed.await(1, TimeUnit.SECONDS);\n          \n          \n            \n            \n          \n          \n            \n                    // 2nd consumer is added\n          \n          \n            \n                    eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n          \n          \n            \n            \n          \n          \n            \n                    future.get();\n          \n          \n            \n            \n          \n          \n            \n                    waitForConsumerRegistration.countDown();\n          \n          \n            \n            \n          \n          \n            \n                    then(logger).should(times(1)).info(\"1\");\n          \n          \n            \n                }", "author": "RobWin", "createdAt": "2020-08-20T09:39:38Z", "path": "resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java", "diffHunk": "@@ -107,4 +110,48 @@ public void testNoConsumers() {\n         assertThat(consumed).isEqualTo(false);\n     }\n \n+\n+    @Test\n+    public void testOnEventParallel() throws ExecutionException {\n+        EventProcessor<Number> eventProcessor = new EventProcessor<>();\n+        EventConsumer<Integer> eventConsumer1 = event -> {\n+            // Artificial delay in a listener's code\n+            System.out.println(\"1\" + \"start\" + event.toString());\n+            try {\n+                Thread.sleep(10 * 1000L);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            System.out.println(\"1\" + \"end\" + event.toString());\n+        };\n+\n+        EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n+\n+        // 1st consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n+\n+        // process first event in a separate thread to create a race condition\n+        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+            eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n+        });\n+\n+        try {\n+            Thread.sleep(1 * 1000L);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+\n+        // 2nd consumer is added\n+        eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n+\n+        try {\n+            future.get();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        } catch (ExecutionException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+    }", "originalCommit": "c3e4d1fb78ad10c27ff5d72a6ec0bba5b8a3b0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70527a65d2e2419fdba55cbae4fc7d2fe3f8b5a5", "chunk": "diff --git a/resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java b/resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java\nindex 23d6377f..b17d798a 100644\n--- a/resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java\n+++ b/resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java\n\n@@ -112,46 +112,41 @@ public class EventProcessorTest {\n \n \n     @Test\n-    public void testOnEventParallel() throws ExecutionException {\n+    public void testOnEventParallel() throws ExecutionException, InterruptedException {\n+        CountDownLatch eventConsumed = new CountDownLatch(1);\n+        CountDownLatch waitForConsumerRegistration = new CountDownLatch(1);\n+\n         EventProcessor<Number> eventProcessor = new EventProcessor<>();\n         EventConsumer<Integer> eventConsumer1 = event -> {\n-            // Artificial delay in a listener's code\n-            System.out.println(\"1\" + \"start\" + event.toString());\n             try {\n-                Thread.sleep(10 * 1000L);\n+                eventConsumed.countDown();\n+                waitForConsumerRegistration.await(5, TimeUnit.SECONDS);\n+                logger.info(event.toString());\n             } catch (InterruptedException e) {\n-                e.printStackTrace();\n+                fail(\"Must not happen\");\n             }\n-            System.out.println(\"1\" + \"end\" + event.toString());\n         };\n \n-        EventConsumer<Integer> eventConsumer2 = event -> System.out.println(\"2\" + event.toString());\n+        EventConsumer<Integer> eventConsumer2 = event -> logger.info(event.toString());\n \n         // 1st consumer is added\n         eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer1);\n \n         // process first event in a separate thread to create a race condition\n         CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n-            eventProcessor.processEvent(1); // sleeps 10 sec inside listener's code\n+            eventProcessor.processEvent(1); // blocks because of the count down latch\n         });\n \n-        try {\n-            Thread.sleep(1 * 1000L);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        }\n+        eventConsumed.await(1, TimeUnit.SECONDS);\n \n         // 2nd consumer is added\n         eventProcessor.registerConsumer(Integer.class.getSimpleName(), eventConsumer2);\n \n-        try {\n-            future.get();\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        } catch (ExecutionException e) {\n-            e.printStackTrace();\n-            throw e;\n-        }\n+        future.get();\n+\n+        waitForConsumerRegistration.countDown();\n+\n+        then(logger).should(times(1)).info(\"1\");\n     }\n \n }\n"}}, {"oid": "70527a65d2e2419fdba55cbae4fc7d2fe3f8b5a5", "url": "https://github.com/resilience4j/resilience4j/commit/70527a65d2e2419fdba55cbae4fc7d2fe3f8b5a5", "message": "Update resilience4j-core/src/test/java/io/github/resilience4j/core/EventProcessorTest.java\n\nCo-authored-by: Robert Winkler <robwin@t-online.de>", "committedDate": "2020-08-20T11:30:58Z", "type": "commit"}, {"oid": "235081d0c32fd5c828d3a5b9c4e0ed8b83c8157b", "url": "https://github.com/resilience4j/resilience4j/commit/235081d0c32fd5c828d3a5b9c4e0ed8b83c8157b", "message": "Add missing imports.", "committedDate": "2020-08-20T11:59:56Z", "type": "commit"}]}