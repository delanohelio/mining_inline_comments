{"pr_number": 26717, "pr_title": "Initial Toml validator Implementation", "pr_createdAt": "2020-11-03T10:32:59Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717", "timeline": [{"oid": "86c79f04b7d6cab034f17d955d3f729e24ad5170", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86c79f04b7d6cab034f17d955d3f729e24ad5170", "message": "Initial Impl of Toml Validator", "committedDate": "2020-11-03T10:35:30Z", "type": "forcePushed"}, {"oid": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "message": "Initial Impl of Toml Validator", "committedDate": "2020-11-03T10:40:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA5MzM4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r517093382", "bodyText": "Licenses should come to the top.", "author": "anuruddhal", "createdAt": "2020-11-04T04:38:50Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.ballerina.toml.validator.models;", "originalCommit": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\nindex 34c391becd5..cb6f83020b4 100644\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\n+++ b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\n\n@@ -1,7 +1,3 @@\n-package io.ballerina.toml.validator.models;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.annotations.SerializedName;\n /*\n  * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEyNTIwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r517125206", "bodyText": "Shall we add proper messages?", "author": "anuruddhal", "createdAt": "2020-11-04T06:42:27Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {\n+\n+    private final Schema schema;\n+    private final TopLevelNode topLevelNode;\n+\n+    public Type(Schema schema, TopLevelNode topLevelNode) {\n+        this.schema = schema;\n+        this.topLevelNode = topLevelNode;\n+    }\n+\n+    @Override\n+    public List<TomlDiagnostic> apply() {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+\n+        if (topLevelNode == null) {\n+            return diagnostics;\n+        }\n+\n+        if (schema.getType().equals(\"object\")) {\n+            if (topLevelNode.kind() != TomlType.TABLE) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"0000\", \"Message Here\",", "originalCommit": "3a0ebf5f973c60a7e17e18a84d2f96a3a5aeb830", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\nindex 4c7b6060c30..7589e4663dd 100644\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\n+++ b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\n\n@@ -58,13 +58,13 @@ public class Type implements Command {\n \n         if (schema.getType().equals(\"object\")) {\n             if (topLevelNode.kind() != TomlType.TABLE) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"0000\", \"Message Here\",\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n                         DiagnosticSeverity.ERROR, \"Table Expected. Found \" + topLevelNode.kind().toString());\n                 diagnostics.add(diagnostic);\n             }\n         } else if (schema.getType().equals(\"array\")) {\n             if (!(topLevelNode.kind() == TomlType.TABLE_ARRAY || topLevelNode.kind() == TomlType.ARRAY)) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"0000\", \"Message Here\",\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n                         DiagnosticSeverity.ERROR, \"Table Array Expected. Found \" + topLevelNode.kind().toString());\n                 diagnostics.add(diagnostic);\n             }\n"}}, {"oid": "01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/01b68a4d57b003ff0ce1501f4cc5ee95ee4875f8", "message": "Initial Impl of Toml Validator", "committedDate": "2020-11-04T12:20:38Z", "type": "forcePushed"}, {"oid": "e2fc2e867d552ab8ec60249620fe4489c365a7fb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2fc2e867d552ab8ec60249620fe4489c365a7fb", "message": "Make Toml object persist diagnostics", "committedDate": "2020-11-06T10:45:41Z", "type": "forcePushed"}, {"oid": "07e17551829888ef4642abaff6cc3d95c83bf1b8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07e17551829888ef4642abaff6cc3d95c83bf1b8", "message": "Make Toml object persist diagnostics", "committedDate": "2020-11-10T10:58:02Z", "type": "forcePushed"}, {"oid": "735b35e4ad3f152d36632484187926ce0403c8cd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/735b35e4ad3f152d36632484187926ce0403c8cd", "message": "Fix diagnostic filename issue", "committedDate": "2020-11-10T14:12:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxMTYxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521811618", "bodyText": "Do we need this method?\nWe can use String content = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8); to get the content from input stream", "author": "SupunS", "createdAt": "2020-11-12T03:46:05Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +100,46 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8), null);\n     }\n \n     /**\n      * Read TOML File using Reader.\n      *\n      * @param reader reader of the TOML file\n+     * @param filePath path of the TOML file\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n+    public static Toml read(Reader reader, String filePath) throws IOException {\n         BufferedReader bufferedReader = new BufferedReader(reader);\n         StringBuilder w = new StringBuilder();\n         for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n             w.append(line).append('\\n');\n         }\n-        return read(w.toString());\n+        return read(w.toString(), filePath);\n     }", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex a55407f5225..44495f072ff 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -100,24 +99,7 @@ public class Toml {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8), null);\n-    }\n-\n-    /**\n-     * Read TOML File using Reader.\n-     *\n-     * @param reader reader of the TOML file\n-     * @param filePath path of the TOML file\n-     * @return TOML Object\n-     * @throws IOException if file is not accessible\n-     */\n-    public static Toml read(Reader reader, String filePath) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString(), filePath);\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxMzQxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521813417", "bodyText": "We could use Files.readString(path)", "author": "SupunS", "createdAt": "2020-11-12T03:48:47Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -71,7 +84,12 @@ private Toml(TomlTableNode tomlTableNode) {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(Path path) throws IOException {\n-        return read(Files.newBufferedReader(path));\n+        Path fileNamePath = path.getFileName();\n+        if (fileNamePath == null) {\n+            return null;\n+        }\n+        return read(Files.newBufferedReader(path),", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex a55407f5225..44495f072ff 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -88,7 +87,7 @@ public class Toml {\n         if (fileNamePath == null) {\n             return null;\n         }\n-        return read(Files.newBufferedReader(path),\n+        return read(Files.readString(path),\n                 fileNamePath.toString());\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxNjEwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521816107", "bodyText": "In getTable method, the condition in the if-clause is inverted. It's good to follow a single pattern in all places.", "author": "SupunS", "createdAt": "2020-11-12T03:52:52Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,7 +188,7 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n-        if (tableNode.kind() == TomlType.TABLE_ARRAY) {\n+        if (tableNode != null && tableNode.kind() == TomlType.TABLE_ARRAY) {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex a55407f5225..44495f072ff 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -188,20 +170,19 @@ public class Toml {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n-        if (tableNode != null && tableNode.kind() == TomlType.TABLE_ARRAY) {\n-            TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n-            List<TomlTableNode> childs = tomlTableArrayNode.children();\n-            List<Toml> tomlList = new ArrayList<>();\n-            for (TomlTableNode child : childs) {\n-                tomlList.add(new Toml(child));\n-            }\n-            return tomlList;\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n+        List<TomlTableNode> childs = tomlTableArrayNode.children();\n+        List<Toml> tomlList = new ArrayList<>();\n+        for (TomlTableNode child : childs) {\n+            tomlList.add(new Toml(child));\n         }\n-        return null;\n+        return tomlList;\n     }\n \n-    public List<Diagnostic> getDiagnostics() {\n-        this.diagnostics.sort(new DiagnosticComparator());\n+    public Set<Diagnostic> getDiagnostics() {\n         return this.diagnostics;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgxNzU0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521817544", "bodyText": "We can use a TreeSet with DiagnosticComparator to store diagnostics. Then we don't have to sort it every-time here.", "author": "SupunS", "createdAt": "2020-11-12T03:54:57Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -181,7 +200,12 @@ public Toml getTable(String key) {\n         return null;\n     }\n \n-    public List<TomlDiagnostic> getDiagnostics() {\n-        return this.rootNode.diagnostics();\n+    public List<Diagnostic> getDiagnostics() {\n+        this.diagnostics.sort(new DiagnosticComparator());", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex a55407f5225..44495f072ff 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -188,20 +170,19 @@ public class Toml {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n-        if (tableNode != null && tableNode.kind() == TomlType.TABLE_ARRAY) {\n-            TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n-            List<TomlTableNode> childs = tomlTableArrayNode.children();\n-            List<Toml> tomlList = new ArrayList<>();\n-            for (TomlTableNode child : childs) {\n-                tomlList.add(new Toml(child));\n-            }\n-            return tomlList;\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n+        List<TomlTableNode> childs = tomlTableArrayNode.children();\n+        List<Toml> tomlList = new ArrayList<>();\n+        for (TomlTableNode child : childs) {\n+            tomlList.add(new Toml(child));\n         }\n-        return null;\n+        return tomlList;\n     }\n \n-    public List<Diagnostic> getDiagnostics() {\n-        this.diagnostics.sort(new DiagnosticComparator());\n+    public Set<Diagnostic> getDiagnostics() {\n         return this.diagnostics;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjAzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521822032", "bodyText": "Shall we use the visitor pattern for validations? Each separate validator is a new visitor.", "author": "SupunS", "createdAt": "2020-11-12T04:01:34Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyODQ3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521828475", "bodyText": "Can we call this a C2CSchemaValidator?", "author": "SupunS", "createdAt": "2020-11-12T04:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTY1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r522849653", "bodyText": "This class contains Type related validations of toml. its not Toml specific.", "author": "xlight05", "createdAt": "2020-11-13T10:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\ndeleted file mode 100644\nindex 4a3e71ffdbc..00000000000\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\n+++ /dev/null\n\n@@ -1,132 +0,0 @@\n-/*\n- * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- * WSO2 Inc. licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package io.ballerina.toml.validator.models;\n-\n-import io.ballerina.toml.semantic.TomlType;\n-import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n-import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n-import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n-import io.ballerina.toml.semantic.ast.TomlValueNode;\n-import io.ballerina.toml.semantic.ast.TopLevelNode;\n-import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n-import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n-import io.ballerina.tools.diagnostics.Diagnostic;\n-import io.ballerina.tools.diagnostics.DiagnosticInfo;\n-import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-\n-/**\n- * Contains the validation logic related to Type checking and type related validations.\n- *\n- * @since 2.0.0\n- */\n-public class Type implements Command {\n-\n-    private final Schema schema;\n-    private final TopLevelNode topLevelNode;\n-\n-    public Type(Schema schema, TopLevelNode topLevelNode) {\n-        this.schema = schema;\n-        this.topLevelNode = topLevelNode;\n-    }\n-\n-    @Override\n-    public List<Diagnostic> apply() {\n-        List<Diagnostic> diagnostics = new ArrayList<>();\n-\n-        if (topLevelNode == null) {\n-            return diagnostics;\n-        }\n-\n-        if (schema.getType().equals(\"object\")) {\n-            if (topLevelNode.kind() != TomlType.TABLE) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else if (schema.getType().equals(\"array\")) {\n-            if (!(topLevelNode.kind() == TomlType.TABLE_ARRAY || topLevelNode.kind() == TomlType.ARRAY)) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Array Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else {\n-            TomlValueNode tomlValue = ((TomlKeyValueNode) topLevelNode).value();\n-            if (schema.getType().equals(\"string\")) {\n-                if (tomlValue.kind() != TomlType.STRING) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"String Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getPattern() != null) {\n-                        if (!Pattern.compile(schema.getPattern()).matcher(((TomlStringValueNode) tomlValue).getValue())\n-                                .matches()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0003\", \"error\" +\n-                                            \".regex.mismatch\",\n-                                    DiagnosticSeverity.ERROR,\n-                                    \"Value does not match the Regex provided in Schema \" + schema.getPattern());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"integer\")) {\n-                if (tomlValue.kind() != TomlType.INTEGER) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Integer Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getMaximum() != null) {\n-                        Long maxValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (maxValue >= schema.getMaximum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0005\", \"error\" +\n-                                            \".maximum.value.exceed\", DiagnosticSeverity.ERROR, \"Value can't be higher\" +\n-                                    \" than \" + schema.getMaximum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                    if (schema.getMinimum() != null) {\n-                        Long minValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (minValue <= schema.getMinimum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0004\", \"error\" +\n-                                            \".minimum.value.deceed\", DiagnosticSeverity.ERROR, \"Value can't be lower \" +\n-                                    \"than \" + schema.getMinimum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"boolean\")) {\n-                if (tomlValue.kind() != TomlType.BOOLEAN) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Boolean Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                }\n-            }\n-        }\n-        return diagnostics;\n-    }\n-\n-    private TomlDiagnostic getTomlDiagnostic(TomlNodeLocation location, String code, String template,\n-                                             DiagnosticSeverity severity, String message) {\n-        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(code, template, severity);\n-        return new TomlDiagnostic(location, diagnosticInfo, message);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMzIwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521823206", "bodyText": "Instead of returning diagnostics as a list, Can we append them to the TOML model then and there?", "author": "SupunS", "createdAt": "2020-11-12T04:03:31Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Contains the validation logic related to Type checking and type related validations.\n+ *\n+ * @since 2.0.0\n+ */\n+public class Type implements Command {\n+\n+    private final Schema schema;\n+    private final TopLevelNode topLevelNode;\n+\n+    public Type(Schema schema, TopLevelNode topLevelNode) {\n+        this.schema = schema;\n+        this.topLevelNode = topLevelNode;\n+    }\n+\n+    @Override\n+    public List<Diagnostic> apply() {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\ndeleted file mode 100644\nindex 4a3e71ffdbc..00000000000\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\n+++ /dev/null\n\n@@ -1,132 +0,0 @@\n-/*\n- * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- * WSO2 Inc. licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package io.ballerina.toml.validator.models;\n-\n-import io.ballerina.toml.semantic.TomlType;\n-import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n-import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n-import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n-import io.ballerina.toml.semantic.ast.TomlValueNode;\n-import io.ballerina.toml.semantic.ast.TopLevelNode;\n-import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n-import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n-import io.ballerina.tools.diagnostics.Diagnostic;\n-import io.ballerina.tools.diagnostics.DiagnosticInfo;\n-import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-\n-/**\n- * Contains the validation logic related to Type checking and type related validations.\n- *\n- * @since 2.0.0\n- */\n-public class Type implements Command {\n-\n-    private final Schema schema;\n-    private final TopLevelNode topLevelNode;\n-\n-    public Type(Schema schema, TopLevelNode topLevelNode) {\n-        this.schema = schema;\n-        this.topLevelNode = topLevelNode;\n-    }\n-\n-    @Override\n-    public List<Diagnostic> apply() {\n-        List<Diagnostic> diagnostics = new ArrayList<>();\n-\n-        if (topLevelNode == null) {\n-            return diagnostics;\n-        }\n-\n-        if (schema.getType().equals(\"object\")) {\n-            if (topLevelNode.kind() != TomlType.TABLE) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else if (schema.getType().equals(\"array\")) {\n-            if (!(topLevelNode.kind() == TomlType.TABLE_ARRAY || topLevelNode.kind() == TomlType.ARRAY)) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Array Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else {\n-            TomlValueNode tomlValue = ((TomlKeyValueNode) topLevelNode).value();\n-            if (schema.getType().equals(\"string\")) {\n-                if (tomlValue.kind() != TomlType.STRING) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"String Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getPattern() != null) {\n-                        if (!Pattern.compile(schema.getPattern()).matcher(((TomlStringValueNode) tomlValue).getValue())\n-                                .matches()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0003\", \"error\" +\n-                                            \".regex.mismatch\",\n-                                    DiagnosticSeverity.ERROR,\n-                                    \"Value does not match the Regex provided in Schema \" + schema.getPattern());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"integer\")) {\n-                if (tomlValue.kind() != TomlType.INTEGER) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Integer Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getMaximum() != null) {\n-                        Long maxValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (maxValue >= schema.getMaximum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0005\", \"error\" +\n-                                            \".maximum.value.exceed\", DiagnosticSeverity.ERROR, \"Value can't be higher\" +\n-                                    \" than \" + schema.getMaximum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                    if (schema.getMinimum() != null) {\n-                        Long minValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (minValue <= schema.getMinimum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0004\", \"error\" +\n-                                            \".minimum.value.deceed\", DiagnosticSeverity.ERROR, \"Value can't be lower \" +\n-                                    \"than \" + schema.getMinimum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"boolean\")) {\n-                if (tomlValue.kind() != TomlType.BOOLEAN) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Boolean Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                }\n-            }\n-        }\n-        return diagnostics;\n-    }\n-\n-    private TomlDiagnostic getTomlDiagnostic(TomlNodeLocation location, String code, String template,\n-                                             DiagnosticSeverity severity, String message) {\n-        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(code, template, severity);\n-        return new TomlDiagnostic(location, diagnosticInfo, message);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNTAxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521825018", "bodyText": "Can we have a better name for AdditionalProperties?", "author": "SupunS", "createdAt": "2020-11-12T04:06:18Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/AdditionalProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Contains the validation logic for AdditionalProperties in the JSON schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class AdditionalProperties implements Command {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/AdditionalProperties.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/validations/AdditionalPropertiesVisitor.java\nsimilarity index 66%\nrename from misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/AdditionalProperties.java\nrename to misc/toml-parser/src/main/java/io/ballerina/toml/validator/validations/AdditionalPropertiesVisitor.java\nindex 32787522830..21abe8512ab 100644\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/AdditionalProperties.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/validations/AdditionalPropertiesVisitor.java\n\n@@ -16,45 +16,39 @@\n  * under the License.\n  */\n \n-package io.ballerina.toml.validator.models;\n+package io.ballerina.toml.validator.validations;\n \n-import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n import io.ballerina.toml.semantic.ast.TomlTableNode;\n import io.ballerina.toml.semantic.ast.TopLevelNode;\n import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.validator.Schema;\n import io.ballerina.tools.diagnostics.Diagnostic;\n import io.ballerina.tools.diagnostics.DiagnosticInfo;\n import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n \n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n /**\n- * Contains the validation logic for AdditionalProperties in the JSON schema.\n+ * Visitor to validate additional properties field in json schema.\n  *\n  * @since 2.0.0\n  */\n-public class AdditionalProperties implements Command {\n+public class AdditionalPropertiesVisitor implements TomlNodeVisitor {\n+    Schema schema;\n+    Set<Diagnostic> diagnostics;\n \n-    private final Schema schema;\n-    private final TopLevelNode topLevelNode;\n-\n-    public AdditionalProperties(Schema schema, TopLevelNode topLevelNode) {\n+    public AdditionalPropertiesVisitor(Set<Diagnostic> diagnostics, Schema schema) {\n+        this.diagnostics = diagnostics;\n         this.schema = schema;\n-        this.topLevelNode = topLevelNode;\n     }\n \n     @Override\n-    public List<Diagnostic> apply() {\n-        List<Diagnostic> diagnostics = new ArrayList<>();\n-\n-        if (schema.getType().equals(\"object\") && !schema.isAdditionalProperties() && topLevelNode != null\n-                && topLevelNode.kind() == TomlType.TABLE) {\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (!schema.isAdditionalProperties()) {\n             Map<String, Schema> properties = schema.getProperties();\n-\n-            Map<String, TopLevelNode> children = ((TomlTableNode) topLevelNode).children();\n+            Map<String, TopLevelNode> children = tomlTableNode.children();\n             Set<Map.Entry<String, TopLevelNode>> entries = children.entrySet();\n             for (Map.Entry<String, TopLevelNode> subEntry : entries) {\n                 if (!properties.containsKey(subEntry.getKey())) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNjk1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521826954", "bodyText": "Add java-docs for all public APIs", "author": "SupunS", "createdAt": "2020-11-12T04:09:22Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+/**\n+ * Represents deserialized version of a Json Schema.\n+ */\n+public class Schema {\n+    @SerializedName(\"$schema\")\n+    private String schema;\n+    private String title;\n+    private String description;\n+    private String type;\n+    private boolean additionalProperties;\n+    private Map<String, Schema> properties;\n+    private Schema items;\n+    private Integer minimum;\n+    private Integer maximum;\n+    private String pattern;\n+\n+    private Schema () {}\n+\n+    public static Schema from(Path jsonPath) throws IOException {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\nsimilarity index 82%\nrename from misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\nrename to misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\nindex cb6f83020b4..7600fb572fd 100644\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\n\n@@ -16,7 +16,7 @@\n  * under the License.\n  */\n \n-package io.ballerina.toml.validator.models;\n+package io.ballerina.toml.validator;\n \n import com.google.gson.Gson;\n import com.google.gson.annotations.SerializedName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNzIwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521827200", "bodyText": "Missing @since", "author": "SupunS", "createdAt": "2020-11-12T04:09:45Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+/**\n+ * Represents deserialized version of a Json Schema.\n+ */\n+public class Schema {", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\nsimilarity index 82%\nrename from misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\nrename to misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\nindex cb6f83020b4..7600fb572fd 100644\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Schema.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/Schema.java\n\n@@ -16,7 +16,7 @@\n  * under the License.\n  */\n \n-package io.ballerina.toml.validator.models;\n+package io.ballerina.toml.validator;\n \n import com.google.gson.Gson;\n import com.google.gson.annotations.SerializedName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyOTMwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r521829309", "bodyText": "Since this is a C2C specific validator implementation, I think this should go to the C2C repo.\nThe base validator framework can be moved to the toml-parser module itself.", "author": "SupunS", "createdAt": "2020-11-12T04:17:14Z", "path": "misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.models;", "originalCommit": "735b35e4ad3f152d36632484187926ce0403c8cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NTkxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r522295919", "bodyText": "This is not a C2C specific implementation. We use C2C as a test case, other than that, all the source code is entirely independent and can be used with any json schema and toml file.\nThat means we'll move everything to toml parser module right?", "author": "xlight05", "createdAt": "2020-11-12T17:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyOTMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "fb41946970d61a8ef366e9b8501b393ecdab712d", "chunk": "diff --git a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java b/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\ndeleted file mode 100644\nindex 4a3e71ffdbc..00000000000\n--- a/misc/toml-validator/src/main/java/io/ballerina/toml/validator/models/Type.java\n+++ /dev/null\n\n@@ -1,132 +0,0 @@\n-/*\n- * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- * WSO2 Inc. licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package io.ballerina.toml.validator.models;\n-\n-import io.ballerina.toml.semantic.TomlType;\n-import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n-import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n-import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n-import io.ballerina.toml.semantic.ast.TomlValueNode;\n-import io.ballerina.toml.semantic.ast.TopLevelNode;\n-import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n-import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n-import io.ballerina.tools.diagnostics.Diagnostic;\n-import io.ballerina.tools.diagnostics.DiagnosticInfo;\n-import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-\n-/**\n- * Contains the validation logic related to Type checking and type related validations.\n- *\n- * @since 2.0.0\n- */\n-public class Type implements Command {\n-\n-    private final Schema schema;\n-    private final TopLevelNode topLevelNode;\n-\n-    public Type(Schema schema, TopLevelNode topLevelNode) {\n-        this.schema = schema;\n-        this.topLevelNode = topLevelNode;\n-    }\n-\n-    @Override\n-    public List<Diagnostic> apply() {\n-        List<Diagnostic> diagnostics = new ArrayList<>();\n-\n-        if (topLevelNode == null) {\n-            return diagnostics;\n-        }\n-\n-        if (schema.getType().equals(\"object\")) {\n-            if (topLevelNode.kind() != TomlType.TABLE) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else if (schema.getType().equals(\"array\")) {\n-            if (!(topLevelNode.kind() == TomlType.TABLE_ARRAY || topLevelNode.kind() == TomlType.ARRAY)) {\n-                TomlDiagnostic diagnostic = getTomlDiagnostic(topLevelNode.location(), \"TVE0002\", \"error.invalid.type\",\n-                        DiagnosticSeverity.ERROR, \"Table Array Expected. Found \" + topLevelNode.kind().toString());\n-                diagnostics.add(diagnostic);\n-            }\n-        } else {\n-            TomlValueNode tomlValue = ((TomlKeyValueNode) topLevelNode).value();\n-            if (schema.getType().equals(\"string\")) {\n-                if (tomlValue.kind() != TomlType.STRING) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"String Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getPattern() != null) {\n-                        if (!Pattern.compile(schema.getPattern()).matcher(((TomlStringValueNode) tomlValue).getValue())\n-                                .matches()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0003\", \"error\" +\n-                                            \".regex.mismatch\",\n-                                    DiagnosticSeverity.ERROR,\n-                                    \"Value does not match the Regex provided in Schema \" + schema.getPattern());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"integer\")) {\n-                if (tomlValue.kind() != TomlType.INTEGER) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Integer Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                } else {\n-                    if (schema.getMaximum() != null) {\n-                        Long maxValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (maxValue >= schema.getMaximum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0005\", \"error\" +\n-                                            \".maximum.value.exceed\", DiagnosticSeverity.ERROR, \"Value can't be higher\" +\n-                                    \" than \" + schema.getMaximum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                    if (schema.getMinimum() != null) {\n-                        Long minValue = ((TomlLongValueNode) tomlValue).getValue();\n-                        if (minValue <= schema.getMinimum()) {\n-                            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0004\", \"error\" +\n-                                            \".minimum.value.deceed\", DiagnosticSeverity.ERROR, \"Value can't be lower \" +\n-                                    \"than \" + schema.getMinimum());\n-                            diagnostics.add(diagnostic);\n-                        }\n-                    }\n-                }\n-            } else if (schema.getType().equals(\"boolean\")) {\n-                if (tomlValue.kind() != TomlType.BOOLEAN) {\n-                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlValue.location(), \"TVE0002\", \"error.invalid.type\",\n-                            DiagnosticSeverity.ERROR, \"Boolean Expected. Found \" + tomlValue.kind().toString());\n-                    diagnostics.add(diagnostic);\n-                }\n-            }\n-        }\n-        return diagnostics;\n-    }\n-\n-    private TomlDiagnostic getTomlDiagnostic(TomlNodeLocation location, String code, String template,\n-                                             DiagnosticSeverity severity, String message) {\n-        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(code, template, severity);\n-        return new TomlDiagnostic(location, diagnosticInfo, message);\n-    }\n-}\n"}}, {"oid": "fb41946970d61a8ef366e9b8501b393ecdab712d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb41946970d61a8ef366e9b8501b393ecdab712d", "message": "Move toml validator into toml parser", "committedDate": "2020-11-13T10:35:39Z", "type": "forcePushed"}, {"oid": "2bb042bc2a4e4f662b3761996071b8e1c0bd3aa5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2bb042bc2a4e4f662b3761996071b8e1c0bd3aa5", "message": "Remove Ballerina lang dependancy", "committedDate": "2020-11-15T12:28:32Z", "type": "forcePushed"}, {"oid": "d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d241cf7d09135a267ebfa2e18dd9ceb551d829ff", "message": "Improve validator error messages", "committedDate": "2020-11-15T17:13:44Z", "type": "forcePushed"}, {"oid": "99c1f91e783f80a1e18990b522bf585e50df8a73", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99c1f91e783f80a1e18990b522bf585e50df8a73", "message": "Introduce one visitor instead of having multiple visitors for each validations", "committedDate": "2020-11-18T13:24:18Z", "type": "forcePushed"}, {"oid": "df22a7272687960ca6a77f0054ed275dafee64a7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df22a7272687960ca6a77f0054ed275dafee64a7", "message": "Make AST Visitor abstract class", "committedDate": "2020-11-19T05:10:40Z", "type": "forcePushed"}, {"oid": "2a0f237f1364351f1a305b6aa1a2cbb7dcf5671d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a0f237f1364351f1a305b6aa1a2cbb7dcf5671d", "message": "Initial Impl of Toml Validator\n\nMove toml validator into toml parser", "committedDate": "2020-11-19T09:03:44Z", "type": "commit"}, {"oid": "e88e4d88108b11607f08c1b5448818759f778b98", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e88e4d88108b11607f08c1b5448818759f778b98", "message": "Make ast nodes store diagnostics", "committedDate": "2020-11-19T09:03:44Z", "type": "commit"}, {"oid": "e0a952d8c1b206b7e6003be6504564d4554794a2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e0a952d8c1b206b7e6003be6504564d4554794a2", "message": "Add hierarchical schemas", "committedDate": "2020-11-19T09:03:44Z", "type": "commit"}, {"oid": "dfd443c9b29690575d2a7ee9c241ed56253f4b0e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dfd443c9b29690575d2a7ee9c241ed56253f4b0e", "message": "Introduce one visitor instead of having multiple visitors for each validations", "committedDate": "2020-11-19T09:03:44Z", "type": "commit"}, {"oid": "4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "message": "Make AST Visitor abstract class", "committedDate": "2020-11-19T09:03:44Z", "type": "commit"}, {"oid": "4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e52cd5571f73c88ed5c1706c22ed418a36cc0c0", "message": "Make AST Visitor abstract class", "committedDate": "2020-11-19T09:03:44Z", "type": "forcePushed"}, {"oid": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cdb11e327e94a5d61713ea806ea31a91833ec3a", "message": "Address review suggestions", "committedDate": "2020-11-19T11:56:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5MzU5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527393591", "bodyText": "Remove the commented out codes", "author": "SupunS", "createdAt": "2020-11-20T04:41:20Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java", "diffHunk": "@@ -32,29 +33,38 @@\n public abstract class TomlNode implements Node {\n \n     private final TomlType kind;\n-    private final List<TomlDiagnostic> diagnostics;\n-    private final TomlNodeLocation location; //The position of this node in the source file.\n+    private final TomlNodeLocation location;\n+    protected Set<Diagnostic> diagnostics;\n \n     public TomlNode(TomlType kind, TomlNodeLocation location) {\n-        this.diagnostics = new ArrayList<>();\n         this.kind = kind;\n         this.location = location;\n+        diagnostics = new TreeSet<>(new DiagnosticComparator());\n+//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n \n-    public List<TomlDiagnostic> diagnostics() {\n+    public Set<Diagnostic> diagnostics() {\n         return diagnostics;\n     }\n \n-    public void addDiagnostic(TomlDiagnostic diagnostic) {\n+    public void addDiagnostic(Diagnostic diagnostic) {\n         diagnostics.add(diagnostic);\n     }\n \n     public TomlNodeLocation location() {\n         return location;\n     }\n \n+//    private void copySyntaxDiagnostics() {\n+//        if (stNode != null && stNode.hasDiagnostics()) {\n+//            for (Diagnostic diagnostic : stNode.diagnostics()) {\n+//                this.addDiagnostic(diagnostic);\n+//            }\n+//        }\n+//    }", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\nindex 31299bd3277..d276f6e724b 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\n\n@@ -40,7 +41,6 @@ public abstract class TomlNode implements Node {\n         this.kind = kind;\n         this.location = location;\n         diagnostics = new TreeSet<>(new DiagnosticComparator());\n-//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NDA4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527394082", "bodyText": "Its better for the API to return a List<Diagnostic>", "author": "SupunS", "createdAt": "2020-11-20T04:43:04Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java", "diffHunk": "@@ -32,29 +33,38 @@\n public abstract class TomlNode implements Node {\n \n     private final TomlType kind;\n-    private final List<TomlDiagnostic> diagnostics;\n-    private final TomlNodeLocation location; //The position of this node in the source file.\n+    private final TomlNodeLocation location;\n+    protected Set<Diagnostic> diagnostics;\n \n     public TomlNode(TomlType kind, TomlNodeLocation location) {\n-        this.diagnostics = new ArrayList<>();\n         this.kind = kind;\n         this.location = location;\n+        diagnostics = new TreeSet<>(new DiagnosticComparator());\n+//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n \n-    public List<TomlDiagnostic> diagnostics() {\n+    public Set<Diagnostic> diagnostics() {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\nindex 31299bd3277..d276f6e724b 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlNode.java\n\n@@ -40,7 +41,6 @@ public abstract class TomlNode implements Node {\n         this.kind = kind;\n         this.location = location;\n         diagnostics = new TreeSet<>(new DiagnosticComparator());\n-//        copySyntaxDiagnostics();\n     }\n \n     public abstract void accept(TomlNodeVisitor visitor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NDY5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527394697", "bodyText": "Lets follow the early-exit pattern for if-else conditions", "author": "SupunS", "createdAt": "2020-11-20T04:45:39Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTQ0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527395441", "bodyText": "Let's follow a similar approach that is used in the parser and compiler to log diagnostics, using diagnostic codes and templates.", "author": "SupunS", "createdAt": "2020-11-20T04:48:48Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                            tomlLongValueNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlLongValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void lookupNode(TomlNode node) {\n+        AbstractSchema previousSchema = this.schema;\n+        String previousKey = this.key;\n+        node.accept(this);\n+        this.schema = previousSchema;\n+        this.key = previousKey;\n+    }\n+\n+    private TomlDiagnostic getTomlDiagnostic(TomlNodeLocation location, String code, String template,", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU3NDk2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527574961", "bodyText": "Is it ok if we do this in a separate PR? there are some things that needs to be discussed.", "author": "xlight05", "createdAt": "2020-11-20T09:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjI4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527582280", "bodyText": "Yea, that should be fine", "author": "SupunS", "createdAt": "2020-11-20T10:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYwMjc4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527602782", "bodyText": "#27041", "author": "xlight05", "createdAt": "2020-11-20T10:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTQ0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTkyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527395921", "bodyText": "lookupNode -> visitNode", "author": "SupunS", "createdAt": "2020-11-20T04:50:37Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                            tomlLongValueNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlLongValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void lookupNode(TomlNode node) {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NjQwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527396408", "bodyText": "This seems to not correct. You are caching the state only after changing it. So what you cache is the changed state, not the original state.", "author": "SupunS", "createdAt": "2020-11-20T04:52:18Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NzQxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527397418", "bodyText": "A visitor should be visited using child.accept(this)", "author": "SupunS", "createdAt": "2020-11-20T04:56:18Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODM3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398376", "bodyText": "variable name abstractSchema is a bit misleading. Shall we call it just schema?", "author": "SupunS", "createdAt": "2020-11-20T05:00:07Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODY2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398664", "bodyText": "Usually a table has 'entries'\nSo better to change tableChildren -> tableEntries\nIt would also be better to change the method name as well x.children() to x.entries()", "author": "SupunS", "createdAt": "2020-11-20T05:01:10Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5ODk5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527398990", "bodyText": "propertyEntry -> tableEntry", "author": "SupunS", "createdAt": "2020-11-20T05:02:19Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527401038", "bodyText": "additionalProperties -> hasAdditionalProperties", "author": "SupunS", "createdAt": "2020-11-20T05:10:15Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * Represents Object schema in JSON schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class ObjectSchema extends AbstractSchema {\n+    private String description;\n+    private boolean additionalProperties;\n+    private Map<String, AbstractSchema> properties;\n+\n+    public ObjectSchema(Type type) {\n+        super(type);\n+        this.additionalProperties = true;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    public ObjectSchema(Type type, Map<String, AbstractSchema> properties) {\n+        super(type);\n+        this.additionalProperties = true;\n+        this.properties = properties;\n+    }\n+\n+    public ObjectSchema(Type type, String description, boolean additionalProperties,\n+                        Map<String, AbstractSchema> properties) {\n+        super(type);\n+        this.description = description;\n+        this.additionalProperties = additionalProperties;\n+        this.properties = properties;\n+    }\n+\n+    public Optional<String> description() {\n+        return Optional.ofNullable(description);\n+    }\n+\n+    public boolean hasAdditionalProperties() {\n+        return additionalProperties;", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java\nindex b476c812604..9add795beed 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/ObjectSchema.java\n\n@@ -29,26 +29,26 @@ import java.util.Optional;\n  */\n public class ObjectSchema extends AbstractSchema {\n     private String description;\n-    private boolean additionalProperties;\n+    private boolean hasAdditionalProperties;\n     private Map<String, AbstractSchema> properties;\n \n     public ObjectSchema(Type type) {\n         super(type);\n-        this.additionalProperties = true;\n+        this.hasAdditionalProperties = true;\n         this.properties = new HashMap<>();\n     }\n \n     public ObjectSchema(Type type, Map<String, AbstractSchema> properties) {\n         super(type);\n-        this.additionalProperties = true;\n+        this.hasAdditionalProperties = true;\n         this.properties = properties;\n     }\n \n-    public ObjectSchema(Type type, String description, boolean additionalProperties,\n+    public ObjectSchema(Type type, String description, boolean hasAdditionalProperties,\n                         Map<String, AbstractSchema> properties) {\n         super(type);\n         this.description = description;\n-        this.additionalProperties = additionalProperties;\n+        this.hasAdditionalProperties = hasAdditionalProperties;\n         this.properties = properties;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527401783", "bodyText": "items -> memberSchema", "author": "SupunS", "createdAt": "2020-11-20T05:12:55Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMjcyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527402722", "bodyText": "Here we are traversing the diagnostics again.\nInstead, can't we add the diagnostics to the node itself directly?", "author": "SupunS", "createdAt": "2020-11-20T05:16:30Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+        } else {\n+            ObjectSchema objectSchema = (ObjectSchema) schema;\n+            Map<String, AbstractSchema> properties = objectSchema.properties();\n+            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n+            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n+                String key = propertyEntry.getKey();\n+                TopLevelNode value = propertyEntry.getValue();\n+                AbstractSchema abstractSchema = properties.get(key);\n+                if (abstractSchema != null) {\n+                    this.schema = abstractSchema;\n+                    this.key = key;\n+                    lookupNode(value);\n+                } else {\n+                    if (!objectSchema.hasAdditionalProperties()) {\n+                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                                DiagnosticSeverity.WARNING);\n+                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                        tomlTableNode.addDiagnostic(diagnostic);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+        } else {\n+            ArraySchema arraySchema = (ArraySchema) schema;\n+            AbstractSchema items = arraySchema.items();\n+            List<TomlTableNode> children = tomlTableArrayNode.children();\n+            for (TomlTableNode child : children) {\n+                this.schema = items;\n+                visit(child);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        lookupNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        lookupNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+        } else {\n+            StringSchema stringSchema = (StringSchema) this.schema;\n+            if (stringSchema.pattern().isPresent()) {\n+                String pattern = stringSchema.pattern().get();\n+                if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                    TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                            \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                    pattern));\n+                    tomlStringValueNode.addDiagnostic(diagnostic);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+        } else {\n+            List<Diagnostic> diagnostics =\n+                    validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                            tomlDoubleValueNodeNode.location());\n+            for (Diagnostic diagnostic : diagnostics) {\n+                tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            }", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\nindex cc83928304e..737f4cd33e2 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java\n\n@@ -68,27 +68,25 @@ public class SchemaValidator extends TomlNodeVisitor {\n                     DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n                             schema.type()));\n             tomlTableNode.addDiagnostic(diagnostic);\n-        } else {\n-            ObjectSchema objectSchema = (ObjectSchema) schema;\n-            Map<String, AbstractSchema> properties = objectSchema.properties();\n-            Map<String, TopLevelNode> tableChildren = tomlTableNode.children();\n-            for (Map.Entry<String, TopLevelNode> propertyEntry : tableChildren.entrySet()) {\n-                String key = propertyEntry.getKey();\n-                TopLevelNode value = propertyEntry.getValue();\n-                AbstractSchema abstractSchema = properties.get(key);\n-                if (abstractSchema != null) {\n-                    this.schema = abstractSchema;\n-                    this.key = key;\n-                    lookupNode(value);\n-                } else {\n-                    if (!objectSchema.hasAdditionalProperties()) {\n-                        DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n-                                DiagnosticSeverity.WARNING);\n-                        TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n-                                \"Unexpected Property \\\"\" + key + \"\\\"\");\n-                        tomlTableNode.addDiagnostic(diagnostic);\n-                    }\n-                }\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMzU3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527403574", "bodyText": "We should throw our own exception here. Throwing an exception from  the gson library is not correct.", "author": "SupunS", "createdAt": "2020-11-20T05:19:58Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\nindex 6d7f25e6ba0..e6dd42b1ebb 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n\n@@ -22,7 +22,6 @@ import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonObject;\n-import com.google.gson.JsonParseException;\n \n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMzg0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527403848", "bodyText": "Shall we move all these hardcoded strings to constants?", "author": "SupunS", "createdAt": "2020-11-20T05:21:00Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");\n+        }\n+    }\n+\n+    private ObjectSchema getObjectSchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement descriptionProperty = jsonObj.get(\"description\");\n+        String description = descriptionProperty != null ? descriptionProperty.getAsString() : null;\n+        JsonElement additionalProperty = jsonObj.get(\"additionalProperties\");\n+        boolean additionalProperties = additionalProperty == null || additionalProperty.getAsBoolean();\n+        JsonObject properties = jsonObj.get(\"properties\").getAsJsonObject();\n+        Set<Map.Entry<String, JsonElement>> entries = properties.entrySet();\n+        Map<String, AbstractSchema> propertiesList = new HashMap<>();\n+        for (Map.Entry<String, JsonElement> entry : entries) {\n+            String key = entry.getKey();\n+            AbstractSchema\n+                    abstractSchema = jsonDeserializationContext.deserialize(entry.getValue(), AbstractSchema.class);\n+            propertiesList.put(key, abstractSchema);\n+        }\n+        return new ObjectSchema(Type.OBJECT, description, additionalProperties, propertiesList);\n+    }\n+\n+    private AbstractSchema getArraySchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement items = jsonObj.get(\"items\").getAsJsonObject();\n+        AbstractSchema abstractSchema = jsonDeserializationContext.deserialize(items, AbstractSchema.class);\n+        return new ArraySchema(Type.ARRAY, abstractSchema);\n+    }\n+\n+    private StringSchema getStringSchema(JsonObject jsonObj) {\n+        JsonElement patternProperty = jsonObj.get(\"pattern\");\n+        String pattern = patternProperty != null ? patternProperty.getAsString() : null;\n+        return new StringSchema(Type.STRING, pattern);\n+    }\n+\n+    private NumericSchema getNumericSchema(JsonObject jsonObj, Type type) {\n+        JsonElement minimumProperty = jsonObj.get(\"minimum\");\n+        Double minimum = minimumProperty != null ? minimumProperty.getAsDouble() : null;\n+        JsonElement maximumProperty = jsonObj.get(\"maximum\");", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\nindex 6d7f25e6ba0..e6dd42b1ebb 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n\n@@ -22,7 +22,6 @@ import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonObject;\n-import com.google.gson.JsonParseException;\n \n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwOTgyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527409828", "bodyText": "Trying to get as double without checking the value first can lead to runtime errors, such as ClassCastExceptions, NumberFormatExceptions, etc. So we need to do the validations first, and throw proper errors.\nDo we have any negative test cases for the schema?", "author": "SupunS", "createdAt": "2020-11-20T05:28:05Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    @Override\n+    public AbstractSchema deserialize(JsonElement jsonElement, java.lang.reflect.Type refType,\n+                                      JsonDeserializationContext jsonDeserializationContext)\n+            throws JsonParseException {\n+        JsonObject jsonObj = jsonElement.getAsJsonObject();\n+        String type = jsonObj.get(\"type\").getAsString();\n+        switch (type) {\n+            case \"object\":\n+                return getObjectSchema(jsonDeserializationContext, jsonObj);\n+            case \"array\":\n+                return getArraySchema(jsonDeserializationContext, jsonObj);\n+            case \"integer\":\n+                return getNumericSchema(jsonObj, Type.INTEGER);\n+            case \"number\":\n+                return getNumericSchema(jsonObj, Type.NUMBER);\n+            case \"string\":\n+                return getStringSchema(jsonObj);\n+            case \"boolean\":\n+                return new BooleanSchema(Type.BOOLEAN);\n+            default:\n+                throw new JsonParseException(\"type \" + type + \" is not supported type\");\n+        }\n+    }\n+\n+    private ObjectSchema getObjectSchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement descriptionProperty = jsonObj.get(\"description\");\n+        String description = descriptionProperty != null ? descriptionProperty.getAsString() : null;\n+        JsonElement additionalProperty = jsonObj.get(\"additionalProperties\");\n+        boolean additionalProperties = additionalProperty == null || additionalProperty.getAsBoolean();\n+        JsonObject properties = jsonObj.get(\"properties\").getAsJsonObject();\n+        Set<Map.Entry<String, JsonElement>> entries = properties.entrySet();\n+        Map<String, AbstractSchema> propertiesList = new HashMap<>();\n+        for (Map.Entry<String, JsonElement> entry : entries) {\n+            String key = entry.getKey();\n+            AbstractSchema\n+                    abstractSchema = jsonDeserializationContext.deserialize(entry.getValue(), AbstractSchema.class);\n+            propertiesList.put(key, abstractSchema);\n+        }\n+        return new ObjectSchema(Type.OBJECT, description, additionalProperties, propertiesList);\n+    }\n+\n+    private AbstractSchema getArraySchema(JsonDeserializationContext jsonDeserializationContext, JsonObject jsonObj) {\n+        JsonElement items = jsonObj.get(\"items\").getAsJsonObject();\n+        AbstractSchema abstractSchema = jsonDeserializationContext.deserialize(items, AbstractSchema.class);\n+        return new ArraySchema(Type.ARRAY, abstractSchema);\n+    }\n+\n+    private StringSchema getStringSchema(JsonObject jsonObj) {\n+        JsonElement patternProperty = jsonObj.get(\"pattern\");\n+        String pattern = patternProperty != null ? patternProperty.getAsString() : null;\n+        return new StringSchema(Type.STRING, pattern);\n+    }\n+\n+    private NumericSchema getNumericSchema(JsonObject jsonObj, Type type) {\n+        JsonElement minimumProperty = jsonObj.get(\"minimum\");\n+        Double minimum = minimumProperty != null ? minimumProperty.getAsDouble() : null;", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU1OTM0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527559344", "bodyText": "Ack. As the initial implementation I wasn't concerned with the schema validations. Anyways I've implemented validations for basic data types for now and test cases for them. We need to implement validations for required and optional fields as well. I will create a issue for this.", "author": "xlight05", "createdAt": "2020-11-20T09:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwOTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYwMzA2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527603069", "bodyText": "#27039", "author": "xlight05", "createdAt": "2020-11-20T10:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwOTgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\nindex 6d7f25e6ba0..e6dd42b1ebb 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java\n\n@@ -22,7 +22,6 @@ import com.google.gson.JsonDeserializationContext;\n import com.google.gson.JsonDeserializer;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonObject;\n-import com.google.gson.JsonParseException;\n \n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDk5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527410996", "bodyText": "Let's remove the get prefix from all methods.\nThis also should return a list.", "author": "SupunS", "createdAt": "2020-11-20T05:29:27Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,19 +206,23 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n+        List<TomlTableNode> childs = tomlTableArrayNode.children();\n         List<Toml> tomlList = new ArrayList<>();\n-        if (tableNode.kind() == TomlType.TABLE_ARRAY) {\n-            TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n-            List<TomlTableNode> childs = tomlTableArrayNode.children();\n-            for (TomlTableNode child : childs) {\n-                tomlList.add(new Toml(child));\n-            }\n-            return tomlList;\n+        for (TomlTableNode child : childs) {\n+            tomlList.add(new Toml(child));\n         }\n         return tomlList;\n     }\n \n-    public List<TomlDiagnostic> getDiagnostics() {\n+    public Set<Diagnostic> getDiagnostics() {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU2Mjk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527562980", "bodyText": "get prefix should exist for data retrieval methods such as get(), getTable() , getTables() for consistency right?\nFixed rootNode() and diagnostics().", "author": "xlight05", "createdAt": "2020-11-20T09:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjExOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527582119", "bodyText": "I see. ack.", "author": "SupunS", "createdAt": "2020-11-20T10:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex 436573023b5..686c408776a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -205,24 +210,26 @@ public class Toml {\n      * @return List of Tables\n      */\n     public List<Toml> getTables(String key) {\n-        TopLevelNode tableNode = rootNode.children().get(key);\n+        TopLevelNode tableNode = rootNode.entries().get(key);\n         if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n             return null;\n         }\n+\n         TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n         List<TomlTableNode> childs = tomlTableArrayNode.children();\n         List<Toml> tomlList = new ArrayList<>();\n         for (TomlTableNode child : childs) {\n             tomlList.add(new Toml(child));\n         }\n+\n         return tomlList;\n     }\n \n-    public Set<Diagnostic> getDiagnostics() {\n-        return this.rootNode.diagnostics();\n+    public List<Diagnostic> diagnostics() {\n+        return new ArrayList<>(this.rootNode.diagnostics());\n     }\n \n-    public TomlTableNode getRootNode() {\n+    public TomlTableNode rootNode() {\n         return rootNode;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMjkwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527412905", "bodyText": "rootSchema -> schema", "author": "SupunS", "createdAt": "2020-11-20T05:31:30Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +104,60 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n-     * Read TOML File using Reader.\n+     * Read TOML File using InputStream and validate against a json schema.\n      *\n-     * @param reader reader of the TOML file\n+     * @param inputStream InputStream of the TOML file\n+     * @param rootSchema Root schema of the validator\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString());\n+    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {\n+        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, rootSchema);\n     }\n \n     /**\n      * Parse TOML file using TOML String.\n      *\n      * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n      * @return TOML Object\n      */\n-    public static Toml read(String content) {\n+    public static Toml read(String content, String filePath) {\n         TextDocument textDocument = TextDocuments.from(content);\n-        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n-        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument, filePath);\n         TomlTransformer nodeTransformer = new TomlTransformer();\n         TomlTableNode\n                 transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n-        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n-        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        transformedTable.addSyntaxDiagnostics(reportSyntaxDiagnostics(syntaxTree));\n         return new Toml(transformedTable);\n     }\n \n-    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n-        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+    /**\n+     * Parse TOML file using TOML String and validate against a json schema.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @param filePath path of the TOML file\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content, String filePath, Schema rootSchema) {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMzI5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527413291", "bodyText": "Third parameter is missing in the doc comment", "author": "SupunS", "createdAt": "2020-11-20T05:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMjkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex 436573023b5..686c408776a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -111,12 +112,12 @@ public class Toml {\n      * Read TOML File using InputStream and validate against a json schema.\n      *\n      * @param inputStream InputStream of the TOML file\n-     * @param rootSchema Root schema of the validator\n+     * @param schema json schema to validate the toml against\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {\n-        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, rootSchema);\n+    public static Toml read(InputStream inputStream, Schema schema) throws IOException {\n+        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, schema);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMzk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527413978", "bodyText": "rootSchema -> schema", "author": "SupunS", "createdAt": "2020-11-20T05:32:44Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -82,45 +104,60 @@ public static Toml read(Path path) throws IOException {\n      * @throws IOException if file is not accessible\n      */\n     public static Toml read(InputStream inputStream) throws IOException {\n-        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+       return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null);\n     }\n \n     /**\n-     * Read TOML File using Reader.\n+     * Read TOML File using InputStream and validate against a json schema.\n      *\n-     * @param reader reader of the TOML file\n+     * @param inputStream InputStream of the TOML file\n+     * @param rootSchema Root schema of the validator\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(Reader reader) throws IOException {\n-        BufferedReader bufferedReader = new BufferedReader(reader);\n-        StringBuilder w = new StringBuilder();\n-        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n-            w.append(line).append('\\n');\n-        }\n-        return read(w.toString());\n+    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex 436573023b5..686c408776a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -111,12 +112,12 @@ public class Toml {\n      * Read TOML File using InputStream and validate against a json schema.\n      *\n      * @param inputStream InputStream of the TOML file\n-     * @param rootSchema Root schema of the validator\n+     * @param schema json schema to validate the toml against\n      * @return TOML Object\n      * @throws IOException if file is not accessible\n      */\n-    public static Toml read(InputStream inputStream, Schema rootSchema) throws IOException {\n-        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, rootSchema);\n+    public static Toml read(InputStream inputStream, Schema schema) throws IOException {\n+        return read(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8), null, schema);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxNDc5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527414794", "bodyText": "keep a newline after a block (if-else, while, etc)", "author": "SupunS", "createdAt": "2020-11-20T05:33:43Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -169,19 +206,23 @@ public Toml getTable(String key) {\n      */\n     public List<Toml> getTables(String key) {\n         TopLevelNode tableNode = rootNode.children().get(key);\n+        if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n+            return null;\n+        }\n+        TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;", "originalCommit": "2cdb11e327e94a5d61713ea806ea31a91833ec3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\nindex 436573023b5..686c408776a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java\n\n@@ -205,24 +210,26 @@ public class Toml {\n      * @return List of Tables\n      */\n     public List<Toml> getTables(String key) {\n-        TopLevelNode tableNode = rootNode.children().get(key);\n+        TopLevelNode tableNode = rootNode.entries().get(key);\n         if (tableNode == null || tableNode.kind() != TomlType.TABLE_ARRAY) {\n             return null;\n         }\n+\n         TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n         List<TomlTableNode> childs = tomlTableArrayNode.children();\n         List<Toml> tomlList = new ArrayList<>();\n         for (TomlTableNode child : childs) {\n             tomlList.add(new Toml(child));\n         }\n+\n         return tomlList;\n     }\n \n-    public Set<Diagnostic> getDiagnostics() {\n-        return this.rootNode.diagnostics();\n+    public List<Diagnostic> diagnostics() {\n+        return new ArrayList<>(this.rootNode.diagnostics());\n     }\n \n-    public TomlTableNode getRootNode() {\n+    public TomlTableNode rootNode() {\n         return rootNode;\n     }\n }\n"}}, {"oid": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/028b7c3f37457fa99dce57a0bacedf5476eb650a", "message": "Address Review comments", "committedDate": "2020-11-20T09:48:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxMzI2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527613269", "bodyText": "If we are not changing the states, no need to cache it either", "author": "SupunS", "createdAt": "2020-11-20T10:56:51Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/SchemaValidator.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator;\n+\n+import io.ballerina.toml.semantic.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.semantic.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlLongValueNode;\n+import io.ballerina.toml.semantic.ast.TomlNode;\n+import io.ballerina.toml.semantic.ast.TomlNodeVisitor;\n+import io.ballerina.toml.semantic.ast.TomlStringValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.validator.schema.AbstractSchema;\n+import io.ballerina.toml.validator.schema.ArraySchema;\n+import io.ballerina.toml.validator.schema.NumericSchema;\n+import io.ballerina.toml.validator.schema.ObjectSchema;\n+import io.ballerina.toml.validator.schema.Schema;\n+import io.ballerina.toml.validator.schema.StringSchema;\n+import io.ballerina.toml.validator.schema.Type;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Visitor to validate toml object against rules in json schema.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaValidator extends TomlNodeVisitor {\n+\n+    private AbstractSchema schema;\n+    private String key;\n+\n+    public SchemaValidator(Schema schema) {\n+        this.schema = schema;\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        if (schema.type() != Type.OBJECT) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlTableNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                    DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found object\", this.key,\n+                            schema.type()));\n+            tomlTableNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        ObjectSchema objectSchema = (ObjectSchema) schema;\n+        Map<String, AbstractSchema> properties = objectSchema.properties();\n+        Map<String, TopLevelNode> tableEntries = tomlTableNode.entries();\n+        for (Map.Entry<String, TopLevelNode> tableEntry : tableEntries.entrySet()) {\n+            String key = tableEntry.getKey();\n+            TopLevelNode value = tableEntry.getValue();\n+            AbstractSchema schema = properties.get(key);\n+            if (schema != null) {\n+                visitNode(value, schema, key);\n+                continue;\n+            }\n+            if (!objectSchema.hasAdditionalProperties()) {\n+                DiagnosticInfo diagnosticInfo = new DiagnosticInfo(\"TVE0001\", \"warn.unexpected.property\",\n+                        DiagnosticSeverity.WARNING);\n+                TomlDiagnostic diagnostic = new TomlDiagnostic(value.location(), diagnosticInfo,\n+                        \"Unexpected Property \\\"\" + key + \"\\\"\");\n+                tomlTableNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlTableArrayNode tomlTableArrayNode) {\n+        if (schema.type() != Type.ARRAY) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlTableArrayNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR, String.format(\"Key \\\"%s\\\" expects %s . Found array\", this.key,\n+                                    schema.type()));\n+            tomlTableArrayNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        ArraySchema arraySchema = (ArraySchema) schema;\n+        AbstractSchema memberSchema = arraySchema.items();\n+        List<TomlTableNode> children = tomlTableArrayNode.children();\n+        for (TomlTableNode child : children) {\n+            visitNode(child, memberSchema);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlKeyValueNode keyValue) {\n+        TomlValueNode value = keyValue.value();\n+        visitNode(value);\n+    }\n+\n+    @Override\n+    public void visit(TomlValueNode tomlValue) {\n+        visitNode(tomlValue);\n+    }\n+\n+    @Override\n+    public void visit(TomlStringValueNode tomlStringValueNode) {\n+        if (schema.type() != Type.STRING) {\n+            TomlDiagnostic diagnostic =\n+                    getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0002\", \"error.invalid.type\",\n+                            DiagnosticSeverity.ERROR,\n+                            String.format(\"Key \\\"%s\\\" expects %s . Found string\", this.key, schema.type()));\n+            tomlStringValueNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        StringSchema stringSchema = (StringSchema) this.schema;\n+        if (stringSchema.pattern().isPresent()) {\n+            String pattern = stringSchema.pattern().get();\n+            if (!Pattern.compile(pattern).matcher(tomlStringValueNode.getValue()).matches()) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(tomlStringValueNode.location(), \"TVE0003\",\n+                        \"error.regex.mismatch\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value does not match the Regex provided in Schema %s\", this.key,\n+                                pattern));\n+                tomlStringValueNode.addDiagnostic(diagnostic);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visit(TomlDoubleValueNodeNode tomlDoubleValueNodeNode) {\n+        if (schema.type() != Type.NUMBER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlDoubleValueNodeNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found number\", this.key, schema.type()));\n+            tomlDoubleValueNodeNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        List<Diagnostic> diagnostics =\n+                validateMinMaxValues((NumericSchema) schema, tomlDoubleValueNodeNode.getValue(),\n+                        tomlDoubleValueNodeNode.location());\n+        tomlDoubleValueNodeNode.addDiagnostics(diagnostics);\n+    }\n+\n+    @Override\n+    public void visit(TomlLongValueNode tomlLongValueNode) {\n+        if (schema.type() != Type.INTEGER) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlLongValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found integer\", this.key, schema.type()));\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+            return;\n+        }\n+        List<Diagnostic> diagnostics =\n+                validateMinMaxValues((NumericSchema) schema, Double.valueOf(tomlLongValueNode.getValue()),\n+                        tomlLongValueNode.location());\n+        for (Diagnostic diagnostic : diagnostics) {\n+            tomlLongValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private List<Diagnostic> validateMinMaxValues(NumericSchema numericSchema, Double value,\n+                                                  TomlNodeLocation location) {\n+        List<Diagnostic> diagnostics = new ArrayList<>();\n+        if (numericSchema.maximum().isPresent()) {\n+            Double max = numericSchema.maximum().get();\n+            if (value >= max) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0005\", \"error\" +\n+                                \".maximum.value.exceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be higher than %f\", this.key,\n+                                max));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        if (numericSchema.minimum().isPresent()) {\n+            Double min = numericSchema.minimum().get();\n+            if (value <= min) {\n+                TomlDiagnostic diagnostic = getTomlDiagnostic(location, \"TVE0004\",\n+                        \"error.minimum.value.deceed\", DiagnosticSeverity.ERROR,\n+                        String.format(\"Key \\\"%s\\\" value can't be lower than %f\", this.key,\n+                                min));\n+                diagnostics.add(diagnostic);\n+            }\n+        }\n+        return diagnostics;\n+    }\n+\n+    @Override\n+    public void visit(TomlBooleanValueNode tomlBooleanValueNode) {\n+        if (schema.type() != Type.BOOLEAN) {\n+            TomlDiagnostic diagnostic = getTomlDiagnostic(tomlBooleanValueNode.location(), \"TVE0002\",\n+                    \"error.invalid.type\", DiagnosticSeverity.ERROR,\n+                    String.format(\"Key \\\"%s\\\" expects %s . Found boolean\", this.key, schema.type()));\n+            tomlBooleanValueNode.addDiagnostic(diagnostic);\n+        }\n+    }\n+\n+    private void visitNode(TomlNode node) {\n+        AbstractSchema previousSchema = this.schema;\n+        String previousKey = this.key;\n+        node.accept(this);\n+        this.schema = previousSchema;\n+        this.key = previousKey;", "originalCommit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYxMzk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26717#discussion_r527613980", "bodyText": "all the constants should be private since they are not used anywhere else", "author": "SupunS", "createdAt": "2020-11-20T10:58:23Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/validator/schema/SchemaDeserializer.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.validator.schema;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for Deserializing abstract Schema nodes accordingly.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SchemaDeserializer implements JsonDeserializer<AbstractSchema> {\n+\n+    public static final String TYPE = \"type\";\n+    public static final String OBJECT = \"object\";\n+    public static final String ARRAY = \"array\";\n+    public static final String INTEGER = \"integer\";\n+    public static final String NUMBER = \"number\";\n+    public static final String STRING = \"string\";\n+    public static final String BOOLEAN = \"boolean\";\n+    public static final String DESCRIPTION = \"description\";\n+    public static final String ADDITIONAL_PROPERTIES = \"additionalProperties\";\n+    public static final String PROPERTIES = \"properties\";\n+    public static final String ITEMS = \"items\";\n+    public static final String PATTERN = \"pattern\";\n+    public static final String MINIMUM = \"minimum\";\n+    public static final String MAXIMUM = \"maximum\";", "originalCommit": "028b7c3f37457fa99dce57a0bacedf5476eb650a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}