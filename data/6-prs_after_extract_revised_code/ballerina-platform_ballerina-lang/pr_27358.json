{"pr_number": 27358, "pr_title": "Improve Numeric values, Literal Strings  few bug fixes for Toml Parser", "pr_createdAt": "2020-12-07T07:08:38Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMTMzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r538011330", "bodyText": "what would be the outcome for something like 004.12?", "author": "SupunS", "createdAt": "2020-12-08T03:44:08Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -570,7 +570,7 @@ private STToken processNumericLiteral(int startChar) {\n             type = SyntaxKind.IDENTIFIER_LITERAL;\n         }\n         // Integer cannot have a leading zero\n-        if (startChar == '0' && len > 1) {\n+        if (startChar == '0' && len > 1 && type == SyntaxKind.DECIMAL_INT_TOKEN) {", "originalCommit": "c879b94af140fa44adbfa4f163120293d72212a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a188e3797e6810fa539740441ef0f3535ebbd91a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\nindex b41d67c4e32..dcaef3f0f74 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n\n@@ -544,37 +546,161 @@ public class TomlLexer extends AbstractLexer {\n      */\n     private STToken processNumericLiteral(int startChar) {\n         int nextChar = peek();\n-        if (nextChar == '+' || nextChar == '-') {\n-            reader.advance();\n-            nextChar = peek();\n+        if (isHexIndicator(startChar, nextChar)) {\n+            return processHexLiteral();\n+        }\n+        if (isOctalIndicator(startChar, nextChar)) {\n+            return processOctalLiteral();\n+        }\n+        if (isBinaryIndicator(startChar, nextChar)) {\n+            return processBinaryLiteral();\n         }\n \n         int len = 1;\n-        SyntaxKind type = SyntaxKind.DECIMAL_INT_TOKEN;\n-        boolean isString = false;\n         while (!reader.isEOF()) {\n-            if (isDigit(nextChar) || nextChar == '.' || nextChar == '_') {\n-                if (nextChar == '.') {\n-                    type = SyntaxKind.DECIMAL_FLOAT_TOKEN;\n-                }\n-                reader.advance();\n-                len++;\n-                nextChar = peek();\n-                continue;\n-            } else if (Character.isLetter(nextChar)) {\n-                isString = true;\n+            switch (nextChar) {\n+                case LexerTerminals.DOT:\n+                case 'e':\n+                case 'E':\n+                    // If there's more than one dot, only capture the integer\n+                    if (reader.peek(1) == LexerTerminals.DOT) {\n+                        break;\n+                    }\n+\n+                    // Integer part of the float cannot have a leading zero\n+                    if (startChar == '0' && len > 1) {\n+                        reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n+                    }\n+\n+                    // Code would not reach here if the floating point starts with a dot\n+                    return processDecimalFloatLiteral();\n+                default:\n+                    if (isAlphabeticChar(nextChar)) {\n+                        return processKey();\n+                    }\n+                    if (isValidNumericalDigit(nextChar)) {\n+                        reader.advance();\n+                        len++;\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n             }\n             break;\n         }\n-        if (isString) {\n-            type = SyntaxKind.IDENTIFIER_LITERAL;\n-        }\n+\n         // Integer cannot have a leading zero\n-        if (startChar == '0' && len > 1 && type == SyntaxKind.DECIMAL_INT_TOKEN) {\n+        if (startChar == '0' && len > 1) {\n             reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n         }\n \n-        return getLiteral(type);\n+        return getLiteral(SyntaxKind.DECIMAL_INT_TOKEN);\n+    }\n+\n+    /**\n+     * Process Decimal Literal.\n+     *\n+     * @return Decimal Literal\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.DOT) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        while (isValidNumericalDigit(nextChar)) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        switch (nextChar) {\n+            case 'e':\n+            case 'E':\n+                return processExponent();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOAT_TOKEN);\n+    }\n+\n+    /**\n+     * Process the Hex Literal.\n+     *\n+     * @return Hex Literal\n+     */\n+    private STToken processHexLiteral() {\n+        reader.advance();\n+        while (isHexDigit(peek())) {\n+            reader.advance();\n+        }\n+        return getLiteral(SyntaxKind.HEX_INTEGER_LITERAL_TOKEN);\n+    }\n+\n+    /**\n+     * Process the Octal Literal.\n+     *\n+     * @return Ocatal Literal\n+     */\n+    private STToken processOctalLiteral() {\n+        reader.advance();\n+        while (isOctalDigit(peek())) {\n+            reader.advance();\n+        }\n+        return getLiteral(SyntaxKind.OCTAL_INTEGER_LITERAL_TOKEN);\n+    }\n+\n+    /**\n+     * Process the Binary Literal.\n+     *\n+     * @return Binary Literal\n+     */\n+    private STToken processBinaryLiteral() {\n+        reader.advance();\n+        while (isBinaryDigit(peek())) {\n+            reader.advance();\n+        }\n+        return getLiteral(SyntaxKind.BINARY_INTEGER_LITERAL_TOKEN);\n+    }\n+\n+    /**\n+     * Process an exponent of Float.\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processExponent() {\n+        // Advance reader as exponent indicator is already validated\n+        reader.advance();\n+        int nextChar = peek();\n+\n+        // Capture if there is a sign\n+        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        // Make sure at least one digit is present after the indicator\n+        if (!isValidNumericalDigit(nextChar)) {\n+            reportLexerError(DiagnosticErrorCode.ERROR_MISSING_DIGIT_AFTER_EXPONENT_INDICATOR);\n+        }\n+\n+        while (isValidNumericalDigit(nextChar)) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOAT_TOKEN);\n+    }\n+\n+    private boolean isHexIndicator(int startChar, int nextChar) {\n+        return startChar == '0' && (nextChar == 'x' || nextChar == 'X');\n+    }\n+\n+    private boolean isOctalIndicator(int startChar, int nextChar) {\n+        return startChar == '0' && (nextChar == 'o' || nextChar == 'O');\n+    }\n+\n+    private boolean isBinaryIndicator(int startChar, int nextChar) {\n+        return startChar == '0' && (nextChar == 'b' || nextChar == 'B');\n     }\n \n     /**\n"}}, {"oid": "a188e3797e6810fa539740441ef0f3535ebbd91a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a188e3797e6810fa539740441ef0f3535ebbd91a", "message": "Improve Numeric Values and bug fixes", "committedDate": "2020-12-14T05:38:11Z", "type": "forcePushed"}, {"oid": "afc25b6bbb7d8f8090fa8895eea47e8b53377a4d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/afc25b6bbb7d8f8090fa8895eea47e8b53377a4d", "message": "Improve Numeric Values and bug fixes", "committedDate": "2020-12-14T05:42:14Z", "type": "forcePushed"}, {"oid": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc3e8b2a950cb00332d127779cb76aa994ce70f0", "message": "Improve Numeric Values and bug fixes", "committedDate": "2020-12-14T06:07:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5NjY5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542296696", "bodyText": "Not related to this PR. getQuoteToken() would be a better name as it is used for single quotes as well.", "author": "lochana-chathura", "createdAt": "2020-12-14T11:02:04Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -96,7 +96,8 @@ private STToken readToken() {\n                 token = getSyntaxToken(SyntaxKind.CLOSE_BRACKET_TOKEN);\n                 break;\n             case LexerTerminals.SINGLE_QUOTE:\n-                if (this.reader.peek(1) == LexerTerminals.SINGLE_QUOTE) {\n+                if (this.reader.peek() == LexerTerminals.SINGLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.SINGLE_QUOTE) {\n                     this.reader.advance(2);\n                     token = getDoubleQuoteToken(SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN);", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\nindex dcaef3f0f74..040e0ccbe93 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n\n@@ -99,9 +99,9 @@ public class TomlLexer extends AbstractLexer {\n                 if (this.reader.peek() == LexerTerminals.SINGLE_QUOTE &&\n                         this.reader.peek(1) == LexerTerminals.SINGLE_QUOTE) {\n                     this.reader.advance(2);\n-                    token = getDoubleQuoteToken(SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN);\n+                    token = getQuoteToken(SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN);\n                 } else {\n-                    token = getDoubleQuoteToken(SyntaxKind.SINGLE_QUOTE_TOKEN);\n+                    token = getQuoteToken(SyntaxKind.SINGLE_QUOTE_TOKEN);\n                 }\n                 startMode(ParserMode.LITERAL_STRING);\n                 break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTQxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542305415", "bodyText": "do we consider something starts with a number as an identifier? e.g. 123bar", "author": "lochana-chathura", "createdAt": "2020-12-14T11:16:30Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -544,37 +546,161 @@ private STNode processComment() {\n      */\n     private STToken processNumericLiteral(int startChar) {\n         int nextChar = peek();\n-        if (nextChar == '+' || nextChar == '-') {\n-            reader.advance();\n-            nextChar = peek();\n+        if (isHexIndicator(startChar, nextChar)) {\n+            return processHexLiteral();\n+        }\n+        if (isOctalIndicator(startChar, nextChar)) {\n+            return processOctalLiteral();\n+        }\n+        if (isBinaryIndicator(startChar, nextChar)) {\n+            return processBinaryLiteral();\n         }\n \n         int len = 1;\n-        SyntaxKind type = SyntaxKind.DECIMAL_INT_TOKEN;\n-        boolean isString = false;\n         while (!reader.isEOF()) {\n-            if (isDigit(nextChar) || nextChar == '.' || nextChar == '_') {\n-                if (nextChar == '.') {\n-                    type = SyntaxKind.DECIMAL_FLOAT_TOKEN;\n-                }\n-                reader.advance();\n-                len++;\n-                nextChar = peek();\n-                continue;\n-            } else if (Character.isLetter(nextChar)) {\n-                isString = true;\n+            switch (nextChar) {\n+                case LexerTerminals.DOT:\n+                case 'e':\n+                case 'E':\n+                    // If there's more than one dot, only capture the integer\n+                    if (reader.peek(1) == LexerTerminals.DOT) {\n+                        break;\n+                    }\n+\n+                    // Integer part of the float cannot have a leading zero\n+                    if (startChar == '0' && len > 1) {\n+                        reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n+                    }\n+\n+                    // Code would not reach here if the floating point starts with a dot\n+                    return processDecimalFloatLiteral();\n+                default:\n+                    if (isAlphabeticChar(nextChar)) {\n+                        return processKey();", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAwMjU3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r543002579", "bodyText": "Yes.", "author": "xlight05", "createdAt": "2020-12-15T02:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTQxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "116e80e909e12eaff88cc5d6ed99102ab3cb86a4", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\nindex dcaef3f0f74..b41d67c4e32 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n\n@@ -546,161 +544,37 @@ public class TomlLexer extends AbstractLexer {\n      */\n     private STToken processNumericLiteral(int startChar) {\n         int nextChar = peek();\n-        if (isHexIndicator(startChar, nextChar)) {\n-            return processHexLiteral();\n-        }\n-        if (isOctalIndicator(startChar, nextChar)) {\n-            return processOctalLiteral();\n-        }\n-        if (isBinaryIndicator(startChar, nextChar)) {\n-            return processBinaryLiteral();\n+        if (nextChar == '+' || nextChar == '-') {\n+            reader.advance();\n+            nextChar = peek();\n         }\n \n         int len = 1;\n+        SyntaxKind type = SyntaxKind.DECIMAL_INT_TOKEN;\n+        boolean isString = false;\n         while (!reader.isEOF()) {\n-            switch (nextChar) {\n-                case LexerTerminals.DOT:\n-                case 'e':\n-                case 'E':\n-                    // If there's more than one dot, only capture the integer\n-                    if (reader.peek(1) == LexerTerminals.DOT) {\n-                        break;\n-                    }\n-\n-                    // Integer part of the float cannot have a leading zero\n-                    if (startChar == '0' && len > 1) {\n-                        reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n-                    }\n-\n-                    // Code would not reach here if the floating point starts with a dot\n-                    return processDecimalFloatLiteral();\n-                default:\n-                    if (isAlphabeticChar(nextChar)) {\n-                        return processKey();\n-                    }\n-                    if (isValidNumericalDigit(nextChar)) {\n-                        reader.advance();\n-                        len++;\n-                        nextChar = peek();\n-                        continue;\n-                    }\n-                    break;\n+            if (isDigit(nextChar) || nextChar == '.' || nextChar == '_') {\n+                if (nextChar == '.') {\n+                    type = SyntaxKind.DECIMAL_FLOAT_TOKEN;\n+                }\n+                reader.advance();\n+                len++;\n+                nextChar = peek();\n+                continue;\n+            } else if (Character.isLetter(nextChar)) {\n+                isString = true;\n             }\n             break;\n         }\n-\n+        if (isString) {\n+            type = SyntaxKind.IDENTIFIER_LITERAL;\n+        }\n         // Integer cannot have a leading zero\n-        if (startChar == '0' && len > 1) {\n+        if (startChar == '0' && len > 1 && type == SyntaxKind.DECIMAL_INT_TOKEN) {\n             reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n         }\n \n-        return getLiteral(SyntaxKind.DECIMAL_INT_TOKEN);\n-    }\n-\n-    /**\n-     * Process Decimal Literal.\n-     *\n-     * @return Decimal Literal\n-     */\n-    private STToken processDecimalFloatLiteral() {\n-        int nextChar = peek();\n-        if (nextChar == LexerTerminals.DOT) {\n-            reader.advance();\n-            nextChar = peek();\n-        }\n-\n-        while (isValidNumericalDigit(nextChar)) {\n-            reader.advance();\n-            nextChar = peek();\n-        }\n-\n-        switch (nextChar) {\n-            case 'e':\n-            case 'E':\n-                return processExponent();\n-        }\n-\n-        return getLiteral(SyntaxKind.DECIMAL_FLOAT_TOKEN);\n-    }\n-\n-    /**\n-     * Process the Hex Literal.\n-     *\n-     * @return Hex Literal\n-     */\n-    private STToken processHexLiteral() {\n-        reader.advance();\n-        while (isHexDigit(peek())) {\n-            reader.advance();\n-        }\n-        return getLiteral(SyntaxKind.HEX_INTEGER_LITERAL_TOKEN);\n-    }\n-\n-    /**\n-     * Process the Octal Literal.\n-     *\n-     * @return Ocatal Literal\n-     */\n-    private STToken processOctalLiteral() {\n-        reader.advance();\n-        while (isOctalDigit(peek())) {\n-            reader.advance();\n-        }\n-        return getLiteral(SyntaxKind.OCTAL_INTEGER_LITERAL_TOKEN);\n-    }\n-\n-    /**\n-     * Process the Binary Literal.\n-     *\n-     * @return Binary Literal\n-     */\n-    private STToken processBinaryLiteral() {\n-        reader.advance();\n-        while (isBinaryDigit(peek())) {\n-            reader.advance();\n-        }\n-        return getLiteral(SyntaxKind.BINARY_INTEGER_LITERAL_TOKEN);\n-    }\n-\n-    /**\n-     * Process an exponent of Float.\n-     *\n-     * @return The decimal floating point literal.\n-     */\n-    private STToken processExponent() {\n-        // Advance reader as exponent indicator is already validated\n-        reader.advance();\n-        int nextChar = peek();\n-\n-        // Capture if there is a sign\n-        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n-            reader.advance();\n-            nextChar = peek();\n-        }\n-\n-        // Make sure at least one digit is present after the indicator\n-        if (!isValidNumericalDigit(nextChar)) {\n-            reportLexerError(DiagnosticErrorCode.ERROR_MISSING_DIGIT_AFTER_EXPONENT_INDICATOR);\n-        }\n-\n-        while (isValidNumericalDigit(nextChar)) {\n-            reader.advance();\n-            nextChar = peek();\n-        }\n-\n-        return getLiteral(SyntaxKind.DECIMAL_FLOAT_TOKEN);\n-    }\n-\n-    private boolean isHexIndicator(int startChar, int nextChar) {\n-        return startChar == '0' && (nextChar == 'x' || nextChar == 'X');\n-    }\n-\n-    private boolean isOctalIndicator(int startChar, int nextChar) {\n-        return startChar == '0' && (nextChar == 'o' || nextChar == 'O');\n-    }\n-\n-    private boolean isBinaryIndicator(int startChar, int nextChar) {\n-        return startChar == '0' && (nextChar == 'b' || nextChar == 'B');\n+        return getLiteral(type);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzMDI3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542330275", "bodyText": "Extra new line", "author": "lochana-chathura", "createdAt": "2020-12-14T11:59:28Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -31,6 +31,11 @@\n     STRING_LITERAL_TOKEN(203),\n     DECIMAL_INT_TOKEN(204),\n     DECIMAL_FLOAT_TOKEN(205),\n+    HEX_INTEGER_LITERAL_TOKEN(206),\n+    OCTAL_INTEGER_LITERAL_TOKEN(207),\n+    BINARY_INTEGER_LITERAL_TOKEN(208),\n+\n+", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java b/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\nindex b2d8488c3b7..10381433ad0 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\n\n@@ -34,8 +34,7 @@ public enum SyntaxKind {\n     HEX_INTEGER_LITERAL_TOKEN(206),\n     OCTAL_INTEGER_LITERAL_TOKEN(207),\n     BINARY_INTEGER_LITERAL_TOKEN(208),\n-\n-\n+    \n     //Separators\n     OPEN_BRACKET_TOKEN(500, \"[\"),\n     CLOSE_BRACKET_TOKEN(501, \"]\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzMDc3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542330771", "bodyText": "Since there are lot of cases let's use a switch case", "author": "lochana-chathura", "createdAt": "2020-12-14T12:00:24Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -389,27 +399,42 @@ private STNode parseValue() {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind;\n-        if (token.kind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            kind = DEC_INT;\n+        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n+    }\n+\n+    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {\n+        if (tokenKind == SyntaxKind.DECIMAL_INT_TOKEN) {\n+            return DEC_INT;\n+        } else if (tokenKind == HEX_INTEGER_LITERAL_TOKEN) {\n+            return HEX_INT;\n+        } else if (tokenKind == OCTAL_INTEGER_LITERAL_TOKEN) {\n+           return OCT_INT;\n+        } else if (tokenKind == BINARY_INTEGER_LITERAL_TOKEN) {\n+            return BINARY_INT;\n         } else {\n-            kind = FLOAT;\n+            return FLOAT;\n         }\n-        return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n     }\n \n     private STNode parseNumericalToken() {\n         STToken token = peek();\n-        if (token.kind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            return consume();\n-        } else if (token.kind == SyntaxKind.DECIMAL_FLOAT_TOKEN) {\n+        if (isNumerticalLiteral(token)) {\n             return consume();\n         } else {\n             recover(token, ParserRuleContext.NUMERICAL_LITERAL);\n             return parseNumericalToken();\n         }\n     }\n \n+    private boolean isNumerticalLiteral(STToken token) {\n+        return token.kind == SyntaxKind.DECIMAL_INT_TOKEN ||", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..661671a9417 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -399,21 +396,22 @@ public class TomlParser extends AbstractParser {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        SyntaxKind kind = getNumericLiteralKind(token.kind);\n         return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n     }\n \n-    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {\n-        if (tokenKind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            return DEC_INT;\n-        } else if (tokenKind == HEX_INTEGER_LITERAL_TOKEN) {\n-            return HEX_INT;\n-        } else if (tokenKind == OCTAL_INTEGER_LITERAL_TOKEN) {\n-           return OCT_INT;\n-        } else if (tokenKind == BINARY_INTEGER_LITERAL_TOKEN) {\n-            return BINARY_INT;\n-        } else {\n-            return FLOAT;\n+    private SyntaxKind getNumericLiteralKind(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DECIMAL_INT_TOKEN:\n+                return DEC_INT;\n+            case HEX_INTEGER_LITERAL_TOKEN:\n+                return HEX_INT;\n+            case OCTAL_INTEGER_LITERAL_TOKEN:\n+                return OCT_INT;\n+            case BINARY_INTEGER_LITERAL_TOKEN:\n+                return BINARY_INT;\n+            default:\n+                return FLOAT;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0NzAwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542347007", "bodyText": "Shall we use something like getNumericLiteralKind as the name?\nLe'ts use a switch case here also", "author": "lochana-chathura", "createdAt": "2020-12-14T12:30:52Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -389,27 +399,42 @@ private STNode parseValue() {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind;\n-        if (token.kind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            kind = DEC_INT;\n+        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n+    }\n+\n+    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..661671a9417 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -399,21 +396,22 @@ public class TomlParser extends AbstractParser {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        SyntaxKind kind = getNumericLiteralKind(token.kind);\n         return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n     }\n \n-    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {\n-        if (tokenKind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            return DEC_INT;\n-        } else if (tokenKind == HEX_INTEGER_LITERAL_TOKEN) {\n-            return HEX_INT;\n-        } else if (tokenKind == OCTAL_INTEGER_LITERAL_TOKEN) {\n-           return OCT_INT;\n-        } else if (tokenKind == BINARY_INTEGER_LITERAL_TOKEN) {\n-            return BINARY_INT;\n-        } else {\n-            return FLOAT;\n+    private SyntaxKind getNumericLiteralKind(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DECIMAL_INT_TOKEN:\n+                return DEC_INT;\n+            case HEX_INTEGER_LITERAL_TOKEN:\n+                return HEX_INT;\n+            case OCTAL_INTEGER_LITERAL_TOKEN:\n+                return OCT_INT;\n+            case BINARY_INTEGER_LITERAL_TOKEN:\n+                return BINARY_INT;\n+            default:\n+                return FLOAT;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MDE0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542350144", "bodyText": "we need to do this check inside the parseStringContent().", "author": "lochana-chathura", "createdAt": "2020-12-14T12:36:34Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -446,6 +461,11 @@ private STNode parseBoolean() {\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n         STNode content = parseStringContent();\n+        //Empty String\n+        if (content.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+            return STNodeFactory.createStringLiteralNode(startingDoubleQuote, STNodeFactory.createEmptyNode(), content);\n+        }", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..661671a9417 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -461,14 +464,9 @@ public class TomlParser extends AbstractParser {\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n         STNode content = parseStringContent();\n-        //Empty String\n-        if (content.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n-            return STNodeFactory.createStringLiteralNode(startingDoubleQuote, STNodeFactory.createEmptyNode(), content);\n-        }\n-\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n-    }\n+    }//TODO change optional\n \n     /**\n      * Parse Double quote token.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MDc5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542350799", "bodyText": "if the syntaxkind is DOUBLE_QUOTE_TOKEN then return STNodeFactory.createEmptyNode();\nAlso need to fix recovery for this method with above change", "author": "lochana-chathura", "createdAt": "2020-12-14T12:37:32Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -468,7 +488,7 @@ private STNode parseDoubleQuoteToken(ParserRuleContext ctx) {\n \n     private STNode parseStringContent() {\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL || nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2ODY1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542368658", "bodyText": "if there's IDENTIFIER_LITERAL we consume it and return\nif there's DOUBLE_QUOTE_TOKEN we simply create emptyNode and return (need to make the token optional in the Syntax API)\nsomething is wrong. Hence go to recovery and re-parse\n\nSimilar case from BallerinaParser.java \n  \n    \n      ballerina-lang/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n    \n    \n        Lines 6055 to 6066\n      in\n      7289b5b\n    \n    \n    \n    \n\n        \n          \n           private STNode parseOptionalEllipsis() { \n        \n\n        \n          \n               STToken nextToken = peek(); \n        \n\n        \n          \n               switch (nextToken.kind) { \n        \n\n        \n          \n                   case ELLIPSIS_TOKEN: \n        \n\n        \n          \n                       return consume(); \n        \n\n        \n          \n                   case IDENTIFIER_TOKEN: \n        \n\n        \n          \n                       return STNodeFactory.createEmptyNode(); \n        \n\n        \n          \n                   default: \n        \n\n        \n          \n                       recover(nextToken, ParserRuleContext.PATH_PARAM_ELLIPSIS); \n        \n\n        \n          \n                       return parseOptionalEllipsis(); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "author": "lochana-chathura", "createdAt": "2020-12-14T13:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MDc5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..661671a9417 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -488,12 +486,14 @@ public class TomlParser extends AbstractParser {\n \n     private STNode parseStringContent() {\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL || nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n             return consume();\n-        } else {\n-            recover(nextToken, ParserRuleContext.STRING_CONTENT);\n-            return parseStringContent();\n         }\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        recover(nextToken, ParserRuleContext.STRING_BODY);\n+        return parseStringContent();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542352333", "bodyText": "why we need this? what happens to the consumed token in L573?", "author": "lochana-chathura", "createdAt": "2020-12-14T12:40:08Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -549,6 +569,9 @@ private STNode parseValueEnd() {\n             case CLOSE_BRACKET_TOKEN:\n                 // null marks the end of values\n                 return null;\n+            case NEWLINE:\n+                consume();\n+                return parseValueEnd();", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjMyMDgzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546320836", "bodyText": "We only use newlines for validation. Ex - There should be a new line after each key value pair.\nBut in few cases, in thats different. Here, we are ignoring the new line token passed to parser as that validation is not needed. Ex -  Arrays\narr = [\n\"hello\",\n\"hello1\"\n,\n\"hello2\"\n]", "author": "xlight05", "createdAt": "2020-12-20T04:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzMjI1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546532254", "bodyText": "I see. I guess it should be fine then. Usually syntax tree represents everything including minutiae that user inputs. (useful when formatting, etc)\nAnyway since we capture the newline explicitly from the lexer, we need to add NEWLINE as an alternative path for ARRAY_VALUE_END ctx in error handler I think. There could be invalid tokens before the NEWLINE token.\ne.g.\n[ \"abc\"  + invalid +\n, \"ABC\" ]\n\n@SupunS please have a look.", "author": "lochana-chathura", "createdAt": "2020-12-21T06:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0OTY1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r547049655", "bodyText": "Interesting point.\nWe designed the error handler to be same as the ballerina error handler, to not to consider newlines. Because newlines are just for validations and parsing could done even without newlines - also simplifies things.\n@xlight05 However, I just noticed that we are not ignoring the newlines in the error-handler. We should skip the newline tokens or do as @lochana-chathura suggested. (I prefer skipping, for simplicity)", "author": "SupunS", "createdAt": "2020-12-22T03:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExOTczNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r547119734", "bodyText": "+1 for skipping. @xlight05 May be we can create a new issue and address this in a separate PR.", "author": "lochana-chathura", "createdAt": "2020-12-22T07:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzNDY1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551134652", "bodyText": "Done. #27641", "author": "xlight05", "createdAt": "2021-01-04T06:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "116e80e909e12eaff88cc5d6ed99102ab3cb86a4", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..ff29f240b3a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -569,9 +549,6 @@ public class TomlParser extends AbstractParser {\n             case CLOSE_BRACKET_TOKEN:\n                 // null marks the end of values\n                 return null;\n-            case NEWLINE:\n-                consume();\n-                return parseValueEnd();\n             default:\n                 recover(peek(), ParserRuleContext.ARRAY_VALUE_END);\n                 return parseValueEnd();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MzAwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r542353001", "bodyText": "Need to update the error handler for the above change. (when recovering with NUMERICAL_LITERAL ctx)", "author": "lochana-chathura", "createdAt": "2020-12-14T12:41:27Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -389,27 +399,42 @@ private STNode parseValue() {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind;\n-        if (token.kind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            kind = DEC_INT;\n+        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n+    }\n+\n+    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {\n+        if (tokenKind == SyntaxKind.DECIMAL_INT_TOKEN) {\n+            return DEC_INT;\n+        } else if (tokenKind == HEX_INTEGER_LITERAL_TOKEN) {\n+            return HEX_INT;\n+        } else if (tokenKind == OCTAL_INTEGER_LITERAL_TOKEN) {\n+           return OCT_INT;\n+        } else if (tokenKind == BINARY_INTEGER_LITERAL_TOKEN) {\n+            return BINARY_INT;\n         } else {\n-            kind = FLOAT;\n+            return FLOAT;\n         }\n-        return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n     }\n \n     private STNode parseNumericalToken() {\n         STToken token = peek();\n-        if (token.kind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            return consume();\n-        } else if (token.kind == SyntaxKind.DECIMAL_FLOAT_TOKEN) {\n+        if (isNumerticalLiteral(token)) {\n             return consume();\n         } else {\n             recover(token, ParserRuleContext.NUMERICAL_LITERAL);", "originalCommit": "bc3e8b2a950cb00332d127779cb76aa994ce70f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10cbf36b647f25db144b085471338b7c61c908ab", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 6b867b7a0b9..661671a9417 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -399,21 +396,22 @@ public class TomlParser extends AbstractParser {\n     private STNode parseNumericalNode() {\n         STNode sign = parseSign();\n         STNode token = parseNumericalToken();\n-        SyntaxKind kind = getNodeKindNumericNode(token.kind);\n+        SyntaxKind kind = getNumericLiteralKind(token.kind);\n         return STNodeFactory.createNumericLiteralNode(kind, sign, token);\n     }\n \n-    private SyntaxKind getNodeKindNumericNode(SyntaxKind tokenKind) {\n-        if (tokenKind == SyntaxKind.DECIMAL_INT_TOKEN) {\n-            return DEC_INT;\n-        } else if (tokenKind == HEX_INTEGER_LITERAL_TOKEN) {\n-            return HEX_INT;\n-        } else if (tokenKind == OCTAL_INTEGER_LITERAL_TOKEN) {\n-           return OCT_INT;\n-        } else if (tokenKind == BINARY_INTEGER_LITERAL_TOKEN) {\n-            return BINARY_INT;\n-        } else {\n-            return FLOAT;\n+    private SyntaxKind getNumericLiteralKind(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DECIMAL_INT_TOKEN:\n+                return DEC_INT;\n+            case HEX_INTEGER_LITERAL_TOKEN:\n+                return HEX_INT;\n+            case OCTAL_INTEGER_LITERAL_TOKEN:\n+                return OCT_INT;\n+            case BINARY_INTEGER_LITERAL_TOKEN:\n+                return BINARY_INT;\n+            default:\n+                return FLOAT;\n         }\n     }\n \n"}}, {"oid": "10cbf36b647f25db144b085471338b7c61c908ab", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10cbf36b647f25db144b085471338b7c61c908ab", "message": "Address Review comments", "committedDate": "2020-12-20T05:59:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyODAwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546528000", "bodyText": "Let's keep this comment and update according this scenario.\n// Trivia after the single or double quote including whitespace belongs to the content inside the quotes.\n// Therefore do not process trailing trivia for starting quote. We reach here only for\n// starting single or double quote. Ending quote is processed by the LITERAL_STRING mode.", "author": "lochana-chathura", "createdAt": "2020-12-21T06:18:20Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -382,11 +384,8 @@ private STToken getLiteral(SyntaxKind kind) {\n         return STNodeFactory.createLiteralValueToken(kind, lexeme, leadingTrivia, trailingTrivia);\n     }\n \n-    private STToken getDoubleQuoteToken(SyntaxKind kind) {\n+    private STToken getQuoteToken(SyntaxKind kind) {\n         STNode leadingTrivia = getLeadingTrivia();\n-        // Trivia after the back-tick including whitespace belongs to the content of the back-tick.\n-        // Therefore do not process trailing trivia for starting back-tick. We reach here only for\n-        // starting back-tick. Ending back-tick is processed by the template mode.", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\nindex 040e0ccbe93..50647dda75a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n\n@@ -385,6 +417,9 @@ public class TomlLexer extends AbstractLexer {\n     }\n \n     private STToken getQuoteToken(SyntaxKind kind) {\n+        // Trivia after the single or double quote including whitespace belongs to the content inside the quotes.\n+        // Therefore do not process trailing trivia for starting quote. We reach here only for\n+        // starting single or double quote. Ending quote is processed by the LITERAL_STRING mode.\n         STNode leadingTrivia = getLeadingTrivia();\n         STNode trailingTrivia = STNodeFactory.createEmptyNodeList();\n         return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyODc1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546528753", "bodyText": "what does this TODO suppose to mean? I guess we don't need this.", "author": "lochana-chathura", "createdAt": "2020-12-21T06:21:22Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -448,7 +466,7 @@ private STNode parseStringValue() {\n         STNode content = parseStringContent();\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n-    }\n+    }//TODO change optional", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 661671a9417..8476149ae1d 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -466,7 +470,34 @@ public class TomlParser extends AbstractParser {\n         STNode content = parseStringContent();\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n-    }//TODO change optional\n+    }\n+\n+    /**\n+     * Parse Literal String Value.\n+     *\n+     * @return String Literal Node.\n+     */\n+    private STNode parseLiteralStringValue() {\n+        STNode startingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_START);\n+        STNode content = parseStringContent();\n+        STNode endingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_END);\n+        return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Double quote token.\n+     *\n+     * @return Double quote token\n+     */\n+    private STNode parseSingleQuoteToken(ParserRuleContext ctx) {\n+        STToken token = peek();\n+        if (token.kind == SINGLE_QUOTE_TOKEN || token.kind == TRIPLE_SINGLE_QUOTE_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ctx);\n+            return parseSingleQuoteToken(ctx);\n+        }\n+    }\n \n     /**\n      * Parse Double quote token.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyOTA1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546529054", "bodyText": "shouldn't we go to recovery with STRING_CONTENT parser rule context?", "author": "lochana-chathura", "createdAt": "2020-12-21T06:22:43Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -470,10 +488,12 @@ private STNode parseStringContent() {\n         STToken nextToken = peek();\n         if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n             return consume();\n-        } else {\n-            recover(nextToken, ParserRuleContext.STRING_CONTENT);\n-            return parseStringContent();\n         }\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        recover(nextToken, ParserRuleContext.STRING_BODY);", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 661671a9417..8476149ae1d 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -492,7 +522,7 @@ public class TomlParser extends AbstractParser {\n         if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n             return STNodeFactory.createEmptyNode();\n         }\n-        recover(nextToken, ParserRuleContext.STRING_BODY);\n+        recover(nextToken, ParserRuleContext.STRING_CONTENT);\n         return parseStringContent();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyOTI5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546529299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ParserRuleContext.STRING_BODY};\n          \n          \n            \n                        ParserRuleContext.STRING_BODY };", "author": "lochana-chathura", "createdAt": "2020-12-21T06:23:32Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java", "diffHunk": "@@ -82,6 +83,9 @@\n     private static final ParserRuleContext[] KEY_LIST_END = {\n             ParserRuleContext.ASSIGN_OP, ParserRuleContext.TABLE_END, ParserRuleContext.ARRAY_TABLE_FIRST_END};\n \n+    private static final ParserRuleContext[] STRING_CONTENT = { ParserRuleContext.STRING_END,\n+            ParserRuleContext.STRING_BODY};", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\nindex ecdeda9dcf0..1f89026cb9d 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\n\n@@ -69,14 +69,16 @@ public class TomlParserErrorHandler extends AbstractParserErrorHandler {\n             ParserRuleContext.OCTAL_INTEGER_LITERAL, ParserRuleContext.BINARY_INTEGER_LITERAL};\n \n     private static final ParserRuleContext[] VALUE = {ParserRuleContext.STRING_START,\n-            ParserRuleContext.SIGN_TOKEN, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.NUMERICAL_LITERAL,\n+            ParserRuleContext.LITERAL_STRING_START, ParserRuleContext.SIGN_TOKEN, ParserRuleContext.BOOLEAN_LITERAL,\n+            ParserRuleContext.NUMERICAL_LITERAL,\n //            ParserRuleContext.ARRAY_VALUE_LIST\n     };\n \n     private static final ParserRuleContext[] ARRAY_VALUE_START = VALUE;\n \n     private static final ParserRuleContext[] KEY_START = {ParserRuleContext.IDENTIFIER_LITERAL,\n-            ParserRuleContext.NUMERICAL_LITERAL, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.STRING_START};\n+            ParserRuleContext.NUMERICAL_LITERAL, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.STRING_START,\n+            ParserRuleContext.LITERAL_STRING_START};\n \n     private static final ParserRuleContext[] KEY_END = {ParserRuleContext.DOT, ParserRuleContext.KEY_LIST_END};\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyOTgwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546529801", "bodyText": "correct formatting should be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ParserRuleContext.OCTAL_INTEGER_LITERAL, ParserRuleContext.BINARY_INTEGER_LITERAL};\n          \n          \n            \n                        ParserRuleContext.OCTAL_INTEGER_LITERAL, ParserRuleContext.BINARY_INTEGER_LITERAL };\n          \n      \n    \n    \n  \n\nadd a space after { here also.", "author": "lochana-chathura", "createdAt": "2020-12-21T06:25:15Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java", "diffHunk": "@@ -65,7 +65,8 @@\n             { ParserRuleContext.ARRAY_VALUE_LIST_END, ParserRuleContext.ARRAY_VALUE_START };\n \n     private static final ParserRuleContext[] NUMERICAL_LITERAL = {ParserRuleContext.DECIMAL_INTEGER_LITERAL,\n-            ParserRuleContext.DECIMAL_FLOATING_POINT_LITERAL};\n+            ParserRuleContext.DECIMAL_FLOATING_POINT_LITERAL, ParserRuleContext.HEX_INTEGER_LITERAL,\n+            ParserRuleContext.OCTAL_INTEGER_LITERAL, ParserRuleContext.BINARY_INTEGER_LITERAL};", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\nindex ecdeda9dcf0..1f89026cb9d 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParserErrorHandler.java\n\n@@ -69,14 +69,16 @@ public class TomlParserErrorHandler extends AbstractParserErrorHandler {\n             ParserRuleContext.OCTAL_INTEGER_LITERAL, ParserRuleContext.BINARY_INTEGER_LITERAL};\n \n     private static final ParserRuleContext[] VALUE = {ParserRuleContext.STRING_START,\n-            ParserRuleContext.SIGN_TOKEN, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.NUMERICAL_LITERAL,\n+            ParserRuleContext.LITERAL_STRING_START, ParserRuleContext.SIGN_TOKEN, ParserRuleContext.BOOLEAN_LITERAL,\n+            ParserRuleContext.NUMERICAL_LITERAL,\n //            ParserRuleContext.ARRAY_VALUE_LIST\n     };\n \n     private static final ParserRuleContext[] ARRAY_VALUE_START = VALUE;\n \n     private static final ParserRuleContext[] KEY_START = {ParserRuleContext.IDENTIFIER_LITERAL,\n-            ParserRuleContext.NUMERICAL_LITERAL, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.STRING_START};\n+            ParserRuleContext.NUMERICAL_LITERAL, ParserRuleContext.BOOLEAN_LITERAL, ParserRuleContext.STRING_START,\n+            ParserRuleContext.LITERAL_STRING_START};\n \n     private static final ParserRuleContext[] KEY_END = {ParserRuleContext.DOT, ParserRuleContext.KEY_LIST_END};\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzNDM3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r546534370", "bodyText": "same comment(#27358 (comment)) valid here also.", "author": "lochana-chathura", "createdAt": "2020-12-21T06:41:47Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -565,6 +588,9 @@ private STNode parseArrayValue() {\n             return parseArray();\n         } else if (nextToken.kind == CLOSE_BRACKET_TOKEN) {\n             return null;\n+        } else if (nextToken.kind == NEWLINE) {\n+            consume();\n+            return parseArrayValue();\n         } else {\n             recover(peek(), ParserRuleContext.ARRAY_VALUE_START);", "originalCommit": "10cbf36b647f25db144b085471338b7c61c908ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzNDczMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551134732", "bodyText": "Created an issue for this. #27641", "author": "xlight05", "createdAt": "2021-01-04T06:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUzNDM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 661671a9417..8476149ae1d 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -582,6 +612,9 @@ public class TomlParser extends AbstractParser {\n         STToken nextToken = peek();\n         if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN || nextToken.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {\n             return parseStringValue();\n+        } else if (nextToken.kind == SyntaxKind.SINGLE_QUOTE_TOKEN ||\n+                nextToken.kind == SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN) {\n+            return parseLiteralStringValue();\n         } else if (isBasicValue(nextToken)) {\n             return parseValue();\n         } else if (nextToken.kind == OPEN_BRACKET_TOKEN) {\n"}}, {"oid": "1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e63fe7df9bd9ea02b4eccb5ac502273a01b9dcd", "message": "Sync Abstract classes with master", "committedDate": "2021-01-01T11:06:05Z", "type": "forcePushed"}, {"oid": "116e80e909e12eaff88cc5d6ed99102ab3cb86a4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/116e80e909e12eaff88cc5d6ed99102ab3cb86a4", "message": "Fix leading 0 in integer bug in floats", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "91b67568efc95fde722694535bc90f54531d5485", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/91b67568efc95fde722694535bc90f54531d5485", "message": "Improve Numeric Values and bug fixes", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "149d9f3c6c35350f6b85667e2dcfa24374a578de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/149d9f3c6c35350f6b85667e2dcfa24374a578de", "message": "Address Review comments", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "b28ba1346d18c604c75a26513154d82afa7e0c9c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b28ba1346d18c604c75a26513154d82afa7e0c9c", "message": "Add Literal String support", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "64a6dd9a2b540555a68c809236571d8447ce3c13", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/64a6dd9a2b540555a68c809236571d8447ce3c13", "message": "Sync Abstract classes with master", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "b6db46d1be3604874bbd82878952df7d55bdccab", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6db46d1be3604874bbd82878952df7d55bdccab", "message": "Add Toml parser to jballerina tools", "committedDate": "2021-01-04T04:47:29Z", "type": "commit"}, {"oid": "b6db46d1be3604874bbd82878952df7d55bdccab", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6db46d1be3604874bbd82878952df7d55bdccab", "message": "Add Toml parser to jballerina tools", "committedDate": "2021-01-04T04:47:29Z", "type": "forcePushed"}, {"oid": "6f8b8d356f2563336894ea9842b5249a934c4c61", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f8b8d356f2563336894ea9842b5249a934c4c61", "message": "Fix formatting in TomlErrorHandler", "committedDate": "2021-01-04T06:29:49Z", "type": "forcePushed"}, {"oid": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "message": "Fix formatting in TomlErrorHandler", "committedDate": "2021-01-04T06:39:50Z", "type": "commit"}, {"oid": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "message": "Fix formatting in TomlErrorHandler", "committedDate": "2021-01-04T06:39:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMDM1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551210357", "bodyText": "looks like return value is never used. Can be used to add diagnostic similar to;\n\n  \n    \n      ballerina-lang/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaLexer.java\n    \n    \n         Line 295\n      in\n      56f500e\n    \n    \n    \n    \n\n        \n          \n           token = SyntaxErrors.addDiagnostic(token, DiagnosticErrorCode.ERROR_INVALID_TOKEN, invalidToken);", "author": "lochana-chathura", "createdAt": "2021-01-04T09:46:24Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -606,15 +764,16 @@ private STToken processKey() {\n      * Process and returns an invalid token. Consumes the input until {@link #isEndOfInvalidToken()}\n      * is reached.\n      */\n-    private void processInvalidToken() {\n+    private STToken processInvalidToken() {", "originalCommit": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551258900", "bodyText": "Can we have a single key like this?\n [[\"\"\"fruit\"\"\"]]\nIn this method we go to recovery with KEY_START ctx which allows both TRIPLE_DOUBLE_QUOTE_TOKEN and TRIPLE_SINGLE_QUOTE_TOKEN, but the parsing method does not allow them.\nTherefore, for above example parseSingleKey will keep re-parsing again and again.", "author": "lochana-chathura", "createdAt": "2021-01-04T11:21:51Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -291,9 +296,9 @@ private STNode parseSingleKey() {\n             case IDENTIFIER_LITERAL:\n                 return parseIdentifierLiteral();\n             case DOUBLE_QUOTE_TOKEN:\n-            case TRIPLE_DOUBLE_QUOTE_TOKEN:", "originalCommit": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NTY5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551445693", "bodyText": "It seems like we cant reuse same context for multi strings. Addressed this issue by introducing separate tokens for parsing multiline (literal) strings.", "author": "xlight05", "createdAt": "2021-01-04T17:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MDk0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551260940", "bodyText": "single quote token", "author": "lochana-chathura", "createdAt": "2021-01-04T11:26:15Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -450,15 +472,41 @@ private STNode parseStringValue() {\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n \n+    /**\n+     * Parse Literal String Value.\n+     *\n+     * @return String Literal Node.\n+     */\n+    private STNode parseLiteralStringValue() {\n+        STNode startingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_START);\n+        STNode content = parseStringContent();\n+        STNode endingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_END);\n+        return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Double quote token.\n+     *\n+     * @return Double quote token", "originalCommit": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 8476149ae1d..cfa656ad890 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -467,11 +470,23 @@ public class TomlParser extends AbstractParser {\n      */\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n-        STNode content = parseStringContent();\n+        STNode content = parseStringContent(ParserRuleContext.STRING_CONTENT);\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n \n+    /**\n+     * Parse Multiline String Value.\n+     *\n+     * @return String Multiline String Literal Node.\n+     */\n+    private STNode parseMultilineStringValue() {\n+        STNode startingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.MULTILINE_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_END);\n+        return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n     /**\n      * Parse Literal String Value.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDk1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551264958", "bodyText": "seems this method is called within both string and literal string. if it is literal string shouldn't we need to go to recovery with LITERAL_STRING_CONTENT?", "author": "lochana-chathura", "createdAt": "2021-01-04T11:35:14Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -470,10 +518,12 @@ private STNode parseStringContent() {\n         STToken nextToken = peek();\n         if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n             return consume();\n-        } else {\n-            recover(nextToken, ParserRuleContext.STRING_CONTENT);\n-            return parseStringContent();\n         }\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        recover(nextToken, ParserRuleContext.STRING_CONTENT);", "originalCommit": "e465533e56d161eaa00e6b6ab7b0000f3c00ac7b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex 8476149ae1d..cfa656ad890 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -514,16 +556,32 @@ public class TomlParser extends AbstractParser {\n         }\n     }\n \n-    private STNode parseStringContent() {\n+    /**\n+     * Parse Triple Double quote token.\n+     *\n+     * @return Triple Double quote token\n+     */\n+    private STNode parseTripleDoubleQuoteToken(ParserRuleContext ctx) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ctx);\n+            return parseTripleDoubleQuoteToken(ctx);\n+        }\n+    }\n+\n+    private STNode parseStringContent(ParserRuleContext ctx) {\n         STToken nextToken = peek();\n         if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n             return consume();\n         }\n-        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN || nextToken.kind == SINGLE_QUOTE_TOKEN ||\n+                nextToken.kind == TRIPLE_SINGLE_QUOTE_TOKEN || nextToken.kind == TRIPLE_DOUBLE_QUOTE_TOKEN) {\n             return STNodeFactory.createEmptyNode();\n         }\n-        recover(nextToken, ParserRuleContext.STRING_CONTENT);\n-        return parseStringContent();\n+        recover(nextToken, ctx);\n+        return parseStringContent(ctx);\n     }\n \n     /**\n"}}, {"oid": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/364940663b314f9f5ec6934b2dc33ea8559fb05a", "message": "Introduce seperate tokens requried for parsing multiline strings", "committedDate": "2021-01-04T17:01:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUyMTc3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551521771", "bodyText": "shall we call this parseTripleSingleQuoteToken? (To be consistence with  parseTripleDoubleQuoteToken below)", "author": "lochana-chathura", "createdAt": "2021-01-04T19:31:15Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -467,63 +470,118 @@ private STNode parseBoolean() {\n      */\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n-        STNode content = parseStringContent();\n+        STNode content = parseStringContent(ParserRuleContext.STRING_CONTENT);\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n \n+    /**\n+     * Parse Multiline String Value.\n+     *\n+     * @return String Multiline String Literal Node.\n+     */\n+    private STNode parseMultilineStringValue() {\n+        STNode startingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.MULTILINE_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_END);\n+        return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n     /**\n      * Parse Literal String Value.\n      *\n      * @return String Literal Node.\n      */\n     private STNode parseLiteralStringValue() {\n         STNode startingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_START);\n-        STNode content = parseStringContent();\n+        STNode content = parseStringContent(ParserRuleContext.LITERAL_STRING_CONTENT);\n         STNode endingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_END);\n         return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n \n     /**\n-     * Parse Double quote token.\n+     * Parse Multiline Literal String Value.\n      *\n-     * @return Double quote token\n+     * @return Multiline String Literal Node.\n+     */\n+    private STNode parseMultilineLiteralStringValue() {\n+        STNode startingDoubleQuote = parseMultipleSingleQuoteToken(ParserRuleContext.MULTILINE_LITERAL_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.MULTILINE_LITERAL_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseMultipleSingleQuoteToken(ParserRuleContext.MULTILINE_LITERAL_STRING_END);\n+        return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Single quote token.\n+     *\n+     * @return Single quote token\n      */\n     private STNode parseSingleQuoteToken(ParserRuleContext ctx) {\n         STToken token = peek();\n-        if (token.kind == SINGLE_QUOTE_TOKEN || token.kind == TRIPLE_SINGLE_QUOTE_TOKEN) {\n+        if (token.kind == SINGLE_QUOTE_TOKEN) {\n             return consume();\n         } else {\n             recover(token, ctx);\n             return parseSingleQuoteToken(ctx);\n         }\n     }\n \n+    /**\n+     * Parse Single quote token.\n+     *\n+     * @return Single quote token\n+     */\n+    private STNode parseMultipleSingleQuoteToken(ParserRuleContext ctx) {", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex cfa656ad890..8e4cc03f891 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -470,7 +470,7 @@ public class TomlParser extends AbstractParser {\n      */\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n-        STNode content = parseStringContent(ParserRuleContext.STRING_CONTENT);\n+        STNode content = parseStringContent();\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUyNTg2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551525860", "bodyText": "we have a long if-else-if ladder which is slower and complex than equivalent switch. Shall we replace?", "author": "lochana-chathura", "createdAt": "2021-01-04T19:38:48Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -610,11 +668,14 @@ private STNode parseValueEnd() {\n \n     private STNode parseArrayValue() {\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN || nextToken.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n             return parseStringValue();\n-        } else if (nextToken.kind == SyntaxKind.SINGLE_QUOTE_TOKEN ||\n-                nextToken.kind == SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN) {\n+        } else if (nextToken.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex cfa656ad890..8e4cc03f891 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -668,33 +703,30 @@ public class TomlParser extends AbstractParser {\n \n     private STNode parseArrayValue() {\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n-            return parseStringValue();\n-        } else if (nextToken.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {\n-            return parseMultilineStringValue();\n-        } else if (nextToken.kind == SyntaxKind.SINGLE_QUOTE_TOKEN) {\n-            return parseLiteralStringValue();\n-        } else if (nextToken.kind == SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN) {\n-            return parseMultilineLiteralStringValue();\n-        } else if (isBasicValue(nextToken)) {\n-            return parseValue();\n-        } else if (nextToken.kind == OPEN_BRACKET_TOKEN) {\n-            return parseArray();\n-        } else if (nextToken.kind == CLOSE_BRACKET_TOKEN) {\n-            return null;\n-        } else if (nextToken.kind == NEWLINE) {\n-            consume();\n-            return parseArrayValue();\n-        } else {\n-            recover(peek(), ParserRuleContext.ARRAY_VALUE_START);\n-            return parseArrayValue();\n+        switch (nextToken.kind) {\n+            case DOUBLE_QUOTE_TOKEN:\n+                return parseStringValue();\n+            case TRIPLE_DOUBLE_QUOTE_TOKEN:\n+                return parseMultilineStringValue();\n+            case SINGLE_QUOTE_TOKEN:\n+                return parseLiteralStringValue();\n+            case TRIPLE_SINGLE_QUOTE_TOKEN:\n+                return parseMultilineLiteralStringValue();\n+            case DECIMAL_INT_TOKEN:\n+            case DECIMAL_FLOAT_TOKEN:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+                return parseValue();\n+            case OPEN_BRACKET_TOKEN:\n+                return parseArray();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            case NEWLINE:\n+                consume();\n+                return parseArrayValue();\n+            default:\n+                recover(peek(), ParserRuleContext.ARRAY_VALUE_START);\n+                return parseArrayValue();\n         }\n     }\n-\n-    private static boolean isBasicValue(STToken token) {\n-        return token.kind == SyntaxKind.DECIMAL_INT_TOKEN ||\n-                token.kind == SyntaxKind.DECIMAL_FLOAT_TOKEN ||\n-                token.kind == SyntaxKind.TRUE_KEYWORD ||\n-                token.kind == SyntaxKind.FALSE_KEYWORD;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUyNjYyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551526624", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                LITERAL_STRING_BODY(\"literal-string-content\"),\n          \n          \n            \n                LITERAL_STRING_BODY(\"literal-string-body\"),", "author": "lochana-chathura", "createdAt": "2021-01-04T19:40:26Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserRuleContext.java", "diffHunk": "@@ -61,9 +61,19 @@\n \n     // Expressions\n     DECIMAL_INTEGER_LITERAL(\"decimal-int-literal\"),\n+    STRING_BODY(\"string-body\"),\n+    MULTILINE_STRING_BODY(\"multiline-string-body\"),\n+    LITERAL_STRING_BODY(\"literal-string-content\"),", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserRuleContext.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserRuleContext.java\nindex fee7a111651..8e58554f23a 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserRuleContext.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserRuleContext.java\n\n@@ -63,7 +63,7 @@ public enum ParserRuleContext {\n     DECIMAL_INTEGER_LITERAL(\"decimal-int-literal\"),\n     STRING_BODY(\"string-body\"),\n     MULTILINE_STRING_BODY(\"multiline-string-body\"),\n-    LITERAL_STRING_BODY(\"literal-string-content\"),\n+    LITERAL_STRING_BODY(\"literal-string-body\"),\n     MULTILINE_LITERAL_STRING_BODY(\"multiline-literal-string-body\"),\n     STRING_CONTENT(\"string-content\"),\n     MULTILINE_STRING_CONTENT(\"multiline-string-content\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcwNDU3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551704570", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (nextChar == LexerTerminals.SINGLE_QUOTE && secondNextChar == LexerTerminals.SINGLE_QUOTE && thirdNextChar\n          \n          \n            \n                            == LexerTerminals.SINGLE_QUOTE) {\n          \n          \n            \n                    if (nextChar == LexerTerminals.SINGLE_QUOTE && secondNextChar == LexerTerminals.SINGLE_QUOTE && \n          \n          \n            \n                    thirdNextChar == LexerTerminals.SINGLE_QUOTE) {", "author": "lochana-chathura", "createdAt": "2021-01-05T04:01:34Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java", "diffHunk": "@@ -356,6 +365,32 @@ private STToken readMultilineStringToken() {\n         return getUnquotedKey();\n     }\n \n+    private STToken readMultilineLiteralStringToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        char nextChar = this.reader.peek();\n+        char secondNextChar = this.reader.peek(1);\n+        char thirdNextChar = this.reader.peek(2);\n+        if (nextChar == LexerTerminals.SINGLE_QUOTE && secondNextChar == LexerTerminals.SINGLE_QUOTE && thirdNextChar\n+                == LexerTerminals.SINGLE_QUOTE) {", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\nindex 08e8017b6bb..88e25a089b4 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlLexer.java\n\n@@ -374,8 +374,8 @@ public class TomlLexer extends AbstractLexer {\n         char nextChar = this.reader.peek();\n         char secondNextChar = this.reader.peek(1);\n         char thirdNextChar = this.reader.peek(2);\n-        if (nextChar == LexerTerminals.SINGLE_QUOTE && secondNextChar == LexerTerminals.SINGLE_QUOTE && thirdNextChar\n-                == LexerTerminals.SINGLE_QUOTE) {\n+        if (nextChar == LexerTerminals.SINGLE_QUOTE && secondNextChar == LexerTerminals.SINGLE_QUOTE &&\n+                thirdNextChar == LexerTerminals.SINGLE_QUOTE) {\n             endMode();\n             reader.advance(3);\n             return getSyntaxToken(SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcwODQ2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551708469", "bodyText": "We have a small problem here. We call parseStringContent in 4 places and depending on the context we need only one kind to be checked here. Here we are heavily depending on the lexer logic. i.e we assume SINGLE_QUOTE_TOKEN is always followed by SINGLE_QUOTE_TOKEN when the string content is empty. We can make parsing independent of lexer logic by having 4 separate methods to parse each.", "author": "lochana-chathura", "createdAt": "2021-01-05T04:20:00Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -445,35 +470,118 @@ private STNode parseBoolean() {\n      */\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n-        STNode content = parseStringContent();\n+        STNode content = parseStringContent(ParserRuleContext.STRING_CONTENT);\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n \n+    /**\n+     * Parse Multiline String Value.\n+     *\n+     * @return String Multiline String Literal Node.\n+     */\n+    private STNode parseMultilineStringValue() {\n+        STNode startingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.MULTILINE_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseTripleDoubleQuoteToken(ParserRuleContext.MULTILINE_STRING_END);\n+        return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Literal String Value.\n+     *\n+     * @return String Literal Node.\n+     */\n+    private STNode parseLiteralStringValue() {\n+        STNode startingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.LITERAL_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseSingleQuoteToken(ParserRuleContext.LITERAL_STRING_END);\n+        return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Multiline Literal String Value.\n+     *\n+     * @return Multiline String Literal Node.\n+     */\n+    private STNode parseMultilineLiteralStringValue() {\n+        STNode startingDoubleQuote = parseMultipleSingleQuoteToken(ParserRuleContext.MULTILINE_LITERAL_STRING_START);\n+        STNode content = parseStringContent(ParserRuleContext.MULTILINE_LITERAL_STRING_CONTENT);\n+        STNode endingDoubleQuote = parseMultipleSingleQuoteToken(ParserRuleContext.MULTILINE_LITERAL_STRING_END);\n+        return STNodeFactory.createLiteralStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n+    }\n+\n+    /**\n+     * Parse Single quote token.\n+     *\n+     * @return Single quote token\n+     */\n+    private STNode parseSingleQuoteToken(ParserRuleContext ctx) {\n+        STToken token = peek();\n+        if (token.kind == SINGLE_QUOTE_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ctx);\n+            return parseSingleQuoteToken(ctx);\n+        }\n+    }\n+\n+    /**\n+     * Parse Single quote token.\n+     *\n+     * @return Single quote token\n+     */\n+    private STNode parseMultipleSingleQuoteToken(ParserRuleContext ctx) {\n+        STToken token = peek();\n+        if (token.kind == TRIPLE_SINGLE_QUOTE_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ctx);\n+            return parseMultipleSingleQuoteToken(ctx);\n+        }\n+    }\n+\n     /**\n      * Parse Double quote token.\n      *\n      * @return Double quote token\n      */\n     private STNode parseDoubleQuoteToken(ParserRuleContext ctx) {\n         STToken token = peek();\n-        if (token.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN || token.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN\n-                || token.kind == SINGLE_QUOTE_TOKEN) {\n+        if (token.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN) {\n             return consume();\n         } else {\n             recover(token, ctx);\n             return parseDoubleQuoteToken(ctx);\n         }\n     }\n \n-    private STNode parseStringContent() {\n+    /**\n+     * Parse Triple Double quote token.\n+     *\n+     * @return Triple Double quote token\n+     */\n+    private STNode parseTripleDoubleQuoteToken(ParserRuleContext ctx) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ctx);\n+            return parseTripleDoubleQuoteToken(ctx);\n+        }\n+    }\n+\n+    private STNode parseStringContent(ParserRuleContext ctx) {\n         STToken nextToken = peek();\n         if (nextToken.kind == SyntaxKind.IDENTIFIER_LITERAL) {\n             return consume();\n-        } else {\n-            recover(nextToken, ParserRuleContext.STRING_CONTENT);\n-            return parseStringContent();\n         }\n+        if (nextToken.kind == SyntaxKind.DOUBLE_QUOTE_TOKEN || nextToken.kind == SINGLE_QUOTE_TOKEN ||\n+                nextToken.kind == TRIPLE_SINGLE_QUOTE_TOKEN || nextToken.kind == TRIPLE_DOUBLE_QUOTE_TOKEN) {", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\nindex cfa656ad890..8e4cc03f891 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java\n\n@@ -470,7 +470,7 @@ public class TomlParser extends AbstractParser {\n      */\n     private STNode parseStringValue() {\n         STNode startingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_START);\n-        STNode content = parseStringContent(ParserRuleContext.STRING_CONTENT);\n+        STNode content = parseStringContent();\n         STNode endingDoubleQuote = parseDoubleQuoteToken(ParserRuleContext.STRING_END);\n         return STNodeFactory.createStringLiteralNode(startingDoubleQuote, content, endingDoubleQuote);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcwOTU5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551709593", "bodyText": "can use == to check. (it can prevent possible NPE, complie time type safe and faster compared to a method call)", "author": "lochana-chathura", "createdAt": "2021-01-05T04:25:39Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlTransformer.java", "diffHunk": "@@ -338,24 +340,93 @@ private TomlNodeLocation getPosition(Node node) {\n \n     @Override\n     public TomlNode transform(StringLiteralNode stringLiteralNode) {\n-        String valueString = stringLiteralNode.content().text();\n+        boolean multilineString = isMultilineString(stringLiteralNode.startDoubleQuote());\n+        Optional<Token> content = stringLiteralNode.content();\n+        String valueString;\n+        if (content.isEmpty()) {\n+            valueString = \"\";\n+        } else {\n+            valueString = content.get().text();\n+            if (multilineString) {\n+                valueString = removeFirstNewline(valueString);\n+                valueString = trimBackslashWhitespaces(valueString);\n+            }\n+        }\n         String unescapedJava = StringEscapeUtils.unescapeJava(valueString);\n         TomlNodeLocation position = getPosition(stringLiteralNode);\n \n         return new TomlStringValueNode(unescapedJava, position);\n     }\n \n+    private String trimBackslashWhitespaces (String value) {\n+        StringBuilder output = new StringBuilder();\n+        String[] split = value.split(\"\\\\\\\\\\\\r?\\\\n\");\n+        for (String str : split) {\n+            output.append(str.stripLeading());\n+        }\n+        return output.toString();\n+    }\n+\n+    @Override\n+    public TomlNode transform(LiteralStringLiteralNode literalStringLiteralNode) {\n+        boolean multilineString = isMultilineString(literalStringLiteralNode.startSingleQuote());\n+        Optional<Token> content = literalStringLiteralNode.content();\n+        String valueString;\n+        if (content.isEmpty()) {\n+            valueString = \"\";\n+        } else {\n+            valueString = content.get().text();\n+            if (multilineString) {\n+                valueString = removeFirstNewline(valueString);\n+            }\n+        }\n+        TomlNodeLocation position = getPosition(literalStringLiteralNode);\n+\n+        return new TomlStringValueNode(valueString, position);\n+    }\n+\n+    private boolean isMultilineString(Token token) {\n+        return token.kind().equals(SyntaxKind.TRIPLE_SINGLE_QUOTE_TOKEN) ||\n+                token.kind().equals(SyntaxKind.TRIPLE_DOUBLE_QUOTE_TOKEN);", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlTransformer.java b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlTransformer.java\nindex 90ab8201242..f42a01f08b0 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlTransformer.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/semantic/ast/TomlTransformer.java\n\n@@ -358,7 +358,7 @@ public class TomlTransformer extends NodeTransformer<TomlNode> {\n         return new TomlStringValueNode(unescapedJava, position);\n     }\n \n-    private String trimBackslashWhitespaces (String value) {\n+    private String trimBackslashWhitespaces(String value) {\n         StringBuilder output = new StringBuilder();\n         String[] split = value.split(\"\\\\\\\\\\\\r?\\\\n\");\n         for (String str : split) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcwOTc4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27358#discussion_r551709789", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                INVALID_TOKEN_MINUTIAE_NODE(1603),\n          \n          \n            \n                INVALID_TOKEN_MINUTIAE_NODE(1602),", "author": "lochana-chathura", "createdAt": "2021-01-05T04:26:22Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -57,6 +62,7 @@\n     // Invalid nodes\n     INVALID_TOKEN(1600),\n     MISSING_VALUE(1601),\n+    INVALID_TOKEN_MINUTIAE_NODE(1603),", "originalCommit": "364940663b314f9f5ec6934b2dc33ea8559fb05a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "chunk": "diff --git a/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java b/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\nindex 80f5e258733..5151471c6f5 100644\n--- a/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\n+++ b/misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java\n\n@@ -62,7 +62,7 @@ public enum SyntaxKind {\n     // Invalid nodes\n     INVALID_TOKEN(1600),\n     MISSING_VALUE(1601),\n-    INVALID_TOKEN_MINUTIAE_NODE(1603),\n+    INVALID_TOKEN_MINUTIAE_NODE(1602),\n \n     // Documentation\n     MARKDOWN_DOCUMENTATION_LINE(1504),\n"}}, {"oid": "61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61610b48cbb641a37db9ad7b7e9bd862b35c92b9", "message": "Minor Refactoring to address review comments", "committedDate": "2021-01-05T05:28:16Z", "type": "commit"}]}