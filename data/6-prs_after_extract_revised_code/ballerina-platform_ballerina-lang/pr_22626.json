{"pr_number": 22626, "pr_title": "Add local-type-defn-stmt support for incremental parser", "pr_createdAt": "2020-04-15T07:36:22Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22626", "timeline": [{"oid": "a08543c59ebf824bbb1b91afc1f45406150e88f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a08543c59ebf824bbb1b91afc1f45406150e88f6", "message": "Add Local Type Definition Statement support", "committedDate": "2020-04-10T08:38:29Z", "type": "commit"}, {"oid": "802f20439819c13b3a936dee41d971da7e996c41", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/802f20439819c13b3a936dee41d971da7e996c41", "message": "finished adding tests", "committedDate": "2020-04-15T07:26:46Z", "type": "commit"}, {"oid": "bce9d4bfb8fecee12def1c385a1722b5bbceeda5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bce9d4bfb8fecee12def1c385a1722b5bbceeda5", "message": "Fix merge conflict", "committedDate": "2020-04-15T07:30:59Z", "type": "commit"}, {"oid": "53ede50ddeaa8d054917c0d1e89e8259825b7030", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53ede50ddeaa8d054917c0d1e89e8259825b7030", "message": "Fix merge conflict", "committedDate": "2020-04-15T07:34:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI1MTE3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22626#discussion_r409251170", "bodyText": "We can add annotations now, since the annotation support is available", "author": "SupunS", "createdAt": "2020-04-16T02:56:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4702,5 +4704,21 @@ private boolean isUnaryOperator(SyntaxKind kind) {\n                 return false;\n         }\n     }\n+\n+    /**\n+     * Parse local type definition statement statement.\n+     * <code>ocal-type-defn-stmt := [annots] type identifier type-descriptor ;</code>\n+     *\n+     * @return local type definition statement statement\n+     */\n+    private STNode parseLocalTypeDefinitionStatement() {\n+        startContext(ParserRuleContext.LOCAL_TYPE_DEFINITION_STMT);\n+        STNode typeKeyword = parseTypeKeyword();", "originalCommit": "53ede50ddeaa8d054917c0d1e89e8259825b7030", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4e5dfcde1cb058ecce6f06f785803d1dddb40ed", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 2f2f44b52c0..86fe7f52bd3 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -4705,20 +5212,157 @@ public class BallerinaParser {\n         }\n     }\n \n+    /**\n+     * Parse annotations.\n+     * <p>\n+     * <i>Note: In the ballerina spec ({@link https://ballerina.io/spec/lang/2020R1/#annots})\n+     * annotations-list is specified as one-or-more annotations. And the usage is marked as\n+     * optional annotations-list. However, for the consistency of the tree, here we make the\n+     * annotation-list as zero-or-more annotations, and the usage is not-optional.</i>\n+     * <p>\n+     * <code>annots := annotation*</code>\n+     * \n+     * @return Parsed node\n+     */\n+    private STNode parseAnnotations() {\n+        STToken nextToken = peek();\n+        return parseAnnotations(nextToken.kind);\n+    }\n+\n+    private STNode parseAnnotations(SyntaxKind nextTokenKind) {\n+        startContext(ParserRuleContext.ANNOTATIONS);\n+        List<STNode> annotList = new ArrayList<>();\n+        while (nextTokenKind == SyntaxKind.AT_TOKEN) {\n+            annotList.add(parseAnnotation());\n+            nextTokenKind = peek().kind;\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(annotList);\n+    }\n+\n+    /**\n+     * Parse annotation attachment.\n+     * <p>\n+     * <code>annotation := @ annot-tag-reference annot-value</code>\n+     * \n+     * @return Parsed node\n+     */\n+    private STNode parseAnnotation() {\n+        STNode atToken = parseAtToken();\n+        STNode annotReference = parseQualifiedIdentifier(ParserRuleContext.ANNOT_REFERENCE);\n+        STNode annotValue = parseMappingConstructorExpr();\n+        return STNodeFactory.createAnnotation(atToken, annotReference, annotValue);\n+    }\n+\n+    /**\n+     * Parse '@' token.\n+     * \n+     * @return Parsed node\n+     */\n+    private STNode parseAtToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.AT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.AT);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse metadata. Meta data consist of optional doc string and\n+     * an annotations list.\n+     * <p>\n+     * <code>metadata := [DocumentationString] annots</code>\n+     * \n+     * @return Parse node\n+     */\n+    private STNode parseMetaData() {\n+        STToken nextToken = peek();\n+        return parseMetaData(nextToken.kind);\n+    }\n+\n+    private STNode parseMetaData(SyntaxKind nextTokenKind) {\n+        STNode docString;\n+        STNode annotations;\n+        switch (nextTokenKind) {\n+            case HASH_TOKEN:\n+                // TODO:\n+                consume();\n+                docString = STNodeFactory.createEmptyNode();\n+                annotations = parseAnnotations();\n+                break;\n+            case AT_TOKEN:\n+                docString = STNodeFactory.createEmptyNode();\n+                annotations = parseAnnotations(nextTokenKind);\n+                break;\n+            default:\n+                return createEmptyMetadata();\n+        }\n+\n+        return STNodeFactory.createMetadata(docString, annotations);\n+    }\n+\n+    /**\n+     * Create empty metadata node.\n+     * \n+     * @return A metadata node with no doc string and no annotations\n+     */\n+    private STNode createEmptyMetadata() {\n+        return STNodeFactory.createMetadata(STNodeFactory.createEmptyNode(),\n+                STNodeFactory.createNodeList(new ArrayList<>()));\n+    }\n+\n+    /**\n+     * Get the number of tokens to skip to reach the end of annotations.\n+     * \n+     * @return Number of tokens to skip to reach the end of annotations\n+     */\n+    private int getNumberOfTokensToAnnotsEnd() {\n+        STToken nextToken;\n+        int lookahead = 0;\n+        while (true) {\n+            nextToken = peek(lookahead);\n+            switch (nextToken.kind) {\n+                case EOF_TOKEN:\n+                case FUNCTION_KEYWORD:\n+                case TYPE_KEYWORD:\n+                case LISTENER_KEYWORD:\n+                case CONST_KEYWORD:\n+                case IMPORT_KEYWORD:\n+                case SERVICE_KEYWORD:\n+                    return lookahead;\n+                case IDENTIFIER_TOKEN:\n+                    if (isVarDeclStart(lookahead)) {\n+                        return lookahead;\n+                    }\n+                    // fall through\n+                default:\n+                    lookahead++;\n+                    break;\n+            }\n+        }\n+    }\n+\n     /**\n      * Parse local type definition statement statement.\n      * <code>ocal-type-defn-stmt := [annots] type identifier type-descriptor ;</code>\n      *\n      * @return local type definition statement statement\n      */\n-    private STNode parseLocalTypeDefinitionStatement() {\n+    private STNode parseLocalTypeDefinitionStatement(STNode annots) {\n         startContext(ParserRuleContext.LOCAL_TYPE_DEFINITION_STMT);\n         STNode typeKeyword = parseTypeKeyword();\n         STNode typeName = parseTypeName();\n         STNode typeDescriptor = parseTypeDescriptor();\n         STNode semicolon = parseSemicolon();\n         endContext();\n-        return STNodeFactory.createLocalTypeDefinitionStatement(typeKeyword, typeName, typeDescriptor, semicolon);\n+        return STNodeFactory.createLocalTypeDefinitionStatement(\n+            annots,\n+            typeKeyword,\n+            typeName,\n+            typeDescriptor,\n+            semicolon);\n     }\n }\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5ODgxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22626#discussion_r409298813", "bodyText": "Lets address the TODO, or remove it if its already addressed", "author": "SupunS", "createdAt": "2020-04-16T05:54:32Z", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/statements/LocalTypeDefinitionStatement.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.ballerinalang.compiler.parser.test.syntax.statements;\n+\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test parsing object type definitions.\n+ */\n+public class LocalTypeDefinitionStatement extends AbstractStatementTest {\n+\n+    // Valid syntax tests\n+\n+    // TODO: abstract object | client object test", "originalCommit": "53ede50ddeaa8d054917c0d1e89e8259825b7030", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b42036b56eab2ede166c7aa4481a97a8356cdbe", "chunk": "diff --git a/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/statements/LocalTypeDefinitionStatement.java b/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/statements/LocalTypeDefinitionStatement.java\nindex 66dfcd11337..73252de41a7 100644\n--- a/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/statements/LocalTypeDefinitionStatement.java\n+++ b/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/statements/LocalTypeDefinitionStatement.java\n\n@@ -26,8 +26,6 @@ public class LocalTypeDefinitionStatement extends AbstractStatementTest {\n \n     // Valid syntax tests\n \n-    // TODO: abstract object | client object test\n-\n     @Test\n     public void testComplexLocalTypeDefStmt() {\n         testFile(\"local-type-defn-stmt/local_type_defn_stmt_source_01.bal\",\n"}}, {"oid": "b4e5dfcde1cb058ecce6f06f785803d1dddb40ed", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b4e5dfcde1cb058ecce6f06f785803d1dddb40ed", "message": "Added annots", "committedDate": "2020-04-16T09:33:38Z", "type": "commit"}, {"oid": "3b42036b56eab2ede166c7aa4481a97a8356cdbe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b42036b56eab2ede166c7aa4481a97a8356cdbe", "message": "Add annotation support for local type defn statement", "committedDate": "2020-04-16T10:51:00Z", "type": "commit"}, {"oid": "bed668ab2c0a573b70d82466c310c2175beec51a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bed668ab2c0a573b70d82466c310c2175beec51a", "message": "Add recovery", "committedDate": "2020-04-16T11:00:03Z", "type": "commit"}, {"oid": "7cbb5d58276ac6bb9f9ee88390f9bc307bfb13d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7cbb5d58276ac6bb9f9ee88390f9bc307bfb13d4", "message": "Fix Merge Conflict", "committedDate": "2020-04-16T11:05:38Z", "type": "commit"}]}