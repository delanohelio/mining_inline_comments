{"pr_number": 26610, "pr_title": "Add isolated module variable declaration parsing support", "pr_createdAt": "2020-10-26T20:30:27Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610", "timeline": [{"oid": "60143f04d22e6e95004c3f1d468ac1caa11d3fc6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60143f04d22e6e95004c3f1d468ac1caa11d3fc6", "message": "Modify syntax tree and test cases", "committedDate": "2020-10-23T13:58:50Z", "type": "commit"}, {"oid": "66f2b172de2621dcaf4ee954a3db621b86e9b143", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66f2b172de2621dcaf4ee954a3db621b86e9b143", "message": "Add isolated module var declaration parsing support", "committedDate": "2020-10-26T20:06:32Z", "type": "commit"}, {"oid": "150f92609a578d651bd8c0503ed0fe1b636d5f8c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/150f92609a578d651bd8c0503ed0fe1b636d5f8c", "message": "Refactor parser qualifier validation", "committedDate": "2020-10-27T10:01:53Z", "type": "commit"}, {"oid": "d527a6166714d0202e28f1b9b456e8d67f9f98ed", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d527a6166714d0202e28f1b9b456e8d67f9f98ed", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\n\u0001\tmisc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "committedDate": "2020-10-27T10:15:19Z", "type": "commit"}, {"oid": "f757890e5566f67857fe6e01007b45fd2a4326fb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f757890e5566f67857fe6e01007b45fd2a4326fb", "message": "Revert auto formatting changes when merging", "committedDate": "2020-10-27T11:12:45Z", "type": "commit"}, {"oid": "00bd03d44814aa909cbb1f89ce1c1cac14e89778", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/00bd03d44814aa909cbb1f89ce1c1cac14e89778", "message": "Fix few parsing issues", "committedDate": "2020-10-27T14:18:40Z", "type": "commit"}, {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a51c0896c4418c154dc264b5c2b1354fca6755fc", "message": "Fix isolated object unit tests", "committedDate": "2020-10-27T15:53:56Z", "type": "commit"}, {"oid": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a51c0896c4418c154dc264b5c2b1354fca6755fc", "message": "Fix isolated object unit tests", "committedDate": "2020-10-27T15:53:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0NjE1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514146156", "bodyText": "Since this method do both get+remove from the list, shall we call it extractVarDeclQualifiers()?", "author": "SupunS", "createdAt": "2020-10-29T10:14:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -828,23 +822,72 @@ private STNode parseTopLevelNode(STNode metadata, STNode publicQualifier, List<S\n                     // If the solution is {@link Action#KEEP}, that means next immediate token is\n                     // at the correct place, but some token after that is not. There only one such\n                     // cases here, which is the `case IDENTIFIER_TOKEN`. So accept it, and continue.\n-                    reportInvalidQualifierList(qualifiers);\n-                    return parseModuleVarDecl(metadata, publicQualifier);\n+                    reportInvalidQualifier(publicQualifier);\n+                    return parseModuleVarDecl(metadata, qualifiers);\n                 }\n \n                 return parseTopLevelNode(metadata, publicQualifier, qualifiers);\n         }\n     }\n \n-    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier) {\n-        List<STNode> topLevelQualifiers = new ArrayList<>();\n-        return parseModuleVarDecl(metadata, qualifier, topLevelQualifiers);\n+    private STNode parseModuleVarDecl(STNode metadata) {\n+        List<STNode> emptyList = new ArrayList<>();\n+        return parseVariableDecl(metadata, emptyList, emptyList, true);\n     }\n \n-    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier, List<STNode> qualifiers) {\n-        reportInvalidQualifier(qualifier);\n-        STNode finalKeyword = STNodeFactory.createEmptyNode();\n-        return parseVariableDecl(metadata, finalKeyword, qualifiers, true);\n+    /**\n+     * <p>\n+     * Parse module variable declaration.\n+     * </p>\n+     *\n+     * <code>\n+     * module-var-decl := module-init-var-decl | module-no-init-var-decl\n+     * <br/><br/>\n+     * module-init-var-decl := metadata isolated-final-quals typed-binding-pattern = expression ;\n+     * <br/><br/>\n+     * module-no-init-var-decl := metadata [final] type-descriptor variable-name ;\n+     * <br/><br/>\n+     * isolated-final-quals := (final | isolated-qual)*\n+     * </code>\n+     *\n+     * @param metadata           Preceding metadata\n+     * @param topLevelQualifiers Preceding top level qualifiers\n+     * @return Parsed node\n+     */\n+    private STNode parseModuleVarDecl(STNode metadata, List<STNode> topLevelQualifiers) {\n+        List<STNode> varDeclQuals = getVarDeclQualifiers(topLevelQualifiers);\n+        return parseVariableDecl(metadata, varDeclQuals, topLevelQualifiers, true);\n+    }\n+\n+    private List<STNode> getVarDeclQualifiers(List<STNode> qualifiers) {", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -855,11 +855,11 @@ public class BallerinaParser extends AbstractParser {\n      * @return Parsed node\n      */\n     private STNode parseModuleVarDecl(STNode metadata, List<STNode> topLevelQualifiers) {\n-        List<STNode> varDeclQuals = getVarDeclQualifiers(topLevelQualifiers);\n+        List<STNode> varDeclQuals = extractVarDeclQualifiers(topLevelQualifiers);\n         return parseVariableDecl(metadata, varDeclQuals, topLevelQualifiers, true);\n     }\n \n-    private List<STNode> getVarDeclQualifiers(List<STNode> qualifiers) {\n+    private List<STNode> extractVarDeclQualifiers(List<STNode> qualifiers) {\n         // Check if the first two qualifiers are belong to the variable declaration.\n         // If they do, extract them to a separate list and return.\n         List<STNode> varDeclQualList = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDUzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514150539", "bodyText": "Why do we need to remove this?\nI feel handling duplicate qualifiers in one place would be cleaner.", "author": "SupunS", "createdAt": "2020-10-29T10:21:55Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -942,43 +982,32 @@ private boolean isObjectMemberQualifier(SyntaxKind tokenKind) {\n     private void parseTopLevelQualifiers(List<STNode> qualifiers) {\n         while (isTopLevelQualifier(peek().kind)) {\n             STToken qualifier = consume();\n-            if (isNodeWithSyntaxKindInList(qualifiers, qualifier.kind)) {\n-                updateLastNodeInListOrAddInvalidNodeToNextToken(qualifiers, qualifier,\n-                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, qualifier.text());\n-            } else {\n-                qualifiers.add(qualifier);\n-            }\n+            qualifiers.add(qualifier);\n         }\n     }\n \n     private void parseTypeDescQualifiers(List<STNode> qualifiers) {\n         while (isTypeDescQualifier(peek().kind)) {\n             STToken qualifier = consume();\n-            if (isNodeWithSyntaxKindInList(qualifiers, qualifier.kind)) {", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMzI4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515833285", "bodyText": "Removed considering the language complications.\nExample 1:\nAt top level something like below is valid.\nisolated isolated object { } a = b;\n\nHere we have duplicate qualifiers and we don't know if it results in an syntax error until equal sign is parsed.\nThis forces us to remove the duplicate restriction from parseTopLevelQualifiers and move that validation to the end.\nSince duplicate restriction was removed from parseTopLevelQualifiers, for the consistency I removed it parseTypeDescQualifiers, parseObjectMemberQualifiers so that duplication validation takes place at the parsing end in all places, which I think is cleaner. WDYT?\n\nExample 2:\nAt both top level and type descriptor level something like below is a valid type. (recursively using distinct type desc).\ndistinct distinct distinct student ;\nFor now I have excluded distinct as a top level/ type desc level qualifier with following check. But, in future we can consider adding it to the qualifier list and parse it recursively in parseTypeDescriptorInternal.\ncase DISTINCT_KEYWORD: // class-def, distinct-type-desc\n                nextNextToken = getNextNextToken();\n                // distinct-type-desc can occur recursively.\n                // e.g. `distinct distinct student` is a valid type descriptor\n                // Treat distinct as a top level qualifier only with class definition.\n                switch (nextNextToken.kind) {\n                    case CLIENT_KEYWORD:\n                    case READONLY_KEYWORD:\n                    case ISOLATED_KEYWORD:\n                    case CLASS_KEYWORD:\n                        return true;\n                    default:\n                        return false;\n                }", "author": "lochana-chathura", "createdAt": "2020-11-02T09:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NTY4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515855689", "bodyText": "I see. ok", "author": "SupunS", "createdAt": "2020-11-02T09:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDUzOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514152654", "bodyText": "Can we send all qualifiers in a single list?\nThen we don't have to do the null checks either in the downstream code", "author": "SupunS", "createdAt": "2020-10-29T10:25:40Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -991,73 +1020,66 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      * function-type-descriptor := `function` function-signature\n      * </code>\n      *\n-     * @param context Parsing context\n      * @param metadata Preceding metadata\n+     * @param visibilityQualifier\n      * @param qualifiers Preceding visibility qualifier\n      * @param isObjectMember Whether object member or not\n      * @param isObjectTypeDesc Whether object type or not\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMzQzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515833435", "bodyText": "We already did  this change when implementing new service changes in service-typing branch. There also had to move validation to parsing end. No null checks at the middle. Only at the end validation. Here in master we have null checks in the middle since I didn't align parseResource. When syncing they will be removed.\nAnyway if we treat it as a single list,  at the end validation we will have to extract it from the list before validating. WDYT?", "author": "lochana-chathura", "createdAt": "2020-11-02T09:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1MDgyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515850825", "bodyText": "ack.\nWill it handle duplicate public qualifiers?", "author": "SupunS", "createdAt": "2020-11-02T09:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0ODM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515948352", "bodyText": "As of now public qualifier is not a part of parseToplvelQualifiers.\nIt is parsed only one time and in case duplicated will be removed under TOP_LEVEL_NODE_WITHOUT_MODIFIER at recovery.", "author": "lochana-chathura", "createdAt": "2020-11-02T12:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwNTY4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r516405681", "bodyText": "ok", "author": "SupunS", "createdAt": "2020-11-03T03:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MjY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..c5c1ffbd9b8 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -1045,7 +1045,7 @@ public class BallerinaParser extends AbstractParser {\n             STNode qualifier = qualifierList.get(i);\n             int nextIndex = i + 1;\n \n-            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {\n+            if (isDuplicate(validatedList, qualifier.kind)) {\n                 updateLastNodeInListWithInvalidNode(validatedList, qualifier,\n                         DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n             } else if (isValidFuncDefQualifier(qualifier.kind)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1NDY5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r514154696", "bodyText": "Better to rename isNodeWithSyntaxKindInList to isDuplicateQualifier", "author": "SupunS", "createdAt": "2020-10-29T10:29:08Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -991,73 +1020,66 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      * function-type-descriptor := `function` function-signature\n      * </code>\n      *\n-     * @param context Parsing context\n      * @param metadata Preceding metadata\n+     * @param visibilityQualifier\n      * @param qualifiers Preceding visibility qualifier\n      * @param isObjectMember Whether object member or not\n      * @param isObjectTypeDesc Whether object type or not\n      * @return Parsed node\n      */\n-    private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n+    private STNode parseFuncDefOrFuncTypeDesc(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n                                               boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNode qualifierList;\n-        // TODO: remove validation at this level when syncing to service-typing branch\n-        if (context == ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC) {\n-            qualifierList = createFuncDefNodeList(qualifiers);\n-        } else {\n-            qualifierList = createMethodQualNodeList(qualifiers);\n-        }\n-        return parseFuncDefOrFuncTypeDesc(metadata, qualifierList, isObjectMember, isObjectTypeDesc);\n+        startContext(ParserRuleContext.FUNC_DEF_OR_FUNC_TYPE);\n+        STNode functionKeyword = parseFunctionKeyword();\n+        STNode funcDefOrType = parseFunctionKeywordRhs(metadata, visibilityQualifier, qualifiers, functionKeyword,\n+                isObjectMember, isObjectTypeDesc);\n+        return funcDefOrType;\n     }\n \n     private STNode createFuncDefNodeList(List<STNode> qualifierList) {\n         // This method is temporary. Will be removed when syncing to service-typing branch\n         // Validate qualifiers and create a STNodeList\n-        for (int i = 0; i < qualifierList.size();) {\n+        List<STNode> validatedList = new ArrayList<>();\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n             STNode qualifier = qualifierList.get(i);\n-            if (isValidFuncDefQualifier(qualifier.kind)) {\n-                i++;\n-                continue;\n-            }\n+            int nextIndex = i + 1;\n \n-            qualifierList.remove(i);\n-            if (qualifierList.size() == i) {\n-                addInvalidNodeToNextToken(qualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n-                        ((STToken) qualifier).text());\n-            } else {\n-                STNode nextQual = qualifierList.remove(i);\n-                nextQual = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(nextQual, qualifier,\n+            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0ODQ2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515948466", "bodyText": "isNodeWithSyntaxKindInList is used / can be used in the places other than checking for duplicate qualifiers. Changing the name would be a problem in such scenario.\nIn fact in duplicate check we have \"ERROR_DUPLICATE_QUALIFIER\" in the next line. So keeping the name as it is, would not affect readability I think. WDYT?", "author": "lochana-chathura", "createdAt": "2020-11-02T12:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1NDY5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r516382597", "bodyText": "We can say isDuplicate then. It's more intuitive.", "author": "SupunS", "createdAt": "2020-11-03T01:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1NDY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..c5c1ffbd9b8 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -1045,7 +1045,7 @@ public class BallerinaParser extends AbstractParser {\n             STNode qualifier = qualifierList.get(i);\n             int nextIndex = i + 1;\n \n-            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {\n+            if (isDuplicate(validatedList, qualifier.kind)) {\n                 updateLastNodeInListWithInvalidNode(validatedList, qualifier,\n                         DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n             } else if (isValidFuncDefQualifier(qualifier.kind)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNjI3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515726274", "bodyText": "Theres a qualifier validation at the start of this function. Can we handle this also in the same block?", "author": "SupunS", "createdAt": "2020-11-02T03:41:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1197,72 +1207,78 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         // Function definition cannot have missing param-names. So validate it.\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n-        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifiers,\n+        // TODO: remove following block when syncing to service-typing branch\n+        if (visibilityQualifier != null) {\n+            qualifiers.add(0, visibilityQualifier);\n+        }\n+        STNode qualifierNodeList;\n+        if (isObjectMember) {\n+            qualifierNodeList = createMethodQualNodeList(qualifiers);\n+        } else {\n+            qualifierNodeList = createFuncDefNodeList(qualifiers);\n+        }\n+\n+        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifierNodeList,\n                 isObjectMember, isObjectTypeDesc);\n         endContext();\n         return funcDef;\n     }\n \n-    private STNode parseVarDeclWithFunctionType(STNode functionKeyword, STNode funcSignature, STNode qualifiers,\n-                                                STNode metadata, boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNodeList qualifierList = (STNodeList) qualifiers;\n-        STNode visibilityQualifier = STNodeFactory.createEmptyNode();\n+    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n+                                                STNode functionKeyword, STNode funcSignature, boolean isObjectMember,\n+                                                boolean isObjectTypeDesc) {\n+        List<STNode> isolatedFinalQualifiers = new ArrayList<>();\n+        if (!isObjectMember) {\n+            isolatedFinalQualifiers = getVarDeclQualifiers(qualifiers);\n+        }\n+\n         List<STNode> validatedQualifierList = new ArrayList<>();\n \n         // qualifiers are only allowed in the following cases for func type desc.\n         // isolated and transactional qualifiers are allowed.\n         // public, private and remote qualifiers are allowed in object field.\n-        for (int position = 0; position < qualifierList.size(); position++) {\n-            STNode qualifier = qualifierList.get(position);\n+        for (int position = 0; position < qualifiers.size(); position++) {\n+            STNode qualifier = qualifiers.get(position);\n \n             if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD || qualifier.kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {\n                 validatedQualifierList.add(qualifier);\n                 continue;\n             }\n \n-            if (isObjectMember) {\n-                if (isVisibilityQualifier(qualifier)) {\n-                    // public or private qualifier allowed in object field.\n-                    visibilityQualifier = qualifier;\n-                    continue;\n-                } else if (qualifier.kind == SyntaxKind.REMOTE_KEYWORD) {\n-                    validatedQualifierList.add(qualifier);\n-                    continue;\n-                }\n-            }\n-\n             functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n                     DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n         }\n \n-        qualifiers = STNodeFactory.createNodeList(validatedQualifierList);\n-        STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifiers, functionKeyword,\n+        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedQualifierList);\n+        STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifierNodeList, functionKeyword,\n                 funcSignature);\n \n         // Check if it is a complex type desc starting with function type.\n         typeDesc = parseComplexTypeDescriptor(typeDesc,\n                 ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC, false);\n \n         if (isObjectMember) {\n-            STNode readonlyQualifier = STNodeFactory.createEmptyNode();\n+            STNode finalQualifier = STNodeFactory.createEmptyNode();\n             STNode fieldName = parseVariableName();\n-            return parseObjectFieldRhs(metadata, visibilityQualifier, readonlyQualifier, typeDesc, fieldName,\n+            return parseObjectFieldRhs(metadata, visibilityQualifier, finalQualifier, typeDesc, fieldName,\n                     isObjectTypeDesc);\n         }\n \n+        if (visibilityQualifier != null) {\n+            // Visibility qualifier is not allowed in the variable declaration\n+            STToken invalidQualifier = (STToken) visibilityQualifier;\n+            if (isolatedFinalQualifiers.isEmpty()) {\n+                typeDesc = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDesc, invalidQualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+            } else {\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidQualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+            }\n+        }", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -1224,32 +1224,56 @@ public class BallerinaParser extends AbstractParser {\n         return funcDef;\n     }\n \n-    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n+    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifierList,\n                                                 STNode functionKeyword, STNode funcSignature, boolean isObjectMember,\n                                                 boolean isObjectTypeDesc) {\n-        List<STNode> isolatedFinalQualifiers = new ArrayList<>();\n+\n+        // --------------------------------------- Validate Qualifiers ---------------------------------------------\n+\n+        List<STNode> varDeclQualifiers = new ArrayList<>();\n+\n         if (!isObjectMember) {\n-            isolatedFinalQualifiers = getVarDeclQualifiers(qualifiers);\n+            if (visibilityQualifier != null) {\n+                // Visibility qualifier is not allowed in the variable declaration\n+                STToken invalidQualifier = (STToken) visibilityQualifier;\n+                if (qualifierList.isEmpty()) {\n+                    functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword,\n+                            visibilityQualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                            ((STToken) visibilityQualifier).text());\n+                } else {\n+                    updateFirstNodeInListWithInvalidNode(qualifierList, invalidQualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+                }\n+            }\n+\n+            varDeclQualifiers = extractVarDeclQualifiers(qualifierList);\n         }\n \n-        List<STNode> validatedQualifierList = new ArrayList<>();\n+        // Validate qualifiers and create a STNodeList\n+        List<STNode> validatedList = new ArrayList<>();\n \n-        // qualifiers are only allowed in the following cases for func type desc.\n-        // isolated and transactional qualifiers are allowed.\n-        // public, private and remote qualifiers are allowed in object field.\n-        for (int position = 0; position < qualifiers.size(); position++) {\n-            STNode qualifier = qualifiers.get(position);\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            int nextIndex = i + 1;\n \n-            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD || qualifier.kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {\n-                validatedQualifierList.add(qualifier);\n-                continue;\n+            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {\n+                updateLastNodeInListWithInvalidNode(validatedList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else if (isRegularFuncQualifier(qualifier.kind)) {\n+                validatedList.add(qualifier);\n+            } else if (qualifierList.size() == nextIndex) {\n+                functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n+            } else {\n+                updateANodeInListWithInvalidNode(qualifierList, nextIndex, qualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n             }\n-\n-            functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n-                    DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n         }\n \n-        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedQualifierList);\n+        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedList);\n+\n+        // --------------------------------------- End of Validation -----------------------------------------------\n+\n         STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifierNodeList, functionKeyword,\n                 funcSignature);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNzE0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515727140", "bodyText": "I feel this check should be moved to createFuncDefOrMethodDecl  method.", "author": "SupunS", "createdAt": "2020-11-02T03:46:43Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1197,72 +1207,78 @@ private STNode parseReturnTypeDescRhs(STNode metadata, STNode functionKeyword, S\n         // Function definition cannot have missing param-names. So validate it.\n         funcSignature = validateAndGetFuncParams((STFunctionSignatureNode) funcSignature);\n \n-        STNode funcDef = createFuncDefOrMethodDecl(metadata, functionKeyword, name, funcSignature, qualifiers,\n+        // TODO: remove following block when syncing to service-typing branch\n+        if (visibilityQualifier != null) {\n+            qualifiers.add(0, visibilityQualifier);\n+        }\n+        STNode qualifierNodeList;\n+        if (isObjectMember) {\n+            qualifierNodeList = createMethodQualNodeList(qualifiers);\n+        } else {\n+            qualifierNodeList = createFuncDefNodeList(qualifiers);\n+        }", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMzUwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515833503", "bodyText": "yea it should be. This is a temporary workaround. whole block is removed when syncing to service-typing branch as the TODO above. Is it alright? or do we need to do that refactoring here also?", "author": "lochana-chathura", "createdAt": "2020-11-02T09:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNzE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NjAyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515856029", "bodyText": "ack. should be fine", "author": "SupunS", "createdAt": "2020-11-02T09:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyNzE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -1224,32 +1224,56 @@ public class BallerinaParser extends AbstractParser {\n         return funcDef;\n     }\n \n-    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifiers,\n+    private STNode parseVarDeclWithFunctionType(STNode metadata, STNode visibilityQualifier, List<STNode> qualifierList,\n                                                 STNode functionKeyword, STNode funcSignature, boolean isObjectMember,\n                                                 boolean isObjectTypeDesc) {\n-        List<STNode> isolatedFinalQualifiers = new ArrayList<>();\n+\n+        // --------------------------------------- Validate Qualifiers ---------------------------------------------\n+\n+        List<STNode> varDeclQualifiers = new ArrayList<>();\n+\n         if (!isObjectMember) {\n-            isolatedFinalQualifiers = getVarDeclQualifiers(qualifiers);\n+            if (visibilityQualifier != null) {\n+                // Visibility qualifier is not allowed in the variable declaration\n+                STToken invalidQualifier = (STToken) visibilityQualifier;\n+                if (qualifierList.isEmpty()) {\n+                    functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword,\n+                            visibilityQualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                            ((STToken) visibilityQualifier).text());\n+                } else {\n+                    updateFirstNodeInListWithInvalidNode(qualifierList, invalidQualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, invalidQualifier.text());\n+                }\n+            }\n+\n+            varDeclQualifiers = extractVarDeclQualifiers(qualifierList);\n         }\n \n-        List<STNode> validatedQualifierList = new ArrayList<>();\n+        // Validate qualifiers and create a STNodeList\n+        List<STNode> validatedList = new ArrayList<>();\n \n-        // qualifiers are only allowed in the following cases for func type desc.\n-        // isolated and transactional qualifiers are allowed.\n-        // public, private and remote qualifiers are allowed in object field.\n-        for (int position = 0; position < qualifiers.size(); position++) {\n-            STNode qualifier = qualifiers.get(position);\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            int nextIndex = i + 1;\n \n-            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD || qualifier.kind == SyntaxKind.TRANSACTIONAL_KEYWORD) {\n-                validatedQualifierList.add(qualifier);\n-                continue;\n+            if (isNodeWithSyntaxKindInList(validatedList, qualifier.kind)) {\n+                updateLastNodeInListWithInvalidNode(validatedList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else if (isRegularFuncQualifier(qualifier.kind)) {\n+                validatedList.add(qualifier);\n+            } else if (qualifierList.size() == nextIndex) {\n+                functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n+            } else {\n+                updateANodeInListWithInvalidNode(qualifierList, nextIndex, qualifier,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n             }\n-\n-            functionKeyword = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(functionKeyword, qualifier,\n-                    DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n         }\n \n-        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedQualifierList);\n+        STNode qualifierNodeList = STNodeFactory.createNodeList(validatedList);\n+\n+        // --------------------------------------- End of Validation -----------------------------------------------\n+\n         STNode typeDesc = STNodeFactory.createFunctionTypeDescriptorNode(qualifierNodeList, functionKeyword,\n                 funcSignature);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515728214", "bodyText": "This is a semantic validation. We don't need to handle that in the parser.", "author": "SupunS", "createdAt": "2020-11-02T03:52:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0OTUwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515949501", "bodyText": "Thing is isolatedFinalQualifiers can only have following possibilities.\nempty, final, isolated, final isolated and isolated final. No duplicate scenarios.\nWhen parsing isolated, final isolated had  to be anyway validated as we should let isolated to be part of the type descriptor.\nOnly missing validation scenario is isolated final. We can simply do that also in parser as all other scenarios are already filtered. It only adds 3 lines. Shall we keep?", "author": "lochana-chathura", "createdAt": "2020-11-02T12:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4Mzc5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r516383797", "bodyText": "Sorry, I was referring to the comment \"Only final qualifier is allowed for non initialized module var declaration\".\nWe don't need to do cross validation between qualifiers and the presence of the initializer, at the parser level - That usually is done at the semantic analyzer.", "author": "SupunS", "createdAt": "2020-11-03T01:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MTM1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r522041356", "bodyText": "@MaryamZi Sorry I forgot pass this piece of information.\nWe need to do semantic validation for isolated-module-non-init-var-decl.\nFor example in following scenario we don't log an error in parser,\nisolated final object{ }  obj;\nBut in the other scenarios we were forced to validate at parser as it could be a part of the immediate type descriptor.", "author": "lochana-chathura", "createdAt": "2020-11-12T11:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NDg1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r522044859", "bodyText": "Noted, will add this validation. Thanks!", "author": "MaryamZi", "createdAt": "2020-11-12T11:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -3578,36 +3590,8 @@ public class BallerinaParser extends AbstractParser {\n \n         endContext();\n         if (isModuleVar) {\n-            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n-                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                        typedBindingPattern, assign, expr, semicolon);\n-            }\n-\n-            // Only final qualifier is allowed for non initialized module var declaration\n-\n-            // If type descriptor in the binding pattern is either object or function type\n-            // and qualifier list has isolated qualifier as the last token,\n-            // that isolated qualifier should be part of the type.\n-            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n-            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n-                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n-                typedBindingPattern =\n-                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n-            }\n-\n-            // Now the list can have only following possibilities\n-            // empty, final, isolated final\n-            if (!isolatedFinalQualifiers.isEmpty() &&\n-                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n-                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n-                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n-                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n-            }\n-\n-            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                    typedBindingPattern, assign, expr, semicolon);\n+            return createModuleVarDeclaration(metadata, isolatedFinalQualifiers, typedBindingPattern, assign, expr,\n+                    semicolon, hasVarInit);\n         }\n \n         STNode finalKeyword;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcyODgxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515728816", "bodyText": "This method has become a bit too large. Shall we extract everything inside if (isModuleVar) {...} to a separate method?", "author": "SupunS", "createdAt": "2020-11-02T03:55:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n+                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n+            }\n+\n+            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                    typedBindingPattern, assign, expr, semicolon);\n+        }", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -3578,36 +3590,8 @@ public class BallerinaParser extends AbstractParser {\n \n         endContext();\n         if (isModuleVar) {\n-            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n-                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                        typedBindingPattern, assign, expr, semicolon);\n-            }\n-\n-            // Only final qualifier is allowed for non initialized module var declaration\n-\n-            // If type descriptor in the binding pattern is either object or function type\n-            // and qualifier list has isolated qualifier as the last token,\n-            // that isolated qualifier should be part of the type.\n-            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n-            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n-                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n-                typedBindingPattern =\n-                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n-            }\n-\n-            // Now the list can have only following possibilities\n-            // empty, final, isolated final\n-            if (!isolatedFinalQualifiers.isEmpty() &&\n-                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n-                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n-                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n-                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n-            }\n-\n-            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                    typedBindingPattern, assign, expr, semicolon);\n+            return createModuleVarDeclaration(metadata, isolatedFinalQualifiers, typedBindingPattern, assign, expr,\n+                    semicolon, hasVarInit);\n         }\n \n         STNode finalKeyword;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMDg0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515730843", "bodyText": "Duplicate qualifier validation should happen in a single place IMO", "author": "SupunS", "createdAt": "2020-11-02T04:06:13Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -3578,36 +3590,8 @@ public class BallerinaParser extends AbstractParser {\n \n         endContext();\n         if (isModuleVar) {\n-            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n-                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                        typedBindingPattern, assign, expr, semicolon);\n-            }\n-\n-            // Only final qualifier is allowed for non initialized module var declaration\n-\n-            // If type descriptor in the binding pattern is either object or function type\n-            // and qualifier list has isolated qualifier as the last token,\n-            // that isolated qualifier should be part of the type.\n-            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n-            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n-                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n-                typedBindingPattern =\n-                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n-            }\n-\n-            // Now the list can have only following possibilities\n-            // empty, final, isolated final\n-            if (!isolatedFinalQualifiers.isEmpty() &&\n-                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n-                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n-                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n-                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n-            }\n-\n-            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                    typedBindingPattern, assign, expr, semicolon);\n+            return createModuleVarDeclaration(metadata, isolatedFinalQualifiers, typedBindingPattern, assign, expr,\n+                    semicolon, hasVarInit);\n         }\n \n         STNode finalKeyword;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMTA3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515731073", "bodyText": "Method name modifyTypedBindingPatternWithMissingQualifier suggests you are updating the node with a missing qualifier, but here the qualifier is isolated", "author": "SupunS", "createdAt": "2020-11-02T04:07:43Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -3578,36 +3590,8 @@ public class BallerinaParser extends AbstractParser {\n \n         endContext();\n         if (isModuleVar) {\n-            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n-                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                        typedBindingPattern, assign, expr, semicolon);\n-            }\n-\n-            // Only final qualifier is allowed for non initialized module var declaration\n-\n-            // If type descriptor in the binding pattern is either object or function type\n-            // and qualifier list has isolated qualifier as the last token,\n-            // that isolated qualifier should be part of the type.\n-            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n-            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n-                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n-                typedBindingPattern =\n-                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n-            }\n-\n-            // Now the list can have only following possibilities\n-            // empty, final, isolated final\n-            if (!isolatedFinalQualifiers.isEmpty() &&\n-                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n-                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n-                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n-                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n-            }\n-\n-            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                    typedBindingPattern, assign, expr, semicolon);\n+            return createModuleVarDeclaration(metadata, isolatedFinalQualifiers, typedBindingPattern, assign, expr,\n+                    semicolon, hasVarInit);\n         }\n \n         STNode finalKeyword;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMTQ4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515731486", "bodyText": "Qualifier extraction part is common to this and the method above this one. Can extract to a common method.", "author": "SupunS", "createdAt": "2020-11-02T04:10:03Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3553,26 +3563,139 @@ private STNode parseVarDeclRhs(STNode metadata, STNode finalKeyword, STNode type\n                     expr = parseActionOrExpression();\n                 }\n                 semicolon = parseSemicolon();\n+                hasVarInit = true;\n                 break;\n             case SEMICOLON_TOKEN:\n                 assign = STNodeFactory.createEmptyNode();\n                 expr = STNodeFactory.createEmptyNode();\n                 semicolon = parseSemicolon();\n                 break;\n             default:\n-                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, finalKeyword, typedBindingPattern,\n-                        isModuleVar);\n-                return parseVarDeclRhs(metadata, finalKeyword, typedBindingPattern, isModuleVar);\n+                recover(nextToken, ParserRuleContext.VAR_DECL_STMT_RHS, metadata, isolatedFinalQualifiers,\n+                        typedBindingPattern, isModuleVar);\n+                return parseVarDeclRhs(metadata, isolatedFinalQualifiers, typedBindingPattern, isModuleVar);\n         }\n \n         endContext();\n         if (isModuleVar) {\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern,\n-                    assign, expr, semicolon);\n+            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n+                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                        typedBindingPattern, assign, expr, semicolon);\n+            }\n+\n+            // Only final qualifier is allowed for non initialized module var declaration\n+\n+            // If type descriptor in the binding pattern is either object or function type\n+            // and qualifier list has isolated qualifier as the last token,\n+            // that isolated qualifier should be part of the type.\n+            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n+            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n+                typedBindingPattern =\n+                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n+            }\n+\n+            // Now the list can have only following possibilities\n+            // empty, final, isolated final\n+            if (!isolatedFinalQualifiers.isEmpty() &&\n+                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n+                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n+                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n+                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n+            }\n+\n+            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n+            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n+                    typedBindingPattern, assign, expr, semicolon);\n+        }\n+\n+        STNode finalKeyword;\n+        if (isolatedFinalQualifiers.isEmpty()) {\n+            finalKeyword = STNodeFactory.createEmptyNode();\n+        } else {\n+            finalKeyword = isolatedFinalQualifiers.get(0);\n         }\n         assert metadata.kind == SyntaxKind.LIST; // Annotations only\n-        return STNodeFactory.createVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern, assign, expr,\n-                semicolon);\n+        return STNodeFactory.createVariableDeclarationNode(metadata, finalKeyword, typedBindingPattern, assign,\n+                expr, semicolon);\n+    }\n+\n+    private STNode modifyTypedBindingPatternWithMissingQualifier(STNode typedBindingPattern, STNode isolatedQualifier) {\n+        STTypedBindingPatternNode typedBindingPatternNode = (STTypedBindingPatternNode) typedBindingPattern;\n+        STNode typeDescriptor = typedBindingPatternNode.typeDescriptor;\n+        STNode bindingPattern = typedBindingPatternNode.bindingPattern;\n+        switch (typeDescriptor.kind) {\n+            case OBJECT_TYPE_DESC:\n+                typeDescriptor = modifyObjectTypeDescWithIsolatedQualifier(typeDescriptor, isolatedQualifier);\n+                break;\n+            case FUNCTION_TYPE_DESC:\n+                typeDescriptor = modifyFuncTypeDescWithIsolatedQualifier(typeDescriptor, isolatedQualifier);\n+                break;\n+            default:\n+                typeDescriptor = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(typeDescriptor, isolatedQualifier);\n+        }\n+\n+        return STNodeFactory.createTypedBindingPatternNode(typeDescriptor, bindingPattern);\n+    }\n+\n+    /**\n+     * Add isolated qualifier to object type descriptor and modify the node.\n+     *\n+     * @param objectTypeDesc  Object type descriptor node to be modified\n+     * @param isolatedKeyword Isolated keyword to be made an object type qualifier\n+     * @return Modified node\n+     */\n+    private STNode modifyObjectTypeDescWithIsolatedQualifier(STNode objectTypeDesc, STNode isolatedKeyword) {\n+        List<STNode> newQualifierList = new ArrayList<>();\n+        newQualifierList.add(isolatedKeyword);\n+\n+        STObjectTypeDescriptorNode objectTypeDescriptorNode = (STObjectTypeDescriptorNode) objectTypeDesc;\n+        STNodeList qualifierList = (STNodeList) objectTypeDescriptorNode.objectTypeQualifiers;\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                updateLastNodeInListWithInvalidNode(newQualifierList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else {\n+                newQualifierList.add(qualifier);\n+            }\n+        }\n+\n+        STNode newObjectTypeQualifiers = STNodeFactory.createNodeList(newQualifierList);\n+        return objectTypeDescriptorNode.modify(newObjectTypeQualifiers, objectTypeDescriptorNode.objectKeyword,\n+                objectTypeDescriptorNode.openBrace, objectTypeDescriptorNode.members,\n+                objectTypeDescriptorNode.closeBrace);\n+    }\n+\n+    /**\n+     * Add isolated qualifier to function type descriptor and modify the node.\n+     *\n+     * @param funcTypeDesc  Function type descriptor node to be modified\n+     * @param isolatedKeyword Isolated keyword to be made an object type qualifier\n+     * @return Modified node\n+     */\n+    private STNode modifyFuncTypeDescWithIsolatedQualifier(STNode funcTypeDesc, STNode isolatedKeyword) {\n+        List<STNode> newQualifierList = new ArrayList<>();\n+        newQualifierList.add(isolatedKeyword);\n+\n+        STFunctionTypeDescriptorNode funcTypeDescriptorNode = (STFunctionTypeDescriptorNode) funcTypeDesc;\n+        STNodeList qualifierList = (STNodeList) funcTypeDescriptorNode.qualifierList;\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                updateLastNodeInListWithInvalidNode(newQualifierList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+            } else {\n+                newQualifierList.add(qualifier);\n+            }\n+        }", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -3578,36 +3590,8 @@ public class BallerinaParser extends AbstractParser {\n \n         endContext();\n         if (isModuleVar) {\n-            if (hasVarInit || isolatedFinalQualifiers.isEmpty()) {\n-                STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-                return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                        typedBindingPattern, assign, expr, semicolon);\n-            }\n-\n-            // Only final qualifier is allowed for non initialized module var declaration\n-\n-            // If type descriptor in the binding pattern is either object or function type\n-            // and qualifier list has isolated qualifier as the last token,\n-            // that isolated qualifier should be part of the type.\n-            STNode lastQualifier = isolatedFinalQualifiers.get(isolatedFinalQualifiers.size() - 1);\n-            if (lastQualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n-                lastQualifier = isolatedFinalQualifiers.remove(isolatedFinalQualifiers.size() - 1);\n-                typedBindingPattern =\n-                        modifyTypedBindingPatternWithMissingQualifier(typedBindingPattern, lastQualifier);\n-            }\n-\n-            // Now the list can have only following possibilities\n-            // empty, final, isolated final\n-            if (!isolatedFinalQualifiers.isEmpty() &&\n-                    isNodeWithSyntaxKindInList(isolatedFinalQualifiers, SyntaxKind.ISOLATED_KEYWORD)) {\n-                STNode invalidIsolatedToken = isolatedFinalQualifiers.remove(0);\n-                updateFirstNodeInListWithInvalidNode(isolatedFinalQualifiers, invalidIsolatedToken,\n-                        DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) invalidIsolatedToken).text());\n-            }\n-\n-            STNode isolatedFinalQualifierNode = STNodeFactory.createNodeList(isolatedFinalQualifiers);\n-            return STNodeFactory.createModuleVariableDeclarationNode(metadata, isolatedFinalQualifierNode,\n-                    typedBindingPattern, assign, expr, semicolon);\n+            return createModuleVarDeclaration(metadata, isolatedFinalQualifiers, typedBindingPattern, assign, expr,\n+                    semicolon, hasVarInit);\n         }\n \n         STNode finalKeyword;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMjM1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515732356", "bodyText": "Do we need to remove this? Can we use get() to retrieve and then set() to replace the original item?\nRemove is a very expensive operation. It shifts all the trailing items by one. Lets try to minimize the usage of remove() in all the places", "author": "SupunS", "createdAt": "2020-11-02T04:14:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java", "diffHunk": "@@ -226,12 +226,29 @@ protected void updateFirstNodeInListWithInvalidNode(List<STNode> nodeList,\n                                                         STNode invalidParam,\n                                                         DiagnosticCode diagnosticCode,\n                                                         Object... args) {\n-        STNode firstNode = nodeList.remove(0);\n-        STNode newNode = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(firstNode, invalidParam);\n+        updateANodeInListWithInvalidNode(nodeList, 0, invalidParam, diagnosticCode, args);\n+    }\n+\n+    /**\n+     * Clones the a node in list with the invalid node as leading minutiae and update the list.\n+     *\n+     * @param nodeList       node list to be updated\n+     * @param indexOfTheNode index of the node in list to be updated\n+     * @param invalidParam   the invalid node to be attached to the first node in list as minutiae\n+     * @param diagnosticCode diagnostic code related to the invalid node\n+     * @param args           additional arguments used in diagnostic message\n+     */\n+    protected void updateANodeInListWithInvalidNode(List<STNode> nodeList,\n+                                                    int indexOfTheNode,\n+                                                    STNode invalidParam,\n+                                                    DiagnosticCode diagnosticCode,\n+                                                    Object... args) {\n+        STNode node = nodeList.remove(indexOfTheNode);", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java\nindex c6b26bd7ad6..fa54a132126 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractParser.java\n\n@@ -243,12 +243,12 @@ public abstract class AbstractParser {\n                                                     STNode invalidParam,\n                                                     DiagnosticCode diagnosticCode,\n                                                     Object... args) {\n-        STNode node = nodeList.remove(indexOfTheNode);\n+        STNode node = nodeList.get(indexOfTheNode);\n         STNode newNode = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(node, invalidParam);\n         if (diagnosticCode != null) {\n             newNode = SyntaxErrors.addDiagnostic(newNode, diagnosticCode, args);\n         }\n-        nodeList.add(indexOfTheNode, newNode);\n+        nodeList.set(indexOfTheNode, newNode);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczMjgxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26610#discussion_r515732817", "bodyText": "Variable name is misleading. Lets rename it to qualifiers", "author": "SupunS", "createdAt": "2020-11-02T04:17:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -15435,7 +15570,7 @@ private STNode bracedListMemberStartsWithReadonly(STNode readonlyKeyword) {\n                         ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n                 endContext();\n                 STNode annots = STNodeFactory.createEmptyNodeList();\n-                STNode finalKeyword = STNodeFactory.createEmptyNode();\n+                List<STNode> finalKeyword = new ArrayList<>();", "originalCommit": "a51c0896c4418c154dc264b5c2b1354fca6755fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a636283c0f6501e812a16ef4701ebda32e74b46", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\nindex d6f08b72789..9dc6ccd249b 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java\n\n@@ -15570,9 +15588,9 @@ public class BallerinaParser extends AbstractParser {\n                         ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n                 endContext();\n                 STNode annots = STNodeFactory.createEmptyNodeList();\n-                List<STNode> finalKeyword = new ArrayList<>();\n+                List<STNode> varDeclQualifiers = new ArrayList<>();\n                 STNode typedBP = parseTypedBindingPatternTypeRhs(typeDesc, ParserRuleContext.VAR_DECL_STMT);\n-                return parseVarDeclRhs(annots, finalKeyword, typedBP, false);\n+                return parseVarDeclRhs(annots, varDeclQualifiers, typedBP, false);\n         }\n     }\n \n"}}, {"oid": "0a636283c0f6501e812a16ef4701ebda32e74b46", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a636283c0f6501e812a16ef4701ebda32e74b46", "message": "Add review changes", "committedDate": "2020-11-02T12:48:26Z", "type": "commit"}, {"oid": "0a636283c0f6501e812a16ef4701ebda32e74b46", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a636283c0f6501e812a16ef4701ebda32e74b46", "message": "Add review changes", "committedDate": "2020-11-02T12:48:26Z", "type": "forcePushed"}, {"oid": "3b3a889d1adbe14c3050992557bf44e84d456066", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b3a889d1adbe14c3050992557bf44e84d456066", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var", "committedDate": "2020-11-02T13:24:41Z", "type": "commit"}, {"oid": "c4222c6e2b35a0ada8b40ef649b2727e4eec2024", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c4222c6e2b35a0ada8b40ef649b2727e4eec2024", "message": "Fix IsolationAnalysisTest unit test", "committedDate": "2020-11-02T15:58:57Z", "type": "commit"}, {"oid": "4ab7f75eed4f9f227b9d491b7ffd09217050b343", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4ab7f75eed4f9f227b9d491b7ffd09217050b343", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var", "committedDate": "2020-11-03T05:05:20Z", "type": "commit"}, {"oid": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5eff72f8b8f0322fa900413e4c37494202cc91b2", "message": "Add second tier review suggestions", "committedDate": "2020-11-03T05:38:53Z", "type": "commit"}, {"oid": "5eff72f8b8f0322fa900413e4c37494202cc91b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5eff72f8b8f0322fa900413e4c37494202cc91b2", "message": "Add second tier review suggestions", "committedDate": "2020-11-03T05:38:53Z", "type": "forcePushed"}, {"oid": "387273e8c981ca065b1baf210ea01d96550fca63", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/387273e8c981ca065b1baf210ea01d96550fca63", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into isolated-module-var\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerina/compiler/syntax/tree/ModuleVariableDeclarationNode.java\n\u0001\tmisc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormattingTreeModifier.java", "committedDate": "2020-11-03T09:50:55Z", "type": "commit"}, {"oid": "e3cc5b0b1dda74b254dcec2e48a834dfc9b47462", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3cc5b0b1dda74b254dcec2e48a834dfc9b47462", "message": "Regenerate syntax tree and fix FormattingTreeModifier", "committedDate": "2020-11-03T09:59:41Z", "type": "commit"}]}