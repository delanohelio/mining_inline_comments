{"pr_number": 24057, "pr_title": "Add lang-lib methods to improve JSON compatibility", "pr_createdAt": "2020-06-13T08:42:56Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732108", "bodyText": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\n\nthere may be other non-array member string values that will not get changed to BString if we change only here.\n\nFor example, the following might fail\npublic function main() {\n    string st = \"\\\"hello\\\"\";\n    string j = <string> st.fromJsonString();\n}\n\nOn paths where changeForBString is already called and there are arrays present we'll be calling this method twice unnecessarily.\n\ne.g., \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n    \n    \n         Line 95\n      in\n      8077e15\n    \n    \n    \n    \n\n        \n          \n           return changeForBString(jsonObj);", "author": "MaryamZi", "createdAt": "2020-06-13T11:32:20Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDA3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440370076", "bodyText": "Got it. Solved", "author": "dulajdilshan", "createdAt": "2020-06-15T18:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\nindex 21534c39ed6..cbc076bf17e 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n\n@@ -687,7 +687,7 @@ public class JSONParser {\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));\n+                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n                         state = ARRAY_ELEMENT_END_STATE;\n                     } else if (ch == REV_SOL) {\n                         state = STRING_AE_ESC_CHAR_PROCESSING_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439739524", "bodyText": "Please check the following example.\npublic function main() {\n    map<int> m = {a: 1, b: 2};\n    map<json> mj = <map<json>> m.toJson();\n\n    mj[\"c\"] = \"non-int json\";\n}\nThis currently fails with\n$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)", "author": "MaryamZi", "createdAt": "2020-06-13T13:30:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDY2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590665", "bodyText": "Solved", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex ac22dd2f0ed..952896ec459 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -18,6 +18,7 @@\n package org.ballerinalang.langlib.value;\n \n import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n import org.ballerinalang.jvm.StringUtils;\n import org.ballerinalang.jvm.TypeChecker;\n import org.ballerinalang.jvm.TypeConverter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439760353", "bodyText": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the lang.value functions have used this format. Let's check with the others and verify.", "author": "pubudu91", "createdAt": "2020-06-13T18:48:04Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDU5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590595", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\nindex 32454fc5419..4fdc1acec63 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\n\n@@ -19,6 +19,7 @@ package org.ballerinalang.langlib.value;\n \n import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n import org.ballerinalang.jvm.values.TypedescValue;\n"}}, {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "message": "Allow more tests", "committedDate": "2020-06-15T17:21:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440438566", "bodyText": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\nimport ballerina/io;\n\npublic function main() {\n    string foo = \"Foo\";\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\nThe above fails with the following panic:\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]\n\nIt says string value cannot be converted to int but then has an XML parsing error as well.", "author": "pubudu91", "createdAt": "2020-06-15T20:49:42Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "originalCommit": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzYwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440597605", "bodyText": "The spec says that fromJsonWithType should do the inverse of the toJson which converts xml into a  string.\nSo, fromJsonWithType should be able to convert an appropriate string to an xml.\nChanging the behaviour of TypeConverter.getConvertibleTypes() to support this would also work, but will affect cloneWithType method and future methods to be implemented (if there are)\nI'll fix showing xml conversion error", "author": "dulajdilshan", "createdAt": "2020-06-16T05:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440599353", "bodyText": "Yeah, it doesn't make sense to try and convert to XML if I didn't specify an XML typedesc", "author": "pubudu91", "createdAt": "2020-06-16T05:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440602304", "bodyText": "Yeah. Thanks!", "author": "dulajdilshan", "createdAt": "2020-06-16T05:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 73a7858f88b..ef0db75c57f 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -127,7 +127,8 @@ public class FromJsonWithType {\n         List<BType> convertibleTypes;\n         convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n         if (convertibleTypes.isEmpty()) {\n-            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n                 try {\n                     return XMLFactory.parse(((StringValue) value).getValue());\n                 } catch (Throwable e) {\n"}}, {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f7f31f56391c00bca0e631d0db24e25c803ff64", "message": "Fix showing XML conversion error in other string type related conversions", "committedDate": "2020-06-16T05:46:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440607832", "bodyText": "Shall we add an upper bound for the subtypes as well for the following? If we add another anydata type, this will break.\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG", "author": "pubudu91", "createdAt": "2020-06-16T06:12:37Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611548", "bodyText": "okay", "author": "dulajdilshan", "createdAt": "2020-06-16T06:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex ef0db75c57f..dda139cbc2a 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -95,10 +95,6 @@ public class FromJsonWithType {\n         return convert(describingType, v, t, strand);\n     }\n \n-    public static Object convert(BType convertType, Object inputValue) {\n-        return convert(convertType, inputValue, null, null);\n-    }\n-\n     public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n         try {\n             return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTkxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611918", "bodyText": "Since this array type is not going to change, how about adding it to BTypes, instead of creating a new JSON array type each time?", "author": "pubudu91", "createdAt": "2020-06-16T06:23:22Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, t, strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex ef0db75c57f..dda139cbc2a 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -95,10 +95,6 @@ public class FromJsonWithType {\n         return convert(describingType, v, t, strand);\n     }\n \n-    public static Object convert(BType convertType, Object inputValue) {\n-        return convert(convertType, inputValue, null, null);\n-    }\n-\n     public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n         try {\n             return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440630740", "bodyText": "This should be thrown right? Since the signature of toJson() is json", "author": "pubudu91", "createdAt": "2020-06-16T07:07:36Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc1ODc0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440758745", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-06-16T10:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex 018cfe85639..62d1f459a66 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -87,7 +87,8 @@ public class ToJson {\n         BType sourceType = TypeChecker.getType(value);\n         BType targetJsonType = BTypes.typeJSON;\n         if (!isConvertibleToJson(value, new ArrayList<>())) {\n-            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+            if ((sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG && sourceType.getTag() <= TypeTags.XML_TEXT_TAG) ||\n+                    sourceType.getTag() == TypeTags.XML_TAG) {\n                 return ToString.toString(strand, value);\n             } else {\n                 throw createConversionError(value, targetJsonType);\n"}}, {"oid": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-06-16T14:03:37Z", "type": "forcePushed"}, {"oid": "6a2f3b589925768e932552b23987b87aed442edb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a2f3b589925768e932552b23987b87aed442edb", "message": "Disable langlib value tests", "committedDate": "2020-06-16T20:31:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjYyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443446629", "bodyText": "Should return", "author": "dulajdilshan", "createdAt": "2020-06-22T09:55:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0073636ea0493ddb1d44e18b2afa599d563946a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 7b7c5992471..372a9b22501 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,7 +32,6 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n-import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NzI0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443447246", "bodyText": "no need isambiguity", "author": "dulajdilshan", "createdAt": "2020-06-22T09:56:44Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0073636ea0493ddb1d44e18b2afa599d563946a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 7b7c5992471..372a9b22501 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,7 +32,6 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n-import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njg4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443466883", "bodyText": "Error put as a cause", "author": "dulajdilshan", "createdAt": "2020-06-22T10:34:00Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        // handle string (xml as string) to xml conversion\n+        if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                ((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG && matchingType.getTag() <= TypeTags.XML_TEXT_TAG)\n+                        || matchingType.getTag() == TypeTags.XML_TAG)) {\n+            try {\n+                return XMLFactory.parse(((StringValue) value).getValue());", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0073636ea0493ddb1d44e18b2afa599d563946a", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 7b7c5992471..372a9b22501 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,7 +32,6 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n-import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"oid": "b0073636ea0493ddb1d44e18b2afa599d563946a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0073636ea0493ddb1d44e18b2afa599d563946a", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-06-30T06:24:32Z", "type": "forcePushed"}, {"oid": "aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:40:24Z", "type": "forcePushed"}, {"oid": "39bbe770806904ada758446ee80c9df6cfeed410", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:56:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449571794", "bodyText": "Can't we do something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Object val = record.get(key);\n          \n          \n            \n                            BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n          \n            \n            //                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n          \n          \n            \n                            BString strVal = StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n      \n    \n    \n  \n\ninstead?\nLet's also remove commented out code.", "author": "MaryamZi", "createdAt": "2020-07-03T13:00:51Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1MjE4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451352184", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\nindex 03108c49045..a3142d11cee 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\n\n@@ -159,11 +159,9 @@ public class TableJSONDataSource implements JSONDataSource {\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                Object val = record.get(key);\n                 BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n-                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n                 jsonObject.put(StringUtils.fromString(name), strVal);\n-//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n                 break;\n             default:\n                 jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449645751", "bodyText": "In this value type check, we check for simple basic types and string right? Since they are always json, wondering if we can skip the next line and directly return true.", "author": "MaryamZi", "createdAt": "2020-07-03T16:01:49Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NDAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451354038", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\nindex 815bbad343a..c52270d5f2d 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\n\n@@ -355,7 +355,7 @@ public class TypeChecker {\n             ArrayValue source = (ArrayValue) sourceValue;\n             BType elementType = ((BArrayType) source.getType()).getElementType();\n             if (BTypes.isValueType(elementType)) {\n-                return TypeChecker.checkIsType(elementType, BTypes.typeJSON, new ArrayList<>());\n+                return true;\n             }\n \n             Object[] arrayValues = source.getValues();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659754", "bodyText": "Do we need this isConvertibleToJson check at all? toJson can only be called on anydata values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to json?\n\n  \n    \n      ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal\n    \n    \n         Line 133\n      in\n      39bbe77\n    \n    \n    \n    \n\n        \n          \n           public function toJson(anydata v) returns json = external;", "author": "MaryamZi", "createdAt": "2020-07-03T16:55:56Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzQyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451753425", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-07-08T18:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BType targetJsonType = BTypes.typeJSON;\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, targetJsonType, new ArrayList<>(), strand);\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);", "author": "MaryamZi", "createdAt": "2020-07-03T16:56:38Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NjQ3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451356473", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449660321", "bodyText": "Isn't the target type always json? Makes this check always true right?", "author": "MaryamZi", "createdAt": "2020-07-03T16:58:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzYyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451363622", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449666019", "bodyText": "Once we remove error from anydata, we won't reach here right? For the time-being I think we can panic if reach here.", "author": "MaryamZi", "createdAt": "2020-07-03T17:26:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNzYwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451937606", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-09T03:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449667453", "bodyText": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\nIMO, we can move this to after the null check and remove this here.", "author": "MaryamZi", "createdAt": "2020-07-03T17:33:10Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODE4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668188", "bodyText": "Also, assuming this is for simple basic types, they are always JSON. So we don't have to check getConvertibleTypes.", "author": "MaryamZi", "createdAt": "2020-07-03T17:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r452241304", "bodyText": "Changed.", "author": "dulajdilshan", "createdAt": "2020-07-09T14:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668578", "bodyText": "targetType is always map<json> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "author": "MaryamZi", "createdAt": "2020-07-03T17:39:03Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTcwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451761706", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T18:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668902", "bodyText": "We should have extracted this out to a variable. But then again since this is always json, we can use the JSON type in BTypes.", "author": "MaryamZi", "createdAt": "2020-07-03T17:40:49Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2MDEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451560124", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669406", "bodyText": "Can't we use BTypes.typeJsonArray you've introduced?", "author": "MaryamZi", "createdAt": "2020-07-03T17:43:31Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557980", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669545", "bodyText": "We don't need a separate method for this right?", "author": "MaryamZi", "createdAt": "2020-07-03T17:44:16Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzc5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557790", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex d0710cb6632..41dd4f4e0f4 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -69,24 +69,21 @@ public class ToJson {\n     private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n \n     public static Object toJson(Strand strand, Object value) {\n-        BType targetJsonType = BTypes.typeJSON;\n         try {\n-            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+            return convert(value, new ArrayList<>(), strand);\n         } catch (Exception e) {\n             return e;\n         }\n     }\n \n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n         if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+            return null;\n         }\n \n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        TypeValuePair typeValuePair = new TypeValuePair(value, jsonType);\n \n         if (unresolvedValues.contains(typeValuePair)) {\n             throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449673862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(enabled = true)\n          \n          \n            \n            @Test", "author": "MaryamZi", "createdAt": "2020-07-03T18:06:36Z", "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NzYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449677634", "bodyText": "We can just remove (enabled = false). Please fix everywhere.", "author": "MaryamZi", "createdAt": "2020-07-03T18:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451850674", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T22:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4eab681541972b946f574cd3232aae86a19cb817", "chunk": "diff --git a/langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java b/langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java\nindex dcd82398095..437f8bbaeba 100644\n--- a/langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java\n+++ b/langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java\n\n@@ -41,7 +41,7 @@ import static org.testng.Assert.assertNull;\n  *\n  * @since 1.0\n  */\n-@Test(enabled = true)\n+@Test\n public class LangLibValueTest {\n \n     private CompileResult compileResult;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449678223", "bodyText": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "author": "MaryamZi", "createdAt": "2020-07-03T18:29:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODAzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451388031", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwODI0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451808244", "bodyText": "But, There can be situations like\npublic function main() {\n    json anObject = { name : \"anObject\", value : 10, sub : { subName : \"subObject\", subValue : 10 }};\n    string k = anObject.toJsonString();\n}\nif we remove this line :unresolvedValues.remove(typeValuePair); ,  10 will be duplicated inside unresolvedValues the fail. won't it?", "author": "dulajdilshan", "createdAt": "2020-07-08T20:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\ndeleted file mode 100644\nindex 14d2ccd9573..00000000000\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ /dev/null\n\n@@ -1,268 +0,0 @@\n-/*\n- *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- *  WSO2 Inc. licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except\n- *  in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- */\n-package org.ballerinalang.langlib.value;\n-\n-import org.ballerinalang.jvm.BallerinaErrors;\n-import org.ballerinalang.jvm.BallerinaValues;\n-import org.ballerinalang.jvm.StringUtils;\n-import org.ballerinalang.jvm.TypeChecker;\n-import org.ballerinalang.jvm.TypeConverter;\n-import org.ballerinalang.jvm.XMLFactory;\n-import org.ballerinalang.jvm.commons.TypeValuePair;\n-import org.ballerinalang.jvm.scheduling.Strand;\n-import org.ballerinalang.jvm.types.BArrayType;\n-import org.ballerinalang.jvm.types.BField;\n-import org.ballerinalang.jvm.types.BMapType;\n-import org.ballerinalang.jvm.types.BRecordType;\n-import org.ballerinalang.jvm.types.BTableType;\n-import org.ballerinalang.jvm.types.BTupleType;\n-import org.ballerinalang.jvm.types.BType;\n-import org.ballerinalang.jvm.types.BTypes;\n-import org.ballerinalang.jvm.types.TypeTags;\n-import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n-import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n-import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n-import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n-import org.ballerinalang.jvm.values.ErrorValue;\n-import org.ballerinalang.jvm.values.MapValue;\n-import org.ballerinalang.jvm.values.MapValueImpl;\n-import org.ballerinalang.jvm.values.RefValue;\n-import org.ballerinalang.jvm.values.StringValue;\n-import org.ballerinalang.jvm.values.TableValueImpl;\n-import org.ballerinalang.jvm.values.TupleValueImpl;\n-import org.ballerinalang.jvm.values.TypedescValue;\n-import org.ballerinalang.jvm.values.api.BString;\n-import org.ballerinalang.natives.annotations.BallerinaFunction;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static org.ballerinalang.jvm.BallerinaErrors.createError;\n-import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n-import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n-import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n-import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n-\n-/**\n- * Extern function lang.values:fromJsonWithType.\n- *\n- * @since 2.0\n- */\n-@BallerinaFunction(\n-        orgName = \"ballerina\",\n-        packageName = \"lang.value\", version = VALUE_VERSION,\n-        functionName = \"fromJsonWithType\",\n-        isPublic = true\n-)\n-public class FromJsonWithType {\n-    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n-\n-    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n-        BType describingType = t.getDescribingType();\n-        try {\n-            return convert(v, describingType, new ArrayList<>(), t, strand);\n-        } catch (ErrorValue e) {\n-            return e;\n-        } catch (BallerinaException e) {\n-            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n-        }\n-    }\n-\n-    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n-                                  TypedescValue t, Strand strand) {\n-\n-        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n-        BType sourceType = TypeChecker.getType(value);\n-\n-        if (unresolvedValues.contains(typeValuePair)) {\n-            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n-        }\n-\n-        unresolvedValues.add(typeValuePair);\n-\n-        if (value == null) {\n-            if (targetType.isNilable()) {\n-                return null;\n-            }\n-            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n-                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n-        }\n-\n-        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n-        if (convertibleTypes.isEmpty()) {\n-            throw createConversionError(value, targetType);\n-        } else if (convertibleTypes.size() > 1) {\n-            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n-        }\n-\n-        BType matchingType = convertibleTypes.get(0);\n-\n-        Object newValue;\n-        switch (sourceType.getTag()) {\n-            case TypeTags.MAP_TAG:\n-            case TypeTags.RECORD_TYPE_TAG:\n-                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n-                break;\n-            case TypeTags.ARRAY_TAG:\n-            case TypeTags.TUPLE_TAG:\n-                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n-                break;\n-            case TypeTags.ERROR_TAG:\n-                newValue = ((RefValue) value).copy(new HashMap<>());\n-                break;\n-            default:\n-                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n-                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n-                    try {\n-                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n-                        break;\n-                    } catch (Throwable e) {\n-                        throw createConversionError(value, targetType, e.getMessage());\n-                    }\n-                }\n-\n-                // handle primitive values\n-                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n-                    if (TypeChecker.checkIsType(value, matchingType)) {\n-                        newValue = value;\n-                    } else {\n-                        // Has to be a numeric conversion.\n-                        newValue = TypeConverter.convertValues(matchingType, value);\n-                    }\n-                    break;\n-                }\n-                // should never reach here\n-                throw BallerinaErrors.createConversionError(value, targetType);\n-        }\n-\n-        unresolvedValues.remove(typeValuePair);\n-        return newValue;\n-    }\n-\n-    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n-                                     TypedescValue t, Strand strand) {\n-        switch (targetType.getTag()) {\n-            case TypeTags.MAP_TAG:\n-                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n-                for (Map.Entry entry : map.entrySet()) {\n-                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n-                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n-                }\n-                return newMap;\n-            case TypeTags.RECORD_TYPE_TAG:\n-                BRecordType recordType = (BRecordType) targetType;\n-                MapValueImpl<BString, Object> newRecord;\n-                if (t != null && t.getDescribingType() == targetType) {\n-                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n-                } else {\n-                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n-                            .createRecordValue(recordType.getPackage(), recordType.getName());\n-                }\n-\n-                BType restFieldType = recordType.restFieldType;\n-                Map<String, BType> targetTypeField = new HashMap<>();\n-                for (BField field : recordType.getFields().values()) {\n-                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n-                }\n-\n-                for (Map.Entry entry : map.entrySet()) {\n-                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n-                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n-                }\n-                return newRecord;\n-            case TypeTags.JSON_TAG:\n-                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n-                return convert(map, matchingType, unresolvedValues, t, strand);\n-            default:\n-                break;\n-        }\n-        // should never reach here\n-        throw BallerinaErrors.createConversionError(map, targetType);\n-    }\n-\n-\n-    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n-                                       TypedescValue t, Strand strand) {\n-        switch (targetType.getTag()) {\n-            case TypeTags.ARRAY_TAG:\n-                BArrayType arrayType = (BArrayType) targetType;\n-                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n-                for (int i = 0; i < array.size(); i++) {\n-                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n-                    newArray.add(i, newValue);\n-                }\n-                return newArray;\n-            case TypeTags.TUPLE_TAG:\n-                BTupleType tupleType = (BTupleType) targetType;\n-                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n-                int minLen = tupleType.getTupleTypes().size();\n-                for (int i = 0; i < array.size(); i++) {\n-                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n-                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n-                    newTuple.add(i, newValue);\n-                }\n-                return newTuple;\n-            case TypeTags.JSON_TAG:\n-                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n-                for (int i = 0; i < array.size(); i++) {\n-                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n-                    newArray.add(i, newValue);\n-                }\n-                return newArray;\n-            case TypeTags.TABLE_TAG:\n-                BTableType tableType = (BTableType) targetType;\n-\n-                BTableType newTableType = new BTableType(tableType.getConstrainedType(),\n-                        tableType.getFieldNames(), false);\n-                TableValueImpl newTable = new TableValueImpl(newTableType);\n-                for (int i = 0; i < array.size(); i++) {\n-                    MapValueImpl mapValue = (MapValueImpl) convert(array.get(i), tableType.getConstrainedType(),\n-                            unresolvedValues, t, strand);\n-                    newTable.add(mapValue);\n-                }\n-                return newTable;\n-            default:\n-                break;\n-        }\n-        // should never reach here\n-        throw BallerinaErrors.createConversionError(array, targetType);\n-    }\n-\n-    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,\n-                                 List<TypeValuePair> unresolvedValues, TypedescValue t, Strand strand) {\n-        Object newValue = convert(entry.getValue(), fieldType, unresolvedValues, t, strand);\n-        map.put(StringUtils.fromString(entry.getKey().toString()), newValue);\n-    }\n-\n-    private static ErrorValue createConversionError(Object inputValue, BType targetType) {\n-        return createError(StringUtils.fromString(VALUE_LANG_LIB_CONVERSION_ERROR), StringUtils.fromString(\n-                BLangExceptionHelper.getErrorMessage(INCOMPATIBLE_CONVERT_OPERATION,\n-                        TypeChecker.getType(inputValue), targetType)));\n-    }\n-\n-    private static ErrorValue createConversionError(Object inputValue, BType targetType, String detailMessage) {\n-        return createError(StringUtils.fromString(VALUE_LANG_LIB_CONVERSION_ERROR),\n-                StringUtils.fromString(BLangExceptionHelper.getErrorMessage(\n-                        INCOMPATIBLE_CONVERT_OPERATION, TypeChecker.getType(inputValue), targetType)\n-                        .concat(\": \".concat(detailMessage))));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449681403", "bodyText": "We need to consider maps also right? And arrays/tuples?", "author": "MaryamZi", "createdAt": "2020-07-03T18:47:41Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MTI0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451371240", "bodyText": "They were caught in this method call in line: 310\nTypeConverter.getConvertibleTypes(value, targetType)", "author": "dulajdilshan", "createdAt": "2020-07-08T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\nindex ce046d682f8..0951940a989 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n\n@@ -264,44 +263,7 @@ public class TypeConverter {\n         return convertibleTypes;\n     }\n \n-    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n-                                                          List<TypeValuePair> unresolvedValues) {\n-        List<BType> convertibleTypes = new ArrayList<>();\n-\n-        int targetTypeTag = targetType.getTag();\n-\n-        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n-\n-        if (convertibleTypes.size() == 0) {\n-            switch (targetTypeTag) {\n-                case TypeTags.RECORD_TYPE_TAG:\n-                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.TABLE_TAG:\n-                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n-                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.XML_TAG:\n-                case TypeTags.XML_ELEMENT_TAG:\n-                case TypeTags.XML_COMMENT_TAG:\n-                case TypeTags.XML_PI_TAG:\n-                case TypeTags.XML_TEXT_TAG:\n-                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-        }\n-        return convertibleTypes;\n-    }\n-\n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType, boolean isFromJson,\n+    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n                                                      List<TypeValuePair> unresolvedValues) {\n         if (!(sourceValue instanceof MapValueImpl)) {\n             return false;\n"}}, {"oid": "4eab681541972b946f574cd3232aae86a19cb817", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4eab681541972b946f574cd3232aae86a19cb817", "message": "Do requested changes", "committedDate": "2020-07-08T23:16:23Z", "type": "forcePushed"}, {"oid": "2a31013c144b3612838e874c86d65cdfd2702d49", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a31013c144b3612838e874c86d65cdfd2702d49", "message": "Do requested changes", "committedDate": "2020-07-09T01:05:22Z", "type": "forcePushed"}, {"oid": "69a619558a21aedaa2ac5727653f1b03e548c99e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69a619558a21aedaa2ac5727653f1b03e548c99e", "message": "Add more tests", "committedDate": "2020-07-09T09:20:03Z", "type": "forcePushed"}, {"oid": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18319d65386ad7772f516aed1adbb4e5ba4896f8", "message": "Add 'typeJsonArray' to BTypes", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "584d1f4f88a7748393c236a367567ccd4113b8b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/584d1f4f88a7748393c236a367567ccd4113b8b1", "message": "Add 'fromJsonWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "826fdf23b9d3eef7d7907a51ea8c768e957779b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/826fdf23b9d3eef7d7907a51ea8c768e957779b2", "message": "Add 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "08ec106ed797507f30ac84d2ddaabb73061138e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08ec106ed797507f30ac84d2ddaabb73061138e2", "message": "Add 'toJson' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "message": "Allow \"toJsonString\" lanlib method to support for anydata type", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "e16087ac3c123daff005349f682b357e8413bb76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16087ac3c123daff005349f682b357e8413bb76", "message": "Fix String to BString casting error", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "message": "Add test cases", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5e950db86a85c766a500ff5549178165b5365e5d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e950db86a85c766a500ff5549178165b5365e5d", "message": "Fix failing completion tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2b83515421b45e1e7d1b55aa65ed8409494cfeca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b83515421b45e1e7d1b55aa65ed8409494cfeca", "message": "Order langlib function descriptions", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "bc38590c8df908dd7cf02cc1001c751330a02159", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc38590c8df908dd7cf02cc1001c751330a02159", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "f34ad6fe935633d63c0a1756d276d4854db975cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34ad6fe935633d63c0a1756d276d4854db975cf", "message": "Add support for xml-typed fields in table to json conversion", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "message": "Add json to table conversion in \"fromJsonWithType\" langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "4bdd9da0f1679bf81679e3ecea87298c3edb861c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bdd9da0f1679bf81679e3ecea87298c3edb861c", "message": "Disable langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "message": "Fix 24247", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1f0ac42e95261685d1ff9640a7e9840d94921fd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f0ac42e95261685d1ff9640a7e9840d94921fd4", "message": "Fix errors in the langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e69a1cd29698b34530672d87c94c48f962da06d", "message": "Add more tests", "committedDate": "2020-07-15T14:11:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455179945", "bodyText": "This same method gets called for jsonutils:fromTable right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying jsonutils:fromXML. Shall we create an issue to track clarifying this with the stdlib team?\nI guess this is broken atm anyway, since record.getStringValue(key) is called for XML.", "author": "MaryamZi", "createdAt": "2020-07-15T16:32:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MDU1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455180559", "bodyText": "Checked with\nimport ballerina/jsonutils;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {i: 1, x: xml `<foo>FOO</foo>`}\n    ];\n\n    json j = jsonutils:fromTable(tb);\n}\nFails with\n$ ballerina run qwe.bal \nCompiling source\n        qwe.bal\nRunning executables\n\nerror: java.lang.ClassCastException message=org.ballerinalang.jvm.values.XMLItem cannot be cast to org.ballerinalang.jvm.values.api.BString\n        at ballerina.0_5_0:externFromTable(jsonutils.bal:63)\n           ballerina.0_5_0:fromTable(jsonutils.bal:60)\n           qwe:main(qwe.bal:13)", "author": "MaryamZi", "createdAt": "2020-07-15T16:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\nindex a3142d11cee..03108c49045 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java\n\n@@ -159,9 +159,11 @@ public class TableJSONDataSource implements JSONDataSource {\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n+                Object val = record.get(key);\n                 BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n-                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n                 jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n                 break;\n             default:\n                 jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455227341", "bodyText": "TypeConverter.getConvertibleTypes(value, targetType) calls isConvertibleToRecordType with isFromJson set to false right?\nWhat if targetType is a union of two records, say Foo|Bar, and the value is convertible to Foo even when  isFromJson is false in isConvertibleToRecordType, but it is only convertible to Bar when isFromJson is true?\nSo IINM, from L273 when we reach here convertibleTypes will only have Foo and we return that in L301. But if we actually check isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues) it'll evaluate to true for Bar, and there'll actually be 2 convertible types?", "author": "MaryamZi", "createdAt": "2020-07-15T17:40:53Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NDI5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455254295", "bodyText": "For example\nimport ballerina/io;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\ntype Bar record {|\n    int i;\n    string x;\n|};\n\ntype FooBar Foo|Bar;\n\npublic function main() {\n    json j = {i: 1, x: \"<abc>ABC</abc>\"};\n\n    // No error.\n    io:println(j.fromJsonWithType(Foo)); // i=1 x=<abc>ABC</abc>\n    // No error.\n    io:println(j.fromJsonWithType(Bar)); // i=1 x=<abc>ABC</abc>\n\n    // Then this should be ambiguous?\n    io:println(j.fromJsonWithType(FooBar)); // i=1 x=<abc>ABC</abc>\n}", "author": "MaryamZi", "createdAt": "2020-07-15T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4MDIzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455580233", "bodyText": "Shouldn't this be okay according to this ?\nLet's take this\n io:println(j.fromJsonWithType(FooBar));\nWhen we reach L273, convertibleTypes will have only have Bar.  isn't it?", "author": "dulajdilshan", "createdAt": "2020-07-16T07:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NDM2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455694367", "bodyText": "Ah, didn't know of the \"fromJsonWithType should only do something different from cloneWithType if cloneWithType would produce an error.\" part.\nYeah, this behaviour is correct then. Thanks!", "author": "MaryamZi", "createdAt": "2020-07-16T10:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\nindex ce046d682f8..0951940a989 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n\n@@ -264,44 +263,7 @@ public class TypeConverter {\n         return convertibleTypes;\n     }\n \n-    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n-                                                          List<TypeValuePair> unresolvedValues) {\n-        List<BType> convertibleTypes = new ArrayList<>();\n-\n-        int targetTypeTag = targetType.getTag();\n-\n-        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n-\n-        if (convertibleTypes.size() == 0) {\n-            switch (targetTypeTag) {\n-                case TypeTags.RECORD_TYPE_TAG:\n-                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.TABLE_TAG:\n-                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n-                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.XML_TAG:\n-                case TypeTags.XML_ELEMENT_TAG:\n-                case TypeTags.XML_COMMENT_TAG:\n-                case TypeTags.XML_PI_TAG:\n-                case TypeTags.XML_TEXT_TAG:\n-                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-        }\n-        return convertibleTypes;\n-    }\n-\n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType, boolean isFromJson,\n+    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n                                                      List<TypeValuePair> unresolvedValues) {\n         if (!(sourceValue instanceof MapValueImpl)) {\n             return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455263978", "bodyText": "Re: the constraint, the spec says\n\nThe type specified by a row-type-parameter must be a subtype of map<any|error>\n\nSo it is always a record or a map right? Do we need this check?", "author": "MaryamZi", "createdAt": "2020-07-15T18:41:07Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxMjg2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455612860", "bodyText": "I think yes. because  If I remove the above-mentioned check,\ntype TableString table<string>;\npublic function main() {\n    json j = [\n        \"cake\",\n        \"buscuit\"\n    ];\n    table<string>|error tabString = j.fromJsonWithType(TableString);\n}\nThis works without giving a prior error for table<string>", "author": "dulajdilshan", "createdAt": "2020-07-16T08:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\nindex ce046d682f8..0951940a989 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n\n@@ -264,44 +263,7 @@ public class TypeConverter {\n         return convertibleTypes;\n     }\n \n-    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n-                                                          List<TypeValuePair> unresolvedValues) {\n-        List<BType> convertibleTypes = new ArrayList<>();\n-\n-        int targetTypeTag = targetType.getTag();\n-\n-        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n-\n-        if (convertibleTypes.size() == 0) {\n-            switch (targetTypeTag) {\n-                case TypeTags.RECORD_TYPE_TAG:\n-                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.TABLE_TAG:\n-                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n-                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.XML_TAG:\n-                case TypeTags.XML_ELEMENT_TAG:\n-                case TypeTags.XML_COMMENT_TAG:\n-                case TypeTags.XML_PI_TAG:\n-                case TypeTags.XML_TEXT_TAG:\n-                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-        }\n-        return convertibleTypes;\n-    }\n-\n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType, boolean isFromJson,\n+    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n                                                      List<TypeValuePair> unresolvedValues) {\n         if (!(sourceValue instanceof MapValueImpl)) {\n             return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455273802", "bodyText": "Do we need this default case?", "author": "MaryamZi", "createdAt": "2020-07-15T18:58:22Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxNTQ0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455615446", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\nindex ce046d682f8..0951940a989 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n\n@@ -264,44 +263,7 @@ public class TypeConverter {\n         return convertibleTypes;\n     }\n \n-    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n-                                                          List<TypeValuePair> unresolvedValues) {\n-        List<BType> convertibleTypes = new ArrayList<>();\n-\n-        int targetTypeTag = targetType.getTag();\n-\n-        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n-\n-        if (convertibleTypes.size() == 0) {\n-            switch (targetTypeTag) {\n-                case TypeTags.RECORD_TYPE_TAG:\n-                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.TABLE_TAG:\n-                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n-                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                case TypeTags.XML_TAG:\n-                case TypeTags.XML_ELEMENT_TAG:\n-                case TypeTags.XML_COMMENT_TAG:\n-                case TypeTags.XML_PI_TAG:\n-                case TypeTags.XML_TEXT_TAG:\n-                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n-                        convertibleTypes.add(targetType);\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-        }\n-        return convertibleTypes;\n-    }\n-\n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType, boolean isFromJson,\n+    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n                                                      List<TypeValuePair> unresolvedValues) {\n         if (!(sourceValue instanceof MapValueImpl)) {\n             return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MDM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455280352", "bodyText": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the isFromJson parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "author": "MaryamZi", "createdAt": "2020-07-15T19:10:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -299,17 +337,33 @@ private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (targetFieldTypes.containsKey(fieldName)) {\n-                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                                        unresolvedValues).size() != 1) {\n+            if (isFromJson) {\n+                if (targetFieldTypes.containsKey(fieldName)) {\n+                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\nindex ce046d682f8..0951940a989 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java\n\n@@ -337,33 +299,17 @@ public class TypeConverter {\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (isFromJson) {\n-                if (targetFieldTypes.containsKey(fieldName)) {\n-                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                            unresolvedValues).size() != 1) {\n-                        return false;\n-                    }\n-                } else if (!targetType.sealed) {\n-                    if (getConvertibleTypesFromJson(valueEntry.getValue(), restFieldType,\n-                            unresolvedValues).size() != 1) {\n-                        return false;\n-                    }\n-                } else {\n+            if (targetFieldTypes.containsKey(fieldName)) {\n+                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n+                                        unresolvedValues).size() != 1) {\n                     return false;\n                 }\n-            } else {\n-                if (targetFieldTypes.containsKey(fieldName)) {\n-                    if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                            unresolvedValues).size() != 1) {\n-                        return false;\n-                    }\n-                } else if (!targetType.sealed) {\n-                    if (getConvertibleTypes(valueEntry.getValue(), restFieldType, unresolvedValues).size() != 1) {\n-                        return false;\n-                    }\n-                } else {\n+            } else if (!targetType.sealed) {\n+                if (getConvertibleTypes(valueEntry.getValue(), restFieldType, unresolvedValues).size() != 1) {\n                     return false;\n                 }\n+            } else {\n+                return false;\n             }\n         }\n         return true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455291129", "bodyText": "We need to check if the target type is nilable.\nThe folowing crashes.\ntype IntMap map<int>;\n\npublic function main() {\n    string s = \"null\";\n\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(\"first\");\n}\nThe get fails with an NPE in the internal log.\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)", "author": "MaryamZi", "createdAt": "2020-07-15T19:29:32Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MjY0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455292649", "bodyText": "Do we need to special case \"null\" anyway? The JSONParser and FromJsonWithType.fromJsonWithType will handle this properly right?", "author": "MaryamZi", "createdAt": "2020-07-15T19:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUzODk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455538980", "bodyText": "Ack.", "author": "dulajdilshan", "createdAt": "2020-07-16T06:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "de711a0900748c01d3b478823bc6f073b2a2a285", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\nindex 4fdc1acec63..691acd032f2 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java\n\n@@ -29,7 +29,7 @@ import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n-import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455296725", "bodyText": "A json value can never hold an error. Do we need this case?", "author": "MaryamZi", "createdAt": "2020-07-15T19:40:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0MzUxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455543511", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T06:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455312848", "bodyText": "Can't we use org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag here instead?", "author": "MaryamZi", "createdAt": "2020-07-15T20:10:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1MDYyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455550623", "bodyText": "Sure", "author": "dulajdilshan", "createdAt": "2020-07-16T06:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455319249", "bodyText": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "author": "MaryamZi", "createdAt": "2020-07-15T20:22:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzE3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455557170", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T07:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455321052", "bodyText": "This also we don't need right?", "author": "MaryamZi", "createdAt": "2020-07-15T20:26:01Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618495", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455322784", "bodyText": "Better to pass the targetType itself instead of BTypes.typeJSON since it could be json & readonly.", "author": "MaryamZi", "createdAt": "2020-07-15T20:29:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455702807", "bodyText": "ok", "author": "dulajdilshan", "createdAt": "2020-07-16T10:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455323807", "bodyText": "Why do we create a new type?", "author": "MaryamZi", "createdAt": "2020-07-15T20:31:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455699773", "bodyText": "Removed", "author": "dulajdilshan", "createdAt": "2020-07-16T10:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455336846", "bodyText": "Do we ever reach here? All the numeric basic types are both anydata and json. So, I don't think you'll ever have to do a numeric conversion?", "author": "MaryamZi", "createdAt": "2020-07-15T20:55:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcxNzE5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455717199", "bodyText": "Got it", "author": "dulajdilshan", "createdAt": "2020-07-16T11:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\nindex 42f7050e9b7..62d1f459a66 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java\n\n@@ -17,6 +17,7 @@\n  */\n package org.ballerinalang.langlib.value;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.JSONUtils;\n import org.ballerinalang.jvm.StringUtils;\n import org.ballerinalang.jvm.TypeChecker;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455609729", "bodyText": "Do we need this null check here? t can never be null right?", "author": "pubudu91", "createdAt": "2020-07-16T08:20:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcyMTMxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455721314", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T11:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618694", "bodyText": "Is there a need to pass both t and describingType?", "author": "pubudu91", "createdAt": "2020-07-16T08:34:41Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc3Nzg5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455777894", "bodyText": "I followed the same implementation as in the cloneWithType.\nconvert method is get called later. Sometimes, t and targetType both are  needed", "author": "dulajdilshan", "createdAt": "2020-07-16T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1ODE2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455858166", "bodyText": "My point was if you have t, you can always get the type from it. Anyways, not a major issue. Just gives the impression that target type can be some other type than what's described by t", "author": "pubudu91", "createdAt": "2020-07-16T15:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}], "type": "inlineReview", "revised_code": {"commit": "32a33fc1798b697a55693b80a4d948526e932ea9", "chunk": "diff --git a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\nindex 14d2ccd9573..7b7c5992471 100644\n--- a/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n+++ b/langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java\n\n@@ -32,6 +32,7 @@ import org.ballerinalang.jvm.types.BRecordType;\n import org.ballerinalang.jvm.types.BTableType;\n import org.ballerinalang.jvm.types.BTupleType;\n import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n import org.ballerinalang.jvm.types.BTypes;\n import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n"}}, {"oid": "32a33fc1798b697a55693b80a4d948526e932ea9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32a33fc1798b697a55693b80a4d948526e932ea9", "message": "Add fromJsonWIthType negative test", "committedDate": "2020-07-16T13:46:28Z", "type": "commit"}, {"oid": "e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "message": "Refactor \"toJson\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "470bf15ddd203933e41a785ab47c5c4be4ddd678", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/470bf15ddd203933e41a785ab47c5c4be4ddd678", "message": "Add value lang lib error message string", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "7e5fbfb2ec384f5722593f972780e362dce450d2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e5fbfb2ec384f5722593f972780e362dce450d2", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "f6adcd93547a952d138340eb1aa45e035622e6a9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adcd93547a952d138340eb1aa45e035622e6a9", "message": "Fix error in the value lib test", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "message": "Do requested changes", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "message": "Remove isConvertibleToJson method in TypeChecker", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "04214fd7fd9ee8ac827123d407fa1c629fff0730", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04214fd7fd9ee8ac827123d407fa1c629fff0730", "message": "Add more tests", "committedDate": "2020-07-16T13:46:30Z", "type": "commit"}, {"oid": "de711a0900748c01d3b478823bc6f073b2a2a285", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de711a0900748c01d3b478823bc6f073b2a2a285", "message": "Change according to the suggestions", "committedDate": "2020-07-16T13:46:30Z", "type": "forcePushed"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "commit"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTIyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455861225", "bodyText": "I think what @MaryamZi meant was to simply pass str to the JSON parser without special casing \"null\".", "author": "pubudu91", "createdAt": "2020-07-16T15:10:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        try {\n+            if (str.equals(\"null\")) {\n+                return FromJsonWithType.fromJsonWithType(strand, null, t);", "originalCommit": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}