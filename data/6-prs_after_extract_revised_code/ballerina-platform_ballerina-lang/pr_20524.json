{"pr_number": 20524, "pr_title": "Enable Signature Help Feature", "pr_createdAt": "2020-01-06T05:11:00Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4Nzk3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363587970", "bodyText": "Shall we add a doc comment for the public method?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:33:19Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.completions.sourceprune;\n+\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManager;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.TokenTraverserFactory;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Factory class for providing token traversers and related artifacts for 'completions' service operation.\n+ */\n+public class CompletionsTokenTraverserFactory implements TokenTraverserFactory {\n+    private final SourcePruneContext sourcePruneCtx;\n+    private final boolean pruneTokens;\n+    private final TokenStream tokenStream;\n+\n+    private static final List<Integer> BLOCK_REMOVE_KW_TERMINALS;\n+    private static final List<Integer> LHS_TRAVERSE_TERMINALS;\n+    private static final List<Integer> RHS_TRAVERSE_TERMINALS;\n+\n+    static {\n+        BLOCK_REMOVE_KW_TERMINALS = Arrays.asList(\n+                BallerinaParser.SERVICE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.MATCH,\n+                BallerinaParser.FOREACH, BallerinaParser.WORKER\n+        );\n+        LHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE, BallerinaParser.SEMICOLON,\n+                BallerinaParser.COMMA, BallerinaParser.LEFT_PARENTHESIS, BallerinaParser.RIGHT_PARENTHESIS,\n+                BallerinaParser.LT, BallerinaParser.RETURNS, BallerinaParser.TRANSACTION,\n+                BallerinaParser.LEFT_CLOSED_RECORD_DELIMITER, BallerinaParser.LEFT_BRACKET\n+        );\n+        RHS_TRAVERSE_TERMINALS = Arrays.asList(\n+                BallerinaParser.SEMICOLON, BallerinaParser.DocumentationLineStart,\n+                BallerinaParser.AT, BallerinaParser.LEFT_BRACE, BallerinaParser.RIGHT_BRACE,\n+                BallerinaParser.RIGHT_PARENTHESIS, BallerinaParser.IMPORT, BallerinaParser.GT,\n+                BallerinaParser.XMLNS, BallerinaParser.SERVICE, BallerinaParser.PUBLIC, BallerinaParser.PRIVATE,\n+                BallerinaParser.REMOTE, BallerinaParser.FUNCTION, BallerinaParser.TYPE, BallerinaParser.ANNOTATION,\n+                BallerinaParser.CONST, BallerinaParser.RIGHT_BRACKET, BallerinaParser.RIGHT_CLOSED_RECORD_DELIMITER,\n+                BallerinaParser.RESOURCE, BallerinaParser.LISTENER, BallerinaParser.MATCH, BallerinaParser.IF,\n+                BallerinaParser.WHILE, BallerinaParser.FOREACH, BallerinaParser.BREAK, BallerinaParser.BREAK,\n+                BallerinaParser.FORK, BallerinaParser.THROW, BallerinaParser.TRANSACTION, BallerinaParser.WORKER\n+        );\n+    }\n+\n+    public CompletionsTokenTraverserFactory(Path filePath, WorkspaceDocumentManager documentManager,", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3ODE3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r364078174", "bodyText": "Added missing doc comments in other places. This is a constructor which we usually don't add doc comments since class level doc comment is already there. For the sake of consistency let's keep this as it is. WDYT?", "author": "rasika", "createdAt": "2020-01-08T06:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4Nzk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "584fd37f5cef5b98644c39cda45a2e46042993f3", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java\nindex 186b2e308b6..d2ccbd56e6b 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/CompletionsTokenTraverserFactory.java\n\n@@ -30,6 +30,8 @@ import java.util.List;\n \n /**\n  * Factory class for providing token traversers and related artifacts for 'completions' service operation.\n+ *\n+ * @since 1.1.1\n  */\n public class CompletionsTokenTraverserFactory implements TokenTraverserFactory {\n     private final SourcePruneContext sourcePruneCtx;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODA5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588095", "bodyText": "Is it possible to make the class package-private if we do not expose this as a public API?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:34:28Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java", "diffHunk": "@@ -32,7 +35,7 @@\n  * \n  * @since 0.995.0\n  */\n-class LHSTokenTraverser extends AbstractTokenTraverser {\n+public class LHSCompletionsTokenTraverser extends AbstractTokenTraverser {", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb370ceed133071f71ea76515d98455cc0b15c76", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java\nindex 7fc7d8c2d12..5e1fd210d49 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/LHSCompletionsTokenTraverser.java\n\n@@ -35,7 +35,7 @@ import java.util.stream.Collectors;\n  * \n  * @since 0.995.0\n  */\n-public class LHSCompletionsTokenTraverser extends AbstractTokenTraverser {\n+class LHSCompletionsTokenTraverser extends AbstractTokenTraverser {\n     private List<Integer> lhsTraverseTerminals;\n     private List<Integer> blockRemoveKWTerminals;\n     private boolean removeBlock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODIwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588206", "bodyText": "Is it possible to make the class package-private since we do not expose this as a public API?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:35:24Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java", "diffHunk": "@@ -29,7 +32,7 @@\n  * \n  * @since 0.995.0\n  */\n-class RHSTokenTraverser extends AbstractTokenTraverser {\n+public class RHSCompletionsTokenTraverser extends AbstractTokenTraverser {", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb370ceed133071f71ea76515d98455cc0b15c76", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java\nindex db4ec685eb3..f20b836dbe7 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/sourceprune/RHSCompletionsTokenTraverser.java\n\n@@ -32,7 +32,7 @@ import java.util.Optional;\n  * \n  * @since 0.995.0\n  */\n-public class RHSCompletionsTokenTraverser extends AbstractTokenTraverser {\n+class RHSCompletionsTokenTraverser extends AbstractTokenTraverser {\n     private int leftBraceCount;\n     private int leftBracketCount;\n     private int leftParenthesisCount;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODMxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588315", "bodyText": "Missing doc comment for the public method", "author": "nadeeshaan", "createdAt": "2020-01-07T04:36:07Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java", "diffHunk": "@@ -126,4 +135,20 @@ private static void setInvocationOrInteractionOrFieldAccessToken(LSContext conte\n         }\n         context.put(CompletionKeys.INVOCATION_TOKEN_TYPE_KEY, resultToken);\n     }\n+\n+    public static void pruneSource(LSContext lsContext) throws SourcePruneException, WorkspaceDocumentException {", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df1d707c3c2d550b6e32044190e592398a406be9", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java\nindex 3fbb661b3d8..eedad4ab3e6 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/util/CompletionUtil.java\n\n@@ -136,6 +136,13 @@ public class CompletionUtil {\n         context.put(CompletionKeys.INVOCATION_TOKEN_TYPE_KEY, resultToken);\n     }\n \n+    /**\n+     * Prune source if syntax errors exists.\n+     *\n+     * @param lsContext {@link LSContext}\n+     * @throws SourcePruneException when file uri is invalid\n+     * @throws WorkspaceDocumentException when document read error occurs\n+     */\n     public static void pruneSource(LSContext lsContext) throws SourcePruneException, WorkspaceDocumentException {\n         WorkspaceDocumentManager documentManager = lsContext.get(CommonKeys.DOC_MANAGER_KEY);\n         String uri = lsContext.get(DocumentServiceKeys.FILE_URI_KEY);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODU3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588572", "bodyText": "Shall we remove the Commented code snippet?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:37:59Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "diffHunk": "@@ -210,31 +133,66 @@ private SignatureHelpUtil() {\n         return new ImmutablePair<>(parseAndGetFunctionInvocationPath(subRule, serviceContext), paramIndex);\n     }\n \n-    private static List<String> getSourcePrunedFunctionInvocation(LSServiceOperationContext serviceContext) {\n+    private static Pair<String, Integer> extractSourcePrunedInvocationDetails(\n+            LSServiceOperationContext serviceContext) {\n+        int parameterOffset = 0;\n         // Collect source-pruned tokens\n-        List<String> tokenText = new ArrayList<>();\n+        List<String> tokenTexts = new ArrayList<>();\n \n         final int[] pendingRParenthesisCount = new int[]{0};\n         Consumer<Integer> tokenAcceptor = type -> {\n-            if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n-                pendingRParenthesisCount[0]++;\n-            } else if (type == BallerinaParser.LEFT_PARENTHESIS) {\n+            if (type == BallerinaParser.LEFT_PARENTHESIS) {\n                 pendingRParenthesisCount[0]--;\n+            } else if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n+                pendingRParenthesisCount[0]++;\n             }\n         };\n \n-        // Visit Left-Hand side tokens\n+        // Visit Left-Hand side tokens before cursor\n         List<CommonToken> lhsTokens = serviceContext.get(CompletionKeys.LHS_TOKENS_KEY);\n         if (lhsTokens != null) {\n-            for (Token commonToken : lhsTokens) {\n-                tokenAcceptor.accept(commonToken.getType());\n-                tokenText.add(commonToken.getText());\n+            while (lhsTokens.get(0).getType() == BallerinaParser.COMMA) {\n+                lhsTokens.remove(0);\n+            }\n+            boolean isLastLeftParenthesisProcessed = false;\n+            for (int i = lhsTokens.size() - 1; i >= 0; i--) {\n+                Token commonToken = lhsTokens.get(i);\n+                int tokenType = commonToken.getType();\n+                if (tokenType == BallerinaParser.LEFT_PARENTHESIS) {\n+                    // Since we are traversing reverse order, we'll get the last LParenthesis first\n+                    isLastLeftParenthesisProcessed = true;\n+                }\n+                if (tokenType == BallerinaParser.COMMA) {\n+                    if (i - 1 >= 0 && lhsTokens.get(i - 1).getType() == BallerinaParser.RIGHT_PARENTHESIS) {\n+                        // eg. func1(func2(10, 10, 5),[cursor]);\n+//                        pendingRParenthesisCount[0]++;", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\nindex 726ef637312..01ec18ce7a0 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\n\n@@ -133,66 +210,31 @@ public class SignatureHelpUtil {\n         return new ImmutablePair<>(parseAndGetFunctionInvocationPath(subRule, serviceContext), paramIndex);\n     }\n \n-    private static Pair<String, Integer> extractSourcePrunedInvocationDetails(\n-            LSServiceOperationContext serviceContext) {\n-        int parameterOffset = 0;\n+    private static List<String> getSourcePrunedFunctionInvocation(LSServiceOperationContext serviceContext) {\n         // Collect source-pruned tokens\n-        List<String> tokenTexts = new ArrayList<>();\n+        List<String> tokenText = new ArrayList<>();\n \n         final int[] pendingRParenthesisCount = new int[]{0};\n         Consumer<Integer> tokenAcceptor = type -> {\n-            if (type == BallerinaParser.LEFT_PARENTHESIS) {\n-                pendingRParenthesisCount[0]--;\n-            } else if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n+            if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n                 pendingRParenthesisCount[0]++;\n+            } else if (type == BallerinaParser.LEFT_PARENTHESIS) {\n+                pendingRParenthesisCount[0]--;\n             }\n         };\n \n-        // Visit Left-Hand side tokens before cursor\n+        // Visit Left-Hand side tokens\n         List<CommonToken> lhsTokens = serviceContext.get(CompletionKeys.LHS_TOKENS_KEY);\n         if (lhsTokens != null) {\n-            while (lhsTokens.get(0).getType() == BallerinaParser.COMMA) {\n-                lhsTokens.remove(0);\n-            }\n-            boolean isLastLeftParenthesisProcessed = false;\n-            for (int i = lhsTokens.size() - 1; i >= 0; i--) {\n-                Token commonToken = lhsTokens.get(i);\n-                int tokenType = commonToken.getType();\n-                if (tokenType == BallerinaParser.LEFT_PARENTHESIS) {\n-                    // Since we are traversing reverse order, we'll get the last LParenthesis first\n-                    isLastLeftParenthesisProcessed = true;\n-                }\n-                if (tokenType == BallerinaParser.COMMA) {\n-                    if (i - 1 >= 0 && lhsTokens.get(i - 1).getType() == BallerinaParser.RIGHT_PARENTHESIS) {\n-                        // eg. func1(func2(10, 10, 5),[cursor]);\n-//                        pendingRParenthesisCount[0]++;\n-                        parameterOffset = 1;\n-                    } else {\n-                        tokenTexts.add(commonToken.getText());\n-                        if (pendingRParenthesisCount[0] == 0 && !isLastLeftParenthesisProcessed) {\n-                            parameterOffset++;\n-                        }\n-                    }\n-                } else {\n-                    tokenAcceptor.accept(tokenType);\n-                    tokenTexts.add(commonToken.getText());\n-                }\n+            for (Token commonToken : lhsTokens) {\n+                tokenAcceptor.accept(commonToken.getType());\n+                tokenText.add(commonToken.getText());\n             }\n         }\n \n-        // Reverse the order of tokens\n-        Collections.reverse(tokenTexts);\n-\n-        // Visit Right-Hand side tokens after cursor\n+        // Visit Right-Hand side tokens\n         List<CommonToken> rhsTokens = serviceContext.get(CompletionKeys.RHS_TOKENS_KEY);\n-        if (rhsTokens != null && !rhsTokens.isEmpty()) {\n-            // Remove if any comma[,] when RHS next immediate token is right parenthesis\n-            int lastIndex = tokenTexts.size() - 1;\n-            while (lastIndex >= 0 && COMMA.equals(tokenTexts.get(lastIndex))\n-                    && rhsTokens.get(0).getType() == BallerinaParser.RIGHT_PARENTHESIS) {\n-                tokenTexts.remove(lastIndex);\n-                lastIndex--;\n-            }\n+        if (rhsTokens != null) {\n             // Collect tokens until we find a Whitespace or Newline\n             for (Token commonToken : rhsTokens) {\n                 int tokenType = commonToken.getType();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODk3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363588976", "bodyText": "Can there be semantically inconsistent issues if we do this?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:40:35Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java", "diffHunk": "@@ -243,20 +201,34 @@ private SignatureHelpUtil() {\n                     break;\n                 }\n                 tokenAcceptor.accept(commonToken.getType());\n-                tokenText.add(commonToken.getText());\n+                tokenTexts.add(commonToken.getText());\n             }\n         }\n \n+        // Remove if any comma[,] when pendingRParenthesis is less than zero\n+        int lastIndex = tokenTexts.size() - 1;\n+        if (COMMA.equals(tokenTexts.get(lastIndex)) && pendingRParenthesisCount[0] <= 0) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n+        //  Remove if any semi-colon[;]\n+        lastIndex = tokenTexts.size() - 1;\n+        if (SEMI_COLON.equals(tokenTexts.get(lastIndex))) {\n+            tokenTexts.remove(lastIndex);\n+        }\n+\n         // Add Missing Parenthesis\n         while (pendingRParenthesisCount[0] < 0) {\n-            tokenText.add(\")\");\n+            tokenTexts.add(\")\");\n             pendingRParenthesisCount[0]++;\n         }\n-        return tokenText;\n+        return Pair.of(String.join(\"\", tokenTexts), parameterOffset);\n     }\n \n     private static Optional<String> parseAndGetFunctionInvocationPath(String subRule, LSServiceOperationContext context)\n             throws CompilationFailedException {\n+        // Replace 'optional field access' with 'field access' to avoid empty top-level nodes\n+        subRule = subRule.replaceAll(\"\\\\?.\", \".\");", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcxNTEzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363715133", "bodyText": "This won't be an issue. Idea is to generate a path string seperated by dots[.] to resolve BInvokableSymbol out of an function invocation text. Here we treat Optional field access as legitimate field access to find the correct function BInvokableSymbol to generate the signature help text.", "author": "rasika", "createdAt": "2020-01-07T11:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4ODk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\nindex 726ef637312..01ec18ce7a0 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/SignatureHelpUtil.java\n\n@@ -201,34 +243,20 @@ public class SignatureHelpUtil {\n                     break;\n                 }\n                 tokenAcceptor.accept(commonToken.getType());\n-                tokenTexts.add(commonToken.getText());\n+                tokenText.add(commonToken.getText());\n             }\n         }\n \n-        // Remove if any comma[,] when pendingRParenthesis is less than zero\n-        int lastIndex = tokenTexts.size() - 1;\n-        if (COMMA.equals(tokenTexts.get(lastIndex)) && pendingRParenthesisCount[0] <= 0) {\n-            tokenTexts.remove(lastIndex);\n-        }\n-\n-        //  Remove if any semi-colon[;]\n-        lastIndex = tokenTexts.size() - 1;\n-        if (SEMI_COLON.equals(tokenTexts.get(lastIndex))) {\n-            tokenTexts.remove(lastIndex);\n-        }\n-\n         // Add Missing Parenthesis\n         while (pendingRParenthesisCount[0] < 0) {\n-            tokenTexts.add(\")\");\n+            tokenText.add(\")\");\n             pendingRParenthesisCount[0]++;\n         }\n-        return Pair.of(String.join(\"\", tokenTexts), parameterOffset);\n+        return tokenText;\n     }\n \n     private static Optional<String> parseAndGetFunctionInvocationPath(String subRule, LSServiceOperationContext context)\n             throws CompilationFailedException {\n-        // Replace 'optional field access' with 'field access' to avoid empty top-level nodes\n-        subRule = subRule.replaceAll(\"\\\\?.\", \".\");\n         Optional<BLangPackage> bLangPackage = ExtendedLSCompiler.compileContent(subRule, CompilerPhase.CODE_ANALYZE)\n                 .getBLangPackage();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU4OTc2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363589765", "bodyText": "Invalid version", "author": "nadeeshaan", "createdAt": "2020-01-07T04:45:53Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * LHS token traverser.\n+ *\n+ * @since 1.0.4", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java\ndeleted file mode 100644\nindex aa91e564a4c..00000000000\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java\n+++ /dev/null\n\n@@ -1,244 +0,0 @@\n-/*\n-  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n- \n-  Licensed under the Apache License, Version 2.0 (the \"License\");\n-  you may not use this file except in compliance with the License.\n-  You may obtain a copy of the License at\n- \n-  http://www.apache.org/licenses/LICENSE-2.0\n- \n-  Unless required by applicable law or agreed to in writing, software\n-  distributed under the License is distributed on an \"AS IS\" BASIS,\n-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-  See the License for the specific language governing permissions and\n-  limitations under the License.\n- */\n-package org.ballerinalang.langserver.signature.sourceprune;\n-\n-import org.antlr.v4.runtime.CommonToken;\n-import org.antlr.v4.runtime.Token;\n-import org.antlr.v4.runtime.TokenStream;\n-import org.ballerinalang.langserver.common.utils.CommonUtil;\n-import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n-import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-\n-/**\n- * LHS token traverser.\n- *\n- * @since 1.0.4\n- */\n-public class LHSSignatureTokenTraverser extends AbstractTokenTraverser {\n-    private List<Integer> lhsTraverseTerminals;\n-    private SourcePruneContext sourcePruneContext;\n-    private boolean forcedProcessedToken = false;\n-    private boolean capturedFirstLeftParenthesis = false;\n-    private boolean capturedFirstColon = false;\n-    private int pendingRightParenthesis = 1;\n-    private int pendingLeftParenthesis = 1;\n-    private int pendingLeftBrace = 0;\n-    private int pendingLeftBracket = 0;\n-    private boolean isCommaTerminal = true;\n-\n-    private boolean isCapturingEnabled = true;\n-    private boolean captureStatement = false;\n-    private boolean addSemiColon = false;\n-\n-    LHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n-        super(pruneTokens);\n-        this.sourcePruneContext = sourcePruneContext;\n-        this.lhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.LHS_TRAVERSE_TERMINALS_KEY);\n-        this.processedTokens = new ArrayList<>();\n-    }\n-\n-    @Override\n-    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n-        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n-        if (token.isPresent()) {\n-            int type = token.get().getType();\n-            if (type == BallerinaParser.COMMA) {\n-                this.isCommaTerminal = false;\n-            }\n-        }\n-        while (token.isPresent()) {\n-            int type = token.get().getType();\n-            if (token.get().getChannel() != 0 && this.capturedFirstLeftParenthesis) {\n-                // if the first left parenthesis '(' is already captured, when we are getting non default channel token\n-                // we disable capturing tokens but continue pruning\n-                Optional<Token> prevToken = CommonUtil.getPreviousDefaultToken(tokenStream, tokenIndex);\n-\n-                // Exception is made for capturing explicit object initializations, eg. new Object()\n-                boolean explicitInit = prevToken.isPresent() && prevToken.get().getType() == BallerinaParser.NEW;\n-\n-                // Exception is made for capturing implicit object initializations, eg. Object obj = new()\n-                if (!this.captureStatement && this.processedTokens.size() >= 2) {\n-                    CommonToken nToken = this.processedTokens.get(this.processedTokens.size() - 1);\n-                    CommonToken nnToken = this.processedTokens.get(this.processedTokens.size() - 2);\n-                    this.captureStatement = nToken.getType() == BallerinaParser.NEW &&\n-                            nnToken.getType() == BallerinaParser.LEFT_PARENTHESIS;\n-                }\n-                if (!explicitInit && !this.captureStatement && this.pendingLeftParenthesis == 0) {\n-                    this.isCapturingEnabled = false;\n-                }\n-            }\n-            if (this.lhsTraverseTerminals.contains(type)) {\n-                boolean terminate = terminateLHSTraverse(token.get(), tokenStream);\n-                if (terminate) {\n-                    break;\n-                }\n-            }\n-            // If match statement, avoid adding semi-colon\n-            this.addSemiColon = this.addSemiColon || token.get().getType() == BallerinaParser.MATCH;\n-            if (!this.forcedProcessedToken) {\n-                processToken(token.get());\n-            }\n-            this.forcedProcessedToken = false;\n-            tokenIndex = token.get().getTokenIndex() - 1;\n-            token = tokenIndex < 0 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n-        }\n-        sourcePruneContext.put(SourcePruneKeys.LEFT_PARAN_COUNT_KEY, this.pendingLeftParenthesis);\n-        sourcePruneContext.put(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY, this.pendingRightParenthesis);\n-        sourcePruneContext.put(SourcePruneKeys.LEFT_BRACE_COUNT_KEY, this.pendingLeftBrace);\n-        sourcePruneContext.put(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY, this.addSemiColon);\n-        Collections.reverse(this.processedTokens);\n-\n-        removeProceedingNonDefaultTokens(this.processedTokens);\n-        return this.processedTokens;\n-    }\n-\n-    private void removeProceedingNonDefaultTokens(List<CommonToken> processedTokens) {\n-        int len = processedTokens.size();\n-        for (int i = 0; i < len; i++) {\n-            CommonToken token = processedTokens.get(i);\n-            if (token.getChannel() != 0) {\n-                processedTokens.remove(token);\n-                i--;\n-                len--;\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-\n-    private boolean terminateLHSTraverse(Token token, TokenStream tokenStream) {\n-        int type = token.getType();\n-        String text = token.getText();\n-        if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n-            // Exception for field access expr. eg. stub.bar(1, false).foo()\n-            boolean isFieldAccess = this.lastProcessedToken.getType() == BallerinaParser.DOT ||\n-                    this.lastProcessedToken.getType() == BallerinaParser.OPTIONAL_FIELD_ACCESS; // ').' or ')?.'\n-            if (isFieldAccess) {\n-                this.isCommaTerminal = false;\n-            }\n-            if (this.capturedFirstLeftParenthesis && !isFieldAccess) {\n-                return true;\n-            }\n-            this.pendingLeftParenthesis++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_PARENTHESIS) {\n-            Optional<Token> tokenToLeft = CommonUtil.getPreviousDefaultToken(tokenStream, token.getTokenIndex());\n-            if (this.pendingLeftParenthesis > 0) {\n-                this.pendingLeftParenthesis--;\n-                this.isCommaTerminal = true;\n-                this.capturedFirstLeftParenthesis = true;\n-                return false;\n-            } else {\n-                this.isCommaTerminal = true;\n-                if (this.capturedFirstLeftParenthesis) {\n-                    return true;\n-                } else {\n-                    this.capturedFirstLeftParenthesis = true;\n-                }\n-            }\n-            if (tokenToLeft.isPresent() &&\n-                    (BallerinaParser.IF == tokenToLeft.get().getType() ||\n-                            BallerinaParser.WHILE == tokenToLeft.get().getType())) {\n-                // Cursor is within the if/ else if/ while condition\n-                this.replaceCondition(tokenStream, token.getTokenIndex());\n-            }\n-            this.isCommaTerminal = true;\n-            this.capturedFirstLeftParenthesis = true;\n-            return false;\n-        } else if (type == BallerinaParser.RIGHT_BRACE) {\n-            this.pendingLeftBrace++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_BRACE) {\n-            if (this.pendingLeftBrace > 0) {\n-                this.pendingLeftBrace--;\n-                return false;\n-            } else {\n-                return true;\n-            }\n-        } else if (type == BallerinaParser.XMLTemplateText && \"${\".equals(text)) {\n-            this.pendingLeftBrace++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.RIGHT_BRACKET) {\n-            this.pendingLeftBracket++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_BRACKET) {\n-            if (this.pendingLeftBracket > 0) {\n-                this.pendingLeftBracket--;\n-                return false;\n-            } else {\n-                return true;\n-            }\n-        } else if (type == BallerinaParser.COMMA) {\n-            if (this.isCommaTerminal && this.capturedFirstLeftParenthesis) {\n-                this.processToken(token);\n-                this.forcedProcessedToken = true;\n-                return true;\n-            }\n-            return false;\n-        } else if (type == BallerinaParser.ASSIGN) {\n-            if (this.capturedFirstLeftParenthesis) {\n-                return true;\n-            }\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.SEMICOLON) {\n-            this.forcedProcessedToken = true;\n-            return true;\n-        } else if (type == BallerinaParser.COLON) {\n-            if (this.capturedFirstColon) {\n-                this.forcedProcessedToken = true;\n-                return true;\n-            }\n-            this.capturedFirstColon = true;\n-        }\n-        return pendingLeftParenthesis == 0 && pendingRightParenthesis == 0;\n-    }\n-\n-    protected boolean processToken(Token token) {\n-        if (this.isCapturingEnabled) {\n-            return super.processToken(token);\n-        } else {\n-            if (token.getType() == BallerinaParser.NEW_LINE || token.getType() == BallerinaParser.EOF ||\n-                    token.getChannel() != Token.DEFAULT_CHANNEL || token.getType() == BallerinaParser.WS) {\n-                return false;\n-            }\n-            this.lastProcessedToken = token;\n-            if (pruneTokens) {\n-                // If the pruneTokens flag is true, replace the token text with empty spaces\n-                ((CommonToken) token).setText(getNCharLengthEmptyLine(token.getText().length()));\n-                ((CommonToken) token).setType(BallerinaParser.WS);\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDMxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363590311", "bodyText": "Shall we refactor this one to use switch case instead of the if-else ladder?", "author": "nadeeshaan", "createdAt": "2020-01-07T04:49:22Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * LHS token traverser.\n+ *\n+ * @since 1.0.4\n+ */\n+public class LHSSignatureTokenTraverser extends AbstractTokenTraverser {\n+    private List<Integer> lhsTraverseTerminals;\n+    private SourcePruneContext sourcePruneContext;\n+    private boolean forcedProcessedToken = false;\n+    private boolean capturedFirstLeftParenthesis = false;\n+    private boolean capturedFirstColon = false;\n+    private int pendingRightParenthesis = 1;\n+    private int pendingLeftParenthesis = 1;\n+    private int pendingLeftBrace = 0;\n+    private int pendingLeftBracket = 0;\n+    private boolean isCommaTerminal = true;\n+\n+    private boolean isCapturingEnabled = true;\n+    private boolean captureStatement = false;\n+    private boolean addSemiColon = false;\n+\n+    LHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n+        super(pruneTokens);\n+        this.sourcePruneContext = sourcePruneContext;\n+        this.lhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.LHS_TRAVERSE_TERMINALS_KEY);\n+        this.processedTokens = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n+        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n+        if (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (type == BallerinaParser.COMMA) {\n+                this.isCommaTerminal = false;\n+            }\n+        }\n+        while (token.isPresent()) {\n+            int type = token.get().getType();\n+            if (token.get().getChannel() != 0 && this.capturedFirstLeftParenthesis) {\n+                // if the first left parenthesis '(' is already captured, when we are getting non default channel token\n+                // we disable capturing tokens but continue pruning\n+                Optional<Token> prevToken = CommonUtil.getPreviousDefaultToken(tokenStream, tokenIndex);\n+\n+                // Exception is made for capturing explicit object initializations, eg. new Object()\n+                boolean explicitInit = prevToken.isPresent() && prevToken.get().getType() == BallerinaParser.NEW;\n+\n+                // Exception is made for capturing implicit object initializations, eg. Object obj = new()\n+                if (!this.captureStatement && this.processedTokens.size() >= 2) {\n+                    CommonToken nToken = this.processedTokens.get(this.processedTokens.size() - 1);\n+                    CommonToken nnToken = this.processedTokens.get(this.processedTokens.size() - 2);\n+                    this.captureStatement = nToken.getType() == BallerinaParser.NEW &&\n+                            nnToken.getType() == BallerinaParser.LEFT_PARENTHESIS;\n+                }\n+                if (!explicitInit && !this.captureStatement && this.pendingLeftParenthesis == 0) {\n+                    this.isCapturingEnabled = false;\n+                }\n+            }\n+            if (this.lhsTraverseTerminals.contains(type)) {\n+                boolean terminate = terminateLHSTraverse(token.get(), tokenStream);\n+                if (terminate) {\n+                    break;\n+                }\n+            }\n+            // If match statement, avoid adding semi-colon\n+            this.addSemiColon = this.addSemiColon || token.get().getType() == BallerinaParser.MATCH;\n+            if (!this.forcedProcessedToken) {\n+                processToken(token.get());\n+            }\n+            this.forcedProcessedToken = false;\n+            tokenIndex = token.get().getTokenIndex() - 1;\n+            token = tokenIndex < 0 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n+        }\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_PARAN_COUNT_KEY, this.pendingLeftParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY, this.pendingRightParenthesis);\n+        sourcePruneContext.put(SourcePruneKeys.LEFT_BRACE_COUNT_KEY, this.pendingLeftBrace);\n+        sourcePruneContext.put(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY, this.addSemiColon);\n+        Collections.reverse(this.processedTokens);\n+\n+        removeProceedingNonDefaultTokens(this.processedTokens);\n+        return this.processedTokens;\n+    }\n+\n+    private void removeProceedingNonDefaultTokens(List<CommonToken> processedTokens) {\n+        int len = processedTokens.size();\n+        for (int i = 0; i < len; i++) {\n+            CommonToken token = processedTokens.get(i);\n+            if (token.getChannel() != 0) {\n+                processedTokens.remove(token);\n+                i--;\n+                len--;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private boolean terminateLHSTraverse(Token token, TokenStream tokenStream) {\n+        int type = token.getType();\n+        String text = token.getText();\n+        if (type == BallerinaParser.RIGHT_PARENTHESIS) {", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzcyMzI0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363723242", "bodyText": "I already tried it but couldn't due to this case. Even making ${\".equals(text) check an inner-if, didn't work due to false checkstyle error Fall through from previous branch of the switch statement.", "author": "rasika", "createdAt": "2020-01-07T12:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java\ndeleted file mode 100644\nindex aa91e564a4c..00000000000\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/LHSSignatureTokenTraverser.java\n+++ /dev/null\n\n@@ -1,244 +0,0 @@\n-/*\n-  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n- \n-  Licensed under the Apache License, Version 2.0 (the \"License\");\n-  you may not use this file except in compliance with the License.\n-  You may obtain a copy of the License at\n- \n-  http://www.apache.org/licenses/LICENSE-2.0\n- \n-  Unless required by applicable law or agreed to in writing, software\n-  distributed under the License is distributed on an \"AS IS\" BASIS,\n-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-  See the License for the specific language governing permissions and\n-  limitations under the License.\n- */\n-package org.ballerinalang.langserver.signature.sourceprune;\n-\n-import org.antlr.v4.runtime.CommonToken;\n-import org.antlr.v4.runtime.Token;\n-import org.antlr.v4.runtime.TokenStream;\n-import org.ballerinalang.langserver.common.utils.CommonUtil;\n-import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n-import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-\n-/**\n- * LHS token traverser.\n- *\n- * @since 1.0.4\n- */\n-public class LHSSignatureTokenTraverser extends AbstractTokenTraverser {\n-    private List<Integer> lhsTraverseTerminals;\n-    private SourcePruneContext sourcePruneContext;\n-    private boolean forcedProcessedToken = false;\n-    private boolean capturedFirstLeftParenthesis = false;\n-    private boolean capturedFirstColon = false;\n-    private int pendingRightParenthesis = 1;\n-    private int pendingLeftParenthesis = 1;\n-    private int pendingLeftBrace = 0;\n-    private int pendingLeftBracket = 0;\n-    private boolean isCommaTerminal = true;\n-\n-    private boolean isCapturingEnabled = true;\n-    private boolean captureStatement = false;\n-    private boolean addSemiColon = false;\n-\n-    LHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n-        super(pruneTokens);\n-        this.sourcePruneContext = sourcePruneContext;\n-        this.lhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.LHS_TRAVERSE_TERMINALS_KEY);\n-        this.processedTokens = new ArrayList<>();\n-    }\n-\n-    @Override\n-    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n-        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n-        if (token.isPresent()) {\n-            int type = token.get().getType();\n-            if (type == BallerinaParser.COMMA) {\n-                this.isCommaTerminal = false;\n-            }\n-        }\n-        while (token.isPresent()) {\n-            int type = token.get().getType();\n-            if (token.get().getChannel() != 0 && this.capturedFirstLeftParenthesis) {\n-                // if the first left parenthesis '(' is already captured, when we are getting non default channel token\n-                // we disable capturing tokens but continue pruning\n-                Optional<Token> prevToken = CommonUtil.getPreviousDefaultToken(tokenStream, tokenIndex);\n-\n-                // Exception is made for capturing explicit object initializations, eg. new Object()\n-                boolean explicitInit = prevToken.isPresent() && prevToken.get().getType() == BallerinaParser.NEW;\n-\n-                // Exception is made for capturing implicit object initializations, eg. Object obj = new()\n-                if (!this.captureStatement && this.processedTokens.size() >= 2) {\n-                    CommonToken nToken = this.processedTokens.get(this.processedTokens.size() - 1);\n-                    CommonToken nnToken = this.processedTokens.get(this.processedTokens.size() - 2);\n-                    this.captureStatement = nToken.getType() == BallerinaParser.NEW &&\n-                            nnToken.getType() == BallerinaParser.LEFT_PARENTHESIS;\n-                }\n-                if (!explicitInit && !this.captureStatement && this.pendingLeftParenthesis == 0) {\n-                    this.isCapturingEnabled = false;\n-                }\n-            }\n-            if (this.lhsTraverseTerminals.contains(type)) {\n-                boolean terminate = terminateLHSTraverse(token.get(), tokenStream);\n-                if (terminate) {\n-                    break;\n-                }\n-            }\n-            // If match statement, avoid adding semi-colon\n-            this.addSemiColon = this.addSemiColon || token.get().getType() == BallerinaParser.MATCH;\n-            if (!this.forcedProcessedToken) {\n-                processToken(token.get());\n-            }\n-            this.forcedProcessedToken = false;\n-            tokenIndex = token.get().getTokenIndex() - 1;\n-            token = tokenIndex < 0 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n-        }\n-        sourcePruneContext.put(SourcePruneKeys.LEFT_PARAN_COUNT_KEY, this.pendingLeftParenthesis);\n-        sourcePruneContext.put(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY, this.pendingRightParenthesis);\n-        sourcePruneContext.put(SourcePruneKeys.LEFT_BRACE_COUNT_KEY, this.pendingLeftBrace);\n-        sourcePruneContext.put(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY, this.addSemiColon);\n-        Collections.reverse(this.processedTokens);\n-\n-        removeProceedingNonDefaultTokens(this.processedTokens);\n-        return this.processedTokens;\n-    }\n-\n-    private void removeProceedingNonDefaultTokens(List<CommonToken> processedTokens) {\n-        int len = processedTokens.size();\n-        for (int i = 0; i < len; i++) {\n-            CommonToken token = processedTokens.get(i);\n-            if (token.getChannel() != 0) {\n-                processedTokens.remove(token);\n-                i--;\n-                len--;\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-\n-    private boolean terminateLHSTraverse(Token token, TokenStream tokenStream) {\n-        int type = token.getType();\n-        String text = token.getText();\n-        if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n-            // Exception for field access expr. eg. stub.bar(1, false).foo()\n-            boolean isFieldAccess = this.lastProcessedToken.getType() == BallerinaParser.DOT ||\n-                    this.lastProcessedToken.getType() == BallerinaParser.OPTIONAL_FIELD_ACCESS; // ').' or ')?.'\n-            if (isFieldAccess) {\n-                this.isCommaTerminal = false;\n-            }\n-            if (this.capturedFirstLeftParenthesis && !isFieldAccess) {\n-                return true;\n-            }\n-            this.pendingLeftParenthesis++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_PARENTHESIS) {\n-            Optional<Token> tokenToLeft = CommonUtil.getPreviousDefaultToken(tokenStream, token.getTokenIndex());\n-            if (this.pendingLeftParenthesis > 0) {\n-                this.pendingLeftParenthesis--;\n-                this.isCommaTerminal = true;\n-                this.capturedFirstLeftParenthesis = true;\n-                return false;\n-            } else {\n-                this.isCommaTerminal = true;\n-                if (this.capturedFirstLeftParenthesis) {\n-                    return true;\n-                } else {\n-                    this.capturedFirstLeftParenthesis = true;\n-                }\n-            }\n-            if (tokenToLeft.isPresent() &&\n-                    (BallerinaParser.IF == tokenToLeft.get().getType() ||\n-                            BallerinaParser.WHILE == tokenToLeft.get().getType())) {\n-                // Cursor is within the if/ else if/ while condition\n-                this.replaceCondition(tokenStream, token.getTokenIndex());\n-            }\n-            this.isCommaTerminal = true;\n-            this.capturedFirstLeftParenthesis = true;\n-            return false;\n-        } else if (type == BallerinaParser.RIGHT_BRACE) {\n-            this.pendingLeftBrace++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_BRACE) {\n-            if (this.pendingLeftBrace > 0) {\n-                this.pendingLeftBrace--;\n-                return false;\n-            } else {\n-                return true;\n-            }\n-        } else if (type == BallerinaParser.XMLTemplateText && \"${\".equals(text)) {\n-            this.pendingLeftBrace++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.RIGHT_BRACKET) {\n-            this.pendingLeftBracket++;\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.LEFT_BRACKET) {\n-            if (this.pendingLeftBracket > 0) {\n-                this.pendingLeftBracket--;\n-                return false;\n-            } else {\n-                return true;\n-            }\n-        } else if (type == BallerinaParser.COMMA) {\n-            if (this.isCommaTerminal && this.capturedFirstLeftParenthesis) {\n-                this.processToken(token);\n-                this.forcedProcessedToken = true;\n-                return true;\n-            }\n-            return false;\n-        } else if (type == BallerinaParser.ASSIGN) {\n-            if (this.capturedFirstLeftParenthesis) {\n-                return true;\n-            }\n-            this.processToken(token);\n-            this.forcedProcessedToken = true;\n-            return false;\n-        } else if (type == BallerinaParser.SEMICOLON) {\n-            this.forcedProcessedToken = true;\n-            return true;\n-        } else if (type == BallerinaParser.COLON) {\n-            if (this.capturedFirstColon) {\n-                this.forcedProcessedToken = true;\n-                return true;\n-            }\n-            this.capturedFirstColon = true;\n-        }\n-        return pendingLeftParenthesis == 0 && pendingRightParenthesis == 0;\n-    }\n-\n-    protected boolean processToken(Token token) {\n-        if (this.isCapturingEnabled) {\n-            return super.processToken(token);\n-        } else {\n-            if (token.getType() == BallerinaParser.NEW_LINE || token.getType() == BallerinaParser.EOF ||\n-                    token.getChannel() != Token.DEFAULT_CHANNEL || token.getType() == BallerinaParser.WS) {\n-                return false;\n-            }\n-            this.lastProcessedToken = token;\n-            if (pruneTokens) {\n-                // If the pruneTokens flag is true, replace the token text with empty spaces\n-                ((CommonToken) token).setText(getNCharLengthEmptyLine(token.getText().length()));\n-                ((CommonToken) token).setType(BallerinaParser.WS);\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MDU1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363590550", "bodyText": "Invalid version", "author": "nadeeshaan", "createdAt": "2020-01-07T04:50:49Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ \n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+ \n+  http://www.apache.org/licenses/LICENSE-2.0\n+ \n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+ */\n+package org.ballerinalang.langserver.signature.sourceprune;\n+\n+import org.antlr.v4.runtime.CommonToken;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.TokenStream;\n+import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n+import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n+import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * RHS Token Traverser.\n+ *\n+ * @since 1.0.4", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java\ndeleted file mode 100644\nindex 02514e7a0f4..00000000000\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/signature/sourceprune/RHSSignatureTokenTraverser.java\n+++ /dev/null\n\n@@ -1,134 +0,0 @@\n-/*\n-  Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n- \n-  Licensed under the Apache License, Version 2.0 (the \"License\");\n-  you may not use this file except in compliance with the License.\n-  You may obtain a copy of the License at\n- \n-  http://www.apache.org/licenses/LICENSE-2.0\n- \n-  Unless required by applicable law or agreed to in writing, software\n-  distributed under the License is distributed on an \"AS IS\" BASIS,\n-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-  See the License for the specific language governing permissions and\n-  limitations under the License.\n- */\n-package org.ballerinalang.langserver.signature.sourceprune;\n-\n-import org.antlr.v4.runtime.CommonToken;\n-import org.antlr.v4.runtime.Token;\n-import org.antlr.v4.runtime.TokenStream;\n-import org.ballerinalang.langserver.sourceprune.AbstractTokenTraverser;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneContext;\n-import org.ballerinalang.langserver.sourceprune.SourcePruneKeys;\n-import org.wso2.ballerinalang.compiler.parser.antlr4.BallerinaParser;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-\n-/**\n- * RHS Token Traverser.\n- *\n- * @since 1.0.4\n- */\n-public class RHSSignatureTokenTraverser extends AbstractTokenTraverser {\n-    private final List<Integer> rhsTraverseTerminals;\n-    private final boolean addSemiColon;\n-    private int pendingRightParenthesis;\n-    private int pendingLeftBrace;\n-    private boolean forcedProcessedToken;\n-    private boolean capturedLastRightParenthesis;\n-\n-    RHSSignatureTokenTraverser(SourcePruneContext sourcePruneContext, boolean pruneTokens) {\n-        super(pruneTokens);\n-        this.pendingRightParenthesis = sourcePruneContext.get(SourcePruneKeys.RIGHT_PARAN_COUNT_KEY);\n-        this.rhsTraverseTerminals = sourcePruneContext.get(SourcePruneKeys.RHS_TRAVERSE_TERMINALS_KEY);\n-        this.pendingLeftBrace = sourcePruneContext.get(SourcePruneKeys.LEFT_BRACE_COUNT_KEY);\n-        this.addSemiColon = sourcePruneContext.get(SourcePruneKeys.ADD_SEMICOLON_COUNT_KEY);\n-        this.forcedProcessedToken = false;\n-        this.capturedLastRightParenthesis = false;\n-        this.processedTokens = new ArrayList<>();\n-    }\n-\n-    @Override\n-    public List<CommonToken> traverse(TokenStream tokenStream, int tokenIndex) {\n-        Optional<Token> token = Optional.of(tokenStream.get(tokenIndex));\n-        while (token.isPresent()) {\n-            int type = token.get().getType();\n-            if (rhsTraverseTerminals.contains(type)) {\n-                boolean terminateRHSTraverse = terminateRHSTraverse(token.get());\n-                if (terminateRHSTraverse) {\n-                    break;\n-                }\n-            }\n-            if (type == BallerinaParser.NEW_LINE && this.capturedLastRightParenthesis) {\n-                break;\n-            }\n-            if (!this.forcedProcessedToken) {\n-                processToken(token.get());\n-            }\n-            this.forcedProcessedToken = false;\n-            tokenIndex = token.get().getTokenIndex() + 1;\n-            token = tokenIndex > tokenStream.size() - 1 ? Optional.empty() : Optional.of(tokenStream.get(tokenIndex));\n-        }\n-        // Check for semi-colon[:], if not found add\n-        if (token.isPresent() && this.addSemiColon) {\n-            checkForSemiColon(tokenStream, tokenIndex, token.get());\n-        }\n-        return this.processedTokens;\n-    }\n-\n-    private boolean terminateRHSTraverse(Token token) {\n-        int type = token.getType();\n-        if (type == BallerinaParser.RIGHT_PARENTHESIS) {\n-            boolean result;\n-            if (this.pendingRightParenthesis > 0) {\n-                this.pendingRightParenthesis--;\n-                result = false;\n-            } else {\n-                this.processToken(token);\n-                result = true;\n-            }\n-            if (this.pendingRightParenthesis == 0) {\n-                this.capturedLastRightParenthesis = true;\n-            }\n-            return result;\n-        } else if (type == BallerinaParser.RIGHT_BRACE && this.pendingLeftBrace > 0) {\n-            this.pendingLeftBrace--;\n-            return false;\n-        } else if (type == BallerinaParser.AT &&\n-                this.lastProcessedToken.getType() == BallerinaParser.RIGHT_PARENTHESIS) {\n-            // To handle, map<string>? attrs = fooX(1,)@;\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Check and add semi-colon to the end.\n-     *\n-     *  @param tokenStream token stream\n-     * @param tokenIndex  token index\n-     * @param token       current token\n-     */\n-    private void checkForSemiColon(TokenStream tokenStream, int tokenIndex, Token token) {\n-        if (token == null || this.lastProcessedToken == null) {\n-            return;\n-        }\n-        while (token.getChannel() != Token.DEFAULT_CHANNEL) {\n-            tokenIndex++;\n-            if (tokenIndex < 0) {\n-                return;\n-            }\n-            token = tokenStream.get(tokenIndex);\n-        }\n-        boolean isWS = this.lastProcessedToken.getType() == BallerinaParser.WS;\n-        if (token.getType() != BallerinaParser.SEMICOLON && isWS) {\n-            CommonToken lastProcessedToken = (CommonToken) this.lastProcessedToken;\n-            lastProcessedToken.setText(\";\");\n-            lastProcessedToken.setType(BallerinaParser.SEMICOLON);\n-            lastProcessedToken.setChannel(Token.DEFAULT_CHANNEL);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU5MTEzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20524#discussion_r363591130", "bodyText": "Invalid version", "author": "nadeeshaan", "createdAt": "2020-01-07T04:55:04Z", "path": "language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.ballerinalang.langserver.sourceprune;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.ballerinalang.langserver.LSContextOperation;\n+import org.ballerinalang.langserver.common.CommonKeys;\n+import org.ballerinalang.langserver.common.utils.CommonUtil;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.langserver.compiler.LSContext;\n+import org.ballerinalang.langserver.compiler.LSServiceOperationContext;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n+import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManagerImpl;\n+import org.ballerinalang.langserver.completions.util.SourcePruneException;\n+import org.ballerinalang.langserver.signature.sourceprune.SignatureTokenTraverserFactory;\n+import org.ballerinalang.langserver.util.FileUtils;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.TextDocumentPositionParams;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+/**\n+ * Test the source prune operation with specific sources individual from the signature operation.\n+ *\n+ * @since 1.0.5", "originalCommit": "89a10b44bdbeb4e9bc902a4e2c2be5307df59e9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "chunk": "diff --git a/language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java b/language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java\ndeleted file mode 100644\nindex 21e91784a72..00000000000\n--- a/language-server/modules/langserver-core/src/test/java/org/ballerinalang/langserver/sourceprune/SignatureSourcePruneTest.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-package org.ballerinalang.langserver.sourceprune;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.JsonObject;\n-import org.ballerinalang.langserver.LSContextOperation;\n-import org.ballerinalang.langserver.common.CommonKeys;\n-import org.ballerinalang.langserver.common.utils.CommonUtil;\n-import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n-import org.ballerinalang.langserver.compiler.LSContext;\n-import org.ballerinalang.langserver.compiler.LSServiceOperationContext;\n-import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentException;\n-import org.ballerinalang.langserver.compiler.workspace.WorkspaceDocumentManagerImpl;\n-import org.ballerinalang.langserver.completions.util.SourcePruneException;\n-import org.ballerinalang.langserver.signature.sourceprune.SignatureTokenTraverserFactory;\n-import org.ballerinalang.langserver.util.FileUtils;\n-import org.eclipse.lsp4j.Position;\n-import org.eclipse.lsp4j.TextDocumentPositionParams;\n-import org.testng.Assert;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Optional;\n-\n-/**\n- * Test the source prune operation with specific sources individual from the signature operation.\n- *\n- * @since 1.0.5\n- */\n-public class SignatureSourcePruneTest {\n-    private Path configRoot;\n-    private Path sourceRoot;\n-    private Path expectedRoot;\n-    private WorkspaceDocumentManagerImpl documentManager;\n-    private Gson gson = new Gson();\n-    private static final String LINE_SEPARATOR = System.lineSeparator();\n-\n-    @BeforeClass\n-    public void init() throws Exception {\n-        configRoot = FileUtils.RES_DIR.resolve(\"signature\").resolve(\"sourceprune\").resolve(\"config\");\n-        expectedRoot = FileUtils.RES_DIR.resolve(\"signature\").resolve(\"sourceprune\").resolve(\"expected\");\n-        sourceRoot = FileUtils.RES_DIR.resolve(\"signature\").resolve(\"sourceprune\").resolve(\"sources\");\n-        documentManager = WorkspaceDocumentManagerImpl.getInstance();\n-    }\n-\n-    @Test(dataProvider = \"testDataProvider\")\n-    public void testSourcePrune(String configPath) throws IOException, WorkspaceDocumentException {\n-        Path sourcePath = configRoot.resolve(configPath);\n-        JsonObject configObject = FileUtils.fileContentAsObject(sourcePath.toString());\n-        Position position = gson.fromJson(configObject.get(\"position\"), Position.class);\n-        String source = configObject.getAsJsonPrimitive(\"source\").getAsString();\n-        LSContext lsContext = this.getLSContext(source, position);\n-        String fileUri = lsContext.get(DocumentServiceKeys.FILE_URI_KEY);\n-        Optional<Path> filePath = CommonUtil.getPathFromURI(fileUri);\n-        if (!filePath.isPresent()) {\n-            Assert.fail(\"Invalid File path: [\" + fileUri + \"]\");\n-        }\n-        String documentContent = new String(Files.readAllBytes(filePath.get())).replaceAll(\"\\r?\\n\", LINE_SEPARATOR);\n-\n-        this.documentManager.openFile(filePath.get(), documentContent);\n-        try {\n-            TokenTraverserFactory tokenTraverserFactory = new SignatureTokenTraverserFactory(filePath.get(),\n-                                                                                             documentManager,\n-                                                                                             SourcePruner.newContext());\n-            SourcePruner.pruneSource(lsContext, tokenTraverserFactory);\n-            String prunedSource = tokenTraverserFactory.getTokenStream().getText();\n-            Path expectedPath = expectedRoot.resolve(configObject.getAsJsonPrimitive(\"expected\").getAsString());\n-            String expected = new String(Files.readAllBytes(expectedPath)).replaceAll(\"\\r?\\n\", LINE_SEPARATOR);\n-            boolean sourceMatch = prunedSource.equals(expected);\n-            if (!sourceMatch) {\n-                Assert.fail(\"Sources Does not Match for \" + configPath + System.lineSeparator()\n-                                    + \"Pruned Source [\" + prunedSource + \"]\" + System.lineSeparator()\n-                                    + \"Expected Source [\" + expected + \"]\");\n-            }\n-            Assert.assertEquals(prunedSource, expected);\n-        } catch (SourcePruneException e) {\n-            Assert.fail(e.getMessage());\n-        }\n-    }\n-\n-    private LSContext getLSContext(String source, Position position) {\n-        LSContext lsContext = new LSServiceOperationContext(LSContextOperation.SOURCE_PRUNER);\n-        URI fileUri = sourceRoot.resolve(source).toUri();\n-        TextDocumentPositionParams positionParams = new TextDocumentPositionParams();\n-        positionParams.setPosition(position);\n-        lsContext.put(CommonKeys.DOC_MANAGER_KEY, documentManager);\n-        lsContext.put(DocumentServiceKeys.POSITION_KEY, positionParams);\n-        lsContext.put(DocumentServiceKeys.FILE_URI_KEY, fileUri.toString());\n-\n-        return lsContext;\n-    }\n-\n-    @DataProvider\n-    public Object[][] testDataProvider() {\n-        return new Object[][] {\n-                {\"src_prune_config1.json\"},\n-                {\"src_prune_config2.json\"},\n-                {\"src_prune_config3.json\"},\n-                {\"src_prune_config4.json\"}\n-        };\n-    }\n-}\n"}}, {"oid": "ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad4dbb42cabae4c795e0a0b85e3e29e3ce694956", "message": "Make SourcePruner extensible introducing TokenTraverserFactory\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:51:26Z", "type": "commit"}, {"oid": "57459e0384a078e005f9f2bbc06773080168d64e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57459e0384a078e005f9f2bbc06773080168d64e", "message": "Add signature source pruner\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:51:33Z", "type": "commit"}, {"oid": "bfae1e450424413d73fc7cdbc6a5f7bc05744e78", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfae1e450424413d73fc7cdbc6a5f7bc05744e78", "message": "Enable signature help\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:51:43Z", "type": "commit"}, {"oid": "01fdfb4dc647e925dcc89ef5b4f1b40b270df0d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/01fdfb4dc647e925dcc89ef5b4f1b40b270df0d3", "message": "persist last-processed token instead of token type\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:51:57Z", "type": "commit"}, {"oid": "58218cc9fdd769cee7b666a9bb729092027d72b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58218cc9fdd769cee7b666a9bb729092027d72b2", "message": "Enable signature help tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:52:03Z", "type": "commit"}, {"oid": "a6bd2c1d6396017eec15270ba6a501b6930ac2bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6bd2c1d6396017eec15270ba6a501b6930ac2bf", "message": "Add source pruner tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:52:20Z", "type": "commit"}, {"oid": "a6942bae220ea3622488ac658c032806283586d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6942bae220ea3622488ac658c032806283586d3", "message": "Add signature tests to cover ballerina-spec-R3\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:52:37Z", "type": "commit"}, {"oid": "fdc3bcd2477dbb7629870ce11bdde90ba78e147b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fdc3bcd2477dbb7629870ce11bdde90ba78e147b", "message": "Fix signature fails for match stmt\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:16Z", "type": "commit"}, {"oid": "63fd664e947db583131f95b250837495a83338ac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63fd664e947db583131f95b250837495a83338ac", "message": "Fix minor check style issues\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:21Z", "type": "commit"}, {"oid": "2446f80e6884abefccaa33abaa5085d9224a7c5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2446f80e6884abefccaa33abaa5085d9224a7c5f", "message": "Add minor refactoring\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:32Z", "type": "commit"}, {"oid": "970bd26d29d0aaa2ab6fd042ddde9b8ad8876b4d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/970bd26d29d0aaa2ab6fd042ddde9b8ad8876b4d", "message": "Fix NPE issue\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:38Z", "type": "commit"}, {"oid": "bdaefd8b513ef41ff0e15f10047949341a459a56", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdaefd8b513ef41ff0e15f10047949341a459a56", "message": "Fix lastProcessedToken is getting replaced with WS\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:48Z", "type": "commit"}, {"oid": "bdaefd8b513ef41ff0e15f10047949341a459a56", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdaefd8b513ef41ff0e15f10047949341a459a56", "message": "Fix lastProcessedToken is getting replaced with WS\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T08:53:48Z", "type": "forcePushed"}, {"oid": "7028cd6836a9ac0e82e9c2eaf68caeca3171a24a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7028cd6836a9ac0e82e9c2eaf68caeca3171a24a", "message": "Merge branch 'ballerina-1.1.x' of https://github.com/ballerina-platform/ballerina-lang into ballerina-1.1.x", "committedDate": "2020-01-07T11:45:15Z", "type": "commit"}, {"oid": "584fd37f5cef5b98644c39cda45a2e46042993f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/584fd37f5cef5b98644c39cda45a2e46042993f3", "message": "Change shipping version text\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T12:02:17Z", "type": "commit"}, {"oid": "fb370ceed133071f71ea76515d98455cc0b15c76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb370ceed133071f71ea76515d98455cc0b15c76", "message": "Making TokenTraversers non public\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T12:22:45Z", "type": "commit"}, {"oid": "df1d707c3c2d550b6e32044190e592398a406be9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df1d707c3c2d550b6e32044190e592398a406be9", "message": "Add review suggestions\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T12:23:27Z", "type": "commit"}, {"oid": "83997acb89eafeb109d90ed44dc40f478d533047", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/83997acb89eafeb109d90ed44dc40f478d533047", "message": "Change shipping version\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-01-07T12:26:58Z", "type": "commit"}]}