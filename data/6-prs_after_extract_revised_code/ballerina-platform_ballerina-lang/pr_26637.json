{"pr_number": 26637, "pr_title": "Refactor JvmMethodGen class", "pr_createdAt": "2020-10-28T01:23:23Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26637", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4NDkzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26637#discussion_r513284932", "bodyText": "since declaration is missing in new classes.", "author": "warunalakshitha", "createdAt": "2020-10-28T09:13:14Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmMainMethodGen.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n+\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.AsyncDataCollector;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.BIRVarToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.AASTORE;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ANEWARRAY;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+\n+/**\n+ * Generates Jvm byte code for the main method.\n+ */", "originalCommit": "ce9be107577c37b0f2f8999aef0bc6ea3360aaf4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmMainMethodGen.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmMainMethodGen.java\ndeleted file mode 100644\nindex f99995cfd76..00000000000\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmMainMethodGen.java\n+++ /dev/null\n\n@@ -1,410 +0,0 @@\n-/*\n- * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- * WSO2 Inc. licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n-\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.AsyncDataCollector;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.BIRVarToJVMIndexMap;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n-import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n-import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n-import org.wso2.ballerinalang.compiler.util.Name;\n-import org.wso2.ballerinalang.compiler.util.TypeTags;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static org.objectweb.asm.Opcodes.AALOAD;\n-import static org.objectweb.asm.Opcodes.AASTORE;\n-import static org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static org.objectweb.asm.Opcodes.ACONST_NULL;\n-import static org.objectweb.asm.Opcodes.ALOAD;\n-import static org.objectweb.asm.Opcodes.ANEWARRAY;\n-import static org.objectweb.asm.Opcodes.ASTORE;\n-import static org.objectweb.asm.Opcodes.BIPUSH;\n-import static org.objectweb.asm.Opcodes.CHECKCAST;\n-import static org.objectweb.asm.Opcodes.DUP;\n-import static org.objectweb.asm.Opcodes.GETFIELD;\n-import static org.objectweb.asm.Opcodes.ICONST_0;\n-import static org.objectweb.asm.Opcodes.ICONST_1;\n-import static org.objectweb.asm.Opcodes.IFNULL;\n-import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n-import static org.objectweb.asm.Opcodes.NEW;\n-import static org.objectweb.asm.Opcodes.PUTFIELD;\n-import static org.objectweb.asm.Opcodes.RETURN;\n-\n-/**\n- * Generates Jvm byte code for the main method.\n- */\n-public class JvmMainMethodGen {\n-\n-    private final SymbolTable symbolTable;\n-\n-    public JvmMainMethodGen(SymbolTable symbolTable) {\n-        this.symbolTable = symbolTable;\n-    }\n-\n-    public void generateMainMethod(BIRNode.BIRFunction userMainFunc, ClassWriter cw, BIRNode.BIRPackage pkg,\n-                            String initClass, boolean serviceEPAvailable, AsyncDataCollector asyncDataCollector) {\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, \"main\", \"([Ljava/lang/String;)V\", null,\n-                                          null);\n-        mv.visitCode();\n-        Label tryCatchStart = new Label();\n-        Label tryCatchEnd = new Label();\n-        Label tryCatchHandle = new Label();\n-        mv.visitTryCatchBlock(tryCatchStart, tryCatchEnd, tryCatchHandle, JvmConstants.THROWABLE);\n-        mv.visitLabel(tryCatchStart);\n-\n-        // check for java compatibility\n-        generateJavaCompatibilityCheck(mv);\n-\n-        // set system properties\n-        initConfigurations(mv);\n-        // start all listeners\n-        startListeners(mv, serviceEPAvailable);\n-\n-        // register a shutdown hook to call package stop() method.\n-        registerShutdownListener(mv, initClass);\n-\n-        // add main string[] args param first\n-        BIRNode.BIRVariableDcl argsVar = new BIRNode.BIRVariableDcl(symbolTable.anyType, new Name(\"argsdummy\"),\n-                                                                    VarScope.FUNCTION,\n-                                                                    VarKind.ARG);\n-        BIRVarToJVMIndexMap indexMap = new BIRVarToJVMIndexMap();\n-        indexMap.addToMapIfNotFoundAndGetIndex(argsVar);\n-\n-        int schedulerVarIndex = getSchedulerVarIndex(mv, indexMap);\n-\n-        if (JvmMethodGenUtils.hasInitFunction(pkg)) {\n-            generateMethodCall(initClass, asyncDataCollector, mv, indexMap, schedulerVarIndex, JvmConstants.MODULE_INIT,\n-                               JvmMethodGenUtils.INIT_FUNCTION_SUFFIX, \"initdummy\");\n-        }\n-\n-        if (userMainFunc != null) {\n-            generateUserMainFunctionCall(userMainFunc, initClass, asyncDataCollector, mv, indexMap, schedulerVarIndex);\n-        }\n-\n-        if (JvmMethodGenUtils.hasInitFunction(pkg)) {\n-            scheduleStartMethod(mv, initClass, serviceEPAvailable, indexMap, schedulerVarIndex,\n-                                asyncDataCollector);\n-        }\n-\n-        // stop all listeners\n-        stopListeners(mv, serviceEPAvailable);\n-        if (!serviceEPAvailable) {\n-            mv.visitMethodInsn(INVOKESTATIC, JvmConstants.JAVA_RUNTIME, \"getRuntime\",\n-                               String.format(\"()L%s;\", JvmConstants.JAVA_RUNTIME), false);\n-            mv.visitInsn(ICONST_0);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, JvmConstants.JAVA_RUNTIME, \"exit\", \"(I)V\", false);\n-        }\n-\n-        mv.visitLabel(tryCatchEnd);\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(tryCatchHandle);\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.RUNTIME_UTILS, JvmConstants.HANDLE_THROWABLE_METHOD,\n-                           String.format(\"(L%s;)V\", JvmConstants.THROWABLE), false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    private void generateJavaCompatibilityCheck(MethodVisitor mv) {\n-        mv.visitLdcInsn(getJavaVersion());\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.COMPATIBILITY_CHECKER, \"verifyJavaCompatibility\",\n-                           String.format(\"(L%s;)V\", JvmConstants.STRING_VALUE), false);\n-    }\n-\n-    private String getJavaVersion() {\n-        String versionProperty = \"java.version\";\n-        String javaVersion = System.getProperty(versionProperty);\n-        return Objects.requireNonNullElse(javaVersion, \"\");\n-    }\n-\n-    private void initConfigurations(MethodVisitor mv) {\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.LAUNCH_UTILS,\n-                           \"initConfigurations\",\n-                           String.format(\"([L%s;)[L%s;\", JvmConstants.STRING_VALUE, JvmConstants.STRING_VALUE), false);\n-        mv.visitVarInsn(ASTORE, 0);\n-    }\n-\n-    private void startListeners(MethodVisitor mv, boolean isServiceEPAvailable) {\n-        mv.visitLdcInsn(isServiceEPAvailable);\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.LAUNCH_UTILS, \"startListeners\", \"(Z)V\", false);\n-    }\n-\n-    private void registerShutdownListener(MethodVisitor mv, String initClass) {\n-        String shutdownClassName = initClass + \"$SignalListener\";\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.JAVA_RUNTIME, \"getRuntime\",\n-                           String.format(\"()L%s;\", JvmConstants.JAVA_RUNTIME), false);\n-        mv.visitTypeInsn(NEW, shutdownClassName);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL, shutdownClassName, JvmConstants.JVM_INIT_METHOD, \"()V\", false);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JvmConstants.JAVA_RUNTIME, \"addShutdownHook\",\n-                           String.format(\"(L%s;)V\", JvmConstants.JAVA_THREAD),\n-                           false);\n-    }\n-\n-    private int getSchedulerVarIndex(MethodVisitor mv, BIRVarToJVMIndexMap indexMap) {\n-        mv.visitTypeInsn(NEW, JvmConstants.SCHEDULER);\n-        mv.visitInsn(DUP);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitMethodInsn(INVOKESPECIAL, JvmConstants.SCHEDULER, JvmConstants.JVM_INIT_METHOD, \"(Z)V\", false);\n-        BIRNode.BIRVariableDcl schedulerVar = new BIRNode.BIRVariableDcl(\n-                symbolTable.anyType, new Name(\"schedulerdummy\"), VarScope.FUNCTION, VarKind.ARG);\n-        int schedulerVarIndex = indexMap.addToMapIfNotFoundAndGetIndex(schedulerVar);\n-        mv.visitVarInsn(ASTORE, schedulerVarIndex);\n-        return schedulerVarIndex;\n-    }\n-\n-    private void scheduleStartMethod(MethodVisitor mv, String initClass, boolean serviceEPAvailable,\n-                                     BIRVarToJVMIndexMap indexMap, int schedulerVarIndex,\n-                                     AsyncDataCollector asyncDataCollector) {\n-        generateMethodCall(initClass, asyncDataCollector, mv, indexMap, schedulerVarIndex, JvmConstants.MODULE_START,\n-                           \"start\",\n-                           \"startdummy\");\n-        // need to set immortal=true and start the scheduler again\n-        if (serviceEPAvailable) {\n-            mv.visitVarInsn(ALOAD, schedulerVarIndex);\n-            mv.visitInsn(DUP);\n-            mv.visitInsn(ICONST_1);\n-            mv.visitFieldInsn(PUTFIELD, JvmConstants.SCHEDULER, \"immortal\", \"Z\");\n-\n-            mv.visitMethodInsn(INVOKEVIRTUAL, JvmConstants.SCHEDULER, JvmConstants.SCHEDULER_START_METHOD, \"()V\",\n-                               false);\n-        }\n-    }\n-\n-    private void generateMethodCall(String initClass, AsyncDataCollector asyncDataCollector, MethodVisitor mv,\n-                                    BIRVarToJVMIndexMap indexMap, int schedulerVarIndex, String moduleInit,\n-                                    String funcName, String dummy) {\n-        JvmMethodGenUtils.genArgs(mv, schedulerVarIndex);\n-        genSubmitToScheduler(initClass, asyncDataCollector, mv, String.format(\"$lambda$%s$\", moduleInit),\n-                             funcName);\n-        genReturn(mv, indexMap, dummy);\n-    }\n-\n-    private void generateUserMainFunctionCall(BIRNode.BIRFunction userMainFunc, String initClass,\n-                                              AsyncDataCollector asyncDataCollector, MethodVisitor mv,\n-                                              BIRVarToJVMIndexMap indexMap, int schedulerVarIndex) {\n-        mv.visitVarInsn(ALOAD, schedulerVarIndex);\n-        loadCLIArgsForMain(mv, new ArrayList<>(userMainFunc.parameters.keySet()), userMainFunc.restParam != null,\n-                           userMainFunc.annotAttachments);\n-\n-        // invoke the user's main method\n-        genSubmitToScheduler(initClass, asyncDataCollector, mv, \"$lambda$main$\", \"main\");\n-\n-        // At this point we are done executing all the functions including asyncs\n-        boolean isVoidFunction = userMainFunc.type.retType.tag == TypeTags.NIL;\n-        if (!isVoidFunction) {\n-            genReturn(mv, indexMap, \"dummy\");\n-        }\n-    }\n-\n-    private void loadCLIArgsForMain(MethodVisitor mv, List<BIRNode.BIRFunctionParameter> params,\n-                                    boolean hasRestParam,\n-                                    List<BIRNode.BIRAnnotationAttachment> annotAttachments) {\n-        // get defaultable arg names from function annotation\n-        List<String> defaultableNames = getDefaultableNames(annotAttachments);\n-        // create function info array\n-        createFunctionInfoArray(mv, params, defaultableNames);\n-        // load string[] that got parsed into to java main\n-        loadStrings(mv, hasRestParam);\n-        // invoke ArgumentParser.extractEntryFuncArgs()\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.ARGUMENT_PARSER, \"extractEntryFuncArgs\",\n-                           String.format(\"([L%s$ParamInfo;[L%s;Z)[L%s;\", JvmConstants.RUNTIME_UTILS,\n-                                         JvmConstants.STRING_VALUE, JvmConstants.OBJECT), false);\n-    }\n-\n-    private void loadStrings(MethodVisitor mv, boolean hasRestParam) {\n-        mv.visitVarInsn(ALOAD, 0);\n-        if (hasRestParam) {\n-            mv.visitInsn(ICONST_1);\n-        } else {\n-            mv.visitInsn(ICONST_0);\n-        }\n-    }\n-\n-    private void createFunctionInfoArray(MethodVisitor mv, List<BIRNode.BIRFunctionParameter> params,\n-                                         List<String> defaultableNames) {\n-        mv.visitIntInsn(BIPUSH, params.size());\n-        mv.visitTypeInsn(ANEWARRAY, String.format(\"%s$ParamInfo\", JvmConstants.RUNTIME_UTILS));\n-        int index = 0;\n-        int defaultableIndex = 0;\n-        for (BIRNode.BIRFunctionParameter param : params) {\n-            mv.visitInsn(DUP);\n-            mv.visitIntInsn(BIPUSH, index);\n-            index += 1;\n-            mv.visitTypeInsn(NEW, String.format(\"%s$ParamInfo\", JvmConstants.RUNTIME_UTILS));\n-            mv.visitInsn(DUP);\n-            if (param != null) {\n-                if (param.hasDefaultExpr) {\n-                    mv.visitInsn(ICONST_1);\n-                } else {\n-                    mv.visitInsn(ICONST_0);\n-                }\n-                mv.visitLdcInsn(defaultableNames.get(defaultableIndex));\n-                defaultableIndex += 1;\n-                JvmTypeGen.loadType(mv, param.type);\n-            }\n-            mv.visitMethodInsn(INVOKESPECIAL, String.format(\"%s$ParamInfo\", JvmConstants.RUNTIME_UTILS),\n-                               JvmConstants.JVM_INIT_METHOD,\n-                               String.format(\"(ZL%s;L%s;)V\", JvmConstants.STRING_VALUE, JvmConstants.TYPE), false);\n-            mv.visitInsn(AASTORE);\n-        }\n-    }\n-\n-    private List<String> getDefaultableNames(List<BIRNode.BIRAnnotationAttachment> annotAttachments) {\n-        List<String> defaultableNames = new ArrayList<>();\n-        int defaultableIndex = 0;\n-        for (BIRNode.BIRAnnotationAttachment attachment : annotAttachments) {\n-            if (attachment != null && attachment.annotTagRef.value.equals(JvmConstants.DEFAULTABLE_ARGS_ANOT_NAME)) {\n-                BIRNode.BIRAnnotationRecordValue\n-                        annotRecValue = (BIRNode.BIRAnnotationRecordValue) attachment.annotValues.get(0);\n-                Map<String, BIRNode.BIRAnnotationValue> annotFieldMap = annotRecValue.annotValueEntryMap;\n-                BIRNode.BIRAnnotationArrayValue annotArrayValue =\n-                        (BIRNode.BIRAnnotationArrayValue) annotFieldMap.get(JvmConstants.DEFAULTABLE_ARGS_ANOT_FIELD);\n-                for (BIRNode.BIRAnnotationValue entryOptional : annotArrayValue.annotArrayValue) {\n-                    BIRNode.BIRAnnotationLiteralValue argValue = (BIRNode.BIRAnnotationLiteralValue) entryOptional;\n-                    defaultableNames.add(defaultableIndex, (String) argValue.value);\n-                    defaultableIndex += 1;\n-                }\n-                break;\n-            }\n-        }\n-        return defaultableNames;\n-    }\n-\n-    private void genReturn(MethodVisitor mv, BIRVarToJVMIndexMap indexMap, String dummy) {\n-        // store future value\n-        BIRNode.BIRVariableDcl futureVar = new BIRNode.BIRVariableDcl(symbolTable.anyType, new Name(dummy),\n-                                                                      VarScope.FUNCTION, VarKind.ARG);\n-        int futureVarIndex = indexMap.addToMapIfNotFoundAndGetIndex(futureVar);\n-        mv.visitVarInsn(ASTORE, futureVarIndex);\n-        mv.visitVarInsn(ALOAD, futureVarIndex);\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.FUTURE_VALUE, \"result\", String.format(\"L%s;\", JvmConstants.OBJECT));\n-\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.RUNTIME_UTILS, JvmConstants.HANDLE_RETURNED_ERROR_METHOD,\n-                           String.format(\"(L%s;)V\", JvmConstants.OBJECT), false);\n-    }\n-\n-    private void genSubmitToScheduler(String initClass, AsyncDataCollector asyncDataCollector, MethodVisitor mv,\n-                                      String lambdaName, String funcName) {\n-        JvmCodeGenUtil.createFunctionPointer(mv, initClass, lambdaName);\n-\n-        // no parent strand\n-        mv.visitInsn(ACONST_NULL);\n-\n-        //submit to the scheduler\n-        BType anyType = symbolTable.anyType;\n-        JvmTypeGen.loadType(mv, anyType);\n-        JvmMethodGenUtils.submitToScheduler(mv, initClass, funcName, asyncDataCollector);\n-        mv.visitInsn(DUP);\n-\n-        mv.visitInsn(DUP);\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.FUTURE_VALUE, JvmConstants.STRAND,\n-                          String.format(\"L%s;\", JvmConstants.STRAND_CLASS));\n-        mv.visitIntInsn(BIPUSH, 100);\n-        mv.visitTypeInsn(ANEWARRAY, JvmConstants.OBJECT);\n-        mv.visitFieldInsn(PUTFIELD, JvmConstants.STRAND_CLASS, JvmMethodGenUtils.FRAMES,\n-                          String.format(\"[L%s;\", JvmConstants.OBJECT));\n-        handleErrorFromFutureValue(mv);\n-    }\n-\n-    private void stopListeners(MethodVisitor mv, boolean isServiceEPAvailable) {\n-        mv.visitLdcInsn(isServiceEPAvailable);\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.LAUNCH_UTILS, \"stopListeners\", \"(Z)V\", false);\n-    }\n-\n-    private void handleErrorFromFutureValue(MethodVisitor mv) {\n-        mv.visitInsn(DUP);\n-        mv.visitInsn(DUP);\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.FUTURE_VALUE, JvmConstants.STRAND,\n-                          String.format(\"L%s;\", JvmConstants.STRAND_CLASS));\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.STRAND_CLASS, \"scheduler\",\n-                          String.format(\"L%s;\", JvmConstants.SCHEDULER));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JvmConstants.SCHEDULER, JvmConstants.SCHEDULER_START_METHOD, \"()V\", false);\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.FUTURE_VALUE, JvmConstants.PANIC_FIELD,\n-                          String.format(\"L%s;\", JvmConstants.THROWABLE));\n-\n-        // handle any runtime errors\n-        Label labelIf = new Label();\n-        mv.visitJumpInsn(IFNULL, labelIf);\n-        mv.visitFieldInsn(GETFIELD, JvmConstants.FUTURE_VALUE, JvmConstants.PANIC_FIELD,\n-                          String.format(\"L%s;\", JvmConstants.THROWABLE));\n-        mv.visitMethodInsn(INVOKESTATIC, JvmConstants.RUNTIME_UTILS, JvmConstants.HANDLE_THROWABLE_METHOD,\n-                           String.format(\"(L%s;)V\", JvmConstants.THROWABLE), false);\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(labelIf);\n-    }\n-\n-    /**\n-     * Generate a lambda function to invoke ballerina main.\n-     *\n-     * @param userMainFunc ballerina main function\n-     * @param cw           class visitor\n-     * @param mainClass    main class that contains the user main\n-     */\n-    public void generateLambdaForMain(BIRNode.BIRFunction userMainFunc, ClassWriter cw, String mainClass) {\n-\n-        BType returnType = userMainFunc.type.retType;\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, \"$lambda$main$\",\n-                                          String.format(\"([L%s;)L%s;\", JvmConstants.OBJECT, JvmConstants.OBJECT), null,\n-                                          null);\n-        mv.visitCode();\n-\n-        //load strand as first arg\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, JvmConstants.STRAND_CLASS);\n-\n-        // load and cast param values\n-        List<BType> paramTypes = userMainFunc.type.paramTypes;\n-\n-        int paramIndex = 1;\n-        for (BType pType : paramTypes) {\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitIntInsn(BIPUSH, paramIndex);\n-            mv.visitInsn(AALOAD);\n-            JvmCastGen.addUnboxInsn(mv, pType);\n-            paramIndex += 1;\n-        }\n-\n-        mv.visitMethodInsn(INVOKESTATIC, mainClass, userMainFunc.name.value,\n-                           JvmCodeGenUtil.getMethodDesc(paramTypes, returnType), false);\n-        JvmCastGen.addBoxInsn(mv, returnType);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4NzQ3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26637#discussion_r513287470", "bodyText": "\"generateDepModInit\" name is bit confusing. AFAIU this generating default methods like start, init", "author": "warunalakshitha", "createdAt": "2020-10-28T09:17:11Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n+\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.JavaClass;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CREATE_TYPES_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n+\n+/**\n+ * Generates Jvm byte code for the init methods.\n+ */\n+public class JvmInitsGen {\n+\n+    private final SymbolTable symbolTable;\n+    private final BUnionType errorOrNilType;\n+    private int nextId = -1;\n+    private int nextVarId = -1;\n+\n+    public JvmInitsGen(SymbolTable symbolTable) {\n+        this.symbolTable = symbolTable;\n+        this.errorOrNilType = BUnionType.create(null, symbolTable.errorType, symbolTable.nilType);\n+    }\n+\n+    /**\n+     * Generate a lambda function to invoke ballerina main.\n+     *\n+     * @param cw        class visitor\n+     * @param pkg       bir package\n+     * @param initClass module init class\n+     * @param depMods   dependent module list\n+     */\n+    public void generateLambdaForPackageInits(ClassWriter cw, BIRNode.BIRPackage pkg, String initClass,\n+                                              List<PackageID> depMods) {\n+        //need to generate lambda for package Init as well, if exist\n+        if (!JvmMethodGenUtils.hasInitFunction(pkg)) {\n+            return;\n+        }\n+        generateLambdaForModuleFunction(cw, MODULE_INIT, initClass);\n+\n+        // generate another lambda for start function as well\n+        generateLambdaForModuleFunction(cw, MODULE_START, initClass);\n+\n+        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(pkg);\n+        String fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId,\n+                                                                               JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n+\n+        generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), initClass);\n+\n+        for (PackageID id : depMods) {\n+            fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n+            String jvmClass = JvmCodeGenUtil.getPackageName(id) + MODULE_INIT_CLASS_NAME;\n+            generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), jvmClass);\n+        }\n+    }\n+\n+    private void generateLambdaForModuleFunction(ClassWriter cw, String funcName, String initClass) {\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n+                                          String.format(\"$lambda$%s$\", funcName),\n+                                          String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n+        mv.visitCode();\n+\n+        //load strand as first arg\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n+\n+        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n+        JvmCastGen.addBoxInsn(mv, errorOrNilType);\n+        JvmMethodGenUtils.visitReturn(mv);\n+    }\n+\n+    private void generateLambdaForDepModStopFunc(ClassWriter cw, String funcName, String initClass) {\n+        MethodVisitor mv;\n+        mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n+                            String.format(\"$lambda$%s\", funcName),\n+                            String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n+        mv.visitCode();\n+\n+        //load strand as first arg\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n+\n+        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n+        JvmMethodGenUtils.visitReturn(mv);\n+    }\n+\n+    public void generateModuleInitializer(ClassWriter cw, BIRNode.BIRPackage module, String typeOwnerClass) {\n+        // Using object return type since this is similar to a ballerina function without a return.\n+        // A ballerina function with no returns is equivalent to a function with nil-return.\n+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, CURRENT_MODULE_INIT,\n+                                          String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), null, null);\n+        mv.visitCode();\n+\n+        mv.visitMethodInsn(INVOKESTATIC, typeOwnerClass, CREATE_TYPES_METHOD, \"()V\", false);\n+        mv.visitTypeInsn(NEW, typeOwnerClass);\n+        mv.visitInsn(DUP);\n+        mv.visitMethodInsn(INVOKESPECIAL, typeOwnerClass, JVM_INIT_METHOD, \"()V\", false);\n+        mv.visitVarInsn(ASTORE, 1);\n+        mv.visitLdcInsn(module.org.value);\n+        mv.visitLdcInsn(module.name.value);\n+        mv.visitLdcInsn(module.version.value);\n+        mv.visitVarInsn(ALOAD, 1);\n+        mv.visitMethodInsn(INVOKESTATIC, String.format(\"%s\", VALUE_CREATOR), \"addValueCreator\",\n+                           String.format(\"(L%s;L%s;L%s;L%s;)V\", STRING_VALUE, STRING_VALUE, STRING_VALUE,\n+                                         VALUE_CREATOR),\n+                           false);\n+\n+        // Add a nil-return\n+        mv.visitInsn(ACONST_NULL);\n+        JvmMethodGenUtils.visitReturn(mv);\n+    }\n+\n+    public void addInitAndTypeInitInstructions(BIRNode.BIRPackage pkg, BIRNode.BIRFunction func) {\n+        List<BIRNode.BIRBasicBlock> basicBlocks = new ArrayList<>();\n+        nextId = -1;\n+        BIRNode.BIRBasicBlock nextBB = new BIRNode.BIRBasicBlock(getNextBBId());\n+        basicBlocks.add(nextBB);\n+\n+        PackageID modID = JvmMethodGenUtils.packageToModuleId(pkg);\n+\n+        BIRNode.BIRBasicBlock typeOwnerCreateBB = new BIRNode.BIRBasicBlock(getNextBBId());\n+        basicBlocks.add(typeOwnerCreateBB);\n+\n+        nextBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modID,\n+                                                   new Name(CURRENT_MODULE_INIT),\n+                                                   new ArrayList<>(), null, typeOwnerCreateBB, Collections.emptyList(),\n+                                                   Collections.emptySet());\n+\n+        if (func.basicBlocks.size() == 0) {\n+            typeOwnerCreateBB.terminator = new BIRTerminator.Return(func.pos);\n+            func.basicBlocks = basicBlocks;\n+            return;\n+        }\n+\n+        typeOwnerCreateBB.terminator = new BIRTerminator.GOTO(null, func.basicBlocks.get(0));\n+\n+        basicBlocks.addAll(func.basicBlocks);\n+        func.basicBlocks = basicBlocks;\n+    }\n+\n+    public void enrichPkgWithInitializers(Map<String, JavaClass> jvmClassMap, String typeOwnerClass,\n+                                          BIRNode.BIRPackage pkg, List<PackageID> moduleImports) {\n+        JavaClass javaClass = jvmClassMap.get(typeOwnerClass);\n+        BIRNode.BIRFunction initFunc = generateDepModInit(moduleImports, pkg, MODULE_INIT,", "originalCommit": "ce9be107577c37b0f2f8999aef0bc6ea3360aaf4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java\ndeleted file mode 100644\nindex 5eb46ff90eb..00000000000\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java\n+++ /dev/null\n\n@@ -1,318 +0,0 @@\n-/*\n- *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- *  WSO2 Inc. licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except\n- *  in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- */\n-\n-package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n-\n-import org.ballerinalang.model.elements.PackageID;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.JavaClass;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n-import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n-import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n-import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n-import org.wso2.ballerinalang.compiler.util.Name;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n-import static org.objectweb.asm.Opcodes.AALOAD;\n-import static org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static org.objectweb.asm.Opcodes.ACONST_NULL;\n-import static org.objectweb.asm.Opcodes.ALOAD;\n-import static org.objectweb.asm.Opcodes.ASTORE;\n-import static org.objectweb.asm.Opcodes.CHECKCAST;\n-import static org.objectweb.asm.Opcodes.DUP;\n-import static org.objectweb.asm.Opcodes.ICONST_0;\n-import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static org.objectweb.asm.Opcodes.NEW;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CREATE_TYPES_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n-\n-/**\n- * Generates Jvm byte code for the init methods.\n- */\n-public class JvmInitsGen {\n-\n-    private final SymbolTable symbolTable;\n-    private final BUnionType errorOrNilType;\n-    private int nextId = -1;\n-    private int nextVarId = -1;\n-\n-    public JvmInitsGen(SymbolTable symbolTable) {\n-        this.symbolTable = symbolTable;\n-        this.errorOrNilType = BUnionType.create(null, symbolTable.errorType, symbolTable.nilType);\n-    }\n-\n-    /**\n-     * Generate a lambda function to invoke ballerina main.\n-     *\n-     * @param cw        class visitor\n-     * @param pkg       bir package\n-     * @param initClass module init class\n-     * @param depMods   dependent module list\n-     */\n-    public void generateLambdaForPackageInits(ClassWriter cw, BIRNode.BIRPackage pkg, String initClass,\n-                                              List<PackageID> depMods) {\n-        //need to generate lambda for package Init as well, if exist\n-        if (!JvmMethodGenUtils.hasInitFunction(pkg)) {\n-            return;\n-        }\n-        generateLambdaForModuleFunction(cw, MODULE_INIT, initClass);\n-\n-        // generate another lambda for start function as well\n-        generateLambdaForModuleFunction(cw, MODULE_START, initClass);\n-\n-        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(pkg);\n-        String fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId,\n-                                                                               JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-\n-        generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), initClass);\n-\n-        for (PackageID id : depMods) {\n-            fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-            String jvmClass = JvmCodeGenUtil.getPackageName(id) + MODULE_INIT_CLASS_NAME;\n-            generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), jvmClass);\n-        }\n-    }\n-\n-    private void generateLambdaForModuleFunction(ClassWriter cw, String funcName, String initClass) {\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n-                                          String.format(\"$lambda$%s$\", funcName),\n-                                          String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        //load strand as first arg\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n-\n-        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n-        JvmCastGen.addBoxInsn(mv, errorOrNilType);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    private void generateLambdaForDepModStopFunc(ClassWriter cw, String funcName, String initClass) {\n-        MethodVisitor mv;\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n-                            String.format(\"$lambda$%s\", funcName),\n-                            String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        //load strand as first arg\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n-\n-        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    public void generateModuleInitializer(ClassWriter cw, BIRNode.BIRPackage module, String typeOwnerClass) {\n-        // Using object return type since this is similar to a ballerina function without a return.\n-        // A ballerina function with no returns is equivalent to a function with nil-return.\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, CURRENT_MODULE_INIT,\n-                                          String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        mv.visitMethodInsn(INVOKESTATIC, typeOwnerClass, CREATE_TYPES_METHOD, \"()V\", false);\n-        mv.visitTypeInsn(NEW, typeOwnerClass);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL, typeOwnerClass, JVM_INIT_METHOD, \"()V\", false);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitLdcInsn(module.org.value);\n-        mv.visitLdcInsn(module.name.value);\n-        mv.visitLdcInsn(module.version.value);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKESTATIC, String.format(\"%s\", VALUE_CREATOR), \"addValueCreator\",\n-                           String.format(\"(L%s;L%s;L%s;L%s;)V\", STRING_VALUE, STRING_VALUE, STRING_VALUE,\n-                                         VALUE_CREATOR),\n-                           false);\n-\n-        // Add a nil-return\n-        mv.visitInsn(ACONST_NULL);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    public void addInitAndTypeInitInstructions(BIRNode.BIRPackage pkg, BIRNode.BIRFunction func) {\n-        List<BIRNode.BIRBasicBlock> basicBlocks = new ArrayList<>();\n-        nextId = -1;\n-        BIRNode.BIRBasicBlock nextBB = new BIRNode.BIRBasicBlock(getNextBBId());\n-        basicBlocks.add(nextBB);\n-\n-        PackageID modID = JvmMethodGenUtils.packageToModuleId(pkg);\n-\n-        BIRNode.BIRBasicBlock typeOwnerCreateBB = new BIRNode.BIRBasicBlock(getNextBBId());\n-        basicBlocks.add(typeOwnerCreateBB);\n-\n-        nextBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modID,\n-                                                   new Name(CURRENT_MODULE_INIT),\n-                                                   new ArrayList<>(), null, typeOwnerCreateBB, Collections.emptyList(),\n-                                                   Collections.emptySet());\n-\n-        if (func.basicBlocks.size() == 0) {\n-            typeOwnerCreateBB.terminator = new BIRTerminator.Return(func.pos);\n-            func.basicBlocks = basicBlocks;\n-            return;\n-        }\n-\n-        typeOwnerCreateBB.terminator = new BIRTerminator.GOTO(null, func.basicBlocks.get(0));\n-\n-        basicBlocks.addAll(func.basicBlocks);\n-        func.basicBlocks = basicBlocks;\n-    }\n-\n-    public void enrichPkgWithInitializers(Map<String, JavaClass> jvmClassMap, String typeOwnerClass,\n-                                          BIRNode.BIRPackage pkg, List<PackageID> moduleImports) {\n-        JavaClass javaClass = jvmClassMap.get(typeOwnerClass);\n-        BIRNode.BIRFunction initFunc = generateDepModInit(moduleImports, pkg, MODULE_INIT,\n-                                                          JvmMethodGenUtils.INIT_FUNCTION_SUFFIX);\n-        javaClass.functions.add(initFunc);\n-        pkg.functions.add(initFunc);\n-\n-        BIRNode.BIRFunction startFunc = generateDepModInit(moduleImports, pkg, MODULE_START,\n-                                                           JvmMethodGenUtils.START_FUNCTION_SUFFIX);\n-        javaClass.functions.add(startFunc);\n-        pkg.functions.add(startFunc);\n-\n-    }\n-\n-    private BIRNode.BIRFunction generateDepModInit(List<PackageID> imprtMods, BIRNode.BIRPackage pkg, String funcName,\n-                                                   String initName) {\n-        nextId = -1;\n-        nextVarId = -1;\n-\n-        BIRNode.BIRVariableDcl retVar = new BIRNode.BIRVariableDcl(null, errorOrNilType, new Name(\"%ret\"),\n-                                                                   VarScope.FUNCTION, VarKind.RETURN, \"\");\n-        BIROperand retVarRef = new BIROperand(retVar);\n-\n-        BInvokableType funcType = new BInvokableType(Collections.emptyList(), null, errorOrNilType, null);\n-        BIRNode.BIRFunction modInitFunc = new BIRNode.BIRFunction(null, new Name(funcName), 0, funcType, null, 0, null,\n-                                                                  VIRTUAL);\n-        modInitFunc.localVars.add(retVar);\n-        addAndGetNextBasicBlock(modInitFunc);\n-\n-        BIRNode.BIRVariableDcl boolVal = addAndGetNextVar(modInitFunc, symbolTable.booleanType);\n-        BIROperand boolRef = new BIROperand(boolVal);\n-\n-        for (PackageID id : imprtMods) {\n-            String initFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, initName);\n-            addCheckedInvocation(modInitFunc, id, initFuncName, retVarRef, boolRef);\n-        }\n-\n-        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(pkg);\n-        String currentInitFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId, initName);\n-        BIRNode.BIRBasicBlock lastBB = addCheckedInvocation(modInitFunc, currentModId, currentInitFuncName, retVarRef,\n-                                                            boolRef);\n-\n-        lastBB.terminator = new BIRTerminator.Return(null);\n-\n-        return modInitFunc;\n-    }\n-\n-    private BIRNode.BIRVariableDcl addAndGetNextVar(BIRNode.BIRFunction func, BType typeVal) {\n-        BIRNode.BIRVariableDcl nextLocalVar = new BIRNode.BIRVariableDcl(typeVal, getNextVarId(), VarScope.FUNCTION,\n-                                                                         VarKind.LOCAL);\n-        func.localVars.add(nextLocalVar);\n-        return nextLocalVar;\n-    }\n-\n-    private Name getNextVarId() {\n-        String varIdPrefix = \"%\";\n-        nextVarId += 1;\n-        return new Name(varIdPrefix + nextVarId);\n-    }\n-\n-    private BIRNode.BIRBasicBlock addCheckedInvocation(BIRNode.BIRFunction func, PackageID modId, String initFuncName,\n-                                                       BIROperand retVar, BIROperand boolRef) {\n-        BIRNode.BIRBasicBlock lastBB = func.basicBlocks.get(func.basicBlocks.size() - 1);\n-        BIRNode.BIRBasicBlock nextBB = addAndGetNextBasicBlock(func);\n-        // TODO remove once lang.annotation is fixed\n-        if (modId.orgName.value.equals(BALLERINA) && modId.name.value.equals(BUILT_IN_PACKAGE_NAME)) {\n-            lastBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modId,\n-                                                       new Name(initFuncName), Collections.emptyList(), null, nextBB,\n-                                                       Collections.emptyList(),\n-                                                       Collections.emptySet());\n-            return nextBB;\n-        }\n-        lastBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modId, new Name(initFuncName),\n-                                                   Collections.emptyList(), retVar, nextBB, Collections.emptyList(),\n-                                                   Collections.emptySet());\n-\n-        BIRNonTerminator.TypeTest typeTest = new BIRNonTerminator.TypeTest(null, symbolTable.errorType, boolRef,\n-                                                                           retVar);\n-        nextBB.instructions.add(typeTest);\n-\n-        BIRNode.BIRBasicBlock trueBB = addAndGetNextBasicBlock(func);\n-        BIRNode.BIRBasicBlock retBB = addAndGetNextBasicBlock(func);\n-        retBB.terminator = new BIRTerminator.Return(null);\n-        trueBB.terminator = new BIRTerminator.GOTO(null, retBB);\n-\n-        BIRNode.BIRBasicBlock falseBB = addAndGetNextBasicBlock(func);\n-        nextBB.terminator = new BIRTerminator.Branch(null, boolRef, trueBB, falseBB);\n-        return falseBB;\n-    }\n-\n-    private BIRNode.BIRBasicBlock addAndGetNextBasicBlock(BIRNode.BIRFunction func) {\n-        BIRNode.BIRBasicBlock nextbb = new BIRNode.BIRBasicBlock(getNextBBId());\n-        func.basicBlocks.add(nextbb);\n-        return nextbb;\n-    }\n-\n-    private Name getNextBBId() {\n-        String bbIdPrefix = \"genBB\";\n-        nextId += 1;\n-        return new Name(bbIdPrefix + nextId);\n-    }\n-\n-    public void resetIds() {\n-        nextId = -1;\n-        nextVarId = -1;\n-    }\n-\n-    public int incrementAndGetNextId() {\n-        return nextId++;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI5MzU1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26637#discussion_r513293554", "bodyText": "AFAIK this will gen modulestop method. \"JvmStopMethodGen\" sounds like method to stop the jvm. Shall we remove the JVM prefix( even from other class).  WDYT?", "author": "warunalakshitha", "createdAt": "2020-10-28T09:26:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmStopMethodGen.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n+\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.AsyncDataCollector;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.BIRVarToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BNilType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.List;\n+\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ANEWARRAY;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_STOP_PANIC_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STARTED;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START_ATTEMPTED;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STOP;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.PANIC_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.RUNTIME_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER_START_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.THROWABLE;\n+\n+/**\n+ * Generates Jvm byte code for the stop method.\n+ */\n+public class JvmStopMethodGen {", "originalCommit": "ce9be107577c37b0f2f8999aef0bc6ea3360aaf4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmStopMethodGen.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmStopMethodGen.java\ndeleted file mode 100644\nindex b68cac557e2..00000000000\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmStopMethodGen.java\n+++ /dev/null\n\n@@ -1,180 +0,0 @@\n-/*\n- *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- *  WSO2 Inc. licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except\n- *  in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- */\n-\n-package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n-\n-import org.ballerinalang.model.elements.PackageID;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Label;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.AsyncDataCollector;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.BIRVarToJVMIndexMap;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n-import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n-import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BNilType;\n-import org.wso2.ballerinalang.compiler.util.Name;\n-\n-import java.util.List;\n-\n-import static org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static org.objectweb.asm.Opcodes.ACONST_NULL;\n-import static org.objectweb.asm.Opcodes.ALOAD;\n-import static org.objectweb.asm.Opcodes.ANEWARRAY;\n-import static org.objectweb.asm.Opcodes.ASTORE;\n-import static org.objectweb.asm.Opcodes.BIPUSH;\n-import static org.objectweb.asm.Opcodes.DUP;\n-import static org.objectweb.asm.Opcodes.GETFIELD;\n-import static org.objectweb.asm.Opcodes.GETSTATIC;\n-import static org.objectweb.asm.Opcodes.ICONST_0;\n-import static org.objectweb.asm.Opcodes.ICONST_1;\n-import static org.objectweb.asm.Opcodes.IFEQ;\n-import static org.objectweb.asm.Opcodes.IFNULL;\n-import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n-import static org.objectweb.asm.Opcodes.NEW;\n-import static org.objectweb.asm.Opcodes.PUTFIELD;\n-import static org.objectweb.asm.Opcodes.RETURN;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_STOP_PANIC_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STARTED;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START_ATTEMPTED;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STOP;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.PANIC_FIELD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.RUNTIME_UTILS;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER_START_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.THROWABLE;\n-\n-/**\n- * Generates Jvm byte code for the stop method.\n- */\n-public class JvmStopMethodGen {\n-    private final SymbolTable symbolTable;\n-\n-    public JvmStopMethodGen(SymbolTable symbolTable) {\n-        this.symbolTable = symbolTable;\n-    }\n-\n-    public void generateExecutionStopMethod(ClassWriter cw, String initClass, BIRNode.BIRPackage module,\n-                                     List<PackageID> imprtMods, AsyncDataCollector asyncDataCollector) {\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, MODULE_STOP, \"()V\", null, null);\n-        mv.visitCode();\n-\n-        BIRVarToJVMIndexMap indexMap = new BIRVarToJVMIndexMap();\n-\n-        BIRNode.BIRVariableDcl argsVar = new BIRNode.BIRVariableDcl(symbolTable.anyType, new Name(\"schedulerVar\"),\n-                                                                    VarScope.FUNCTION, VarKind.ARG);\n-        int schedulerIndex = indexMap.addToMapIfNotFoundAndGetIndex(argsVar);\n-        BIRNode.BIRVariableDcl futureVar = new BIRNode.BIRVariableDcl(symbolTable.anyType, new Name(\"futureVar\"),\n-                                                                      VarScope.FUNCTION, VarKind.ARG);\n-        int futureIndex = indexMap.addToMapIfNotFoundAndGetIndex(futureVar);\n-\n-        mv.visitTypeInsn(NEW, SCHEDULER);\n-        mv.visitInsn(DUP);\n-        mv.visitInsn(ICONST_1);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitMethodInsn(INVOKESPECIAL, SCHEDULER, JVM_INIT_METHOD, \"(IZ)V\", false);\n-\n-        mv.visitVarInsn(ASTORE, schedulerIndex);\n-\n-\n-        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(module);\n-        String moduleInitClass = getModuleInitClassName(currentModId);\n-        String fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId,\n-                                                                               JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-\n-        scheduleStopMethod(mv, initClass, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), schedulerIndex,\n-                           futureIndex, moduleInitClass, asyncDataCollector);\n-        int i = imprtMods.size() - 1;\n-        while (i >= 0) {\n-            PackageID id = imprtMods.get(i);\n-            i -= 1;\n-            fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-            moduleInitClass = getModuleInitClassName(id);\n-            scheduleStopMethod(mv, initClass, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), schedulerIndex,\n-                               futureIndex, moduleInitClass, asyncDataCollector);\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-    }\n-\n-    private void scheduleStopMethod(MethodVisitor mv, String initClass, String stopFuncName,\n-                                    int schedulerIndex, int futureIndex, String moduleClass,\n-                                    AsyncDataCollector asyncDataCollector) {\n-        // Create a scheduler. A new scheduler is used here, to make the stop function to not to\n-        // depend/wait on whatever is being running on the background. eg: a busy loop in the main.\n-        mv.visitFieldInsn(GETSTATIC, moduleClass, MODULE_START_ATTEMPTED, \"Z\");\n-        Label labelIf = new Label();\n-        mv.visitJumpInsn(IFEQ, labelIf);\n-        JvmMethodGenUtils.genArgs(mv, schedulerIndex);\n-\n-        // create FP value\n-        String lambdaFuncName = \"$lambda$\" + stopFuncName;\n-        JvmCodeGenUtil.createFunctionPointer(mv, initClass, lambdaFuncName);\n-\n-        // no parent strand\n-        mv.visitInsn(ACONST_NULL);\n-        JvmTypeGen.loadType(mv, new BNilType());\n-        JvmMethodGenUtils.submitToScheduler(mv, initClass, \"stop\", asyncDataCollector);\n-        mv.visitVarInsn(ASTORE, futureIndex);\n-\n-        mv.visitVarInsn(ALOAD, futureIndex);\n-\n-        mv.visitFieldInsn(GETFIELD, FUTURE_VALUE, STRAND, String.format(\"L%s;\", STRAND_CLASS));\n-        mv.visitIntInsn(BIPUSH, 100);\n-        mv.visitTypeInsn(ANEWARRAY, OBJECT);\n-        mv.visitFieldInsn(PUTFIELD, STRAND_CLASS, JvmMethodGenUtils.FRAMES, String.format(\"[L%s;\", OBJECT));\n-\n-        mv.visitVarInsn(ALOAD, futureIndex);\n-        mv.visitFieldInsn(GETFIELD, FUTURE_VALUE, STRAND, String.format(\"L%s;\", STRAND_CLASS));\n-        mv.visitFieldInsn(GETFIELD, STRAND_CLASS, \"scheduler\", String.format(\"L%s;\", SCHEDULER));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, SCHEDULER, SCHEDULER_START_METHOD, \"()V\", false);\n-\n-        mv.visitVarInsn(ALOAD, futureIndex);\n-        mv.visitFieldInsn(GETFIELD, FUTURE_VALUE, PANIC_FIELD, String.format(\"L%s;\", THROWABLE));\n-\n-        // handle any runtime errors\n-        mv.visitJumpInsn(IFNULL, labelIf);\n-        mv.visitFieldInsn(GETSTATIC, moduleClass, MODULE_STARTED, \"Z\");\n-        mv.visitJumpInsn(IFEQ, labelIf);\n-\n-        mv.visitVarInsn(ALOAD, futureIndex);\n-        mv.visitFieldInsn(GETFIELD, FUTURE_VALUE, PANIC_FIELD, String.format(\"L%s;\", THROWABLE));\n-        mv.visitMethodInsn(INVOKESTATIC, RUNTIME_UTILS, HANDLE_STOP_PANIC_METHOD, String.format(\"(L%s;)V\", THROWABLE),\n-                           false);\n-        mv.visitLabel(labelIf);\n-    }\n-\n-    private String getModuleInitClassName(PackageID id) {\n-        return JvmCodeGenUtil.getModuleLevelClassName(id.orgName.value, id.name.value, id.version.value,\n-                                                      MODULE_INIT_CLASS_NAME);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI5NjMzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26637#discussion_r513296337", "bodyText": "Name can be \"InitMethodGen\" to consistant with other method gen class names.", "author": "warunalakshitha", "createdAt": "2020-10-28T09:30:56Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n+\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n+import org.wso2.ballerinalang.compiler.bir.codegen.internal.JavaClass;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CREATE_TYPES_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n+\n+/**\n+ * Generates Jvm byte code for the init methods.\n+ */\n+public class JvmInitsGen {", "originalCommit": "ce9be107577c37b0f2f8999aef0bc6ea3360aaf4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java\ndeleted file mode 100644\nindex 5eb46ff90eb..00000000000\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/methodgen/JvmInitsGen.java\n+++ /dev/null\n\n@@ -1,318 +0,0 @@\n-/*\n- *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- *  WSO2 Inc. licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except\n- *  in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing,\n- *  software distributed under the License is distributed on an\n- *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- *  KIND, either express or implied.  See the License for the\n- *  specific language governing permissions and limitations\n- *  under the License.\n- */\n-\n-package org.wso2.ballerinalang.compiler.bir.codegen.methodgen;\n-\n-import org.ballerinalang.model.elements.PackageID;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.MethodVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen;\n-import org.wso2.ballerinalang.compiler.bir.codegen.JvmCodeGenUtil;\n-import org.wso2.ballerinalang.compiler.bir.codegen.internal.JavaClass;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n-import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n-import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n-import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n-import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n-import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n-import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n-import org.wso2.ballerinalang.compiler.util.Name;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n-import static org.objectweb.asm.Opcodes.AALOAD;\n-import static org.objectweb.asm.Opcodes.ACC_STATIC;\n-import static org.objectweb.asm.Opcodes.ACONST_NULL;\n-import static org.objectweb.asm.Opcodes.ALOAD;\n-import static org.objectweb.asm.Opcodes.ASTORE;\n-import static org.objectweb.asm.Opcodes.CHECKCAST;\n-import static org.objectweb.asm.Opcodes.DUP;\n-import static org.objectweb.asm.Opcodes.ICONST_0;\n-import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n-import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n-import static org.objectweb.asm.Opcodes.NEW;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CREATE_TYPES_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JVM_INIT_METHOD;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND_CLASS;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n-import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n-\n-/**\n- * Generates Jvm byte code for the init methods.\n- */\n-public class JvmInitsGen {\n-\n-    private final SymbolTable symbolTable;\n-    private final BUnionType errorOrNilType;\n-    private int nextId = -1;\n-    private int nextVarId = -1;\n-\n-    public JvmInitsGen(SymbolTable symbolTable) {\n-        this.symbolTable = symbolTable;\n-        this.errorOrNilType = BUnionType.create(null, symbolTable.errorType, symbolTable.nilType);\n-    }\n-\n-    /**\n-     * Generate a lambda function to invoke ballerina main.\n-     *\n-     * @param cw        class visitor\n-     * @param pkg       bir package\n-     * @param initClass module init class\n-     * @param depMods   dependent module list\n-     */\n-    public void generateLambdaForPackageInits(ClassWriter cw, BIRNode.BIRPackage pkg, String initClass,\n-                                              List<PackageID> depMods) {\n-        //need to generate lambda for package Init as well, if exist\n-        if (!JvmMethodGenUtils.hasInitFunction(pkg)) {\n-            return;\n-        }\n-        generateLambdaForModuleFunction(cw, MODULE_INIT, initClass);\n-\n-        // generate another lambda for start function as well\n-        generateLambdaForModuleFunction(cw, MODULE_START, initClass);\n-\n-        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(pkg);\n-        String fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId,\n-                                                                               JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-\n-        generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), initClass);\n-\n-        for (PackageID id : depMods) {\n-            fullFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, JvmMethodGenUtils.STOP_FUNCTION_SUFFIX);\n-            String jvmClass = JvmCodeGenUtil.getPackageName(id) + MODULE_INIT_CLASS_NAME;\n-            generateLambdaForDepModStopFunc(cw, JvmCodeGenUtil.cleanupFunctionName(fullFuncName), jvmClass);\n-        }\n-    }\n-\n-    private void generateLambdaForModuleFunction(ClassWriter cw, String funcName, String initClass) {\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n-                                          String.format(\"$lambda$%s$\", funcName),\n-                                          String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        //load strand as first arg\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n-\n-        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n-        JvmCastGen.addBoxInsn(mv, errorOrNilType);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    private void generateLambdaForDepModStopFunc(ClassWriter cw, String funcName, String initClass) {\n-        MethodVisitor mv;\n-        mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC,\n-                            String.format(\"$lambda$%s\", funcName),\n-                            String.format(\"([L%s;)L%s;\", OBJECT, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        //load strand as first arg\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitInsn(ICONST_0);\n-        mv.visitInsn(AALOAD);\n-        mv.visitTypeInsn(CHECKCAST, STRAND_CLASS);\n-\n-        mv.visitMethodInsn(INVOKESTATIC, initClass, funcName, String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), false);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    public void generateModuleInitializer(ClassWriter cw, BIRNode.BIRPackage module, String typeOwnerClass) {\n-        // Using object return type since this is similar to a ballerina function without a return.\n-        // A ballerina function with no returns is equivalent to a function with nil-return.\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC + ACC_STATIC, CURRENT_MODULE_INIT,\n-                                          String.format(\"(L%s;)L%s;\", STRAND_CLASS, OBJECT), null, null);\n-        mv.visitCode();\n-\n-        mv.visitMethodInsn(INVOKESTATIC, typeOwnerClass, CREATE_TYPES_METHOD, \"()V\", false);\n-        mv.visitTypeInsn(NEW, typeOwnerClass);\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL, typeOwnerClass, JVM_INIT_METHOD, \"()V\", false);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitLdcInsn(module.org.value);\n-        mv.visitLdcInsn(module.name.value);\n-        mv.visitLdcInsn(module.version.value);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKESTATIC, String.format(\"%s\", VALUE_CREATOR), \"addValueCreator\",\n-                           String.format(\"(L%s;L%s;L%s;L%s;)V\", STRING_VALUE, STRING_VALUE, STRING_VALUE,\n-                                         VALUE_CREATOR),\n-                           false);\n-\n-        // Add a nil-return\n-        mv.visitInsn(ACONST_NULL);\n-        JvmMethodGenUtils.visitReturn(mv);\n-    }\n-\n-    public void addInitAndTypeInitInstructions(BIRNode.BIRPackage pkg, BIRNode.BIRFunction func) {\n-        List<BIRNode.BIRBasicBlock> basicBlocks = new ArrayList<>();\n-        nextId = -1;\n-        BIRNode.BIRBasicBlock nextBB = new BIRNode.BIRBasicBlock(getNextBBId());\n-        basicBlocks.add(nextBB);\n-\n-        PackageID modID = JvmMethodGenUtils.packageToModuleId(pkg);\n-\n-        BIRNode.BIRBasicBlock typeOwnerCreateBB = new BIRNode.BIRBasicBlock(getNextBBId());\n-        basicBlocks.add(typeOwnerCreateBB);\n-\n-        nextBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modID,\n-                                                   new Name(CURRENT_MODULE_INIT),\n-                                                   new ArrayList<>(), null, typeOwnerCreateBB, Collections.emptyList(),\n-                                                   Collections.emptySet());\n-\n-        if (func.basicBlocks.size() == 0) {\n-            typeOwnerCreateBB.terminator = new BIRTerminator.Return(func.pos);\n-            func.basicBlocks = basicBlocks;\n-            return;\n-        }\n-\n-        typeOwnerCreateBB.terminator = new BIRTerminator.GOTO(null, func.basicBlocks.get(0));\n-\n-        basicBlocks.addAll(func.basicBlocks);\n-        func.basicBlocks = basicBlocks;\n-    }\n-\n-    public void enrichPkgWithInitializers(Map<String, JavaClass> jvmClassMap, String typeOwnerClass,\n-                                          BIRNode.BIRPackage pkg, List<PackageID> moduleImports) {\n-        JavaClass javaClass = jvmClassMap.get(typeOwnerClass);\n-        BIRNode.BIRFunction initFunc = generateDepModInit(moduleImports, pkg, MODULE_INIT,\n-                                                          JvmMethodGenUtils.INIT_FUNCTION_SUFFIX);\n-        javaClass.functions.add(initFunc);\n-        pkg.functions.add(initFunc);\n-\n-        BIRNode.BIRFunction startFunc = generateDepModInit(moduleImports, pkg, MODULE_START,\n-                                                           JvmMethodGenUtils.START_FUNCTION_SUFFIX);\n-        javaClass.functions.add(startFunc);\n-        pkg.functions.add(startFunc);\n-\n-    }\n-\n-    private BIRNode.BIRFunction generateDepModInit(List<PackageID> imprtMods, BIRNode.BIRPackage pkg, String funcName,\n-                                                   String initName) {\n-        nextId = -1;\n-        nextVarId = -1;\n-\n-        BIRNode.BIRVariableDcl retVar = new BIRNode.BIRVariableDcl(null, errorOrNilType, new Name(\"%ret\"),\n-                                                                   VarScope.FUNCTION, VarKind.RETURN, \"\");\n-        BIROperand retVarRef = new BIROperand(retVar);\n-\n-        BInvokableType funcType = new BInvokableType(Collections.emptyList(), null, errorOrNilType, null);\n-        BIRNode.BIRFunction modInitFunc = new BIRNode.BIRFunction(null, new Name(funcName), 0, funcType, null, 0, null,\n-                                                                  VIRTUAL);\n-        modInitFunc.localVars.add(retVar);\n-        addAndGetNextBasicBlock(modInitFunc);\n-\n-        BIRNode.BIRVariableDcl boolVal = addAndGetNextVar(modInitFunc, symbolTable.booleanType);\n-        BIROperand boolRef = new BIROperand(boolVal);\n-\n-        for (PackageID id : imprtMods) {\n-            String initFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(id, initName);\n-            addCheckedInvocation(modInitFunc, id, initFuncName, retVarRef, boolRef);\n-        }\n-\n-        PackageID currentModId = JvmMethodGenUtils.packageToModuleId(pkg);\n-        String currentInitFuncName = JvmMethodGenUtils.calculateModuleSpecialFuncName(currentModId, initName);\n-        BIRNode.BIRBasicBlock lastBB = addCheckedInvocation(modInitFunc, currentModId, currentInitFuncName, retVarRef,\n-                                                            boolRef);\n-\n-        lastBB.terminator = new BIRTerminator.Return(null);\n-\n-        return modInitFunc;\n-    }\n-\n-    private BIRNode.BIRVariableDcl addAndGetNextVar(BIRNode.BIRFunction func, BType typeVal) {\n-        BIRNode.BIRVariableDcl nextLocalVar = new BIRNode.BIRVariableDcl(typeVal, getNextVarId(), VarScope.FUNCTION,\n-                                                                         VarKind.LOCAL);\n-        func.localVars.add(nextLocalVar);\n-        return nextLocalVar;\n-    }\n-\n-    private Name getNextVarId() {\n-        String varIdPrefix = \"%\";\n-        nextVarId += 1;\n-        return new Name(varIdPrefix + nextVarId);\n-    }\n-\n-    private BIRNode.BIRBasicBlock addCheckedInvocation(BIRNode.BIRFunction func, PackageID modId, String initFuncName,\n-                                                       BIROperand retVar, BIROperand boolRef) {\n-        BIRNode.BIRBasicBlock lastBB = func.basicBlocks.get(func.basicBlocks.size() - 1);\n-        BIRNode.BIRBasicBlock nextBB = addAndGetNextBasicBlock(func);\n-        // TODO remove once lang.annotation is fixed\n-        if (modId.orgName.value.equals(BALLERINA) && modId.name.value.equals(BUILT_IN_PACKAGE_NAME)) {\n-            lastBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modId,\n-                                                       new Name(initFuncName), Collections.emptyList(), null, nextBB,\n-                                                       Collections.emptyList(),\n-                                                       Collections.emptySet());\n-            return nextBB;\n-        }\n-        lastBB.terminator = new BIRTerminator.Call(null, InstructionKind.CALL, false, modId, new Name(initFuncName),\n-                                                   Collections.emptyList(), retVar, nextBB, Collections.emptyList(),\n-                                                   Collections.emptySet());\n-\n-        BIRNonTerminator.TypeTest typeTest = new BIRNonTerminator.TypeTest(null, symbolTable.errorType, boolRef,\n-                                                                           retVar);\n-        nextBB.instructions.add(typeTest);\n-\n-        BIRNode.BIRBasicBlock trueBB = addAndGetNextBasicBlock(func);\n-        BIRNode.BIRBasicBlock retBB = addAndGetNextBasicBlock(func);\n-        retBB.terminator = new BIRTerminator.Return(null);\n-        trueBB.terminator = new BIRTerminator.GOTO(null, retBB);\n-\n-        BIRNode.BIRBasicBlock falseBB = addAndGetNextBasicBlock(func);\n-        nextBB.terminator = new BIRTerminator.Branch(null, boolRef, trueBB, falseBB);\n-        return falseBB;\n-    }\n-\n-    private BIRNode.BIRBasicBlock addAndGetNextBasicBlock(BIRNode.BIRFunction func) {\n-        BIRNode.BIRBasicBlock nextbb = new BIRNode.BIRBasicBlock(getNextBBId());\n-        func.basicBlocks.add(nextbb);\n-        return nextbb;\n-    }\n-\n-    private Name getNextBBId() {\n-        String bbIdPrefix = \"genBB\";\n-        nextId += 1;\n-        return new Name(bbIdPrefix + nextId);\n-    }\n-\n-    public void resetIds() {\n-        nextId = -1;\n-        nextVarId = -1;\n-    }\n-\n-    public int incrementAndGetNextId() {\n-        return nextId++;\n-    }\n-\n-}\n"}}, {"oid": "03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/03e17d03acb0a39c1bebe3224ea6d3e73d5ac3f0", "message": "Refactor generateLambdaMethod\n\nRelated issue https://github.com/ballerina-platform/ballerina-lang/issues/25252", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "815383720bc7e38db00809a5f6bf67604af0ed7b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/815383720bc7e38db00809a5f6bf67604af0ed7b", "message": "Move main method generation to new class\n\nMore refactoring by moving the main method generation code to a separate class.", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "637216c194556a479f3e29586864eedae94df798", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/637216c194556a479f3e29586864eedae94df798", "message": "Move lambda generation to a new class\n\nMore refactoring by moving the lambda byte code generation code to a separate class.", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "9d5e50512154e2bc740254dc8cad1353905fced9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d5e50512154e2bc740254dc8cad1353905fced9", "message": "Move init methods generation to a new class\n\nMore refactoring by moving the init methods generation code to a separate class.", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "2390a37553931dfe59b5d4137ba2d5f65049de18", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2390a37553931dfe59b5d4137ba2d5f65049de18", "message": "Move stop method generation to a new class\n\nMore refactoring by moving the stop method generation code to a separate class.", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "ad38be37815aa1bca94ed6fee001f797c24081b9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad38be37815aa1bca94ed6fee001f797c24081b9", "message": "Refactor method ordering in JvmMethodGen\n\nThis is to acquire good vertical ordering of code.", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "3e4304c7b075e8ee29250ca6681375706285a241", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e4304c7b075e8ee29250ca6681375706285a241", "message": "Move MethodGen classes to its own package\n\nThe JvmMethodGen class is broken to multiple classes and moved to its own package.\nRename the classes so that they are no longer prefixed with 'Jvm'", "committedDate": "2020-10-28T12:13:34Z", "type": "commit"}, {"oid": "3e4304c7b075e8ee29250ca6681375706285a241", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e4304c7b075e8ee29250ca6681375706285a241", "message": "Move MethodGen classes to its own package\n\nThe JvmMethodGen class is broken to multiple classes and moved to its own package.\nRename the classes so that they are no longer prefixed with 'Jvm'", "committedDate": "2020-10-28T12:13:34Z", "type": "forcePushed"}]}