{"pr_number": 23372, "pr_title": "Add optional field access and conditional expression parsing", "pr_createdAt": "2020-05-19T13:11:57Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372", "timeline": [{"oid": "1335e8583271a80421cf1e762bc9ba08f73c2178", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1335e8583271a80421cf1e762bc9ba08f73c2178", "message": "Add optional field access support", "committedDate": "2020-05-19T07:38:24Z", "type": "commit"}, {"oid": "6b22c97858d7e2369f3898f271f35f63fee907a5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b22c97858d7e2369f3898f271f35f63fee907a5", "message": "Add test cases", "committedDate": "2020-05-19T07:39:16Z", "type": "commit"}, {"oid": "e5377948f1c10cfee299ae705437fc35452c4cb8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5377948f1c10cfee299ae705437fc35452c4cb8", "message": "Add conditional expression support partially", "committedDate": "2020-05-19T13:01:42Z", "type": "commit"}, {"oid": "9a8fd9631b50a2bf62fd7c6676d34bb16b6b8941", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a8fd9631b50a2bf62fd7c6676d34bb16b6b8941", "message": "Add test cases for elvis conditional expression parsing", "committedDate": "2020-05-19T13:02:22Z", "type": "commit"}, {"oid": "1bd31d47993d09d69796a2e83840f780007c16b7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bd31d47993d09d69796a2e83840f780007c16b7", "message": "Change condition expression parsing", "committedDate": "2020-05-20T10:06:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r427896789", "bodyText": "Assuming qualified-identifier gets the higher precedence a ? b:c : d passes as anticipated.\nBut, If we consider simple a ? b : c, it cannot be parsed as b:c is parsed as a qualified-identifier.\nThat's problem I'm facing now", "author": "lochana-chathura", "createdAt": "2020-05-20T10:13:11Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9077,4 +9097,45 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse optional field access expression .\n+     *\n+     * @param lhsExpr Preceding expression of the optional field access\n+     * @return <code>optional-field-access-expr</code>.\n+     */\n+    private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n+        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n+    }\n+\n+    /**\n+     * Parse optional-field-access-token.\n+     *\n+     * @return parsed node\n+     */\n+    private STNode parseOptionalFieldAccessToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.OPTIONAL_CHAINING_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse conditional expression.\n+     *\n+     * @param lhsExpr Preceding expression of the question mark\n+     * @return <code>conditional-expr</code>.\n+     */\n+    private STNode parseConditionalExpression(STNode lhsExpr) {\n+        STNode questionMark = parseQuestionMark();\n+        STNode middleExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        STNode colon = parseColon();\n+        STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n+        return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n+    }", "originalCommit": "1bd31d47993d09d69796a2e83840f780007c16b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkwODIzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r427908237", "bodyText": "I see. May be we would have to special case that. i.e: in expr1 ? expr2 : expr3 if colon is missing, we check whether expr2 is a qualified identifier or not. If yes, we can split it back and treat it as the expr2:expr3. Not the cleanest way, but that would work i think.\nWDYT?", "author": "SupunS", "createdAt": "2020-05-20T10:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDc4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428250787", "bodyText": "Well, expr2 is not always a qualified identifier, when we have this problem.\nFor example in a ? b : c+d, we have a binary expression.\nSo depend on the situation we will have to check their children or children of children or .... for a qualified identifier.\nSometimes there cloud be more than one qualified identifier. Splitting and re-parsing is not possible in such complex cases.", "author": "lochana-chathura", "createdAt": "2020-05-20T19:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjQxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428252417", "bodyText": "Since we have an LL(k) parser I was thinking something like this.\nWhen parsing a qualified identifier, we can check whether there's a spare colon ahead until lower precedence operator or end of expression token is reached. If there's no spare colon ahead, we will not parse the qualified identifier, instead only capture the identifier.\nWe will have to use a flag to identify whether we are in a conditional-expr when doing the above thing.\nAnother problem in this approach is we could have mapping-constructors when checking over the tokens ahead. So we have to make sure that we are looking for a spare colon which is not surrounded by {  }  tokens.\nWDYT?", "author": "lochana-chathura", "createdAt": "2020-05-20T19:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3NjExNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428476114", "bodyText": "Ok.\nI think we have to treat a ? b : c as an invalid code. Because according to ballerina-platform/ballerina-spec#523, b:c is a var ref.\nIf someone want to make it working, they have to use parenthesis like:  a ? (b) : c.\nThat will simplify many things.", "author": "SupunS", "createdAt": "2020-05-21T06:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3Nzc5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23372#discussion_r428477792", "bodyText": "Ok great. Then no trouble at all.", "author": "lochana-chathura", "createdAt": "2020-05-21T06:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5Njc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "afb9a5b1495b8c57f9b74ebb16bd7da78923a112", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 92f095cdb9d..96f4b0a3830 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -9099,23 +9099,25 @@ public class BallerinaParser extends AbstractParser {\n     }\n \n     /**\n-     * Parse optional field access expression .\n+     * Parse optional field access expression.\n+     * <p>\n+     * <code>optional-field-access-expr := expression ?. field-name</code>\n      *\n      * @param lhsExpr Preceding expression of the optional field access\n-     * @return <code>optional-field-access-expr</code>.\n+     * @return Parsed node\n      */\n     private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n-        STNode optionalFieldAccessToken = parseOptionalFieldAccessToken();\n+        STNode optionalFieldAccessToken = parseOptionalChainingToken();\n         STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n         return STNodeFactory.createOptionalFieldAccessExpressionNode(lhsExpr, optionalFieldAccessToken, fieldName);\n     }\n \n     /**\n-     * Parse optional-field-access-token.\n+     * Parse optional chaining token.\n      *\n      * @return parsed node\n      */\n-    private STNode parseOptionalFieldAccessToken() {\n+    private STNode parseOptionalChainingToken() {\n         STToken token = peek();\n         if (token.kind == SyntaxKind.OPTIONAL_CHAINING_TOKEN) {\n             return consume();\n"}}, {"oid": "3e4186836d9e1ab9bfed9b553f2e9ed6f1581a0b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e4186836d9e1ab9bfed9b553f2e9ed6f1581a0b", "message": "Add test cases for conditional-expr validation", "committedDate": "2020-05-21T10:54:30Z", "type": "commit"}, {"oid": "afb9a5b1495b8c57f9b74ebb16bd7da78923a112", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/afb9a5b1495b8c57f9b74ebb16bd7da78923a112", "message": "Refactor code", "committedDate": "2020-05-21T11:24:18Z", "type": "commit"}, {"oid": "199c96c07f221608598f3d704617fd16c5aa6fda", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/199c96c07f221608598f3d704617fd16c5aa6fda", "message": "Add conditional-expr recovery and recovery tests", "committedDate": "2020-05-21T13:43:07Z", "type": "commit"}, {"oid": "1499429ca62677759653e6face6171ccbe8e24ed", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1499429ca62677759653e6face6171ccbe8e24ed", "message": "Refactor optional field access test cases", "committedDate": "2020-05-21T14:02:41Z", "type": "commit"}, {"oid": "a578ab1e5dd0d68783d1c20df2a4a83fd1dd0d1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a578ab1e5dd0d68783d1c20df2a4a83fd1dd0d1c", "message": "Merge branch 'actions' of https://github.com/SupunS/ballerina into expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/AccessExpressionsTest.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-21T18:28:58Z", "type": "commit"}, {"oid": "b1a311574a255d65e18d0103a8a31f2902f59e02", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b1a311574a255d65e18d0103a8a31f2902f59e02", "message": "Regenerate tree after merging", "committedDate": "2020-05-21T18:48:45Z", "type": "commit"}, {"oid": "ad2e8fd4e5d2f4e31e1f31394e289efda23c40c6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad2e8fd4e5d2f4e31e1f31394e289efda23c40c6", "message": "Fix AnnotationsTest > testRecoveryInAnnotValue test case", "committedDate": "2020-05-21T19:13:26Z", "type": "commit"}, {"oid": "04e1cfaccbb17ff41f02974699f781f11ce76656", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04e1cfaccbb17ff41f02974699f781f11ce76656", "message": "Fix json indentation and new line in misc", "committedDate": "2020-05-21T19:14:32Z", "type": "commit"}, {"oid": "e5604bd8bf6e909d9ce288c812f104478135e532", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5604bd8bf6e909d9ce288c812f104478135e532", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into expr-support", "committedDate": "2020-05-21T19:38:34Z", "type": "commit"}]}