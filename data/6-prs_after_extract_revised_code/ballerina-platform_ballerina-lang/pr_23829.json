{"pr_number": 23829, "pr_title": "Add annotation validation to typeconversion expr", "pr_createdAt": "2020-06-09T04:10:03Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTQ2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829#discussion_r437141463", "bodyText": "I'm not sure if this belongs here. Why are we moving this from SemanticAnalyzer, given that BLangAnnotationAttachment itself is not an expression, and only the expr part is?\nWe already seem to be doing the relevant semantic/constant analyzer based analysis in SemanticAnalyzer, and only seem to be calling into TypeChecker for the expression https://github.com/ballerina-platform/ballerina-lang/pull/23829/files#diff-7123076514bbb67aa85076709d29ee0fL2880.", "author": "MaryamZi", "createdAt": "2020-06-09T05:12:49Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3224,10 +3229,113 @@ public void visit(BLangUnaryExpr unaryExpr) {\n         resultType = types.checkType(unaryExpr, actualType, expType);\n     }\n \n+    public void visit(BLangAnnotationAttachment annAttachmentNode) {", "originalCommit": "3874dacb47e020ea5a2d110eb549a63ea2a4cde2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MjQ3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829#discussion_r437152471", "bodyText": "What I want to do is execute annotation validation logic from typecheker since that's where we see the annotation on a typeconvertion expression.\nIf not moving to typechecker we will have to move that logic to its own class, but I don't see any compelling advantage of moving to a separate class that moving to typecheker.", "author": "rdhananjaya", "createdAt": "2020-06-09T05:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NjgwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829#discussion_r437156802", "bodyText": "It seems we do call back to SemanticAnalyzer from typechecker.", "author": "rdhananjaya", "createdAt": "2020-06-09T06:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE2NTg5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829#discussion_r437165892", "bodyText": "Yeah, there was a similar requirement with streaming and it was decided to have this circular dependency for the time-being instead of moving the logic.", "author": "MaryamZi", "createdAt": "2020-06-09T06:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ba2f9551893ed385c5896debff9d4f1e253f10f2", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 3b6eff3c064..1bef0c790c3 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -3229,111 +3226,13 @@ public class TypeChecker extends BLangNodeVisitor {\n         resultType = types.checkType(unaryExpr, actualType, expType);\n     }\n \n-    public void visit(BLangAnnotationAttachment annAttachmentNode) {\n-        BSymbol symbol = this.symResolver.resolveAnnotation(annAttachmentNode.pos, env,\n-                names.fromString(annAttachmentNode.pkgAlias.getValue()),\n-                names.fromString(annAttachmentNode.getAnnotationName().getValue()));\n-        if (symbol == this.symTable.notFoundSymbol) {\n-            this.dlog.error(annAttachmentNode.pos, DiagnosticCode.UNDEFINED_ANNOTATION,\n-                    annAttachmentNode.getAnnotationName().getValue());\n-            return;\n-        }\n-        // Validate Attachment Point against the Annotation Definition.\n-        BAnnotationSymbol annotationSymbol = (BAnnotationSymbol) symbol;\n-        annAttachmentNode.annotationSymbol = annotationSymbol;\n-        if (annotationSymbol.maskedPoints > 0 &&\n-                !Symbols.isAttachPointPresent(annotationSymbol.maskedPoints,\n-                        AttachPoints.asMask(annAttachmentNode.attachPoints))) {\n-            String msg = annAttachmentNode.attachPoints.stream()\n-                    .map(point -> point.name().toLowerCase())\n-                    .collect(Collectors.joining(\", \"));\n-            this.dlog.error(annAttachmentNode.pos, DiagnosticCode.ANNOTATION_NOT_ALLOWED, annotationSymbol, msg);\n-        }\n-        // Validate Annotation Attachment expression against Annotation Definition type.\n-        validateAnnotationAttachmentExpr(annAttachmentNode, annotationSymbol);\n-    }\n-\n-\n-    private void validateAnnotationAttachmentExpr(BLangAnnotationAttachment annAttachmentNode,\n-                                                  BAnnotationSymbol annotationSymbol) {\n-        if (annotationSymbol.attachedType == null ||\n-                types.isAssignable(annotationSymbol.attachedType.type, symTable.trueType)) {\n-            if (annAttachmentNode.expr != null) {\n-                this.dlog.error(annAttachmentNode.pos, DiagnosticCode.ANNOTATION_ATTACHMENT_CANNOT_HAVE_A_VALUE,\n-                        annotationSymbol.name);\n-            }\n-            return;\n-        }\n-\n-\n-        // At this point the type is a subtype of  map<anydata>|record{ anydata...; } or\n-        // map<anydata>[]|record{ anydata...; }[], thus an expression is required.\n-        if (annAttachmentNode.expr == null) {\n-            this.dlog.error(annAttachmentNode.pos, DiagnosticCode.ANNOTATION_ATTACHMENT_REQUIRES_A_VALUE,\n-                    annotationSymbol.name);\n-            return;\n-        }\n-\n-        BType annotType = annotationSymbol.attachedType.type;\n-        checkExpr(annAttachmentNode.expr, env,\n-                annotType.tag == TypeTags.ARRAY ? ((BArrayType) annotType).eType : annotType);\n-\n-        if (Symbols.isFlagOn(annotationSymbol.flags, Flags.CONSTANT)) {\n-            if (annotationSymbol.points.stream().anyMatch(attachPoint -> !attachPoint.source)) {\n-                constantAnalyzer.analyzeExpr(annAttachmentNode.expr);\n-                return;\n-            }\n-            checkAnnotConstantExpression(annAttachmentNode.expr);\n-        }\n-    }\n-\n-    // TODO: 7/10/19 Remove this once const support is added for lists. A separate method is introduced temporarily\n-    //  since we allow array/tuple literals with cont exprs for annotations\n-    private void checkAnnotConstantExpression(BLangExpression expression) {\n-        // Recursively check whether all the nested expressions in the provided expression are constants or can be\n-        // evaluated to constants.\n-        switch (expression.getKind()) {\n-            case LITERAL:\n-            case NUMERIC_LITERAL:\n-                break;\n-            case SIMPLE_VARIABLE_REF:\n-                BSymbol symbol = ((BLangSimpleVarRef) expression).symbol;\n-                // Symbol can be null in some invalid scenarios. Eg - const string m = { name: \"Ballerina\" };\n-                if (symbol != null && (symbol.tag & SymTag.CONSTANT) != SymTag.CONSTANT) {\n-                    dlog.error(expression.pos, DiagnosticCode.EXPRESSION_IS_NOT_A_CONSTANT_EXPRESSION);\n-                }\n-                break;\n-            case RECORD_LITERAL_EXPR:\n-                ((BLangRecordLiteral) expression).fields.forEach(field -> {\n-                    if (field.isKeyValueField()) {\n-                        BLangRecordLiteral.BLangRecordKeyValueField pair =\n-                                (BLangRecordLiteral.BLangRecordKeyValueField) field;\n-                        checkAnnotConstantExpression(pair.key.expr);\n-                        checkAnnotConstantExpression(pair.valueExpr);\n-                    } else {\n-                        checkAnnotConstantExpression((BLangRecordLiteral.BLangRecordVarNameField) field);\n-                    }\n-                });\n-                break;\n-            case LIST_CONSTRUCTOR_EXPR:\n-                ((BLangListConstructorExpr) expression).exprs.forEach(this::checkAnnotConstantExpression);\n-                break;\n-            case FIELD_BASED_ACCESS_EXPR:\n-                checkAnnotConstantExpression(((BLangFieldBasedAccess) expression).expr);\n-                break;\n-            default:\n-                dlog.error(expression.pos, DiagnosticCode.EXPRESSION_IS_NOT_A_CONSTANT_EXPRESSION);\n-                break;\n-        }\n-    }\n-\n     public void visit(BLangTypeConversionExpr conversionExpr) {\n         // Set error type as the actual type.\n         BType actualType = symTable.semanticError;\n \n         for (BLangAnnotationAttachment annAttachment : conversionExpr.annAttachments) {\n             annAttachment.attachPoints.add(AttachPoint.Point.TYPE);\n-            annAttachment.accept(this);\n+            semanticAnalyzer.analyzeNode(annAttachment, this.env);\n         }\n \n         // Annotation such as <@untainted [T]>, where T is not provided,\n"}}, {"oid": "ba2f9551893ed385c5896debff9d4f1e253f10f2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba2f9551893ed385c5896debff9d4f1e253f10f2", "message": "Validate annotations within typeconversion expr", "committedDate": "2020-06-09T11:48:23Z", "type": "commit"}, {"oid": "31523c5d2a23c2cc17612ba6d456259be7deb641", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/31523c5d2a23c2cc17612ba6d456259be7deb641", "message": "Add unit test for annotation in type-conv expr", "committedDate": "2020-06-09T11:48:23Z", "type": "forcePushed"}, {"oid": "53b98ed5318a66ebef43dd944bbabe325e703bd9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53b98ed5318a66ebef43dd944bbabe325e703bd9", "message": "Add unit test for annotation in type-conv expr", "committedDate": "2020-06-09T12:35:32Z", "type": "commit"}, {"oid": "53b98ed5318a66ebef43dd944bbabe325e703bd9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53b98ed5318a66ebef43dd944bbabe325e703bd9", "message": "Add unit test for annotation in type-conv expr", "committedDate": "2020-06-09T12:35:32Z", "type": "forcePushed"}, {"oid": "9463a59cdb67ba5e206aedbf4c913d4d5a2f5fb3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9463a59cdb67ba5e206aedbf4c913d4d5a2f5fb3", "message": "Fix syntax error in websub module", "committedDate": "2020-06-09T16:59:48Z", "type": "forcePushed"}, {"oid": "d124b96fe7d8c5a64fe6caa89cd97e321af1a745", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d124b96fe7d8c5a64fe6caa89cd97e321af1a745", "message": "Fix syntax error in stdlib modules", "committedDate": "2020-06-10T03:51:18Z", "type": "forcePushed"}, {"oid": "487f91f4a658e2e9faf504ec6a982056924c022d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/487f91f4a658e2e9faf504ec6a982056924c022d", "message": "Fix syntax error in stdlib modules", "committedDate": "2020-06-10T06:08:33Z", "type": "forcePushed"}, {"oid": "c19f1cb12777db9a2e97dfd1cb14a6a62aeb5d7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c19f1cb12777db9a2e97dfd1cb14a6a62aeb5d7f", "message": "Fix syntax error in stdlib modules", "committedDate": "2020-06-10T06:58:02Z", "type": "commit"}, {"oid": "c19f1cb12777db9a2e97dfd1cb14a6a62aeb5d7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c19f1cb12777db9a2e97dfd1cb14a6a62aeb5d7f", "message": "Fix syntax error in stdlib modules", "committedDate": "2020-06-10T06:58:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNDU3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23829#discussion_r437924571", "bodyText": "Unused?", "author": "MaryamZi", "createdAt": "2020-06-10T07:43:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -6478,6 +6485,19 @@ private void logUndefinedSymbolError(DiagnosticPos pos, String name) {\n         }\n     }\n \n+    public void checkAnnot(BLangAnnotationAttachment annAttachmentNode, SymbolEnv env) {", "originalCommit": "c19f1cb12777db9a2e97dfd1cb14a6a62aeb5d7f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e62edb24c32010140b49b379b67d36606233f09c", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 16a94387ed2..1bef0c790c3 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -6485,19 +6485,6 @@ public class TypeChecker extends BLangNodeVisitor {\n         }\n     }\n \n-    public void checkAnnot(BLangAnnotationAttachment annAttachmentNode, SymbolEnv env) {\n-        SymbolEnv prevEnv = this.env;\n-        BType preExpType = this.expType;\n-        DiagnosticCode preDiagCode = this.diagCode;\n-        this.env = env;\n-\n-        visit(annAttachmentNode);\n-\n-        this.env = prevEnv;\n-        this.expType = preExpType;\n-        this.diagCode = preDiagCode;\n-    }\n-\n     private static class FieldInfo {\n         List<BType> types;\n         boolean required;\n"}}, {"oid": "e62edb24c32010140b49b379b67d36606233f09c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e62edb24c32010140b49b379b67d36606233f09c", "message": "Apply reivew suggestions", "committedDate": "2020-06-10T07:58:33Z", "type": "commit"}, {"oid": "e3bb4814852c6a2c1c9cfb44dfde495b44fa1ced", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3bb4814852c6a2c1c9cfb44dfde495b44fa1ced", "message": "Add test case for <@taint>", "committedDate": "2020-06-10T11:17:48Z", "type": "commit"}]}