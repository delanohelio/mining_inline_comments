{"pr_number": 25021, "pr_title": "Add missing contexts for resumeParsing, split resumeParsing Method and resolve parsing conflicts", "pr_createdAt": "2020-07-29T12:04:01Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021", "timeline": [{"oid": "44d7e2d46cc333107d9dc5138f81e1f50a59982e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44d7e2d46cc333107d9dc5138f81e1f50a59982e", "message": "Add missing contexts for resumeParsing\n\nAdded missing contexts for resumePasing and added tests to verify those.", "committedDate": "2020-07-29T11:56:17Z", "type": "commit"}, {"oid": "30f46823ffda2d1db5f02c9eb5b97a1f1e2e97b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30f46823ffda2d1db5f02c9eb5b97a1f1e2e97b6", "message": "Fix checkstyle", "committedDate": "2020-07-29T12:20:22Z", "type": "commit"}, {"oid": "f791d1f33f69dec8a52a6a8ddf8f86ebe1b8e78a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f791d1f33f69dec8a52a6a8ddf8f86ebe1b8e78a", "message": "Refactor resumeParsing", "committedDate": "2020-07-30T08:34:00Z", "type": "commit"}, {"oid": "b7122e2b84bca5fc73d98c054f3f2f5123d35fee", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b7122e2b84bca5fc73d98c054f3f2f5123d35fee", "message": "Fix merge conflict", "committedDate": "2020-07-30T09:59:35Z", "type": "commit"}, {"oid": "db846af90d113c7dab22ac997ef520fb273dc240", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db846af90d113c7dab22ac997ef520fb273dc240", "message": "Fix ResumeParsing conflicts\n\nFix conflicts in resumeParsing where more than 1 method recovers with the same context.", "committedDate": "2020-07-30T12:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDUzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463410534", "bodyText": "parseCompoundAssignmentStmt() is only called within resumeParsing()\nNo other usage. Do we need that method?", "author": "lochana-chathura", "createdAt": "2020-07-31T05:21:36Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -594,41 +510,169 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n+            case PARAMETERIZED_TYPE:\n+                return parseParameterizedTypeKeyword();\n+            case LOCK_KEYWORD:\n+                return parseLockKeyword();\n+            case STRING_KEYWORD:\n+                return parseStringKeyword();\n+            case TRANSACTIONAL_KEYWORD:\n+                return parseTransactionalKeyword();\n+            default:\n+                return resumeOtherNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:// 2 resume-points : parseTypeDescOrExprRhs()\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            default:\n+                return resumeKeywordParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            case COMPOUND_ASSIGNMENT_STMT:// following method is only referred in resume parsing\n+                return parseCompoundAssignmentStmt();", "originalCommit": "db846af90d113c7dab22ac997ef520fb273dc240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxODI3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463418274", "bodyText": "I don't think we do. I ll remove it.", "author": "m36dot", "createdAt": "2020-07-31T05:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMDU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463420548", "bodyText": "when removing can remove those enclosing COMPOUND_ASSIGNMENT_STMT ctx as well. Seems it is referred in error handler also.\nSame case with parseNilTypeDescriptor() and its NIL_TYPE_DESCRIPTOR ctx.\nI think we may have to recheck the usage of those ctxs in error handler as well @SupunS WDYT?", "author": "lochana-chathura", "createdAt": "2020-07-31T06:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MTM1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463551350", "bodyText": "Yeah if the method doesn't go to error recovery (eg: parseNilTypeDescriptor method), then we don't need them in the resume method also", "author": "SupunS", "createdAt": "2020-07-31T11:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU2MjU4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463562581", "bodyText": "@SupunS yea. In my second comment what I meant was , if we are removing those two methods we are eliminating\nstartContext(ParserRuleContext.COMPOUND_ASSIGNMENT_STMT); and startContext(ParserRuleContext.NIL_TYPE_DESCRIPTOR); calls from BallerinaParser.\nBut in the error handler still we are starting new ctxs for those ctxs. So I see some kind of inconsistency IINM.\nMay be we can create an issue to check on that and remove those unnecessary ctx starts from error handler?", "author": "lochana-chathura", "createdAt": "2020-07-31T11:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 173be27d5e4..8b50ac0a8bd 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -533,7 +529,7 @@ public class BallerinaParser extends AbstractParser {\n                         (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n             case CONSTANT_EXPRESSION_START:\n                 return parseSimpleConstExprInternal();\n-            case BINDING_PATTERN_OR_EXPR_RHS:// 2 resume-points : parseTypeDescOrExprRhs()\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n                 return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n             case TYPE_DESC_OR_EXPR_RHS:\n                 return parseTypeDescOrExprRhs((STNode) args[0]);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDg3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463410876", "bodyText": "parseNilTypeDescriptor() above this line also has no usage in other places.", "author": "lochana-chathura", "createdAt": "2020-07-31T05:23:03Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -283,121 +213,35 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseOpenBracket();\n             case RESOURCE_DEF:\n                 return parseResource();\n-            case OPTIONAL_SERVICE_NAME:\n-                return parseServiceName();\n-            case SERVICE_KEYWORD:\n-                return parseServiceKeyword();\n-            case ON_KEYWORD:\n-                return parseOnKeyword();\n-            case RESOURCE_KEYWORD:\n-                return parseResourceKeyword();\n-            case LISTENER_KEYWORD:\n-                return parseListenerKeyword();\n             case NIL_TYPE_DESCRIPTOR:// following method is only referred in resume parsing\n                 return parseNilTypeDescriptor();\n-            case COMPOUND_ASSIGNMENT_STMT:// following method is only referred in resume parsing", "originalCommit": "db846af90d113c7dab22ac997ef520fb273dc240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxOTIwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463419206", "bodyText": "yea, will remove that as well.", "author": "m36dot", "createdAt": "2020-07-31T05:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 173be27d5e4..8b50ac0a8bd 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -213,8 +213,6 @@ public class BallerinaParser extends AbstractParser {\n                 return parseOpenBracket();\n             case RESOURCE_DEF:\n                 return parseResource();\n-            case NIL_TYPE_DESCRIPTOR:// following method is only referred in resume parsing\n-                return parseNilTypeDescriptor();\n             case ARRAY_LENGTH:\n                 return parseArrayLength();\n             case COMMA:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTUxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463411511", "bodyText": "we can check if this context is required in resumeParsing and remove // revisit comment", "author": "lochana-chathura", "createdAt": "2020-07-31T05:25:40Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -448,42 +288,20 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseLeftArrowToken();\n             case RECEIVE_WORKERS:\n                 return parseReceiveWorkers();\n-            case WAIT_KEYWORD:\n-                return parseWaitKeyword();\n-            case WAIT_FUTURE_EXPR_END:\n-                return parseWaitFutureExprEnd((int) args[0]);\n             case WAIT_FIELD_NAME:// revisit\n                 return parseWaitField();", "originalCommit": "db846af90d113c7dab22ac997ef520fb273dc240", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 173be27d5e4..8b50ac0a8bd 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -288,7 +284,7 @@ public class BallerinaParser extends AbstractParser {\n                 return parseLeftArrowToken();\n             case RECEIVE_WORKERS:\n                 return parseReceiveWorkers();\n-            case WAIT_FIELD_NAME:// revisit\n+            case WAIT_FIELD_NAME:\n                 return parseWaitField();\n             case WAIT_FIELD_END:\n                 return parseWaitFieldEnd();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTg5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463411893", "bodyText": "if the conflict is resolved, we can remove the comment", "author": "lochana-chathura", "createdAt": "2020-07-31T05:27:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -594,41 +510,169 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n+            case PARAMETERIZED_TYPE:\n+                return parseParameterizedTypeKeyword();\n+            case LOCK_KEYWORD:\n+                return parseLockKeyword();\n+            case STRING_KEYWORD:\n+                return parseStringKeyword();\n+            case TRANSACTIONAL_KEYWORD:\n+                return parseTransactionalKeyword();\n+            default:\n+                return resumeOtherNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:// 2 resume-points : parseTypeDescOrExprRhs()", "originalCommit": "db846af90d113c7dab22ac997ef520fb273dc240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxOTMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463419304", "bodyText": "forgot to remove the comment", "author": "m36dot", "createdAt": "2020-07-31T05:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 173be27d5e4..8b50ac0a8bd 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -533,7 +529,7 @@ public class BallerinaParser extends AbstractParser {\n                         (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n             case CONSTANT_EXPRESSION_START:\n                 return parseSimpleConstExprInternal();\n-            case BINDING_PATTERN_OR_EXPR_RHS:// 2 resume-points : parseTypeDescOrExprRhs()\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n                 return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n             case TYPE_DESC_OR_EXPR_RHS:\n                 return parseTypeDescOrExprRhs((STNode) args[0]);\n"}}, {"oid": "e47de2a07887eec88bad4be07682b5b702e95d7d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e47de2a07887eec88bad4be07682b5b702e95d7d", "message": "Refactor resumeParsing in ballerinaParser\n\nRemoved some outdated comments and removed some cases which werent necessary.", "committedDate": "2020-07-31T06:17:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NjY1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463546654", "bodyText": "Can't we have the logic inside this function iteself?\nThere's no value addition of delegating the logic to another function, if this is the only place it is used..", "author": "SupunS", "createdAt": "2020-07-31T11:01:32Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -138,41 +138,28 @@ public STNode parse(ParserRuleContext context) {\n      */\n     @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        // TODO: revisit the commented resume-points\n+        return resumeTopLevelNodeParsing(context, args);", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MzQzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463553439", "bodyText": "yea sounds good to me", "author": "m36dot", "createdAt": "2020-07-31T11:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NjY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -136,256 +136,168 @@ public class BallerinaParser extends AbstractParser {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n-    @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        return resumeTopLevelNodeParsing(context, args);\n+        switch (context) {\n+            case TOP_LEVEL_NODE:\n+                return parseTopLevelNode();\n+            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n+                return parseTopLevelNode((STNode) args[0]);\n+            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n+                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_DECL_RHS:\n+                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_PREFIX:\n+                return parseImportPrefix();\n+            case IMPORT_MODULE_NAME:\n+            case IMPORT_ORG_OR_MODULE_NAME:\n+            case SERVICE_NAME:\n+            case MODULE_ENUM_NAME:\n+                return parseIdentifier(context);\n+            case IMPORT_VERSION_DECL:\n+                return parseVersion();\n+            case IMPORT_SUB_VERSION:\n+                return parseSubVersion(context);\n+            case IMPORT_PREFIX_DECL:\n+                return parseImportPrefixDecl();\n+            case FUNC_BODY:\n+                return parseFunctionBody((boolean) args[0]);\n+            case FUNC_NAME:\n+                return parseFunctionName();\n+            case FUNCTION_IDENT:\n+                return parseFunctionIdent();\n+            case FUNCTION_KEYWORD_RHS:\n+                return parseFunctionKeywordRhs((STNode) args[0], (STNode) args[1], (boolean) args[2],\n+                        (STNode[]) args[3]);\n+            case ANNOT_REFERENCE:\n+            case RECORD_FIELD_NAME_OR_TYPE_NAME:\n+                return parseQualifiedIdentifier(context, (boolean) args[0]);\n+            case RECORD_BODY_START:\n+                return parseRecordBodyStartDelimiter();\n+            case RECORD_FIELD_OR_RECORD_END:\n+                return parseFieldOrRestDescriptor((boolean) args[0]);\n+            case CLOSED_RECORD_BODY_START:\n+                return parseClosedRecordBodyStart();\n+            case CLOSED_RECORD_BODY_END:\n+                return parseClosedRecordBodyEnd();\n+            case RECORD_BODY_END: // ideally this is never getting called\n+                return parseRecordBodyCloseDelimiter((SyntaxKind) args[0]);\n+            case OBJECT_MEMBER_START:\n+                return parseObjectMember();\n+            case OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY:\n+                return parseObjectMethodOrField((STNode) args[0], (STNode) args[1]);\n+            case OBJECT_FIELD_RHS:\n+                return parseObjectFieldRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case OBJECT_TYPE_QUALIFIER:\n+                return parseObjectTypeQualifiers();\n+            case IDENT_AFTER_OBJECT_IDENT:\n+                return parseIdentAfterObjectIdent();\n+            case OBJECT_MEMBER_WITHOUT_METADATA:\n+                return parseObjectMember((STNode) args[0]);\n+            case OPTIONAL_SERVICE_NAME:\n+                return parseServiceName();\n+            case CONST_DECL_RHS:\n+                return parseConstantOrListenerDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (boolean) args[4]);\n+            case XML_NAMESPACE_PREFIX_DECL:\n+                return parseXMLDeclRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case XML_ATOMIC_NAME_PATTERN_START:\n+                return parseXMLAtomicNamePatternBody();\n+            case ANNOTATION_KEYWORD:\n+                return parseAnnotationKeyword();\n+            case ANNOT_DECL_OPTIONAL_TYPE:\n+                return parseAnnotationDeclFromType((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3]);\n+            case ANNOT_DECL_RHS:\n+                return parseAnnotationDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case ANNOT_OPTIONAL_ATTACH_POINTS:\n+                return parseAnnotationDeclAttachPoints((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (STNode) args[4], (STNode) args[5]);\n+            case ANNOT_CHAINING_TOKEN:\n+                return parseAnnotChainingToken();\n+            case ANNOTATION_TAG:\n+                return parseAnnotationTag();\n+            case EXTERNAL_FUNC_BODY_OPTIONAL_ANNOTS:\n+                return parseExternalFuncBodyRhs((STNode) args[0]);\n+            default:\n+                return resumeStatementNodeParsing(context, args);\n+        }\n     }\n \n-    public STNode resumeOtherNodesParsing(ParserRuleContext context, Object... args) {\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n-            case OPEN_BRACE:\n-                return parseOpenBrace();\n-            case CLOSE_BRACE:\n-                return parseCloseBrace();\n-            case OPEN_PARENTHESIS:\n-            case ARG_LIST_START:\n-                return parseOpenParenthesis(context);\n-            case SIMPLE_TYPE_DESCRIPTOR:\n-                return parseSimpleTypeDescriptor();\n-            case ASSIGN_OP:\n-                return parseAssignOp();\n-            case SEMICOLON:\n-                return parseSemicolon();\n-            case CLOSE_PARENTHESIS:\n-                return parseCloseParenthesis();\n-            case VARIABLE_NAME:\n-                return parseVariableName();\n-            case PARAMETER_START:\n-                return parseParameter((SyntaxKind) args[0], (STNode) args[1], (int) args[2], (boolean) args[3]);\n-            case PARAMETER_WITHOUT_ANNOTS:\n-                return parseParamGivenAnnots((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (int) args[3],\n-                        (boolean) args[4]);\n-            case AFTER_PARAMETER_TYPE:\n-                return parseAfterParamType((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (boolean) args[5]);\n-            case PARAMETER_NAME_RHS:\n-                return parseParameterRhs((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (STNode) args[5]);\n-            case TYPE_NAME_OR_VAR_NAME:\n-            case TYPE_REFERENCE:\n-            case FIELD_ACCESS_IDENTIFIER:\n-                return parseQualifiedIdentifier(context, (boolean) args[0]);\n-            case FIELD_DESCRIPTOR_RHS:\n-                return parseFieldDescriptorRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3]);\n-            case TYPE_DESCRIPTOR:\n-                return parseTypeDescriptorInternal((ParserRuleContext) args[0], (boolean) args[1]);\n-            case TYPE_NAME:\n-                return parseTypeName();\n-            case VARIABLE_REF:\n-            case IMPLICIT_ANON_FUNC_PARAM:\n-            case MAPPING_FIELD_NAME:\n-            case RECEIVE_FIELD_NAME:\n-            case ENUM_MEMBER_NAME:\n-                return parseIdentifier(context);\n-            case SLASH:\n-                return parseSlashToken();\n-            case DOT:\n-                return parseDotToken();\n-            case VERSION_NUMBER:\n-                return parseVersionNumber();\n-            case DECIMAL_INTEGER_LITERAL:\n-            case MAJOR_VERSION:\n-            case MINOR_VERSION:\n-            case PATCH_VERSION:\n-                return parseDecimalIntLiteral(context);\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            case TABLE_KEYWORD_RHS:\n+                return parseTableConstructorOrQuery((STNode) args[0], (boolean) args[1]);\n+            case RETRY_KEYWORD_RHS:\n+                return parseRetryKeywordRhs((STNode) args[0]);\n             case MAPPING_FIELD:\n             case FIRST_MAPPING_FIELD:\n                 return parseMappingField((ParserRuleContext) args[0]);\n             case SPECIFIC_FIELD_RHS:\n                 return parseSpecificFieldRhs((STNode) args[0], (STNode) args[1]);\n-            case FIELD_BINDING_PATTERN_END:\n-                return parseMappingFieldRhs((STNode) args[0]);\n-            case STRING_LITERAL:\n-                return parseStringLiteral();\n-            case COLON:\n-                return parseColon();\n-            case OPEN_BRACKET:\n-                return parseOpenBracket();\n-            case RESOURCE_DEF:\n-                return parseResource();\n-            case ARRAY_LENGTH:\n-                return parseArrayLength();\n-            case COMMA:\n-                return parseComma();\n-            case CONST_DECL_TYPE:\n-                return parseConstDecl((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case LT:\n-                return parseLTToken();\n-            case GT:\n-                return parseGTToken();\n-            case ATTACH_POINT_IDENT:\n-                return parseAttachPointIdent((STNode) args[0]);\n-            case FIELD_IDENT:\n-                return parseFieldIdent();\n-            case ATTACH_POINT_END:\n-                return parseAttachPointEnd();\n-            case NAMESPACE_PREFIX:\n-                return parseNamespacePrefix();\n-            case WORKER_NAME:\n-                return parseWorkerName();\n-            case STREAM_TYPE_FIRST_PARAM_RHS:\n-                return parseStreamTypeParamsNode((STNode) args[0], (STNode) args[1]);\n-            case TEMPLATE_START:\n-            case TEMPLATE_END:\n-                return parseBacktickToken(context);\n-            case KEY_CONSTRAINTS_RHS:\n-                return parseKeyConstraint((STNode) args[0]);\n-            case ORDER_KEY_LIST_END:\n-                return parseOrderKeyListMemberEnd();\n-            case TABLE_CONSTRUCTOR_OR_QUERY_START:\n-                return parseTableConstructorOrQuery((boolean) args[0]);\n-            case TABLE_CONSTRUCTOR_OR_QUERY_RHS:\n-                return parseTableConstructorOrQueryRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n-            case QUERY_PIPELINE_RHS:\n-                return parseIntermediateClause((boolean) args[0]);\n-            case ANON_FUNC_BODY:\n-                return parseAnonFuncBody((boolean) args[0]);\n-            case CLOSE_BRACKET:\n-                return parseCloseBracket();\n-            case ARG_START:\n-                return parseArgument();\n-            case ARG_END:\n-                return parseArgEnd();\n-            case MAPPING_FIELD_END:\n-                return parseMappingFieldEnd();\n-            case FIELD_OR_REST_DESCIPTOR_RHS:\n-                return parseFieldOrRestDescriptorRhs((STNode) args[0], (STNode) args[1]);\n-            case TYPE_DESC_IN_TUPLE_RHS:\n-                return parseTupleMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER_END:\n-                return parseListBindingPatternMemberRhs();\n-            case MAPPING_BINDING_PATTERN_END:\n-                return parseMappingBindingPatternEnd();\n-            case FIELD_BINDING_PATTERN_NAME:\n-                return parseFieldBindingPattern();\n-            case LIST_CONSTRUCTOR_MEMBER_END:\n-                return parseListConstructorMemberEnd();\n-            case NIL_OR_PARENTHESISED_TYPE_DESC_RHS:\n-                return parseNilOrParenthesisedTypeDescRhs((STNode) args[0]);\n-            case ANON_FUNC_PARAM_RHS:\n-                return parseImplicitAnonFuncParamEnd();\n-            case BINDING_PATTERN:\n-                return parseBindingPattern();\n-            case PEER_WORKER_NAME:\n-                return parsePeerWorkerName();\n-            case SYNC_SEND_TOKEN:\n-                return parseSyncSendToken();\n-            case LEFT_ARROW_TOKEN:\n-                return parseLeftArrowToken();\n-            case RECEIVE_WORKERS:\n-                return parseReceiveWorkers();\n-            case WAIT_FIELD_NAME:\n-                return parseWaitField();\n-            case WAIT_FIELD_END:\n-                return parseWaitFieldEnd();\n-            case OPTIONAL_CHAINING_TOKEN:\n-                return parseOptionalChainingToken();\n-            case RETRY_TYPE_PARAM_RHS:\n-                return parseRetryTypeParamRhs((STNode) args[0], (STNode) args[1]);\n-            case RETRY_BODY:\n-                return parseRetryBody();\n-            case ENUM_MEMBER_END:\n-                return parseEnumMemberEnd();\n-            case BRACKETED_LIST_MEMBER_END:\n-                return parseBracketedListMemberEnd();\n-            case TYPED_BINDING_PATTERN_TYPE_RHS:\n-                return parseTypedBindingPatternTypeRhs((STNode) args[0], (ParserRuleContext) args[1],\n-                        (boolean) args[2]);\n-            case BRACKETED_LIST_RHS:\n-                return parseTypedBindingPatternOrMemberAccessRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n-                        (STNode) args[3], (boolean) args[4], (boolean) args[5], (ParserRuleContext) args[6]);\n-            case UNION_OR_INTERSECTION_TOKEN:\n-                return parseUnionOrIntersectionToken();\n-            case BRACKETED_LIST_MEMBER:\n-            case LIST_BINDING_MEMBER_OR_ARRAY_LENGTH:\n-                return parseBracketedListMember((boolean) args[0]);\n-            case DOT_LT_TOKEN:\n-                return parseDotLTToken();\n-            case SLASH_LT_TOKEN:\n-                return parseSlashLTToken();\n-            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n-                return parseDoubleSlashDoubleAsteriskLTToken();\n-            case SPECIFIC_FIELD:\n-                return parseSpecificField((STNode) args[0]);\n-            case OPTIONAL_MATCH_GUARD:\n-                return parseMatchGuard();\n-            case MATCH_PATTERN_START:\n-                return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n-                return parseMatchPatternEnd();\n-            case ENUM_MEMBER_RHS:\n-                return parseEnumMemberRhs((STNode) args[0], (STNode) args[1]);\n-            case RECEIVE_FIELD:\n-                return parseReceiveField();\n-            case PARAM_END:\n-                return parseParameterRhs();\n-            case ELLIPSIS:\n-                return parseEllipsis();\n-            case BINARY_OPERATOR:\n-                return parseBinaryOperator();\n-            case QUESTION_MARK:\n-                return parseQuestionMark();\n-            case COMPOUND_BINARY_OPERATOR:\n-                return parseCompoundBinaryOperator();\n-            case UNARY_OPERATOR:\n-                return parseUnaryOperator();\n-            case AT:\n-                return parseAtToken();\n-            case RIGHT_ARROW:\n-                return parseRightArrow();\n-            case ATTACH_POINT:\n-                return parseAnnotationAttachPoint();\n-            case PIPE:\n-                return parsePipeToken();\n-            case INTERPOLATION_START_TOKEN:\n-                return parseInterpolationStart();\n-            case LIST_MATCH_PATTERN_MEMBER_RHS:\n-                return parseListMatchPatternMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER:\n-                return parseListBindingPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER:\n-                return parseFieldMatchPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER_RHS:\n-                return parseFieldMatchPatternRhs();\n-            case FUNC_MATCH_PATTERN_OR_CONST_PATTERN:\n-                return parseFunctionalMatchPatternOrConsPattern((STNode) args[0]);\n-            case ARG_MATCH_PATTERN:\n-                return parseArgMatchPattern();\n-            case ARG_MATCH_PATTERN_RHS:\n-                return parseArgMatchPatternRhs();\n-            case ARG_BINDING_PATTERN:\n-                return parseArgBindingPattern();\n-            case ARG_BINDING_PATTERN_END:\n-                return parseArgsBindingPatternEnd();\n-            case TABLE_ROW_END:\n-                return parseTableRowEnd();\n-            case LIST_BP_OR_LIST_CONSTRUCTOR_MEMBER:\n-                return parseListBindingPatternOrListConstructorMember();\n-            case TUPLE_TYPE_DESC_OR_LIST_CONST_MEMBER:\n-                return parseTupleTypeDescOrListConstructorMember((STNode) args[0]);\n-            case REMOTE_CALL_OR_ASYNC_SEND_END:\n-                return parseRemoteCallOrAsyncSendEnd((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case RECEIVE_FIELD_END:\n-                return parseReceiveFieldEnd();\n-            case MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER:\n-                return parseMappingBindingPatterOrMappingConstructorMember();\n             default:\n-                throw new IllegalStateException(\"cannot resume parsing the rule: \" + context);\n+                return resumeKeywordParsing(context, args);\n         }\n     }\n \n     public STNode resumeKeywordParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n+            case OBJECT_KEYWORD:\n+                return parseObjectKeyword();\n+            case LISTENER_KEYWORD:\n+                return parseListenerKeyword();\n+            case SERVICE_KEYWORD:\n+                return parseServiceKeyword();\n+            case CONST_KEYWORD:\n+                return parseConstantKeyword();\n+            case XML_KEYWORD:\n+                return parseXMLKeyword();\n+            case RECORD_KEYWORD:\n+                return parseRecordKeyword();\n+            case FUNCTION_KEYWORD:\n+                return parseFunctionKeyword();\n+            case IMPORT_KEYWORD:\n+                return parseImportKeyword();\n             case EXTERNAL_KEYWORD:\n                 return parseExternalKeyword();\n             case IF_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NzIwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463547206", "bodyText": "Shall we re-order the functions in the same order they are chained?", "author": "SupunS", "createdAt": "2020-07-31T11:02:59Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -594,41 +506,167 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n+            case PARAMETERIZED_TYPE:\n+                return parseParameterizedTypeKeyword();\n+            case LOCK_KEYWORD:\n+                return parseLockKeyword();\n+            case STRING_KEYWORD:\n+                return parseStringKeyword();\n+            case TRANSACTIONAL_KEYWORD:\n+                return parseTransactionalKeyword();\n+            default:\n+                return resumeOtherNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            default:\n+                return resumeKeywordParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeTopLevelNodeParsing(ParserRuleContext context, Object... args) {", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgyNTUwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r464825500", "bodyText": "sure", "author": "m36dot", "createdAt": "2020-08-04T06:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NzIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -506,8 +414,6 @@ public class BallerinaParser extends AbstractParser {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n-            case PARAMETERIZED_TYPE:\n-                return parseParameterizedTypeKeyword();\n             case LOCK_KEYWORD:\n                 return parseLockKeyword();\n             case STRING_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0Nzc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463547773", "bodyText": "Since theres a separate method for resuming keywords, shall we move all keywords in to that method?\nFix in all places", "author": "SupunS", "createdAt": "2020-07-31T11:04:32Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -594,41 +506,167 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n+            case PARAMETERIZED_TYPE:\n+                return parseParameterizedTypeKeyword();\n+            case LOCK_KEYWORD:\n+                return parseLockKeyword();\n+            case STRING_KEYWORD:\n+                return parseStringKeyword();\n+            case TRANSACTIONAL_KEYWORD:\n+                return parseTransactionalKeyword();\n+            default:\n+                return resumeOtherNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            default:\n+                return resumeKeywordParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeTopLevelNodeParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TOP_LEVEL_NODE:\n+                return parseTopLevelNode();\n+            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n+                return parseTopLevelNode((STNode) args[0]);\n+            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n+                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_DECL_RHS:\n+                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_PREFIX:\n+                return parseImportPrefix();\n+            case IMPORT_MODULE_NAME:\n+            case IMPORT_ORG_OR_MODULE_NAME:\n+            case SERVICE_NAME:\n+            case MODULE_ENUM_NAME:\n+                return parseIdentifier(context);\n+            case IMPORT_KEYWORD:", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -506,8 +414,6 @@ public class BallerinaParser extends AbstractParser {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n-            case PARAMETERIZED_TYPE:\n-                return parseParameterizedTypeKeyword();\n             case LOCK_KEYWORD:\n                 return parseLockKeyword();\n             case STRING_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0Nzk3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463547977", "bodyText": "This is not a keyword", "author": "SupunS", "createdAt": "2020-07-31T11:04:59Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -523,22 +327,163 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumMemberRhs((STNode) args[0], (STNode) args[1]);\n             case RECEIVE_FIELD:\n                 return parseReceiveField();\n-            case PUBLIC_KEYWORD:// 2 resume-points : parseObjectMemberVisibility()\n+            case PARAM_END:\n+                return parseParameterRhs();\n+            case ELLIPSIS:\n+                return parseEllipsis();\n+            case BINARY_OPERATOR:\n+                return parseBinaryOperator();\n+            case QUESTION_MARK:\n+                return parseQuestionMark();\n+            case COMPOUND_BINARY_OPERATOR:\n+                return parseCompoundBinaryOperator();\n+            case UNARY_OPERATOR:\n+                return parseUnaryOperator();\n+            case AT:\n+                return parseAtToken();\n+            case RIGHT_ARROW:\n+                return parseRightArrow();\n+            case ATTACH_POINT:\n+                return parseAnnotationAttachPoint();\n+            case PIPE:\n+                return parsePipeToken();\n+            case INTERPOLATION_START_TOKEN:\n+                return parseInterpolationStart();\n+            case LIST_MATCH_PATTERN_MEMBER_RHS:\n+                return parseListMatchPatternMemberRhs();\n+            case LIST_BINDING_PATTERN_MEMBER:\n+                return parseListBindingPatternMember();\n+            case FIELD_MATCH_PATTERN_MEMBER:\n+                return parseFieldMatchPatternMember();\n+            case FIELD_MATCH_PATTERN_MEMBER_RHS:\n+                return parseFieldMatchPatternRhs();\n+            case FUNC_MATCH_PATTERN_OR_CONST_PATTERN:\n+                return parseFunctionalMatchPatternOrConsPattern((STNode) args[0]);\n+            case ARG_MATCH_PATTERN:\n+                return parseArgMatchPattern();\n+            case ARG_MATCH_PATTERN_RHS:\n+                return parseArgMatchPatternRhs();\n+            case ARG_BINDING_PATTERN:\n+                return parseArgBindingPattern();\n+            case ARG_BINDING_PATTERN_END:\n+                return parseArgsBindingPatternEnd();\n+            case TABLE_ROW_END:\n+                return parseTableRowEnd();\n+            case LIST_BP_OR_LIST_CONSTRUCTOR_MEMBER:\n+                return parseListBindingPatternOrListConstructorMember();\n+            case TUPLE_TYPE_DESC_OR_LIST_CONST_MEMBER:\n+                return parseTupleTypeDescOrListConstructorMember((STNode) args[0]);\n+            case REMOTE_CALL_OR_ASYNC_SEND_END:\n+                return parseRemoteCallOrAsyncSendEnd((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n+            case RECEIVE_FIELD_END:\n+                return parseReceiveFieldEnd();\n+            case MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER:\n+                return parseMappingBindingPatterOrMappingConstructorMember();\n+            default:\n+                throw new IllegalStateException(\"cannot resume parsing the rule: \" + context);\n+        }\n+    }\n+\n+    public STNode resumeKeywordParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case EXTERNAL_KEYWORD:\n+                return parseExternalKeyword();\n+            case IF_KEYWORD:\n+                return parseIfKeyword();\n+            case ELSE_KEYWORD:\n+                return parseElseKeyword();\n+            case ELSE_BODY:\n+                return parseElseBody();\n+            case WHILE_KEYWORD:\n+                return parseWhileKeyword();\n+            case PANIC_KEYWORD:\n+                return parsePanicKeyword();\n+            case VERSION_KEYWORD:\n+                return parseVersionKeyword();\n+            case AS_KEYWORD:\n+                return parseAsKeyword();\n+            case CONTINUE_KEYWORD:\n+                return parseContinueKeyword();\n+            case BREAK_KEYWORD:\n+                return parseBreakKeyword();\n+            case RETURN_KEYWORD:\n+                return parseReturnKeyword();\n+            case ON_KEYWORD:\n+                return parseOnKeyword();\n+            case RESOURCE_KEYWORD:\n+                return parseResourceKeyword();\n+            case TYPEOF_KEYWORD:\n+                return parseTypeofKeyword();\n+            case IS_KEYWORD:\n+                return parseIsKeyword();\n+            case SOURCE_KEYWORD:\n+                return parseSourceKeyword();\n+            case XMLNS_KEYWORD:\n+                return parseXMLNSKeyword();\n+            case WORKER_KEYWORD:\n+                return parseWorkerKeyword();\n+            case FORK_KEYWORD:\n+                return parseForkKeyword();\n+            case TRAP_KEYWORD:\n+                return parseTrapKeyword();\n+            case IN_KEYWORD:\n+                return parseInKeyword();\n+            case FOREACH_KEYWORD:\n+                return parseForEachKeyword();\n+            case TABLE_KEYWORD:\n+                return parseTableKeyword();\n+            case KEY_KEYWORD:\n+                return parseKeyKeyword();\n+            case TABLE_KEYWORD_RHS:\n+                return parseTableConstructorOrQuery((STNode) args[0], (boolean) args[1]);\n+            case ERROR_KEYWORD:\n+                return parseErrorKeyword();\n+            case LET_KEYWORD:\n+                return parseLetKeyword();\n+            case STREAM_KEYWORD:\n+                return parseStreamKeyword();\n+            case RETURNS_KEYWORD:\n+                return parseReturnsKeyword();\n+            case NEW_KEYWORD:\n+                return parseNewKeyword();\n+            case FROM_KEYWORD:\n+                return parseFromKeyword();\n+            case WHERE_KEYWORD:\n+                return parseWhereKeyword();\n+            case SELECT_KEYWORD:\n+                return parseSelectKeyword();\n+            case ORDER_KEYWORD:\n+                return parseOrderKeyword();\n+            case BY_KEYWORD:\n+                return parseByKeyword();\n+            case ASCENDING_KEYWORD:\n+                return parseAscendingKeyword();\n+            case DESCENDING_KEYWORD:\n+                return parseDescendingKeyword();\n+            case TRANSACTION_KEYWORD:\n+                return parseTransactionKeyword();\n+            case COMMIT_KEYWORD:\n+                return parseCommitKeyword();\n+            case RETRY_KEYWORD:\n+                return parseRetryKeyword();\n+            case ROLLBACK_KEYWORD:\n+                return parseRollbackKeyword();\n+            case WAIT_KEYWORD:\n+                return parseWaitKeyword();\n+            case DO_KEYWORD:\n+                return parseDoKeyword();\n+            case RETRY_KEYWORD_RHS:", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -136,256 +136,168 @@ public class BallerinaParser extends AbstractParser {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n-    @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        return resumeTopLevelNodeParsing(context, args);\n+        switch (context) {\n+            case TOP_LEVEL_NODE:\n+                return parseTopLevelNode();\n+            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n+                return parseTopLevelNode((STNode) args[0]);\n+            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n+                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_DECL_RHS:\n+                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_PREFIX:\n+                return parseImportPrefix();\n+            case IMPORT_MODULE_NAME:\n+            case IMPORT_ORG_OR_MODULE_NAME:\n+            case SERVICE_NAME:\n+            case MODULE_ENUM_NAME:\n+                return parseIdentifier(context);\n+            case IMPORT_VERSION_DECL:\n+                return parseVersion();\n+            case IMPORT_SUB_VERSION:\n+                return parseSubVersion(context);\n+            case IMPORT_PREFIX_DECL:\n+                return parseImportPrefixDecl();\n+            case FUNC_BODY:\n+                return parseFunctionBody((boolean) args[0]);\n+            case FUNC_NAME:\n+                return parseFunctionName();\n+            case FUNCTION_IDENT:\n+                return parseFunctionIdent();\n+            case FUNCTION_KEYWORD_RHS:\n+                return parseFunctionKeywordRhs((STNode) args[0], (STNode) args[1], (boolean) args[2],\n+                        (STNode[]) args[3]);\n+            case ANNOT_REFERENCE:\n+            case RECORD_FIELD_NAME_OR_TYPE_NAME:\n+                return parseQualifiedIdentifier(context, (boolean) args[0]);\n+            case RECORD_BODY_START:\n+                return parseRecordBodyStartDelimiter();\n+            case RECORD_FIELD_OR_RECORD_END:\n+                return parseFieldOrRestDescriptor((boolean) args[0]);\n+            case CLOSED_RECORD_BODY_START:\n+                return parseClosedRecordBodyStart();\n+            case CLOSED_RECORD_BODY_END:\n+                return parseClosedRecordBodyEnd();\n+            case RECORD_BODY_END: // ideally this is never getting called\n+                return parseRecordBodyCloseDelimiter((SyntaxKind) args[0]);\n+            case OBJECT_MEMBER_START:\n+                return parseObjectMember();\n+            case OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY:\n+                return parseObjectMethodOrField((STNode) args[0], (STNode) args[1]);\n+            case OBJECT_FIELD_RHS:\n+                return parseObjectFieldRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case OBJECT_TYPE_QUALIFIER:\n+                return parseObjectTypeQualifiers();\n+            case IDENT_AFTER_OBJECT_IDENT:\n+                return parseIdentAfterObjectIdent();\n+            case OBJECT_MEMBER_WITHOUT_METADATA:\n+                return parseObjectMember((STNode) args[0]);\n+            case OPTIONAL_SERVICE_NAME:\n+                return parseServiceName();\n+            case CONST_DECL_RHS:\n+                return parseConstantOrListenerDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (boolean) args[4]);\n+            case XML_NAMESPACE_PREFIX_DECL:\n+                return parseXMLDeclRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case XML_ATOMIC_NAME_PATTERN_START:\n+                return parseXMLAtomicNamePatternBody();\n+            case ANNOTATION_KEYWORD:\n+                return parseAnnotationKeyword();\n+            case ANNOT_DECL_OPTIONAL_TYPE:\n+                return parseAnnotationDeclFromType((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3]);\n+            case ANNOT_DECL_RHS:\n+                return parseAnnotationDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case ANNOT_OPTIONAL_ATTACH_POINTS:\n+                return parseAnnotationDeclAttachPoints((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (STNode) args[4], (STNode) args[5]);\n+            case ANNOT_CHAINING_TOKEN:\n+                return parseAnnotChainingToken();\n+            case ANNOTATION_TAG:\n+                return parseAnnotationTag();\n+            case EXTERNAL_FUNC_BODY_OPTIONAL_ANNOTS:\n+                return parseExternalFuncBodyRhs((STNode) args[0]);\n+            default:\n+                return resumeStatementNodeParsing(context, args);\n+        }\n     }\n \n-    public STNode resumeOtherNodesParsing(ParserRuleContext context, Object... args) {\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n-            case OPEN_BRACE:\n-                return parseOpenBrace();\n-            case CLOSE_BRACE:\n-                return parseCloseBrace();\n-            case OPEN_PARENTHESIS:\n-            case ARG_LIST_START:\n-                return parseOpenParenthesis(context);\n-            case SIMPLE_TYPE_DESCRIPTOR:\n-                return parseSimpleTypeDescriptor();\n-            case ASSIGN_OP:\n-                return parseAssignOp();\n-            case SEMICOLON:\n-                return parseSemicolon();\n-            case CLOSE_PARENTHESIS:\n-                return parseCloseParenthesis();\n-            case VARIABLE_NAME:\n-                return parseVariableName();\n-            case PARAMETER_START:\n-                return parseParameter((SyntaxKind) args[0], (STNode) args[1], (int) args[2], (boolean) args[3]);\n-            case PARAMETER_WITHOUT_ANNOTS:\n-                return parseParamGivenAnnots((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (int) args[3],\n-                        (boolean) args[4]);\n-            case AFTER_PARAMETER_TYPE:\n-                return parseAfterParamType((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (boolean) args[5]);\n-            case PARAMETER_NAME_RHS:\n-                return parseParameterRhs((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (STNode) args[5]);\n-            case TYPE_NAME_OR_VAR_NAME:\n-            case TYPE_REFERENCE:\n-            case FIELD_ACCESS_IDENTIFIER:\n-                return parseQualifiedIdentifier(context, (boolean) args[0]);\n-            case FIELD_DESCRIPTOR_RHS:\n-                return parseFieldDescriptorRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3]);\n-            case TYPE_DESCRIPTOR:\n-                return parseTypeDescriptorInternal((ParserRuleContext) args[0], (boolean) args[1]);\n-            case TYPE_NAME:\n-                return parseTypeName();\n-            case VARIABLE_REF:\n-            case IMPLICIT_ANON_FUNC_PARAM:\n-            case MAPPING_FIELD_NAME:\n-            case RECEIVE_FIELD_NAME:\n-            case ENUM_MEMBER_NAME:\n-                return parseIdentifier(context);\n-            case SLASH:\n-                return parseSlashToken();\n-            case DOT:\n-                return parseDotToken();\n-            case VERSION_NUMBER:\n-                return parseVersionNumber();\n-            case DECIMAL_INTEGER_LITERAL:\n-            case MAJOR_VERSION:\n-            case MINOR_VERSION:\n-            case PATCH_VERSION:\n-                return parseDecimalIntLiteral(context);\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            case TABLE_KEYWORD_RHS:\n+                return parseTableConstructorOrQuery((STNode) args[0], (boolean) args[1]);\n+            case RETRY_KEYWORD_RHS:\n+                return parseRetryKeywordRhs((STNode) args[0]);\n             case MAPPING_FIELD:\n             case FIRST_MAPPING_FIELD:\n                 return parseMappingField((ParserRuleContext) args[0]);\n             case SPECIFIC_FIELD_RHS:\n                 return parseSpecificFieldRhs((STNode) args[0], (STNode) args[1]);\n-            case FIELD_BINDING_PATTERN_END:\n-                return parseMappingFieldRhs((STNode) args[0]);\n-            case STRING_LITERAL:\n-                return parseStringLiteral();\n-            case COLON:\n-                return parseColon();\n-            case OPEN_BRACKET:\n-                return parseOpenBracket();\n-            case RESOURCE_DEF:\n-                return parseResource();\n-            case ARRAY_LENGTH:\n-                return parseArrayLength();\n-            case COMMA:\n-                return parseComma();\n-            case CONST_DECL_TYPE:\n-                return parseConstDecl((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case LT:\n-                return parseLTToken();\n-            case GT:\n-                return parseGTToken();\n-            case ATTACH_POINT_IDENT:\n-                return parseAttachPointIdent((STNode) args[0]);\n-            case FIELD_IDENT:\n-                return parseFieldIdent();\n-            case ATTACH_POINT_END:\n-                return parseAttachPointEnd();\n-            case NAMESPACE_PREFIX:\n-                return parseNamespacePrefix();\n-            case WORKER_NAME:\n-                return parseWorkerName();\n-            case STREAM_TYPE_FIRST_PARAM_RHS:\n-                return parseStreamTypeParamsNode((STNode) args[0], (STNode) args[1]);\n-            case TEMPLATE_START:\n-            case TEMPLATE_END:\n-                return parseBacktickToken(context);\n-            case KEY_CONSTRAINTS_RHS:\n-                return parseKeyConstraint((STNode) args[0]);\n-            case ORDER_KEY_LIST_END:\n-                return parseOrderKeyListMemberEnd();\n-            case TABLE_CONSTRUCTOR_OR_QUERY_START:\n-                return parseTableConstructorOrQuery((boolean) args[0]);\n-            case TABLE_CONSTRUCTOR_OR_QUERY_RHS:\n-                return parseTableConstructorOrQueryRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n-            case QUERY_PIPELINE_RHS:\n-                return parseIntermediateClause((boolean) args[0]);\n-            case ANON_FUNC_BODY:\n-                return parseAnonFuncBody((boolean) args[0]);\n-            case CLOSE_BRACKET:\n-                return parseCloseBracket();\n-            case ARG_START:\n-                return parseArgument();\n-            case ARG_END:\n-                return parseArgEnd();\n-            case MAPPING_FIELD_END:\n-                return parseMappingFieldEnd();\n-            case FIELD_OR_REST_DESCIPTOR_RHS:\n-                return parseFieldOrRestDescriptorRhs((STNode) args[0], (STNode) args[1]);\n-            case TYPE_DESC_IN_TUPLE_RHS:\n-                return parseTupleMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER_END:\n-                return parseListBindingPatternMemberRhs();\n-            case MAPPING_BINDING_PATTERN_END:\n-                return parseMappingBindingPatternEnd();\n-            case FIELD_BINDING_PATTERN_NAME:\n-                return parseFieldBindingPattern();\n-            case LIST_CONSTRUCTOR_MEMBER_END:\n-                return parseListConstructorMemberEnd();\n-            case NIL_OR_PARENTHESISED_TYPE_DESC_RHS:\n-                return parseNilOrParenthesisedTypeDescRhs((STNode) args[0]);\n-            case ANON_FUNC_PARAM_RHS:\n-                return parseImplicitAnonFuncParamEnd();\n-            case BINDING_PATTERN:\n-                return parseBindingPattern();\n-            case PEER_WORKER_NAME:\n-                return parsePeerWorkerName();\n-            case SYNC_SEND_TOKEN:\n-                return parseSyncSendToken();\n-            case LEFT_ARROW_TOKEN:\n-                return parseLeftArrowToken();\n-            case RECEIVE_WORKERS:\n-                return parseReceiveWorkers();\n-            case WAIT_FIELD_NAME:\n-                return parseWaitField();\n-            case WAIT_FIELD_END:\n-                return parseWaitFieldEnd();\n-            case OPTIONAL_CHAINING_TOKEN:\n-                return parseOptionalChainingToken();\n-            case RETRY_TYPE_PARAM_RHS:\n-                return parseRetryTypeParamRhs((STNode) args[0], (STNode) args[1]);\n-            case RETRY_BODY:\n-                return parseRetryBody();\n-            case ENUM_MEMBER_END:\n-                return parseEnumMemberEnd();\n-            case BRACKETED_LIST_MEMBER_END:\n-                return parseBracketedListMemberEnd();\n-            case TYPED_BINDING_PATTERN_TYPE_RHS:\n-                return parseTypedBindingPatternTypeRhs((STNode) args[0], (ParserRuleContext) args[1],\n-                        (boolean) args[2]);\n-            case BRACKETED_LIST_RHS:\n-                return parseTypedBindingPatternOrMemberAccessRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n-                        (STNode) args[3], (boolean) args[4], (boolean) args[5], (ParserRuleContext) args[6]);\n-            case UNION_OR_INTERSECTION_TOKEN:\n-                return parseUnionOrIntersectionToken();\n-            case BRACKETED_LIST_MEMBER:\n-            case LIST_BINDING_MEMBER_OR_ARRAY_LENGTH:\n-                return parseBracketedListMember((boolean) args[0]);\n-            case DOT_LT_TOKEN:\n-                return parseDotLTToken();\n-            case SLASH_LT_TOKEN:\n-                return parseSlashLTToken();\n-            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n-                return parseDoubleSlashDoubleAsteriskLTToken();\n-            case SPECIFIC_FIELD:\n-                return parseSpecificField((STNode) args[0]);\n-            case OPTIONAL_MATCH_GUARD:\n-                return parseMatchGuard();\n-            case MATCH_PATTERN_START:\n-                return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n-                return parseMatchPatternEnd();\n-            case ENUM_MEMBER_RHS:\n-                return parseEnumMemberRhs((STNode) args[0], (STNode) args[1]);\n-            case RECEIVE_FIELD:\n-                return parseReceiveField();\n-            case PARAM_END:\n-                return parseParameterRhs();\n-            case ELLIPSIS:\n-                return parseEllipsis();\n-            case BINARY_OPERATOR:\n-                return parseBinaryOperator();\n-            case QUESTION_MARK:\n-                return parseQuestionMark();\n-            case COMPOUND_BINARY_OPERATOR:\n-                return parseCompoundBinaryOperator();\n-            case UNARY_OPERATOR:\n-                return parseUnaryOperator();\n-            case AT:\n-                return parseAtToken();\n-            case RIGHT_ARROW:\n-                return parseRightArrow();\n-            case ATTACH_POINT:\n-                return parseAnnotationAttachPoint();\n-            case PIPE:\n-                return parsePipeToken();\n-            case INTERPOLATION_START_TOKEN:\n-                return parseInterpolationStart();\n-            case LIST_MATCH_PATTERN_MEMBER_RHS:\n-                return parseListMatchPatternMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER:\n-                return parseListBindingPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER:\n-                return parseFieldMatchPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER_RHS:\n-                return parseFieldMatchPatternRhs();\n-            case FUNC_MATCH_PATTERN_OR_CONST_PATTERN:\n-                return parseFunctionalMatchPatternOrConsPattern((STNode) args[0]);\n-            case ARG_MATCH_PATTERN:\n-                return parseArgMatchPattern();\n-            case ARG_MATCH_PATTERN_RHS:\n-                return parseArgMatchPatternRhs();\n-            case ARG_BINDING_PATTERN:\n-                return parseArgBindingPattern();\n-            case ARG_BINDING_PATTERN_END:\n-                return parseArgsBindingPatternEnd();\n-            case TABLE_ROW_END:\n-                return parseTableRowEnd();\n-            case LIST_BP_OR_LIST_CONSTRUCTOR_MEMBER:\n-                return parseListBindingPatternOrListConstructorMember();\n-            case TUPLE_TYPE_DESC_OR_LIST_CONST_MEMBER:\n-                return parseTupleTypeDescOrListConstructorMember((STNode) args[0]);\n-            case REMOTE_CALL_OR_ASYNC_SEND_END:\n-                return parseRemoteCallOrAsyncSendEnd((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case RECEIVE_FIELD_END:\n-                return parseReceiveFieldEnd();\n-            case MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER:\n-                return parseMappingBindingPatterOrMappingConstructorMember();\n             default:\n-                throw new IllegalStateException(\"cannot resume parsing the rule: \" + context);\n+                return resumeKeywordParsing(context, args);\n         }\n     }\n \n     public STNode resumeKeywordParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n+            case OBJECT_KEYWORD:\n+                return parseObjectKeyword();\n+            case LISTENER_KEYWORD:\n+                return parseListenerKeyword();\n+            case SERVICE_KEYWORD:\n+                return parseServiceKeyword();\n+            case CONST_KEYWORD:\n+                return parseConstantKeyword();\n+            case XML_KEYWORD:\n+                return parseXMLKeyword();\n+            case RECORD_KEYWORD:\n+                return parseRecordKeyword();\n+            case FUNCTION_KEYWORD:\n+                return parseFunctionKeyword();\n+            case IMPORT_KEYWORD:\n+                return parseImportKeyword();\n             case EXTERNAL_KEYWORD:\n                 return parseExternalKeyword();\n             case IF_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0ODA3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463548077", "bodyText": "Not a keyword", "author": "SupunS", "createdAt": "2020-07-31T11:05:15Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -594,41 +506,167 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n+            case PARAMETERIZED_TYPE:", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -506,8 +414,6 @@ public class BallerinaParser extends AbstractParser {\n                 return parseEnumKeyword();\n             case MATCH_KEYWORD:\n                 return parseMatchKeyword();\n-            case PARAMETERIZED_TYPE:\n-                return parseParameterizedTypeKeyword();\n             case LOCK_KEYWORD:\n                 return parseLockKeyword();\n             case STRING_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0ODc4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463548781", "bodyText": "Whats the size of this method after refactoring?\nShould we separate out syntax tokens (semicolons, commas, etc) as well?", "author": "SupunS", "createdAt": "2020-07-31T11:07:09Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -138,41 +138,28 @@ public STNode parse(ParserRuleContext context) {\n      */\n     @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        // TODO: revisit the commented resume-points\n+        return resumeTopLevelNodeParsing(context, args);\n+    }\n+\n+    public STNode resumeOtherNodesParsing(ParserRuleContext context, Object... args) {", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1MzAxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463553018", "bodyText": "I think that ll be a good idea, resumeothernodes is about 300 lines long.", "author": "m36dot", "createdAt": "2020-07-31T11:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0ODc4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -136,256 +136,168 @@ public class BallerinaParser extends AbstractParser {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n-    @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        return resumeTopLevelNodeParsing(context, args);\n+        switch (context) {\n+            case TOP_LEVEL_NODE:\n+                return parseTopLevelNode();\n+            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n+                return parseTopLevelNode((STNode) args[0]);\n+            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n+                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_DECL_RHS:\n+                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_PREFIX:\n+                return parseImportPrefix();\n+            case IMPORT_MODULE_NAME:\n+            case IMPORT_ORG_OR_MODULE_NAME:\n+            case SERVICE_NAME:\n+            case MODULE_ENUM_NAME:\n+                return parseIdentifier(context);\n+            case IMPORT_VERSION_DECL:\n+                return parseVersion();\n+            case IMPORT_SUB_VERSION:\n+                return parseSubVersion(context);\n+            case IMPORT_PREFIX_DECL:\n+                return parseImportPrefixDecl();\n+            case FUNC_BODY:\n+                return parseFunctionBody((boolean) args[0]);\n+            case FUNC_NAME:\n+                return parseFunctionName();\n+            case FUNCTION_IDENT:\n+                return parseFunctionIdent();\n+            case FUNCTION_KEYWORD_RHS:\n+                return parseFunctionKeywordRhs((STNode) args[0], (STNode) args[1], (boolean) args[2],\n+                        (STNode[]) args[3]);\n+            case ANNOT_REFERENCE:\n+            case RECORD_FIELD_NAME_OR_TYPE_NAME:\n+                return parseQualifiedIdentifier(context, (boolean) args[0]);\n+            case RECORD_BODY_START:\n+                return parseRecordBodyStartDelimiter();\n+            case RECORD_FIELD_OR_RECORD_END:\n+                return parseFieldOrRestDescriptor((boolean) args[0]);\n+            case CLOSED_RECORD_BODY_START:\n+                return parseClosedRecordBodyStart();\n+            case CLOSED_RECORD_BODY_END:\n+                return parseClosedRecordBodyEnd();\n+            case RECORD_BODY_END: // ideally this is never getting called\n+                return parseRecordBodyCloseDelimiter((SyntaxKind) args[0]);\n+            case OBJECT_MEMBER_START:\n+                return parseObjectMember();\n+            case OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY:\n+                return parseObjectMethodOrField((STNode) args[0], (STNode) args[1]);\n+            case OBJECT_FIELD_RHS:\n+                return parseObjectFieldRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case OBJECT_TYPE_QUALIFIER:\n+                return parseObjectTypeQualifiers();\n+            case IDENT_AFTER_OBJECT_IDENT:\n+                return parseIdentAfterObjectIdent();\n+            case OBJECT_MEMBER_WITHOUT_METADATA:\n+                return parseObjectMember((STNode) args[0]);\n+            case OPTIONAL_SERVICE_NAME:\n+                return parseServiceName();\n+            case CONST_DECL_RHS:\n+                return parseConstantOrListenerDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (boolean) args[4]);\n+            case XML_NAMESPACE_PREFIX_DECL:\n+                return parseXMLDeclRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case XML_ATOMIC_NAME_PATTERN_START:\n+                return parseXMLAtomicNamePatternBody();\n+            case ANNOTATION_KEYWORD:\n+                return parseAnnotationKeyword();\n+            case ANNOT_DECL_OPTIONAL_TYPE:\n+                return parseAnnotationDeclFromType((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3]);\n+            case ANNOT_DECL_RHS:\n+                return parseAnnotationDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case ANNOT_OPTIONAL_ATTACH_POINTS:\n+                return parseAnnotationDeclAttachPoints((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (STNode) args[4], (STNode) args[5]);\n+            case ANNOT_CHAINING_TOKEN:\n+                return parseAnnotChainingToken();\n+            case ANNOTATION_TAG:\n+                return parseAnnotationTag();\n+            case EXTERNAL_FUNC_BODY_OPTIONAL_ANNOTS:\n+                return parseExternalFuncBodyRhs((STNode) args[0]);\n+            default:\n+                return resumeStatementNodeParsing(context, args);\n+        }\n     }\n \n-    public STNode resumeOtherNodesParsing(ParserRuleContext context, Object... args) {\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n-            case OPEN_BRACE:\n-                return parseOpenBrace();\n-            case CLOSE_BRACE:\n-                return parseCloseBrace();\n-            case OPEN_PARENTHESIS:\n-            case ARG_LIST_START:\n-                return parseOpenParenthesis(context);\n-            case SIMPLE_TYPE_DESCRIPTOR:\n-                return parseSimpleTypeDescriptor();\n-            case ASSIGN_OP:\n-                return parseAssignOp();\n-            case SEMICOLON:\n-                return parseSemicolon();\n-            case CLOSE_PARENTHESIS:\n-                return parseCloseParenthesis();\n-            case VARIABLE_NAME:\n-                return parseVariableName();\n-            case PARAMETER_START:\n-                return parseParameter((SyntaxKind) args[0], (STNode) args[1], (int) args[2], (boolean) args[3]);\n-            case PARAMETER_WITHOUT_ANNOTS:\n-                return parseParamGivenAnnots((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (int) args[3],\n-                        (boolean) args[4]);\n-            case AFTER_PARAMETER_TYPE:\n-                return parseAfterParamType((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (boolean) args[5]);\n-            case PARAMETER_NAME_RHS:\n-                return parseParameterRhs((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (STNode) args[5]);\n-            case TYPE_NAME_OR_VAR_NAME:\n-            case TYPE_REFERENCE:\n-            case FIELD_ACCESS_IDENTIFIER:\n-                return parseQualifiedIdentifier(context, (boolean) args[0]);\n-            case FIELD_DESCRIPTOR_RHS:\n-                return parseFieldDescriptorRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3]);\n-            case TYPE_DESCRIPTOR:\n-                return parseTypeDescriptorInternal((ParserRuleContext) args[0], (boolean) args[1]);\n-            case TYPE_NAME:\n-                return parseTypeName();\n-            case VARIABLE_REF:\n-            case IMPLICIT_ANON_FUNC_PARAM:\n-            case MAPPING_FIELD_NAME:\n-            case RECEIVE_FIELD_NAME:\n-            case ENUM_MEMBER_NAME:\n-                return parseIdentifier(context);\n-            case SLASH:\n-                return parseSlashToken();\n-            case DOT:\n-                return parseDotToken();\n-            case VERSION_NUMBER:\n-                return parseVersionNumber();\n-            case DECIMAL_INTEGER_LITERAL:\n-            case MAJOR_VERSION:\n-            case MINOR_VERSION:\n-            case PATCH_VERSION:\n-                return parseDecimalIntLiteral(context);\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            case TABLE_KEYWORD_RHS:\n+                return parseTableConstructorOrQuery((STNode) args[0], (boolean) args[1]);\n+            case RETRY_KEYWORD_RHS:\n+                return parseRetryKeywordRhs((STNode) args[0]);\n             case MAPPING_FIELD:\n             case FIRST_MAPPING_FIELD:\n                 return parseMappingField((ParserRuleContext) args[0]);\n             case SPECIFIC_FIELD_RHS:\n                 return parseSpecificFieldRhs((STNode) args[0], (STNode) args[1]);\n-            case FIELD_BINDING_PATTERN_END:\n-                return parseMappingFieldRhs((STNode) args[0]);\n-            case STRING_LITERAL:\n-                return parseStringLiteral();\n-            case COLON:\n-                return parseColon();\n-            case OPEN_BRACKET:\n-                return parseOpenBracket();\n-            case RESOURCE_DEF:\n-                return parseResource();\n-            case ARRAY_LENGTH:\n-                return parseArrayLength();\n-            case COMMA:\n-                return parseComma();\n-            case CONST_DECL_TYPE:\n-                return parseConstDecl((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case LT:\n-                return parseLTToken();\n-            case GT:\n-                return parseGTToken();\n-            case ATTACH_POINT_IDENT:\n-                return parseAttachPointIdent((STNode) args[0]);\n-            case FIELD_IDENT:\n-                return parseFieldIdent();\n-            case ATTACH_POINT_END:\n-                return parseAttachPointEnd();\n-            case NAMESPACE_PREFIX:\n-                return parseNamespacePrefix();\n-            case WORKER_NAME:\n-                return parseWorkerName();\n-            case STREAM_TYPE_FIRST_PARAM_RHS:\n-                return parseStreamTypeParamsNode((STNode) args[0], (STNode) args[1]);\n-            case TEMPLATE_START:\n-            case TEMPLATE_END:\n-                return parseBacktickToken(context);\n-            case KEY_CONSTRAINTS_RHS:\n-                return parseKeyConstraint((STNode) args[0]);\n-            case ORDER_KEY_LIST_END:\n-                return parseOrderKeyListMemberEnd();\n-            case TABLE_CONSTRUCTOR_OR_QUERY_START:\n-                return parseTableConstructorOrQuery((boolean) args[0]);\n-            case TABLE_CONSTRUCTOR_OR_QUERY_RHS:\n-                return parseTableConstructorOrQueryRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n-            case QUERY_PIPELINE_RHS:\n-                return parseIntermediateClause((boolean) args[0]);\n-            case ANON_FUNC_BODY:\n-                return parseAnonFuncBody((boolean) args[0]);\n-            case CLOSE_BRACKET:\n-                return parseCloseBracket();\n-            case ARG_START:\n-                return parseArgument();\n-            case ARG_END:\n-                return parseArgEnd();\n-            case MAPPING_FIELD_END:\n-                return parseMappingFieldEnd();\n-            case FIELD_OR_REST_DESCIPTOR_RHS:\n-                return parseFieldOrRestDescriptorRhs((STNode) args[0], (STNode) args[1]);\n-            case TYPE_DESC_IN_TUPLE_RHS:\n-                return parseTupleMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER_END:\n-                return parseListBindingPatternMemberRhs();\n-            case MAPPING_BINDING_PATTERN_END:\n-                return parseMappingBindingPatternEnd();\n-            case FIELD_BINDING_PATTERN_NAME:\n-                return parseFieldBindingPattern();\n-            case LIST_CONSTRUCTOR_MEMBER_END:\n-                return parseListConstructorMemberEnd();\n-            case NIL_OR_PARENTHESISED_TYPE_DESC_RHS:\n-                return parseNilOrParenthesisedTypeDescRhs((STNode) args[0]);\n-            case ANON_FUNC_PARAM_RHS:\n-                return parseImplicitAnonFuncParamEnd();\n-            case BINDING_PATTERN:\n-                return parseBindingPattern();\n-            case PEER_WORKER_NAME:\n-                return parsePeerWorkerName();\n-            case SYNC_SEND_TOKEN:\n-                return parseSyncSendToken();\n-            case LEFT_ARROW_TOKEN:\n-                return parseLeftArrowToken();\n-            case RECEIVE_WORKERS:\n-                return parseReceiveWorkers();\n-            case WAIT_FIELD_NAME:\n-                return parseWaitField();\n-            case WAIT_FIELD_END:\n-                return parseWaitFieldEnd();\n-            case OPTIONAL_CHAINING_TOKEN:\n-                return parseOptionalChainingToken();\n-            case RETRY_TYPE_PARAM_RHS:\n-                return parseRetryTypeParamRhs((STNode) args[0], (STNode) args[1]);\n-            case RETRY_BODY:\n-                return parseRetryBody();\n-            case ENUM_MEMBER_END:\n-                return parseEnumMemberEnd();\n-            case BRACKETED_LIST_MEMBER_END:\n-                return parseBracketedListMemberEnd();\n-            case TYPED_BINDING_PATTERN_TYPE_RHS:\n-                return parseTypedBindingPatternTypeRhs((STNode) args[0], (ParserRuleContext) args[1],\n-                        (boolean) args[2]);\n-            case BRACKETED_LIST_RHS:\n-                return parseTypedBindingPatternOrMemberAccessRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n-                        (STNode) args[3], (boolean) args[4], (boolean) args[5], (ParserRuleContext) args[6]);\n-            case UNION_OR_INTERSECTION_TOKEN:\n-                return parseUnionOrIntersectionToken();\n-            case BRACKETED_LIST_MEMBER:\n-            case LIST_BINDING_MEMBER_OR_ARRAY_LENGTH:\n-                return parseBracketedListMember((boolean) args[0]);\n-            case DOT_LT_TOKEN:\n-                return parseDotLTToken();\n-            case SLASH_LT_TOKEN:\n-                return parseSlashLTToken();\n-            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n-                return parseDoubleSlashDoubleAsteriskLTToken();\n-            case SPECIFIC_FIELD:\n-                return parseSpecificField((STNode) args[0]);\n-            case OPTIONAL_MATCH_GUARD:\n-                return parseMatchGuard();\n-            case MATCH_PATTERN_START:\n-                return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n-                return parseMatchPatternEnd();\n-            case ENUM_MEMBER_RHS:\n-                return parseEnumMemberRhs((STNode) args[0], (STNode) args[1]);\n-            case RECEIVE_FIELD:\n-                return parseReceiveField();\n-            case PARAM_END:\n-                return parseParameterRhs();\n-            case ELLIPSIS:\n-                return parseEllipsis();\n-            case BINARY_OPERATOR:\n-                return parseBinaryOperator();\n-            case QUESTION_MARK:\n-                return parseQuestionMark();\n-            case COMPOUND_BINARY_OPERATOR:\n-                return parseCompoundBinaryOperator();\n-            case UNARY_OPERATOR:\n-                return parseUnaryOperator();\n-            case AT:\n-                return parseAtToken();\n-            case RIGHT_ARROW:\n-                return parseRightArrow();\n-            case ATTACH_POINT:\n-                return parseAnnotationAttachPoint();\n-            case PIPE:\n-                return parsePipeToken();\n-            case INTERPOLATION_START_TOKEN:\n-                return parseInterpolationStart();\n-            case LIST_MATCH_PATTERN_MEMBER_RHS:\n-                return parseListMatchPatternMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER:\n-                return parseListBindingPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER:\n-                return parseFieldMatchPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER_RHS:\n-                return parseFieldMatchPatternRhs();\n-            case FUNC_MATCH_PATTERN_OR_CONST_PATTERN:\n-                return parseFunctionalMatchPatternOrConsPattern((STNode) args[0]);\n-            case ARG_MATCH_PATTERN:\n-                return parseArgMatchPattern();\n-            case ARG_MATCH_PATTERN_RHS:\n-                return parseArgMatchPatternRhs();\n-            case ARG_BINDING_PATTERN:\n-                return parseArgBindingPattern();\n-            case ARG_BINDING_PATTERN_END:\n-                return parseArgsBindingPatternEnd();\n-            case TABLE_ROW_END:\n-                return parseTableRowEnd();\n-            case LIST_BP_OR_LIST_CONSTRUCTOR_MEMBER:\n-                return parseListBindingPatternOrListConstructorMember();\n-            case TUPLE_TYPE_DESC_OR_LIST_CONST_MEMBER:\n-                return parseTupleTypeDescOrListConstructorMember((STNode) args[0]);\n-            case REMOTE_CALL_OR_ASYNC_SEND_END:\n-                return parseRemoteCallOrAsyncSendEnd((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case RECEIVE_FIELD_END:\n-                return parseReceiveFieldEnd();\n-            case MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER:\n-                return parseMappingBindingPatterOrMappingConstructorMember();\n             default:\n-                throw new IllegalStateException(\"cannot resume parsing the rule: \" + context);\n+                return resumeKeywordParsing(context, args);\n         }\n     }\n \n     public STNode resumeKeywordParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n+            case OBJECT_KEYWORD:\n+                return parseObjectKeyword();\n+            case LISTENER_KEYWORD:\n+                return parseListenerKeyword();\n+            case SERVICE_KEYWORD:\n+                return parseServiceKeyword();\n+            case CONST_KEYWORD:\n+                return parseConstantKeyword();\n+            case XML_KEYWORD:\n+                return parseXMLKeyword();\n+            case RECORD_KEYWORD:\n+                return parseRecordKeyword();\n+            case FUNCTION_KEYWORD:\n+                return parseFunctionKeyword();\n+            case IMPORT_KEYWORD:\n+                return parseImportKeyword();\n             case EXTERNAL_KEYWORD:\n                 return parseExternalKeyword();\n             case IF_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0OTM5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463549391", "bodyText": "These mapping field related stuff are part of mapping constructor.Think these should go under resume expressions method ?\nThere are few other such cases.", "author": "SupunS", "createdAt": "2020-07-31T11:08:50Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -184,97 +171,40 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n             case PARAMETER_NAME_RHS:\n                 return parseParameterRhs((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n                         (STNode) args[4], (STNode) args[5]);\n-            case TOP_LEVEL_NODE:\n-                return parseTopLevelNode();\n-            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n-                return parseTopLevelNode((STNode) args[0]);\n-            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n-                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n             case TYPE_NAME_OR_VAR_NAME:\n-            case RECORD_FIELD_NAME_OR_TYPE_NAME:\n             case TYPE_REFERENCE:\n-            case ANNOT_REFERENCE:\n             case FIELD_ACCESS_IDENTIFIER:\n                 return parseQualifiedIdentifier(context, (boolean) args[0]);\n-            case VAR_DECL_STMT_RHS:\n-                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n             case FIELD_DESCRIPTOR_RHS:\n                 return parseFieldDescriptorRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3]);\n-            case RECORD_BODY_START:\n-                return parseRecordBodyStartDelimiter();\n             case TYPE_DESCRIPTOR:\n                 return parseTypeDescriptorInternal((ParserRuleContext) args[0], (boolean) args[1]);\n-            case OBJECT_MEMBER_START:\n-                return parseObjectMember();\n-            case OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY:\n-                return parseObjectMethodOrField((STNode) args[0], (STNode) args[1]);\n-            case OBJECT_FIELD_RHS:\n-                return parseObjectFieldRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4]);\n-            case OBJECT_TYPE_QUALIFIER:\n-                return parseObjectTypeQualifiers();\n-            case OBJECT_KEYWORD:\n-                return parseObjectKeyword();\n             case TYPE_NAME:\n                 return parseTypeName();\n-            case IF_KEYWORD:\n-                return parseIfKeyword();\n-            case ELSE_KEYWORD:\n-                return parseElseKeyword();\n-            case ELSE_BODY:\n-                return parseElseBody();\n-            case WHILE_KEYWORD:\n-                return parseWhileKeyword();\n-            case PANIC_KEYWORD:\n-                return parsePanicKeyword();\n-            case IMPORT_DECL_RHS:\n-                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n-            case IMPORT_PREFIX:\n-                return parseImportPrefix();\n-            case IMPORT_MODULE_NAME:\n-            case IMPORT_ORG_OR_MODULE_NAME:\n-            case VARIABLE_REF:// 2 resume-points : parseQualifiedIdentifier(context)\n-            case SERVICE_NAME:\n+            case VARIABLE_REF:\n             case IMPLICIT_ANON_FUNC_PARAM:\n             case MAPPING_FIELD_NAME:\n             case RECEIVE_FIELD_NAME:\n-            case MODULE_ENUM_NAME:\n             case ENUM_MEMBER_NAME:\n                 return parseIdentifier(context);\n-            case IMPORT_KEYWORD:\n-                return parseImportKeyword();\n             case SLASH:\n                 return parseSlashToken();\n             case DOT:\n                 return parseDotToken();\n-            case IMPORT_VERSION_DECL:\n-                return parseVersion();\n-            case VERSION_KEYWORD:\n-                return parseVersionKeyword();\n             case VERSION_NUMBER:\n                 return parseVersionNumber();\n             case DECIMAL_INTEGER_LITERAL:\n             case MAJOR_VERSION:\n             case MINOR_VERSION:\n             case PATCH_VERSION:\n                 return parseDecimalIntLiteral(context);\n-            case IMPORT_SUB_VERSION:\n-                return parseSubVersion(context);\n-            case IMPORT_PREFIX_DECL:\n-                return parseImportPrefixDecl();\n-            case AS_KEYWORD:\n-                return parseAsKeyword();\n-            case CONTINUE_KEYWORD:\n-                return parseContinueKeyword();\n-            case BREAK_KEYWORD:\n-                return parseBreakKeyword();\n-            case RETURN_KEYWORD:\n-                return parseReturnKeyword();\n             case MAPPING_FIELD:\n             case FIRST_MAPPING_FIELD:\n                 return parseMappingField((ParserRuleContext) args[0]);\n-            case SPECIFIC_FIELD_RHS:// 2 resume-points : parseMappingFieldRhs(key)\n+            case SPECIFIC_FIELD_RHS:", "originalCommit": "e47de2a07887eec88bad4be07682b5b702e95d7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NTI1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r463555254", "bodyText": "I ll look into it", "author": "m36dot", "createdAt": "2020-07-31T11:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0OTM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzg0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465033847", "bodyText": "@m36dot There are still some more places that we can merge. eg: statements/module-level nodes related stuff that are added under \"resumeOtherNodesParsing\".\nIs it possible to completely remove \"resumeOtherNodesParsing\" method?", "author": "SupunS", "createdAt": "2020-08-04T13:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0OTM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMDY1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465310658", "bodyText": "I am not sure if we can entirely remove resumeothernodesparsing method. Where should types and binding patterns be moved to?", "author": "m36dot", "createdAt": "2020-08-04T20:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0OTM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTQ1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465449452", "bodyText": "Can introduce a resume method for types?", "author": "SupunS", "createdAt": "2020-08-05T03:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0OTM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "942a12e88d2f68b598e11c7949f531249f4c191a", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8b50ac0a8bd..76a175f5af4 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -136,256 +136,168 @@ public class BallerinaParser extends AbstractParser {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n-    @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n-        return resumeTopLevelNodeParsing(context, args);\n+        switch (context) {\n+            case TOP_LEVEL_NODE:\n+                return parseTopLevelNode();\n+            case TOP_LEVEL_NODE_WITHOUT_METADATA:\n+                return parseTopLevelNode((STNode) args[0]);\n+            case TOP_LEVEL_NODE_WITHOUT_MODIFIER:\n+                return parseTopLevelNode((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_DECL_RHS:\n+                return parseImportDecl((STNode) args[0], (STNode) args[1]);\n+            case IMPORT_PREFIX:\n+                return parseImportPrefix();\n+            case IMPORT_MODULE_NAME:\n+            case IMPORT_ORG_OR_MODULE_NAME:\n+            case SERVICE_NAME:\n+            case MODULE_ENUM_NAME:\n+                return parseIdentifier(context);\n+            case IMPORT_VERSION_DECL:\n+                return parseVersion();\n+            case IMPORT_SUB_VERSION:\n+                return parseSubVersion(context);\n+            case IMPORT_PREFIX_DECL:\n+                return parseImportPrefixDecl();\n+            case FUNC_BODY:\n+                return parseFunctionBody((boolean) args[0]);\n+            case FUNC_NAME:\n+                return parseFunctionName();\n+            case FUNCTION_IDENT:\n+                return parseFunctionIdent();\n+            case FUNCTION_KEYWORD_RHS:\n+                return parseFunctionKeywordRhs((STNode) args[0], (STNode) args[1], (boolean) args[2],\n+                        (STNode[]) args[3]);\n+            case ANNOT_REFERENCE:\n+            case RECORD_FIELD_NAME_OR_TYPE_NAME:\n+                return parseQualifiedIdentifier(context, (boolean) args[0]);\n+            case RECORD_BODY_START:\n+                return parseRecordBodyStartDelimiter();\n+            case RECORD_FIELD_OR_RECORD_END:\n+                return parseFieldOrRestDescriptor((boolean) args[0]);\n+            case CLOSED_RECORD_BODY_START:\n+                return parseClosedRecordBodyStart();\n+            case CLOSED_RECORD_BODY_END:\n+                return parseClosedRecordBodyEnd();\n+            case RECORD_BODY_END: // ideally this is never getting called\n+                return parseRecordBodyCloseDelimiter((SyntaxKind) args[0]);\n+            case OBJECT_MEMBER_START:\n+                return parseObjectMember();\n+            case OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY:\n+                return parseObjectMethodOrField((STNode) args[0], (STNode) args[1]);\n+            case OBJECT_FIELD_RHS:\n+                return parseObjectFieldRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case OBJECT_TYPE_QUALIFIER:\n+                return parseObjectTypeQualifiers();\n+            case IDENT_AFTER_OBJECT_IDENT:\n+                return parseIdentAfterObjectIdent();\n+            case OBJECT_MEMBER_WITHOUT_METADATA:\n+                return parseObjectMember((STNode) args[0]);\n+            case OPTIONAL_SERVICE_NAME:\n+                return parseServiceName();\n+            case CONST_DECL_RHS:\n+                return parseConstantOrListenerDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (boolean) args[4]);\n+            case XML_NAMESPACE_PREFIX_DECL:\n+                return parseXMLDeclRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case XML_ATOMIC_NAME_PATTERN_START:\n+                return parseXMLAtomicNamePatternBody();\n+            case ANNOTATION_KEYWORD:\n+                return parseAnnotationKeyword();\n+            case ANNOT_DECL_OPTIONAL_TYPE:\n+                return parseAnnotationDeclFromType((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3]);\n+            case ANNOT_DECL_RHS:\n+                return parseAnnotationDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n+                        (STNode) args[4]);\n+            case ANNOT_OPTIONAL_ATTACH_POINTS:\n+                return parseAnnotationDeclAttachPoints((STNode) args[0], (STNode) args[1], (STNode) args[2],\n+                        (STNode) args[3], (STNode) args[4], (STNode) args[5]);\n+            case ANNOT_CHAINING_TOKEN:\n+                return parseAnnotChainingToken();\n+            case ANNOTATION_TAG:\n+                return parseAnnotationTag();\n+            case EXTERNAL_FUNC_BODY_OPTIONAL_ANNOTS:\n+                return parseExternalFuncBodyRhs((STNode) args[0]);\n+            default:\n+                return resumeStatementNodeParsing(context, args);\n+        }\n     }\n \n-    public STNode resumeOtherNodesParsing(ParserRuleContext context, Object... args) {\n+    public STNode resumeStatementNodeParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n-            case OPEN_BRACE:\n-                return parseOpenBrace();\n-            case CLOSE_BRACE:\n-                return parseCloseBrace();\n-            case OPEN_PARENTHESIS:\n-            case ARG_LIST_START:\n-                return parseOpenParenthesis(context);\n-            case SIMPLE_TYPE_DESCRIPTOR:\n-                return parseSimpleTypeDescriptor();\n-            case ASSIGN_OP:\n-                return parseAssignOp();\n-            case SEMICOLON:\n-                return parseSemicolon();\n-            case CLOSE_PARENTHESIS:\n-                return parseCloseParenthesis();\n-            case VARIABLE_NAME:\n-                return parseVariableName();\n-            case PARAMETER_START:\n-                return parseParameter((SyntaxKind) args[0], (STNode) args[1], (int) args[2], (boolean) args[3]);\n-            case PARAMETER_WITHOUT_ANNOTS:\n-                return parseParamGivenAnnots((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (int) args[3],\n-                        (boolean) args[4]);\n-            case AFTER_PARAMETER_TYPE:\n-                return parseAfterParamType((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (boolean) args[5]);\n-            case PARAMETER_NAME_RHS:\n-                return parseParameterRhs((SyntaxKind) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3],\n-                        (STNode) args[4], (STNode) args[5]);\n-            case TYPE_NAME_OR_VAR_NAME:\n-            case TYPE_REFERENCE:\n-            case FIELD_ACCESS_IDENTIFIER:\n-                return parseQualifiedIdentifier(context, (boolean) args[0]);\n-            case FIELD_DESCRIPTOR_RHS:\n-                return parseFieldDescriptorRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (STNode) args[3]);\n-            case TYPE_DESCRIPTOR:\n-                return parseTypeDescriptorInternal((ParserRuleContext) args[0], (boolean) args[1]);\n-            case TYPE_NAME:\n-                return parseTypeName();\n-            case VARIABLE_REF:\n-            case IMPLICIT_ANON_FUNC_PARAM:\n-            case MAPPING_FIELD_NAME:\n-            case RECEIVE_FIELD_NAME:\n-            case ENUM_MEMBER_NAME:\n-                return parseIdentifier(context);\n-            case SLASH:\n-                return parseSlashToken();\n-            case DOT:\n-                return parseDotToken();\n-            case VERSION_NUMBER:\n-                return parseVersionNumber();\n-            case DECIMAL_INTEGER_LITERAL:\n-            case MAJOR_VERSION:\n-            case MINOR_VERSION:\n-            case PATCH_VERSION:\n-                return parseDecimalIntLiteral(context);\n+            case STATEMENT:\n+                return parseStatement();\n+            case STATEMENT_WITHOUT_ANNOTS:\n+                return parseStatement((STNode) args[0]);\n+            case STMT_START_WITH_EXPR_RHS:\n+                return parseStatementStartWithExprRhs((STNode) args[0]);\n+            case STMT_START_BRACKETED_LIST_MEMBER:\n+                return parseStatementStartBracketedListMember();\n+            case VAR_DECL_STMT_RHS:\n+                return parseVarDeclRhs((STNode) args[0], (STNode) args[1], (STNode) args[2], (boolean) args[3]);\n+            default:\n+                return resumeActionOrExpressionNodesParsing(context, args);\n+        }\n+    }\n+\n+    public STNode resumeActionOrExpressionNodesParsing(ParserRuleContext context, Object... args) {\n+        switch (context) {\n+            case TERMINAL_EXPRESSION:\n+                return parseTerminalExpression((STNode) args[0], (boolean) args[1], (boolean) args[2],\n+                        (boolean) args[3]);\n+            case EXPRESSION_RHS:\n+                return parseExpressionRhs((OperatorPrecedence) args[0], (STNode) args[1], (boolean) args[2],\n+                        (boolean) args[3], (boolean) args[4], (boolean) args[5]);\n+            case CONSTANT_EXPRESSION_START:\n+                return parseSimpleConstExprInternal();\n+            case BINDING_PATTERN_OR_EXPR_RHS:\n+                return parseTypedBindingPatternOrExprRhs((STNode) args[0], (boolean) args[1]);\n+            case TYPE_DESC_OR_EXPR_RHS:\n+                return parseTypeDescOrExprRhs((STNode) args[0]);\n+            case WAIT_FUTURE_EXPR_END:\n+                return parseWaitFutureExprEnd((int) args[0]);\n+            case MEMBER_ACCESS_KEY_EXPR_END:\n+                return parseMemberAccessKeyExprEnd();\n+            case BRACED_EXPR_OR_ANON_FUNC_PARAM_RHS:\n+                return parseBracedExprOrAnonFuncParamRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n+            case EXPR_FUNC_BODY_START:\n+                return parseDoubleRightArrow();\n+            case REMOTE_CALL_OR_ASYNC_SEND_RHS:\n+                return parseRemoteCallOrAsyncSendActionRhs((STNode) args[0], (boolean) args[1], (STNode) args[2]);\n+            case TABLE_KEYWORD_RHS:\n+                return parseTableConstructorOrQuery((STNode) args[0], (boolean) args[1]);\n+            case RETRY_KEYWORD_RHS:\n+                return parseRetryKeywordRhs((STNode) args[0]);\n             case MAPPING_FIELD:\n             case FIRST_MAPPING_FIELD:\n                 return parseMappingField((ParserRuleContext) args[0]);\n             case SPECIFIC_FIELD_RHS:\n                 return parseSpecificFieldRhs((STNode) args[0], (STNode) args[1]);\n-            case FIELD_BINDING_PATTERN_END:\n-                return parseMappingFieldRhs((STNode) args[0]);\n-            case STRING_LITERAL:\n-                return parseStringLiteral();\n-            case COLON:\n-                return parseColon();\n-            case OPEN_BRACKET:\n-                return parseOpenBracket();\n-            case RESOURCE_DEF:\n-                return parseResource();\n-            case ARRAY_LENGTH:\n-                return parseArrayLength();\n-            case COMMA:\n-                return parseComma();\n-            case CONST_DECL_TYPE:\n-                return parseConstDecl((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case LT:\n-                return parseLTToken();\n-            case GT:\n-                return parseGTToken();\n-            case ATTACH_POINT_IDENT:\n-                return parseAttachPointIdent((STNode) args[0]);\n-            case FIELD_IDENT:\n-                return parseFieldIdent();\n-            case ATTACH_POINT_END:\n-                return parseAttachPointEnd();\n-            case NAMESPACE_PREFIX:\n-                return parseNamespacePrefix();\n-            case WORKER_NAME:\n-                return parseWorkerName();\n-            case STREAM_TYPE_FIRST_PARAM_RHS:\n-                return parseStreamTypeParamsNode((STNode) args[0], (STNode) args[1]);\n-            case TEMPLATE_START:\n-            case TEMPLATE_END:\n-                return parseBacktickToken(context);\n-            case KEY_CONSTRAINTS_RHS:\n-                return parseKeyConstraint((STNode) args[0]);\n-            case ORDER_KEY_LIST_END:\n-                return parseOrderKeyListMemberEnd();\n-            case TABLE_CONSTRUCTOR_OR_QUERY_START:\n-                return parseTableConstructorOrQuery((boolean) args[0]);\n-            case TABLE_CONSTRUCTOR_OR_QUERY_RHS:\n-                return parseTableConstructorOrQueryRhs((STNode) args[0], (STNode) args[1], (boolean) args[2]);\n-            case QUERY_PIPELINE_RHS:\n-                return parseIntermediateClause((boolean) args[0]);\n-            case ANON_FUNC_BODY:\n-                return parseAnonFuncBody((boolean) args[0]);\n-            case CLOSE_BRACKET:\n-                return parseCloseBracket();\n-            case ARG_START:\n-                return parseArgument();\n-            case ARG_END:\n-                return parseArgEnd();\n-            case MAPPING_FIELD_END:\n-                return parseMappingFieldEnd();\n-            case FIELD_OR_REST_DESCIPTOR_RHS:\n-                return parseFieldOrRestDescriptorRhs((STNode) args[0], (STNode) args[1]);\n-            case TYPE_DESC_IN_TUPLE_RHS:\n-                return parseTupleMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER_END:\n-                return parseListBindingPatternMemberRhs();\n-            case MAPPING_BINDING_PATTERN_END:\n-                return parseMappingBindingPatternEnd();\n-            case FIELD_BINDING_PATTERN_NAME:\n-                return parseFieldBindingPattern();\n-            case LIST_CONSTRUCTOR_MEMBER_END:\n-                return parseListConstructorMemberEnd();\n-            case NIL_OR_PARENTHESISED_TYPE_DESC_RHS:\n-                return parseNilOrParenthesisedTypeDescRhs((STNode) args[0]);\n-            case ANON_FUNC_PARAM_RHS:\n-                return parseImplicitAnonFuncParamEnd();\n-            case BINDING_PATTERN:\n-                return parseBindingPattern();\n-            case PEER_WORKER_NAME:\n-                return parsePeerWorkerName();\n-            case SYNC_SEND_TOKEN:\n-                return parseSyncSendToken();\n-            case LEFT_ARROW_TOKEN:\n-                return parseLeftArrowToken();\n-            case RECEIVE_WORKERS:\n-                return parseReceiveWorkers();\n-            case WAIT_FIELD_NAME:\n-                return parseWaitField();\n-            case WAIT_FIELD_END:\n-                return parseWaitFieldEnd();\n-            case OPTIONAL_CHAINING_TOKEN:\n-                return parseOptionalChainingToken();\n-            case RETRY_TYPE_PARAM_RHS:\n-                return parseRetryTypeParamRhs((STNode) args[0], (STNode) args[1]);\n-            case RETRY_BODY:\n-                return parseRetryBody();\n-            case ENUM_MEMBER_END:\n-                return parseEnumMemberEnd();\n-            case BRACKETED_LIST_MEMBER_END:\n-                return parseBracketedListMemberEnd();\n-            case TYPED_BINDING_PATTERN_TYPE_RHS:\n-                return parseTypedBindingPatternTypeRhs((STNode) args[0], (ParserRuleContext) args[1],\n-                        (boolean) args[2]);\n-            case BRACKETED_LIST_RHS:\n-                return parseTypedBindingPatternOrMemberAccessRhs((STNode) args[0], (STNode) args[1], (STNode) args[2],\n-                        (STNode) args[3], (boolean) args[4], (boolean) args[5], (ParserRuleContext) args[6]);\n-            case UNION_OR_INTERSECTION_TOKEN:\n-                return parseUnionOrIntersectionToken();\n-            case BRACKETED_LIST_MEMBER:\n-            case LIST_BINDING_MEMBER_OR_ARRAY_LENGTH:\n-                return parseBracketedListMember((boolean) args[0]);\n-            case DOT_LT_TOKEN:\n-                return parseDotLTToken();\n-            case SLASH_LT_TOKEN:\n-                return parseSlashLTToken();\n-            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n-                return parseDoubleSlashDoubleAsteriskLTToken();\n-            case SPECIFIC_FIELD:\n-                return parseSpecificField((STNode) args[0]);\n-            case OPTIONAL_MATCH_GUARD:\n-                return parseMatchGuard();\n-            case MATCH_PATTERN_START:\n-                return parseMatchPattern();\n-            case MATCH_PATTERN_RHS:\n-                return parseMatchPatternEnd();\n-            case ENUM_MEMBER_RHS:\n-                return parseEnumMemberRhs((STNode) args[0], (STNode) args[1]);\n-            case RECEIVE_FIELD:\n-                return parseReceiveField();\n-            case PARAM_END:\n-                return parseParameterRhs();\n-            case ELLIPSIS:\n-                return parseEllipsis();\n-            case BINARY_OPERATOR:\n-                return parseBinaryOperator();\n-            case QUESTION_MARK:\n-                return parseQuestionMark();\n-            case COMPOUND_BINARY_OPERATOR:\n-                return parseCompoundBinaryOperator();\n-            case UNARY_OPERATOR:\n-                return parseUnaryOperator();\n-            case AT:\n-                return parseAtToken();\n-            case RIGHT_ARROW:\n-                return parseRightArrow();\n-            case ATTACH_POINT:\n-                return parseAnnotationAttachPoint();\n-            case PIPE:\n-                return parsePipeToken();\n-            case INTERPOLATION_START_TOKEN:\n-                return parseInterpolationStart();\n-            case LIST_MATCH_PATTERN_MEMBER_RHS:\n-                return parseListMatchPatternMemberRhs();\n-            case LIST_BINDING_PATTERN_MEMBER:\n-                return parseListBindingPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER:\n-                return parseFieldMatchPatternMember();\n-            case FIELD_MATCH_PATTERN_MEMBER_RHS:\n-                return parseFieldMatchPatternRhs();\n-            case FUNC_MATCH_PATTERN_OR_CONST_PATTERN:\n-                return parseFunctionalMatchPatternOrConsPattern((STNode) args[0]);\n-            case ARG_MATCH_PATTERN:\n-                return parseArgMatchPattern();\n-            case ARG_MATCH_PATTERN_RHS:\n-                return parseArgMatchPatternRhs();\n-            case ARG_BINDING_PATTERN:\n-                return parseArgBindingPattern();\n-            case ARG_BINDING_PATTERN_END:\n-                return parseArgsBindingPatternEnd();\n-            case TABLE_ROW_END:\n-                return parseTableRowEnd();\n-            case LIST_BP_OR_LIST_CONSTRUCTOR_MEMBER:\n-                return parseListBindingPatternOrListConstructorMember();\n-            case TUPLE_TYPE_DESC_OR_LIST_CONST_MEMBER:\n-                return parseTupleTypeDescOrListConstructorMember((STNode) args[0]);\n-            case REMOTE_CALL_OR_ASYNC_SEND_END:\n-                return parseRemoteCallOrAsyncSendEnd((STNode) args[0], (STNode) args[1], (STNode) args[2]);\n-            case RECEIVE_FIELD_END:\n-                return parseReceiveFieldEnd();\n-            case MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER:\n-                return parseMappingBindingPatterOrMappingConstructorMember();\n             default:\n-                throw new IllegalStateException(\"cannot resume parsing the rule: \" + context);\n+                return resumeKeywordParsing(context, args);\n         }\n     }\n \n     public STNode resumeKeywordParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n+            case OBJECT_KEYWORD:\n+                return parseObjectKeyword();\n+            case LISTENER_KEYWORD:\n+                return parseListenerKeyword();\n+            case SERVICE_KEYWORD:\n+                return parseServiceKeyword();\n+            case CONST_KEYWORD:\n+                return parseConstantKeyword();\n+            case XML_KEYWORD:\n+                return parseXMLKeyword();\n+            case RECORD_KEYWORD:\n+                return parseRecordKeyword();\n+            case FUNCTION_KEYWORD:\n+                return parseFunctionKeyword();\n+            case IMPORT_KEYWORD:\n+                return parseImportKeyword();\n             case EXTERNAL_KEYWORD:\n                 return parseExternalKeyword();\n             case IF_KEYWORD:\n"}}, {"oid": "942a12e88d2f68b598e11c7949f531249f4c191a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/942a12e88d2f68b598e11c7949f531249f4c191a", "message": "Refactor Code", "committedDate": "2020-08-04T07:24:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzgwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465023808", "bodyText": "Don't we need this method? What if we reach here after recovering?", "author": "SupunS", "createdAt": "2020-08-04T12:47:32Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -5546,7 +5590,7 @@ private STNode parseObjectMember(SyntaxKind nextTokenKind, STNode metadata) {\n                 break;\n             case PUBLIC_KEYWORD:\n             case PRIVATE_KEYWORD:\n-                STNode visibilityQualifier = parseObjectMemberVisibility();", "originalCommit": "942a12e88d2f68b598e11c7949f531249f4c191a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMDE2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465310163", "bodyText": "no we don't. if we reach there all we have to do is just consume that token. Since we reach there we know for sure the token we want is the one we have.", "author": "m36dot", "createdAt": "2020-08-04T20:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0ODY2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465448665", "bodyText": "What if we reach here by inserting a token as the recovery solution? Then consume() will pick the next token from the stream, not the inserted one..", "author": "SupunS", "createdAt": "2020-08-05T03:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NTQ0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465485444", "bodyText": "yes that is correct, but the method currently doesn't solve this issue. e.g if we get an asterisk token then we still just consume it.\nshall I make the method take in next token instead of nextTokenKind, that way we can still use the recovered node.", "author": "m36dot", "createdAt": "2020-08-05T05:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NTg4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r465485886", "bodyText": "also there is the point that the visibility qualifiers are optional hence recovery won't be inserting them.", "author": "m36dot", "createdAt": "2020-08-05T05:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "902fec90e3b57adb8163d15cbc5d8dff6ba47ead", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 76a175f5af4..3968d11be33 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -5590,7 +5598,7 @@ public class BallerinaParser extends AbstractParser {\n                 break;\n             case PUBLIC_KEYWORD:\n             case PRIVATE_KEYWORD:\n-                STNode visibilityQualifier = consume();\n+                STNode visibilityQualifier = parseObjectMemberVisibility();\n                 member = parseObjectMethodOrField(metadata, visibilityQualifier);\n                 break;\n             case REMOTE_KEYWORD:\n"}}, {"oid": "fa65c2e66e4ff0099f4a38668cb102907620009c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa65c2e66e4ff0099f4a38668cb102907620009c", "message": "Refactor Code", "committedDate": "2020-08-05T06:10:18Z", "type": "commit"}, {"oid": "902fec90e3b57adb8163d15cbc5d8dff6ba47ead", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/902fec90e3b57adb8163d15cbc5d8dff6ba47ead", "message": "Fix visibility Qualifier recovery", "committedDate": "2020-08-05T06:56:53Z", "type": "commit"}, {"oid": "12e3143aa4989af2bba8fa66c093a191d96aec3e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12e3143aa4989af2bba8fa66c093a191d96aec3e", "message": "Fix merge conflict", "committedDate": "2020-08-05T07:37:20Z", "type": "commit"}, {"oid": "9a18a89de5d368bc19ef769731df93e28e8f93ba", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a18a89de5d368bc19ef769731df93e28e8f93ba", "message": "Fix parseTypedBindingPatternOrExprRhs\n\nFix how parseTypedBindingPatternOrExprRhs handles SyntaxKind.NONE\nreturned by recovery.", "committedDate": "2020-08-05T09:02:58Z", "type": "commit"}, {"oid": "8fbf7b219e29cf482cccd718cba9c0b5743dfff4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fbf7b219e29cf482cccd718cba9c0b5743dfff4", "message": "Refactor Code", "committedDate": "2020-08-05T12:03:21Z", "type": "commit"}, {"oid": "93ea0cf983ffac2af5743ff494b31ca3598bd517", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93ea0cf983ffac2af5743ff494b31ca3598bd517", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fixResumeParsing", "committedDate": "2020-08-06T05:28:41Z", "type": "commit"}, {"oid": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "message": "Refactor Code", "committedDate": "2020-08-06T06:50:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MjkyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466792921", "bodyText": "@m36dot Do we need this?", "author": "SupunS", "createdAt": "2020-08-07T02:56:02Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -184,8 +184,11 @@\n     private static final ParserRuleContext[] OBJECT_MEMBER_WITHOUT_METADATA =\n             { ParserRuleContext.ASTERISK, ParserRuleContext.OBJECT_FUNC_OR_FIELD, ParserRuleContext.CLOSE_BRACE };\n \n-    private static final ParserRuleContext[] OBJECT_FUNC_OR_FIELD = { ParserRuleContext.PUBLIC_KEYWORD,\n-            ParserRuleContext.PRIVATE_KEYWORD, ParserRuleContext.OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY };\n+    private static final ParserRuleContext[] OBJECT_FUNC_OR_FIELD = { ParserRuleContext.PUBLIC_OR_PRIVATE_KEYWORD,\n+            ParserRuleContext.OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY };\n+\n+    private static final ParserRuleContext[] PUBLIC_OR_PRIVATE_KEYWORD = {ParserRuleContext.PUBLIC_KEYWORD,\n+            ParserRuleContext.PRIVATE_KEYWORD};", "originalCommit": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MzA3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466843078", "bodyText": "forgot to remove it, will remove it", "author": "m36dot", "createdAt": "2020-08-07T06:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MjkyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c99644924974c93ae8f872cc8eaa9e0f4496c575", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex d87e31dc397..c337e2f8bf7 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -184,12 +184,9 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n     private static final ParserRuleContext[] OBJECT_MEMBER_WITHOUT_METADATA =\n             { ParserRuleContext.ASTERISK, ParserRuleContext.OBJECT_FUNC_OR_FIELD, ParserRuleContext.CLOSE_BRACE };\n \n-    private static final ParserRuleContext[] OBJECT_FUNC_OR_FIELD = { ParserRuleContext.PUBLIC_OR_PRIVATE_KEYWORD,\n+    private static final ParserRuleContext[] OBJECT_FUNC_OR_FIELD = { ParserRuleContext.OBJECT_MEMBER_QUALIFIER,\n             ParserRuleContext.OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY };\n \n-    private static final ParserRuleContext[] PUBLIC_OR_PRIVATE_KEYWORD = {ParserRuleContext.PUBLIC_KEYWORD,\n-            ParserRuleContext.PRIVATE_KEYWORD};\n-\n     private static final ParserRuleContext[] OBJECT_FUNC_OR_FIELD_WITHOUT_VISIBILITY =\n             { ParserRuleContext.TYPE_DESC_BEFORE_IDENTIFIER, ParserRuleContext.OBJECT_METHOD_START };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjU4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466802586", "bodyText": "formatting is incorrect", "author": "SupunS", "createdAt": "2020-08-07T03:37:20Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -574,6 +577,9 @@\n     private static final ParserRuleContext[] JOIN_CLAUSE_START =\n             { ParserRuleContext.JOIN_KEYWORD, ParserRuleContext.OUTER_KEYWORD };\n \n+    private static final ParserRuleContext[] MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER =\n+            { ParserRuleContext.MAPPING_BINDING_PATTERN_MEMBER, ParserRuleContext.MAPPING_FIELD};", "originalCommit": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MjkzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466842936", "bodyText": "will fix it", "author": "m36dot", "createdAt": "2020-08-07T06:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c99644924974c93ae8f872cc8eaa9e0f4496c575", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex d87e31dc397..c337e2f8bf7 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -578,7 +575,7 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n             { ParserRuleContext.JOIN_KEYWORD, ParserRuleContext.OUTER_KEYWORD };\n \n     private static final ParserRuleContext[] MAPPING_BP_OR_MAPPING_CONSTRUCTOR_MEMBER =\n-            { ParserRuleContext.MAPPING_BINDING_PATTERN_MEMBER, ParserRuleContext.MAPPING_FIELD};\n+            { ParserRuleContext.MAPPING_BINDING_PATTERN_MEMBER, ParserRuleContext.MAPPING_FIELD };\n \n     public BallerinaParserErrorHandler(AbstractTokenReader tokenReader) {\n         super(tokenReader);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjY2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466802662", "bodyText": "Would \"object member qualifier\" be a better name?", "author": "SupunS", "createdAt": "2020-08-07T03:37:43Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -974,7 +982,10 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                     hasMatch = nextToken.kind == SyntaxKind.ASCENDING_KEYWORD ||\n                             nextToken.kind == SyntaxKind.DESCENDING_KEYWORD;\n                     break;\n-\n+                case PUBLIC_OR_PRIVATE_KEYWORD:", "originalCommit": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0Mjg2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466842865", "bodyText": "will change it", "author": "m36dot", "createdAt": "2020-08-07T06:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c99644924974c93ae8f872cc8eaa9e0f4496c575", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex d87e31dc397..c337e2f8bf7 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -982,7 +979,7 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                     hasMatch = nextToken.kind == SyntaxKind.ASCENDING_KEYWORD ||\n                             nextToken.kind == SyntaxKind.DESCENDING_KEYWORD;\n                     break;\n-                case PUBLIC_OR_PRIVATE_KEYWORD:\n+                case OBJECT_MEMBER_QUALIFIER:\n                     hasMatch = nextToken.kind == SyntaxKind.PRIVATE_KEYWORD ||\n                             nextToken.kind == SyntaxKind.PUBLIC_KEYWORD;\n                     break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjg3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466802871", "bodyText": "Better to keep the override annotation", "author": "SupunS", "createdAt": "2020-08-07T03:38:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -136,220 +136,288 @@ public STNode parse(ParserRuleContext context) {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n-    @Override", "originalCommit": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MjgwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466842806", "bodyText": "alright", "author": "m36dot", "createdAt": "2020-08-07T06:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMjg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c99644924974c93ae8f872cc8eaa9e0f4496c575", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 834e82b11f7..3bcdc824bf9 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -136,6 +136,7 @@ public class BallerinaParser extends AbstractParser {\n      * @param args Arguments that requires to continue parsing from the given parser context\n      * @return Parsed node\n      */\n+    @Override\n     public STNode resumeParsing(ParserRuleContext context, Object... args) {\n         switch (context) {\n             case TOP_LEVEL_NODE:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMzQ4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466803483", "bodyText": "Can you explain why do we need to check SyntaxKind.NONE here?", "author": "SupunS", "createdAt": "2020-08-07T03:41:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -13807,6 +13826,12 @@ private STNode parseTypedBindingPatternOrExprRhs(SyntaxKind nextTokenKind, STNod\n                     return solution.recoveredNode;\n                 }\n \n+                // If the recovered token is not something that can be re-parsed,\n+                // then don't try to re-parse the same rule.\n+                if (solution.tokenKind == SyntaxKind.NONE) {\n+                    return typeOrExpr;\n+                }", "originalCommit": "a1d1031dabf638a85db7bcdd1212306a29a4fc8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MjczNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466842734", "bodyText": "because recovery returns it when we try to parse source 2 from #24651", "author": "m36dot", "createdAt": "2020-08-07T06:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMzQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg1NDM5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25021#discussion_r466854399", "bodyText": "Why is it returning NONE? Shouldn't we fix that?", "author": "SupunS", "createdAt": "2020-08-07T06:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMzQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a557dd04f82cb842eaa2e7f6f82093fedec90b51", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 834e82b11f7..4c8ff308ad0 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -13826,12 +13827,6 @@ public class BallerinaParser extends AbstractParser {\n                     return solution.recoveredNode;\n                 }\n \n-                // If the recovered token is not something that can be re-parsed,\n-                // then don't try to re-parse the same rule.\n-                if (solution.tokenKind == SyntaxKind.NONE) {\n-                    return typeOrExpr;\n-                }\n-\n                 return parseTypedBindingPatternOrExprRhs(solution.tokenKind, typeOrExpr, allowAssignment);\n         }\n     }\n"}}, {"oid": "c99644924974c93ae8f872cc8eaa9e0f4496c575", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c99644924974c93ae8f872cc8eaa9e0f4496c575", "message": "Refactor Code", "committedDate": "2020-08-07T08:42:52Z", "type": "commit"}, {"oid": "a557dd04f82cb842eaa2e7f6f82093fedec90b51", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a557dd04f82cb842eaa2e7f6f82093fedec90b51", "message": "Fix ErrorHandler returning SyntaxKind.NONE\n\nFix error handler returning SyntaxKind.NONE for recovery of\nparseTypedBindingPatternOrExprRhs for source 2 in #24651", "committedDate": "2020-08-10T06:32:10Z", "type": "commit"}, {"oid": "fe3bf52fcd478cf95761b40cd8b108b5f5f71477", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe3bf52fcd478cf95761b40cd8b108b5f5f71477", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fixResumeParsing", "committedDate": "2020-08-10T07:26:06Z", "type": "commit"}, {"oid": "e3d7bc605920fb7e32a1417cc6da9da08accf0d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3d7bc605920fb7e32a1417cc6da9da08accf0d1", "message": "Update assert", "committedDate": "2020-08-10T07:56:35Z", "type": "commit"}, {"oid": "46659751f9d3a65303e9e4085fbc259bccce353a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/46659751f9d3a65303e9e4085fbc259bccce353a", "message": "remove extra new lines", "committedDate": "2020-08-10T11:06:27Z", "type": "commit"}]}