{"pr_number": 27584, "pr_title": "Refactor documentation lexer and parser", "pr_createdAt": "2020-12-18T17:20:38Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584", "timeline": [{"oid": "2a7bf7bdb990e8d5f8f23ab97c2761c6296c0073", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a7bf7bdb990e8d5f8f23ab97c2761c6296c0073", "message": "Move common lexer methods to AbstractLexer", "committedDate": "2020-12-11T11:04:07Z", "type": "commit"}, {"oid": "eb2bcd476457b6561a396aabb5c1f8e515845b9b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb2bcd476457b6561a396aabb5c1f8e515845b9b", "message": "Refactor DocumentationLexer", "committedDate": "2020-12-14T16:31:33Z", "type": "commit"}, {"oid": "c8228abf555676ef0b38d1682a8e4143d21f0437", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8228abf555676ef0b38d1682a8e4143d21f0437", "message": "Add documentation support for the new identifier definition", "committedDate": "2020-12-18T18:15:05Z", "type": "forcePushed"}, {"oid": "ba436b72d22de184f79c9a95205ba498eceeecdd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba436b72d22de184f79c9a95205ba498eceeecdd", "message": "Add documentation support for the new identifier definition", "committedDate": "2020-12-18T19:27:58Z", "type": "commit"}, {"oid": "ba436b72d22de184f79c9a95205ba498eceeecdd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba436b72d22de184f79c9a95205ba498eceeecdd", "message": "Add documentation support for the new identifier definition", "committedDate": "2020-12-18T19:27:58Z", "type": "forcePushed"}, {"oid": "5715fbb08384e71fa2542aa2abcc47cece4b23e5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5715fbb08384e71fa2542aa2abcc47cece4b23e5", "message": "Add warning for incorrect deprecated doc line\n\nGive a parser warning when details of \"# Deprecated\" are added in the same line", "committedDate": "2020-12-20T20:16:48Z", "type": "commit"}, {"oid": "2af4173bc0f7514b587eeb17b6e4184bd0c98573", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2af4173bc0f7514b587eeb17b6e4184bd0c98573", "message": "Cleanup code", "committedDate": "2020-12-20T21:46:52Z", "type": "commit"}, {"oid": "2af4173bc0f7514b587eeb17b6e4184bd0c98573", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2af4173bc0f7514b587eeb17b6e4184bd0c98573", "message": "Cleanup code", "committedDate": "2020-12-20T21:46:52Z", "type": "forcePushed"}, {"oid": "1caf3fae296a8b92f64fae2f54c4485dcbe38460", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1caf3fae296a8b92f64fae2f54c4485dcbe38460", "message": "Revert \"Add warning for incorrect deprecated doc line\"\n\nThis reverts commit 5715fbb0", "committedDate": "2020-12-21T11:43:50Z", "type": "commit"}, {"oid": "87edeaa109cf96dfc004da51b2d3b2e9839725f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/87edeaa109cf96dfc004da51b2d3b2e9839725f3", "message": "Fix trialing trivia of \"Deprecated\" to improve formatting", "committedDate": "2020-12-21T12:26:28Z", "type": "commit"}, {"oid": "07f0c01f5c865704e7656d4403565261ec092167", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07f0c01f5c865704e7656d4403565261ec092167", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into refactor-doc", "committedDate": "2021-01-13T09:15:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NTE2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559955161", "bodyText": "Don't we give a warning for invalid backtick content with NO_KEY. Also combineAndCreateBacktickContentToken can be renamed to combineAndCreateInvalidBacktickContentToken", "author": "rdulmina", "createdAt": "2021-01-19T07:11:22Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -266,10 +378,81 @@ private STNode parseBacktickToken() {\n     }\n \n     /**\n-     * Parse back-tick content token.\n+     * Parse back-tick content.\n      *\n+     * @param referenceType Node that precedes the backtick block\n      * @return Parsed node\n      */\n+    private STNode parseBacktickContent(STNode referenceType) {\n+        ReferenceGenre referenceGenre = getReferenceGenre(referenceType);\n+        if (isValidBacktickContentSequence(referenceGenre)) {\n+            return parseBacktickContent();\n+        }\n+\n+        STNode contentToken = combineAndCreateBacktickContentToken();\n+        if (referenceGenre != ReferenceGenre.NO_KEY) {\n+            // Log warning for backtick block with a reference type, but content is invalid.\n+            contentToken = SyntaxErrors.addDiagnostic(contentToken,\n+                    DiagnosticWarningCode.WARNING_INVALID_DOCUMENTATION_IDENTIFIER, ((STToken) contentToken).text());\n+        }", "originalCommit": "07f0c01f5c865704e7656d4403565261ec092167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMDg0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560010843", "bodyText": "We need to clarify it with the spec. There were several reference like above in repo atm. Create an issue for that. #27958\n+1 on changing the name. Will do once clarified.", "author": "lochana-chathura", "createdAt": "2021-01-19T08:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NTE2MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NjQ1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559956457", "bodyText": "We can remove these new lines.", "author": "rdulmina", "createdAt": "2021-01-19T07:14:58Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java", "diffHunk": "@@ -134,4 +134,117 @@ protected STNode getLeadingTrivia() {\n         this.leadingTriviaList = new ArrayList<>(INITIAL_TRIVIA_CAPACITY);\n         return trivia;\n     }\n+\n+    /**\n+     * Check whether a given char is an identifier following char.\n+     * <p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is a digit.\n+     * <p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * Check whether a given char is a hexa digit.\n+     * <p>\n+     * <code>HexDigit := Digit | a .. f | A .. F</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a hex digit. <code>false</code> otherwise.\n+     */\n+    protected static boolean isHexDigit(int c) {\n+        if ('a' <= c && c <= 'f') {\n+            return true;\n+        }\n+        if ('A' <= c && c <= 'F') {\n+            return true;\n+        }\n+        return isDigit(c);\n+    }\n+\n+    /**\n+     * Check whether a given char is an identifier start char.\n+     * <p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    protected static boolean isIdentifierInitialChar(int c) {\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+", "originalCommit": "07f0c01f5c865704e7656d4403565261ec092167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMjYwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560012600", "bodyText": "I think leaving a newline after a block whenever appropriate is a good practice. Ref: #26717 (comment) also.", "author": "lochana-chathura", "createdAt": "2021-01-19T09:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NjQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "445c81bf1de4bb26f1de217e2f881f28f1988699", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java\nindex 4a8df9b38f1..3c3df80cff9 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/AbstractLexer.java\n\n@@ -171,9 +171,11 @@ public abstract class AbstractLexer {\n         if ('a' <= c && c <= 'f') {\n             return true;\n         }\n+\n         if ('A' <= c && c <= 'F') {\n             return true;\n         }\n+\n         return isDigit(c);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1ODMxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559958313", "bodyText": "Can remove the new line here as well", "author": "rdulmina", "createdAt": "2021-01-19T07:19:16Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -117,56 +107,97 @@ private String getLexeme() {\n     }\n \n     /**\n-     * <p>\n-     * Check whether a given char is an identifier start char.\n-     * </p>\n-     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n-     *\n-     * @param c character to check\n-     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     * Check whether a given char is a possible identifier start.\n      */\n-    private boolean isIdentifierInitialChar(int c) {\n-        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n-        if ('A' <= c && c <= 'Z') {\n-            return true;\n-        }\n-\n-        if ('a' <= c && c <= 'z') {\n-            return true;\n-        }\n-\n-        if (c == '_') {\n-            return true;\n+    private boolean isPossibleIdentifierStart(int startChar) {\n+        switch (startChar) {\n+            case LexerTerminals.SINGLE_QUOTE:\n+            case LexerTerminals.BACKSLASH:\n+                return true;\n+            default:\n+                return isIdentifierInitialChar(startChar);\n         }\n-\n-        // TODO: if (UnicodeIdentifierChar) return false;\n-        return false;\n     }\n \n     /**\n+     * Process identifier end.\n      * <p>\n-     * Check whether a given char is an identifier following char.\n-     * </p>\n-     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     * <code>\n+     * IdentifierEnd := IdentifierChar*\n+     * <br/>\n+     * IdentifierChar := IdentifierFollowingChar | IdentifierEscape\n+     * <br/>\n+     * IdentifierEscape := IdentifierSingleEscape | NumericEscape\n+     * </code>\n      *\n-     * @param c character to check\n-     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     * @param initialEscape Denotes whether <code>\\</code> is at the beginning of the identifier\n      */\n-    private boolean isIdentifierFollowingChar(int c) {\n-        return isIdentifierInitialChar(c) || isDigit(c);\n+    private void processIdentifierEnd(boolean initialEscape) {\n+        while (!reader.isEOF()) {\n+            int k = 1;\n+            int nextChar = reader.peek();\n+            if (isIdentifierFollowingChar(nextChar)) {\n+                reader.advance();\n+                continue;\n+            }\n+", "originalCommit": "07f0c01f5c865704e7656d4403565261ec092167", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2NTQ5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r559965494", "bodyText": "If we can return false from the calling methods (ie hasQualifiedIdentifier and hasBacktickExpr) whenever peek(lookahead.offset).kind == SyntaxKind.BACKTIC_CONTENT then we can simplify this by removing the Lookahead class", "author": "rdulmina", "createdAt": "2021-01-19T07:36:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/DocumentationParser.java", "diffHunk": "@@ -157,13 +158,124 @@ private STNode parseDocumentationReference() {\n         }\n \n         STNode startBacktick = parseBacktickToken();\n-        STNode backtickContent = parseBacktickContent();\n+        STNode backtickContent = parseBacktickContent(referenceType);\n         STNode endBacktick = parseBacktickToken();\n-\n         return STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick, backtickContent,\n                 endBacktick);\n     }\n \n+    /**\n+     * Represents the current position with respect to the head in a token-sequence-search.\n+     */\n+    private static class Lookahead {\n+        private int offset = 1;\n+    }\n+\n+    /**\n+     * Genre of the reference that precedes the backtick block.\n+     */\n+    private enum ReferenceGenre {\n+        NO_KEY, SPECIAL_KEY, FUNCTION_KEY\n+    }\n+\n+    /**\n+     * Look ahead and see if upcoming token sequence is valid.\n+     *\n+     * @param refGenre Genre of the backtick block reference\n+     * @return <code>true</code> if content is valid<code>false</code> otherwise.\n+     */\n+    private boolean isValidBacktickContentSequence(ReferenceGenre refGenre) {\n+        boolean hasMatch;\n+        Lookahead lookahead = new Lookahead();\n+        switch (refGenre) {\n+            case SPECIAL_KEY:\n+                // Look for x, m:x match\n+                hasMatch = hasQualifiedIdentifier(lookahead);\n+                break;\n+            case FUNCTION_KEY:\n+                // Look for x, m:x, x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, true);\n+                break;\n+            case NO_KEY:\n+                // Look for x(), m:x(), T.y(), m:T.y() match\n+                hasMatch = hasBacktickExpr(lookahead, false);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unsupported backtick reference genre\");\n+        }\n+\n+        return hasMatch && peek(lookahead.offset).kind == SyntaxKind.BACKTICK_TOKEN;", "originalCommit": "07f0c01f5c865704e7656d4403565261ec092167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAyMTY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27584#discussion_r560021694", "bodyText": "As we discussed offline problem is, methods like hasIdentifier is called in other places as well. eg. hasQualifiedIdentifer, hasBacktickExpr.", "author": "lochana-chathura", "createdAt": "2021-01-19T09:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk2NTQ5NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "445c81bf1de4bb26f1de217e2f881f28f1988699", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/445c81bf1de4bb26f1de217e2f881f28f1988699", "message": "Cleanup code", "committedDate": "2021-01-19T09:19:18Z", "type": "commit"}]}