{"pr_number": 20749, "pr_title": "Fill-in missing values by list constructor", "pr_createdAt": "2020-01-27T09:16:11Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749", "timeline": [{"oid": "89204061f107109dd671044ca4b098913d14df03", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/89204061f107109dd671044ca4b098913d14df03", "message": "WIP: Fill-in missing values by list constructor\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-27T18:43:26Z", "type": "forcePushed"}, {"oid": "c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "message": "Add XML array test with list ctor", "committedDate": "2020-01-28T06:09:52Z", "type": "forcePushed"}, {"oid": "ca163139d84d3f88a0c677f8533a7f92b938e8f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca163139d84d3f88a0c677f8533a7f92b938e8f6", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-28T10:27:58Z", "type": "forcePushed"}, {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-28T11:03:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371889759", "bodyText": "Shall we improve formatting?\n                    dlog.error(listConstructor.pos, DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, \n                               arrayType.size, listConstructor.exprs.size());", "author": "MaryamZi", "createdAt": "2020-01-28T15:53:23Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -609,10 +609,14 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n+                            ());", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNzE0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372137141", "bodyText": "Reaching 120 character limit. Check now.", "author": "KRVPerera", "createdAt": "2020-01-29T00:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 5df3d02e563..83c61b43740 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -612,8 +612,8 @@ public class TypeChecker extends BLangNodeVisitor {\n             } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n                 if (arrayType.size < listConstructor.exprs.size()) {\n                     dlog.error(listConstructor.pos,\n-                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n-                            ());\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n                     return;\n                 }\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5Mjg0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371892843", "bodyText": "Shall we write this test to panic on failure instead? e.g., https://github.com/ballerina-platform/ballerina-lang/pull/20679/files#diff-8ef02e76dc938bb93e61ae0143f646cdR1060\nThat way we could remove the Java side assertions.", "author": "MaryamZi", "createdAt": "2020-01-28T15:57:54Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java", "diffHunk": "@@ -59,4 +59,11 @@ public void diagnosticsTest() {\n                 23, 34);\n         Assert.assertEquals(resultNegative.getErrorCount(), i);\n     }\n+\n+    @Test\n+    public void testListConstructorAutoFillExpr() {\n+        BValue[] returns = BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java\nindex fc91a902bad..3d7b9b92956 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java\n\n@@ -62,8 +62,6 @@ public class ListConstructorExprTest {\n \n     @Test\n     public void testListConstructorAutoFillExpr() {\n-        BValue[] returns = BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");\n-        Assert.assertEquals(returns.length, 1);\n-        Assert.assertTrue(((BBoolean) returns[0]).booleanValue());\n+        BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371893310", "bodyText": "We can write these tests also in Ballerina right?", "author": "MaryamZi", "createdAt": "2020-01-28T15:58:38Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -53,6 +53,11 @@ public void testCreateIntegerSealedArray() {\n                 returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n         Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n \n+        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0OTQ3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371949474", "bodyText": "Using testerina asserts ? or with If conditions and panics?\nWhat is more suitable in the long term?", "author": "KRVPerera", "createdAt": "2020-01-28T17:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA=="}], "type": "inlineReview", "revised_code": {"commit": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\nindex 0c74e478072..f3d4b0d2b12 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n\n@@ -48,99 +48,46 @@ public class SealedArrayTest {\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateStringSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createStringSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createStringSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createStringAutoFilledSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createStringAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createStringSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createStringSealedArrayWithLabel\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createStringDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[\\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\"]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createStringDefaultSealedArray\");\n     }\n \n     @Test\n"}}, {"oid": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5fc28b9a058502c6955722be7fdd5144c48f5bf3", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-30T02:47:38Z", "type": "forcePushed"}, {"oid": "972f0eab1c92d3d4556b71e9cc3e9914297c5483", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/972f0eab1c92d3d4556b71e9cc3e9914297c5483", "message": "Fix abstract object list construction without error\n\nAbstract object creation through list constructor does not throw error\nand this was fixed and now before we initilize the list we check if the\nunderneath object type is an abstact object type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-02T10:20:56Z", "type": "forcePushed"}, {"oid": "b61a710cde422553991fa45d129723eea51f8d7b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b61a710cde422553991fa45d129723eea51f8d7b", "message": "Refactor fill value check in compile TypeChecker", "committedDate": "2020-02-03T09:53:10Z", "type": "forcePushed"}, {"oid": "c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "message": "Refactor fill value check in compile TypeChecker", "committedDate": "2020-02-05T07:24:34Z", "type": "forcePushed"}, {"oid": "26b29b9c62e479a206d8407c2b6e458bf64c111a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b29b9c62e479a206d8407c2b6e458bf64c111a", "message": "Add union auto fill test cases", "committedDate": "2020-02-05T09:54:59Z", "type": "forcePushed"}, {"oid": "e78f9a4ee679d83110031e2cba7adf2610ae5918", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e78f9a4ee679d83110031e2cba7adf2610ae5918", "message": "Handle array type for fill value", "committedDate": "2020-02-06T04:16:19Z", "type": "forcePushed"}, {"oid": "c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "message": "Refactor and add utils to Types.java", "committedDate": "2020-02-06T15:47:33Z", "type": "forcePushed"}, {"oid": "10d9703486a07ea9bde5047466f1579f195136c5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10d9703486a07ea9bde5047466f1579f195136c5", "message": "Add todo note for sealed-array.bal", "committedDate": "2020-02-07T05:25:26Z", "type": "forcePushed"}, {"oid": "0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "message": "Test object fillinh", "committedDate": "2020-02-07T08:42:45Z", "type": "forcePushed"}, {"oid": "bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "message": "Fix build after conclict resolution", "committedDate": "2020-02-08T04:43:57Z", "type": "forcePushed"}, {"oid": "319dc5d9cbd357f840f2562ac95bdeb4263a721b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/319dc5d9cbd357f840f2562ac95bdeb4263a721b", "message": "Fix sealed singleton array initialization", "committedDate": "2020-02-08T04:49:35Z", "type": "forcePushed"}, {"oid": "19b5d638226b05c465049b3027cbe950c49679e3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19b5d638226b05c465049b3027cbe950c49679e3", "message": "Fix incorrect caching of fillvalue check", "committedDate": "2020-02-08T07:25:52Z", "type": "forcePushed"}, {"oid": "af33fdd90b72da50f6196405e906ac0359fdbdb8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af33fdd90b72da50f6196405e906ac0359fdbdb8", "message": "Fix sealed singleton array initialization", "committedDate": "2020-02-08T16:03:17Z", "type": "forcePushed"}, {"oid": "b14ad7424dd2446f6e2726093d844c71f9ab1024", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b14ad7424dd2446f6e2726093d844c71f9ab1024", "message": "Fix anydata array fill list-ctor related issues", "committedDate": "2020-02-10T04:25:38Z", "type": "forcePushed"}, {"oid": "5519773712e3c4a1f32511620b19da8d52e96bec", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5519773712e3c4a1f32511620b19da8d52e96bec", "message": "Check fill value before array initilization", "committedDate": "2020-02-10T16:13:40Z", "type": "forcePushed"}, {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c003414045f8ef10724fd7f140cf1b3454e7bfeb", "message": "Add BRecord type fill value check", "committedDate": "2020-02-11T06:19:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTM5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:14:20Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java\ndeleted file mode 100644\nindex f800dcc0b28..00000000000\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java\n+++ /dev/null\n\n@@ -1,44 +0,0 @@\n-/*\n- * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- * WSO2 Inc. licenses this file to you under the Apache License,\n- * Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.ballerinalang.test.statements.arrays;\n-\n-import org.ballerinalang.test.util.BCompileUtil;\n-import org.ballerinalang.test.util.CompileResult;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-/**\n- * Test cases for filling the elements of the array with its type's implicit initial value.\n- *\n- * @since 1.1.1\n- */\n-public class ArrayFillTestRuntime {\n-\n-    private CompileResult compileResult;\n-\n-    @BeforeClass\n-    public void setup() {\n-        compileResult = BCompileUtil.compile(\"test-src/statements/arrays/array_fill_runtime_test.bal\");\n-    }\n-\n-    @Test\n-    public void runtimeArrayFillTest(){\n-        BCompileUtil.runMain(compileResult, new String[]{});\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTU0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This will handle two types\n          \n          \n            \n                 * This will handle two types.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:15:05Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 3d4efff55a6..af36177bf0b 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2615,10 +2615,10 @@ public class Types {\n     }\n \n     /**\n-     * This will handle two types\n+     * This will handle two types.\n      *  Singleton : As singleton can have one value that value should it self be a valid fill value\n      *  Union :\n-     *          1. if nil is a member it is the fill valus\n+     *          1. if nil is a member it is the fill values\n      *          2. else all the values should belong to same type and the default value for that type\n      *              should be a member of the union\n      * @param type BFiniteType union or finite\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471677", "bodyText": "Remove extra lines", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:15:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4775,6 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUxMTczNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377511735", "bodyText": "done", "author": "KRVPerera", "createdAt": "2020-02-11T09:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 5b5ab869266..f6595d90af7 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -4775,6 +4774,4 @@ public class TypeChecker extends BLangNodeVisitor {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n-\n-\n }\n"}}, {"oid": "4e72db66fcea5682a5011c9f48e9ac2c96076de1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e72db66fcea5682a5011c9f48e9ac2c96076de1", "message": "Fill only the needed elements in the array", "committedDate": "2020-02-11T07:18:25Z", "type": "forcePushed"}, {"oid": "1fbd4be112257964d55d15afde5dd462dca84696", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fbd4be112257964d55d15afde5dd462dca84696", "message": "Fill only the needed elements in the array", "committedDate": "2020-02-11T07:51:26Z", "type": "forcePushed"}, {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T08:39:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377503242", "bodyText": "If we move this logic to a function, we can improve the readability of the code. WDYT?", "author": "dulvinw", "createdAt": "2020-02-11T08:53:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,10 +619,18 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {", "originalCommit": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU1OTkzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377559932", "bodyText": "It will be like two functions ..\nif (isSealedArray(arrayType) && isSizeMismatch(arrayType, listConstructor.exprs)). Will this help ?", "author": "KRVPerera", "createdAt": "2020-02-11T10:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex f6595d90af7..3e8a88e6ced 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -630,7 +630,6 @@ public class TypeChecker extends BLangNodeVisitor {\n                     dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);\n                     return;\n                 }\n-                arrayType.state = BArrayState.CLOSED_SEALED;\n             }\n             checkExprs(listConstructor.exprs, this.env, arrayType.eType);\n             actualType = arrayType;\n"}}, {"oid": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "message": "Fix style", "committedDate": "2020-02-11T10:12:53Z", "type": "forcePushed"}, {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7ffca3f2535a897d0e44911a0f4d7bff9869799", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T10:36:13Z", "type": "forcePushed"}, {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T19:56:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwNTk2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376805968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();;\n          \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();", "author": "MaryamZi", "createdAt": "2020-02-09T18:49:50Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -71,6 +72,8 @@\n     private String[] stringValues;\n     private BString[] bStringValues;\n \n+    private Optional<Boolean> hasFillerValue = Optional.empty();;", "originalCommit": "14ed660461442578df396c6c3bb26b9062f823b1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\nindex eb7d45533e3..e11ec30a4e9 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n\n@@ -72,8 +71,6 @@ public class ArrayValueImpl extends AbstractArrayValue {\n     private String[] stringValues;\n     private BString[] bStringValues;\n \n-    private Optional<Boolean> hasFillerValue = Optional.empty();;\n-\n     // ------------------------ Constructors -------------------------------------------------------------------\n \n     @Deprecated\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376935955", "bodyText": "Not due to this changes but IIUC, if this method gets called we've been initializing the array to the default size even if the array is a closed, fixed-length one? Shouldn't we only use the default if there is no explicit size?", "author": "MaryamZi", "createdAt": "2020-02-10T09:07:49Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -130,56 +133,60 @@ public ArrayValueImpl(BArrayType type) {\n         this.arrayType = type;\n         BArrayType arrayType = (BArrayType) type;\n         this.elementType = arrayType.getElementType();\n+        initArrayValues(elementType, false);\n         if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n             this.size = maxSize = arrayType.getSize();\n         }\n-        initArrayValues(this.elementType, false);\n     }\n \n     private void initArrayValues(BType elementType, boolean useBString) {\n+        int initialArraySize = Math.max(DEFAULT_ARRAY_SIZE, arrayType.getSize());", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzOTEwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378139105", "bodyText": "Yes, I agree. For a fixed-length array (explicit size), there will be an unused allocated capacity due to this logic.", "author": "KRVPerera", "createdAt": "2020-02-12T09:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5519773712e3c4a1f32511620b19da8d52e96bec", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\nindex e14ed9d8ccb..598be7decb9 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n\n@@ -164,7 +164,8 @@ public class ArrayValueImpl extends AbstractArrayValue {\n             default:\n                 this.refValues = new Object[initialArraySize];\n                 if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n-                    fillValues(arrayType.getSize());\n+                    fillerValueCheck(initialArraySize, initialArraySize);\n+                    fillValues(initialArraySize);\n                 }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376939067", "bodyText": "Not sure if this is the correct error? This just says \"invalid usage of list constructor with type 'T'\" right? IMO, we should say something that implies there's no filler value and there's a size mismatch.", "author": "MaryamZi", "createdAt": "2020-02-10T09:14:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,16 +620,25 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n+                    return;\n+                }\n+                //TODO: check fillable values\n+                if (!types.hasFillerValue(arrayType.eType)) {\n+                    dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMzE2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379103163", "bodyText": "Check the error message on 281133b", "author": "KRVPerera", "createdAt": "2020-02-13T20:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 9087be411c0..5b5ab869266 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -627,7 +627,6 @@ public class TypeChecker extends BLangNodeVisitor {\n                                listConstructor.exprs.size());\n                     return;\n                 }\n-                //TODO: check fillable values\n                 if (!types.hasFillerValue(arrayType.eType)) {\n                     dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);\n                     return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940450", "bodyText": "Shall we add the version?", "author": "MaryamZi", "createdAt": "2020-02-10T09:17:17Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDgxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940817", "bodyText": "And shall we say filler instead of default?", "author": "MaryamZi", "createdAt": "2020-02-10T09:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg3OTc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378879784", "bodyText": "added 1.1.2", "author": "KRVPerera", "createdAt": "2020-02-13T14:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 8e3a5e38313..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -111,8 +111,9 @@ public class Types {\n     private int finiteTypeCount = 0;\n \n     /**\n-     * Keep default values for basic types in String format.\n+     * Keep filler value for basic types in String format.\n      *\n+     * @since 1.1.2\n      */\n     public enum DefaultValues {\n         STRING(\"\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MTA2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376941063", "bodyText": "Is type ever null?", "author": "MaryamZi", "createdAt": "2020-02-10T09:18:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,154 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 8e3a5e38313..3d4efff55a6 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2584,17 +2584,13 @@ public class Types {\n             case TypeTags.OBJECT:\n                 return checkFillerValue((BObjectType) type);\n             case TypeTags.RECORD:\n-                // TODO: record\n-//                return checkFillerValue((BRecordType) type, unanalyzedTypes);\n-                break;\n+                return checkFillerValue((BRecordType) type);\n             case TypeTags.TUPLE:\n                 BTupleType tupleType = (BTupleType) type;\n                 return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n             default:\n                 return false;\n         }\n-\n-        return true;\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377834478", "bodyText": "We only need to check if the return type is not nil right?", "author": "MaryamZi", "createdAt": "2020-02-11T18:59:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0Nzg4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378147889", "bodyText": "yes", "author": "KRVPerera", "createdAt": "2020-02-12T10:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377836466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n          \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam)) {", "author": "MaryamZi", "createdAt": "2020-02-11T19:03:29Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNzExOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377837119", "bodyText": "Shall we avoid using streams btw?", "author": "MaryamZi", "createdAt": "2020-02-11T19:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377845495", "bodyText": "Do we need the null check for value space members? Can the value be null?", "author": "MaryamZi", "createdAt": "2020-02-11T19:19:58Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzOTUwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378039502", "bodyText": "Also, instead of this can't our first check be isNullable like for union types before iterating through the value space?", "author": "MaryamZi", "createdAt": "2020-02-12T04:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjY4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378152688", "bodyText": "let me check the null value.\nIsNullable for \"BFiniteType\" actually goes through every item in value space.\npublic boolean isNullable() {\n        return this.valueSpace.stream().anyMatch(v -> v.type.tag == TypeTags.NIL);\n}\nMay be we can remove nullable check in union type code inside loop and for first item. Let me check.", "author": "KRVPerera", "createdAt": "2020-02-12T10:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0ODY2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377848664", "bodyText": "return getDefaultFillValue(expr.type);", "author": "MaryamZi", "createdAt": "2020-02-11T19:25:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        BType type = expr.type;\n+        return getDefaultFillValue(type);", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378041191", "bodyText": "Can't we just check !isSameType(valueType, firstElement.type) and return false here?", "author": "MaryamZi", "createdAt": "2020-02-12T04:59:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTEzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135135", "bodyText": "What if at the end or after this there is a nil value. Therefore I let the loop continue. If there is nil it is the fill value.", "author": "KRVPerera", "createdAt": "2020-02-12T09:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjg5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042891", "bodyText": "If this was true we would have already returned at https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-782094a79e6831ac57a34ad157af49c1R2678 right?", "author": "MaryamZi", "createdAt": "2020-02-12T05:08:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042966", "bodyText": "Again, can these be null?", "author": "MaryamZi", "createdAt": "2020-02-12T05:08:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTA3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135076", "bodyText": "Let me remove. I think this should not be null", "author": "KRVPerera", "createdAt": "2020-02-12T09:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDM2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044361", "bodyText": "Is this set for record fields too? IINM, we usually check only a flag.", "author": "MaryamZi", "createdAt": "2020-02-12T05:16:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044784", "bodyText": "IINM, this is not correct. According to the spec, fill member should be done only for lists.\ntype Foo record {\n   string s;\n};\n\nFoo[2] arr = [];\nThis should still fail IMO.", "author": "MaryamZi", "createdAt": "2020-02-12T05:18:26Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDAzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379334030", "bodyText": "Commit f21bca4\nshould address this.", "author": "KRVPerera", "createdAt": "2020-02-14T09:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex af36177bf0b..cace408bc0a 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2565,9 +2566,6 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n-        if (type == null) {\n-            return true;\n-        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"oid": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "message": "Fix invalid logic", "committedDate": "2020-02-13T05:45:25Z", "type": "forcePushed"}, {"oid": "7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "message": "Refactor fill value check for Union type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-13T15:29:22Z", "type": "forcePushed"}, {"oid": "5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "message": "Change error for list-expr usage without filler\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-14T04:43:26Z", "type": "forcePushed"}, {"oid": "f21bca4d1e537732576a0558486343c55dd1def9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f21bca4d1e537732576a0558486343c55dd1def9", "message": "Fix filler value check logic for Records\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-14T09:37:59Z", "type": "forcePushed"}, {"oid": "c3c97829d04a244c24dec385c28f71566407be08", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3c97829d04a244c24dec385c28f71566407be08", "message": "Incorporate code quality feedback on code review", "committedDate": "2020-02-14T10:41:04Z", "type": "forcePushed"}, {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d15f2572961cd44fb9146eabfa3b3131e70de7e", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type.", "committedDate": "2020-02-14T10:43:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzIwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380137205", "bodyText": "Comments are invalid now?", "author": "MaryamZi", "createdAt": "2020-02-17T11:49:35Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -842,13 +850,15 @@ protected void rangeCheck(long index, int size) {\n     protected void fillerValueCheck(int index, int size) {\n         // if there has been values added beyond the current index, that means filler values\n         // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\nindex 756a21eb631..7f771ccb257 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n\n@@ -848,8 +848,6 @@ public class ArrayValueImpl extends AbstractArrayValue {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n         if (!hasFillerValue.isPresent()) {\n             hasFillerValue = Optional.of(TypeChecker.hasFillerValue(this.elementType));\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzQzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380143430", "bodyText": "Shouldn't the getter return an unmodifiable set too?", "author": "MaryamZi", "createdAt": "2020-02-17T12:04:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -37,9 +37,11 @@\n  */\n public class BFiniteType extends BType implements FiniteType {\n \n-    public Set<BLangExpression> valueSpace;\n+    private Set<BLangExpression> valueSpace;", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44c71470244d611e03adcc4f5fec68eccf5669bb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\nindex d32ca852513..d38ac02aed3 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n\n@@ -37,11 +37,9 @@ import java.util.StringJoiner;\n  */\n public class BFiniteType extends BType implements FiniteType {\n \n-    private Set<BLangExpression> valueSpace;\n-    private boolean nullable = false;\n+    public Set<BLangExpression> valueSpace;\n     private Optional<Boolean> isAnyData = Optional.empty();\n \n-\n     public BFiniteType(BTypeSymbol tsymbol) {\n         super(TypeTags.FINITE, tsymbol);\n         valueSpace = new LinkedHashSet<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NDg5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380144896", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since 1.1.2\n          \n          \n            \n                 * @since 1.2.0", "author": "MaryamZi", "createdAt": "2020-02-17T12:07:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,32 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep filler value for basic types in String format.\n+     *\n+     * @since 1.1.2", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -113,7 +113,7 @@ public class Types {\n     /**\n      * Keep filler value for basic types in String format.\n      *\n-     * @since 1.1.2\n+     * @since 1.2.0\n      */\n     public enum DefaultValues {\n         STRING(\"\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147055", "bodyText": "This can be\n    return (type.tsymbol.flags & Flags.ABSTRACT) != Flags.ABSTRACT;\nright?", "author": "MaryamZi", "createdAt": "2020-02-17T12:12:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4NDg3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380484878", "bodyText": "Even if the object is not an abstract object we still need to do some checks or parameters in the initializer function. But I changed the logic giving importance to abstraction check. Can you check the new logic whether I got your point correctly? ff0acc0", "author": "KRVPerera", "createdAt": "2020-02-18T06:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2592,23 +2592,22 @@ public class Types {\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n         BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n         if (initFunction == null) {\n-            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n-                return false;\n-            }\n-        } else {\n-            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n-                return false;\n-            }\n-            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n                 return false;\n             }\n-            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n-                if (!bVarSymbol.defaultableParam) {\n-                    return false;\n-                }\n-            }\n         }\n         return true;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147352", "bodyText": "We can then remove this else and move out this block?", "author": "MaryamZi", "createdAt": "2020-02-17T12:13:27Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2592,23 +2592,22 @@ public class Types {\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n         BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n         if (initFunction == null) {\n-            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n-                return false;\n-            }\n-        } else {\n-            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n-                return false;\n-            }\n-            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n                 return false;\n             }\n-            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n-                if (!bVarSymbol.defaultableParam) {\n-                    return false;\n-                }\n-            }\n         }\n         return true;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0Nzk3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147975", "bodyText": "IINM, this can never be just error. It's either nil or a union with error. Just checking initFunction.symbol.getReturnType().getKind() != TypeKind.NIL should be enough?", "author": "MaryamZi", "createdAt": "2020-02-17T12:14:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2592,23 +2592,22 @@ public class Types {\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n         BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n         if (initFunction == null) {\n-            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n-                return false;\n-            }\n-        } else {\n-            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n-                return false;\n-            }\n-            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n                 return false;\n             }\n-            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n-                if (!bVarSymbol.defaultableParam) {\n-                    return false;\n-                }\n-            }\n         }\n         return true;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NDIzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380154234", "bodyText": "IMO, we can remove this.", "author": "MaryamZi", "createdAt": "2020-02-17T12:28:54Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2592,23 +2592,22 @@ public class Types {\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n         BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n         if (initFunction == null) {\n-            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n-                return false;\n-            }\n-        } else {\n-            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n-                return false;\n-            }\n-            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n                 return false;\n             }\n-            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n-                if (!bVarSymbol.defaultableParam) {\n-                    return false;\n-                }\n-            }\n         }\n         return true;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NTgzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380155835", "bodyText": "Can we extract out firstElement.type to a variable?", "author": "MaryamZi", "createdAt": "2020-02-17T12:32:39Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }\n+        boolean defaultFillValuePresent = false;\n+\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElement.type)) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff0acc05501340c2064c3bb1b3211752955782ad", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 229668ff36c..d01ff16e2cd 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2592,23 +2592,22 @@ public class Types {\n     }\n \n     private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n         BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n         if (initFunction == null) {\n-            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n-                return false;\n-            }\n-        } else {\n-            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n-                return false;\n-            }\n-            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n                 return false;\n             }\n-            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n-                if (!bVarSymbol.defaultableParam) {\n-                    return false;\n-                }\n-            }\n         }\n         return true;\n     }\n"}}, {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff0acc05501340c2064c3bb1b3211752955782ad", "message": "Incorporate code review feedback", "committedDate": "2020-02-17T20:56:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381761662", "bodyText": "Can we validate if this works for constants?\nconst ZERO = 0;\n\ntype Foo ZERO|1|2;", "author": "MaryamZi", "createdAt": "2020-02-20T05:12:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMDc1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382100753", "bodyText": "fixed test case added\n7d525fc", "author": "KRVPerera", "createdAt": "2020-02-20T16:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "af14271c90a2a56d7fda35b055a4840553985ad9", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex d01ff16e2cd..123fb7047ff 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2637,12 +2640,15 @@ public class Types {\n         BLangExpression firstElement = (BLangExpression) iterator.next();\n         BType firstElementType = firstElement.type;\n         String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n         if (firstElement.toString().equals(defaultFillValue)) {\n             defaultFillValuePresent = true;\n         }\n \n         while (iterator.hasNext()) {\n-            Object value =  iterator.next();\n+            Object value = iterator.next();\n             BType valueType = ((BLangExpression) value).type;\n             if (!isSameType(valueType, firstElementType)) {\n                 return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381762506", "bodyText": "This fillerValueCheck() method is called for each and every add operation. So could this be an overhead?\nSince hasFillerValue needs to be calculated only once for a given type, can we move this flag to the array-type, and have it calculated only once during the initialisation of the type?", "author": "SupunS", "createdAt": "2020-02-20T05:14:41Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -840,15 +848,15 @@ protected void rangeCheck(long index, int size) {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {\n-            return;\n+        if (!hasFillerValue.isPresent()) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4NTYxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382085618", "bodyText": "fixed by c0998bf", "author": "KRVPerera", "createdAt": "2020-02-20T15:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "af14271c90a2a56d7fda35b055a4840553985ad9", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\nindex 7f771ccb257..8e1fc52f20a 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n\n@@ -848,17 +846,13 @@ public class ArrayValueImpl extends AbstractArrayValue {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        if (!hasFillerValue.isPresent()) {\n-            hasFillerValue = Optional.of(TypeChecker.hasFillerValue(this.elementType));\n-        }\n-\n         // if the elementType doesn't have an implicit initial value & if the insertion is not a consecutive append\n         // to the array, then an exception will be thrown.\n-        if (hasFillerValue.get()) {\n+        if (arrayType.hasFillerValue()) {\n             return;\n         } else if (index > size) {\n             throw BLangExceptionHelper.getRuntimeException(BallerinaErrorReasons.ILLEGAL_LIST_INSERTION_ERROR,\n-                    RuntimeErrors.ILLEGAL_ARRAY_INSERTION, size, index + 1);\n+                                                           RuntimeErrors.ILLEGAL_ARRAY_INSERTION, size, index + 1);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381772635", "bodyText": "Wondering if keeping this in the String format is the best approach? Can't we use the value itself and compare, based on the assumption that they will only be used for comparison with either literals or constant refs?", "author": "MaryamZi", "createdAt": "2020-02-20T05:35:35Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0Nzk4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382147985", "bodyText": "If the integer is '5' the valid fill value should be '0' for an int. Need to get the default value or implicit default value for int type which is zero.\nI have added a negative test case for this.\nTest Case:  https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-65f99a2264d6173185afec0d71e151c6R63\nError Message: https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-7319ccb85e364b3233fb96f11c424f29R212", "author": "KRVPerera", "createdAt": "2020-02-20T17:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNzkwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382417905", "bodyText": "Note: The code is written similar to run-time check. \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\n    \n    \n         Line 1787\n      in\n      7e0d467\n    \n    \n    \n    \n\n        \n          \n           if (firstElement instanceof String) { \n        \n    \n  \n\n\nThe plan is to replace string enum with objects and also in accordance with spec. This may require calling initialiser methods to create zero value objects for every type. Should handle all basic types. Finally, it will be like src.equals(target)", "author": "KRVPerera", "createdAt": "2020-02-21T06:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "af14271c90a2a56d7fda35b055a4840553985ad9", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex d01ff16e2cd..123fb7047ff 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2637,12 +2640,15 @@ public class Types {\n         BLangExpression firstElement = (BLangExpression) iterator.next();\n         BType firstElementType = firstElement.type;\n         String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n         if (firstElement.toString().equals(defaultFillValue)) {\n             defaultFillValuePresent = true;\n         }\n \n         while (iterator.hasNext()) {\n-            Object value =  iterator.next();\n+            Object value = iterator.next();\n             BType valueType = ((BLangExpression) value).type;\n             if (!isSameType(valueType, firstElementType)) {\n                 return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775470", "bodyText": "Shall we remove the extra lines?", "author": "MaryamZi", "createdAt": "2020-02-20T05:41:18Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -36,177 +36,117 @@\n  */\n public class SealedArrayTest {\n \n-    private CompileResult compileResult, resultNegative, semanticsNegative;\n+    private CompileResult compileResult, resultNegative, semanticsNegative, listExprNegative;\n \n     @BeforeClass\n     public void setup() {\n         compileResult = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array.bal\");\n         resultNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-negative.bal\");\n+        listExprNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed_array_listexpr_negative.bal\");\n         semanticsNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-semantics-negative\" +\n                 \".bal\");\n     }\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n+", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5ODI0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382098241", "bodyText": "Fixed ab2afb7", "author": "KRVPerera", "createdAt": "2020-02-20T16:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\nindex a7361f4125c..5b5e77f70a1 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n\n@@ -50,102 +50,76 @@ public class SealedArrayTest {\n     @Test\n     public void testCreateIntegerSealedArray() {\n         BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n         BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n         BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateStringSealedArray() {\n         BRunUtil.invoke(compileResult, \"createStringSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createStringAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createStringSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createStringDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateJSONSealedArray() {\n         BRunUtil.invoke(compileResult, \"createJSONSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createJSONSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createJSONDefaultSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createJSONAutoFilledSealedArray\");\n     }\n \n     @Test\n     public void testCreateAnySealedArray() {\n         BRunUtil.invoke(compileResult, \"createAnySealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createAnyAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createAnySealedArrayWithLabel\");\n     }\n \n     @Test\n     public void testCreateRecordSealedArray() {\n         BRunUtil.invoke(compileResult, \"createRecordSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createRecordAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createRecordSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createRecordSealedArrayAutoFill\");\n     }\n \n     @Test\n     public void testCreateByteSealedArray() {\n         BRunUtil.invoke(compileResult, \"createByteSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createByteAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createByteSealedArrayWithLabel\");\n-\n         BRunUtil.invoke(compileResult, \"createByteDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateTupleSealedArray() {\n         BRunUtil.invoke(compileResult, \"createTupleSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createTupleAutoFilledSealedArray\");\n-\n         BRunUtil.invoke(compileResult, \"createTupleSealedArrayWithLabel\");\n     }\n \n     @Test\n     public void testFunctionParametersAndReturnValues() {\n         BRunUtil.invoke(compileResult, \"functionParametersAndReturns\");\n-\n         BRunUtil.invoke(compileResult, \"functionParametersAndReturnsAutoFilling\");\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775593", "bodyText": "Invalid comment?", "author": "MaryamZi", "createdAt": "2020-02-20T05:41:34Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjkxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096914", "bodyText": "Fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "af14271c90a2a56d7fda35b055a4840553985ad9", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\nindex a7361f4125c..d49fbf58126 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n\n@@ -225,53 +225,51 @@ public class SealedArrayTest {\n     // TODO : uncomment\n     @Test()\n     public void testNegativeAutoFillSealedArray() {\n-        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 10);\n         BAssertUtil.validateError(listExprNegative, 0,\n                                   \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n                                   24,\n                                   19);\n         BAssertUtil.validateError(listExprNegative, 1,\n-                                  \"invalid usage of list constructor: type 'Person[5][]' does not have a filler value\",\n-                                  31,\n-                                  21);\n-        BAssertUtil.validateError(listExprNegative, 2,\n                                   \"invalid usage of list constructor: type 'Person[5][1]' does not have a filler value\",\n-                                  32,\n+                                  31,\n                                   22);\n-        BAssertUtil.validateError(listExprNegative, 3,\n-                                  \"invalid usage of list constructor: type 'Age[5][]' does not have a filler value\", 44,\n-                                  18);\n-        BAssertUtil.validateError(listExprNegative, 4,\n+        BAssertUtil.validateError(listExprNegative, 2,\n                                   \"invalid usage of list constructor: type 'Age[5][1]' does not have a filler value\",\n-                                  45,\n+                                  43,\n                                   19);\n-        BAssertUtil.validateError(listExprNegative, 5,\n+        BAssertUtil.validateError(listExprNegative, 3,\n                                   \"invalid usage of list constructor: type '1|2|3|4[3]' does not have a filler value\",\n-                                  66,\n+                                  63,\n                                   18);\n-        BAssertUtil.validateError(listExprNegative, 6,\n+        BAssertUtil.validateError(listExprNegative, 4,\n                                   \"invalid usage of list constructor: type '0|0.0f|[3]' does not have a filler value\",\n-                                  72,\n+                                  69,\n                                   34);\n-        BAssertUtil.validateError(listExprNegative, 7,\n+        BAssertUtil.validateError(listExprNegative, 5,\n                                   \"invalid usage of list constructor: type 'Rec[2]' does not have a filler value\",\n-                                  91,\n+                                  88,\n                                   16);\n-        BAssertUtil.validateError(listExprNegative, 8,\n+        BAssertUtil.validateError(listExprNegative, 6,\n                                   \"invalid usage of list constructor: type 'RecWithManyOptional[2]' does not have a \" +\n                                           \"filler value\",\n-                                  95,\n+                                  92,\n                                   32);\n-        BAssertUtil.validateError(listExprNegative, 9,\n+        BAssertUtil.validateError(listExprNegative, 7,\n                                   \"invalid usage of list constructor: type 'RecWithOptional[2]' does not have a \" +\n                                           \"filler value\",\n-                                  99,\n+                                  96,\n                                   28);\n-        BAssertUtil.validateError(listExprNegative, 10,\n+        BAssertUtil.validateError(listExprNegative, 8,\n                                   \"invalid usage of list constructor: type 'ObjError[2]' does not have a \" +\n                                           \"filler value\",\n-                                  112,\n+                                  109,\n                                   22);\n+        BAssertUtil.validateError(listExprNegative, 9,\n+                                  \"invalid usage of list constructor: type '(HELLO|2)[2]' does not have a filler \" +\n+                                          \"value\",\n+                                  118,\n+                                  34);\n     }\n \n     @Test()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775854", "bodyText": "Can we have these in a single line?", "author": "MaryamZi", "createdAt": "2020-02-20T05:42:08Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment\n+    @Test()\n+    public void testNegativeAutoFillSealedArray() {\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        BAssertUtil.validateError(listExprNegative, 0,\n+                                  \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n+                                  24,\n+                                  19);", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjgwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096800", "bodyText": "Fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "af14271c90a2a56d7fda35b055a4840553985ad9", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\nindex a7361f4125c..d49fbf58126 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java\n\n@@ -225,53 +225,51 @@ public class SealedArrayTest {\n     // TODO : uncomment\n     @Test()\n     public void testNegativeAutoFillSealedArray() {\n-        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 10);\n         BAssertUtil.validateError(listExprNegative, 0,\n                                   \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n                                   24,\n                                   19);\n         BAssertUtil.validateError(listExprNegative, 1,\n-                                  \"invalid usage of list constructor: type 'Person[5][]' does not have a filler value\",\n-                                  31,\n-                                  21);\n-        BAssertUtil.validateError(listExprNegative, 2,\n                                   \"invalid usage of list constructor: type 'Person[5][1]' does not have a filler value\",\n-                                  32,\n+                                  31,\n                                   22);\n-        BAssertUtil.validateError(listExprNegative, 3,\n-                                  \"invalid usage of list constructor: type 'Age[5][]' does not have a filler value\", 44,\n-                                  18);\n-        BAssertUtil.validateError(listExprNegative, 4,\n+        BAssertUtil.validateError(listExprNegative, 2,\n                                   \"invalid usage of list constructor: type 'Age[5][1]' does not have a filler value\",\n-                                  45,\n+                                  43,\n                                   19);\n-        BAssertUtil.validateError(listExprNegative, 5,\n+        BAssertUtil.validateError(listExprNegative, 3,\n                                   \"invalid usage of list constructor: type '1|2|3|4[3]' does not have a filler value\",\n-                                  66,\n+                                  63,\n                                   18);\n-        BAssertUtil.validateError(listExprNegative, 6,\n+        BAssertUtil.validateError(listExprNegative, 4,\n                                   \"invalid usage of list constructor: type '0|0.0f|[3]' does not have a filler value\",\n-                                  72,\n+                                  69,\n                                   34);\n-        BAssertUtil.validateError(listExprNegative, 7,\n+        BAssertUtil.validateError(listExprNegative, 5,\n                                   \"invalid usage of list constructor: type 'Rec[2]' does not have a filler value\",\n-                                  91,\n+                                  88,\n                                   16);\n-        BAssertUtil.validateError(listExprNegative, 8,\n+        BAssertUtil.validateError(listExprNegative, 6,\n                                   \"invalid usage of list constructor: type 'RecWithManyOptional[2]' does not have a \" +\n                                           \"filler value\",\n-                                  95,\n+                                  92,\n                                   32);\n-        BAssertUtil.validateError(listExprNegative, 9,\n+        BAssertUtil.validateError(listExprNegative, 7,\n                                   \"invalid usage of list constructor: type 'RecWithOptional[2]' does not have a \" +\n                                           \"filler value\",\n-                                  99,\n+                                  96,\n                                   28);\n-        BAssertUtil.validateError(listExprNegative, 10,\n+        BAssertUtil.validateError(listExprNegative, 8,\n                                   \"invalid usage of list constructor: type 'ObjError[2]' does not have a \" +\n                                           \"filler value\",\n-                                  112,\n+                                  109,\n                                   22);\n+        BAssertUtil.validateError(listExprNegative, 9,\n+                                  \"invalid usage of list constructor: type '(HELLO|2)[2]' does not have a filler \" +\n+                                          \"value\",\n+                                  118,\n+                                  34);\n     }\n \n     @Test()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381779781", "bodyText": "Incorrect version?", "author": "MaryamZi", "createdAt": "2020-02-20T05:50:11Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.test.statements.arrays;\n+\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases for filling the elements of the array with its type's implicit initial value.\n+ *\n+ * @since 1.1.1", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjczMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096733", "bodyText": "fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java\nindex 1345045183d..682b32bc4d3 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java\n\n@@ -26,7 +26,7 @@ import org.testng.annotations.Test;\n /**\n  * Test cases for filling the elements of the array with its type's implicit initial value.\n  *\n- * @since 1.1.1\n+ * @since 1.2.0\n  */\n public class ArrayFillTestRuntime {\n \n"}}, {"oid": "af14271c90a2a56d7fda35b055a4840553985ad9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af14271c90a2a56d7fda35b055a4840553985ad9", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-20T15:43:49Z", "type": "forcePushed"}, {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/17f429daf9d5785fbeee7d411c55b2c892bda422", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-20T17:15:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382397181", "bodyText": "Do we need to check this here?\nIsn't fillValues always called after fillerValueCheck?", "author": "MaryamZi", "createdAt": "2020-02-21T04:55:12Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -808,8 +813,9 @@ protected void fillValues(int index) {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-\n+                if (arrayType.hasFillerValue()) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDg3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382414876", "bodyText": "This is not true for code coming from desugar.\nAs an example.\n     AbstractPersonObject[5][] y = [];\n     AbstractPersonObject e1 = new Employee(\"John\", \"Doe\");\n     y[0] = [e1];\n     AbstractPersonObject[][5] r = [];\n     r[0] = [e1, e1, e1, e1, e1];\n\nr[0] = [e1, e1, e1, e1, e1] expands by first creating a sealed array. Then adding values.\nAbstractPersonObject[5] = [] \n\nThis is not allowed we cannot fill this by 5 AbstractPersonObject s. If user write this code it will give a compiler error . But since this is tool generated implementation we cannot error out this.\nfillerValueCheck error out only if there is a need for filling. Consecutive inserts should not fail too which is guranteed by index > size condition. Since this array size is already 5 as generated by desugar fillerValueCheck at runtime will not give an error.\nBir Dump:\nhttps://gist.github.com/KRVPerera/92dec4c3fd1eee166ba88dd891dd1163", "author": "KRVPerera", "createdAt": "2020-02-21T06:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "44c71470244d611e03adcc4f5fec68eccf5669bb", "chunk": "diff --git a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\nindex 8e1fc52f20a..e11ec30a4e9 100644\n--- a/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n+++ b/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java\n\n@@ -813,9 +808,8 @@ public class ArrayValueImpl extends AbstractArrayValue {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                if (arrayType.hasFillerValue()) {\n-                    Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-                }\n+                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n+\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407373", "bodyText": "We seem to have methods with different namescheckFillerValue, hasFillerValue, etc. across the class for similar checks. Shall we revisit these and group them together?", "author": "MaryamZi", "createdAt": "2020-02-21T05:46:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,35 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    private boolean checkFillerValue(BUnionType type) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNjExMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382416111", "bodyText": "hasFillerValue is the public method which calls checkfillerValue helper methods sometime recursively. I will try to refactor.", "author": "KRVPerera", "createdAt": "2020-02-21T06:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "44c71470244d611e03adcc4f5fec68eccf5669bb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 0e3cb3e13be..c8b7a5f12c0 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -110,33 +110,29 @@ public class Types {\n     private Names names;\n     private int finiteTypeCount = 0;\n \n-    private boolean checkFillerValue(BUnionType type) {\n-        if (type.isNullable()) {\n-            return true;\n-        }\n-        Iterator<BType> iterator = type.getMemberTypes().iterator();\n-        BType firstMember = iterator.next();\n-        boolean defaultFillValuePresent = false;\n+    /**\n+     * Keep default values for basic types in String format.\n+     *\n+     */\n+    public enum DefaultValues {\n+        STRING(\"\"),\n+        INTEGER(\"0\"),\n+        BYTE(\"0\"),\n+        FLOAT(\"0.0\"),\n+        BIGDECIMAL(\"0.0\"),\n+        BOOLEAN(\"false\"),\n+        NIL(\"()\"),\n+        UNKNOWN(\"UNKNOWN\");\n \n-        // is first value is a valid fill value\n-        String defaultFillValue = getDefaultFillValue(firstMember);\n-        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n-            return false;\n-        }\n-        if (firstMember.toString().equals(defaultFillValue)) {\n-            defaultFillValuePresent = true;\n+        private String value;\n+\n+        DefaultValues(String value) {\n+            this.value = value;\n         }\n \n-        while (iterator.hasNext()) {\n-            Object value = iterator.next();\n-            if (!isSameType(firstMember, (BType) value)) {\n-                return false;\n-            }\n-            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n-                defaultFillValuePresent = true;\n-            }\n+        public String getValue() {\n+            return value;\n         }\n-        return defaultFillValuePresent;\n     }\n \n     public static Types getInstance(CompilerContext context) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzQ1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407454", "bodyText": "What about when the value space has more than one value but are all of the same type?", "author": "MaryamZi", "createdAt": "2020-02-21T05:46:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2583,182 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private String getDefaultFillValue(BType type) {\n+        switch(type.getKind()) {\n+            case INT:\n+            case BYTE:\n+                return DefaultValues.INTEGER.getValue();\n+            case STRING:\n+                return DefaultValues.STRING.getValue();\n+            case DECIMAL:\n+            case FLOAT:\n+                return DefaultValues.FLOAT.getValue();\n+            case BOOLEAN:\n+                return DefaultValues.BOOLEAN.getValue();\n+            case NIL:\n+                return DefaultValues.NIL.getValue();\n+            case ERROR:\n+            case TYPEDESC:\n+                return DefaultValues.UNKNOWN.getValue();\n+            default:\n+                if (type instanceof BFiniteType) {\n+                    return getDefaultFillValue((BFiniteType) type);\n+                }\n+                return DefaultValues.UNKNOWN.getValue();\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        if (type.size == -1) {\n+            return true;\n+        }\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BFiniteType finiteType) {\n+        if (finiteType.getValueSpace().size() == 1) {\n+            for (BLangExpression valueLiteral : finiteType.getValueSpace()) {\n+                if (!(valueLiteral instanceof BLangLiteral)) {\n+                    return DefaultValues.UNKNOWN.getValue();\n+                }\n+                return valueLiteral.toString();\n+            }\n+        }\n+        return DefaultValues.UNKNOWN.getValue();", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44c71470244d611e03adcc4f5fec68eccf5669bb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 0e3cb3e13be..c8b7a5f12c0 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2585,6 +2581,9 @@ public class Types {\n     }\n \n     public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n         if (type.tag < TypeTags.RECORD) {\n             return true;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NjgxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r383146816", "bodyText": "isNullable call", "author": "KRVPerera", "createdAt": "2020-02-24T09:13:26Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -111,4 +114,11 @@ public boolean isAnydata() {\n         this.isAnyData = Optional.of(true);\n         return true;\n     }\n+\n+    public void addValue(BLangExpression value) {\n+        this.valueSpace.add(value);\n+        if (!nullable && (value.type.tag == TypeTags.NIL)) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44c71470244d611e03adcc4f5fec68eccf5669bb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\nindex b5bf22675d9..d38ac02aed3 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n\n@@ -114,11 +111,4 @@ public class BFiniteType extends BType implements FiniteType {\n         this.isAnyData = Optional.of(true);\n         return true;\n     }\n-\n-    public void addValue(BLangExpression value) {\n-        this.valueSpace.add(value);\n-        if (!nullable && (value.type.tag == TypeTags.NIL)) {\n-            nullable = true;\n-        }\n-    }\n }\n"}}, {"oid": "44c71470244d611e03adcc4f5fec68eccf5669bb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44c71470244d611e03adcc4f5fec68eccf5669bb", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:31Z", "type": "commit"}, {"oid": "5463e66362a78d6e556e803b56f81121f729d195", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5463e66362a78d6e556e803b56f81121f729d195", "message": "Add run time support for list-expr auto filling\n\nAfter compile time fill value check is done run time needs to actually\nfill the values. Since previously we were not handling situation at\ncompile time object filling is enforced now at compile time\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:31Z", "type": "commit"}, {"oid": "304b6202f2fde0ebc346d1788fd44d51e65d5093", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/304b6202f2fde0ebc346d1788fd44d51e65d5093", "message": "Fix negative test cases to accept list-expr filling\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "message": "Add list-expr auto fill test cases\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\r\n\r\nCode review suggestion to improve doc comment\n\nCo-Authored-By: kalaiyarasiganeshalingam <ashakalai31@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "159db5d3607b5960f1698dab1ed480b7c0363c72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/159db5d3607b5960f1698dab1ed480b7c0363c72", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type.", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "cacda240e52e7d7387d6681d50ef74df3e39cd3b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cacda240e52e7d7387d6681d50ef74df3e39cd3b", "message": "Incorporate code review feedback", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "message": "Cache runtime filler value check in BArrayType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "f238554650314bf495aca1e84c4297d07c2eae98", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f238554650314bf495aca1e84c4297d07c2eae98", "message": "Fix filler value check for unions with constants\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "8c19d9e17da81716ef0cb8a4124481f9990367d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c19d9e17da81716ef0cb8a4124481f9990367d0", "message": "Remove multi-dim dynamic array filler-value check\n\nThis will not give syntax errors for multidimensional arrays with\ndynamic arrays which does not need filler values. This allow user to\ncreate fixed size (sealed) arrays with abstract objects but with inner\nmost dimension is dynamic array. Run time check will still run to make\nsure dynamic automatic array fill by compiler is not allowed. User must\ngive valid objects at runtime to these arrays.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "message": "Improve filler-value check for BFiniteType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "1a5426f3a7cd14ef99f007fc7854f43774c836ef", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a5426f3a7cd14ef99f007fc7854f43774c836ef", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "forcePushed"}, {"oid": "2d67c3899c76d1080418067c6b3570f40011eb05", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2d67c3899c76d1080418067c6b3570f40011eb05", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:18:26Z", "type": "forcePushed"}, {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:37:38Z", "type": "commit"}, {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:37:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384272071", "bodyText": "The following should work right?\nconst FOO = \"foo\";\nconst BAR = \"bar\";\n\ntype FooBar FOO|BAR;\n\npublic function main() {\n    (map<FooBar>|map<string>)[2] x = [];\n}\nI guess it won't work with the isValueType check?", "author": "MaryamZi", "createdAt": "2020-02-26T04:43:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NjQyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384286427", "bodyText": "Shall we create an issue for this?", "author": "hasithaa", "createdAt": "2020-02-26T05:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MzcwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384293702", "bodyText": "Created #21251", "author": "MaryamZi", "createdAt": "2020-02-26T06:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NTg3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384275871", "bodyText": "How about constant refs?", "author": "MaryamZi", "createdAt": "2020-02-26T05:02:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjAxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276018", "bodyText": "Do we need this null check?", "author": "MaryamZi", "createdAt": "2020-02-26T05:03:02Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjEzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276138", "bodyText": "Shouldn't we check if value is null?", "author": "MaryamZi", "createdAt": "2020-02-26T05:03:31Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");\n+                case DECIMAL:\n+                case FLOAT:\n+                    return value.equals(String.valueOf(0.0));\n+                case BOOLEAN:\n+                    return value.equals(Boolean.valueOf(false));\n+                case NIL:\n+                    return true;", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}