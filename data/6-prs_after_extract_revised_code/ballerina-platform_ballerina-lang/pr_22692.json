{"pr_number": 22692, "pr_title": "Fix runtime error in optional field access", "pr_createdAt": "2020-04-16T19:13:49Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692", "timeline": [{"oid": "129576a43770f6619619b2c1c836639b5481d9b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/129576a43770f6619619b2c1c836639b5481d9b2", "message": "Fix error in optional field access", "committedDate": "2020-04-17T03:41:29Z", "type": "forcePushed"}, {"oid": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f686147f125306f9e2d77e13a9acb95ded3dc37", "message": "Fix error in optional field access", "committedDate": "2020-04-17T08:24:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NDcxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411884710", "bodyText": "To minimize the Java code we can intro in the test file\nfunction testFieldAccessInUnionType() {\n    testOptionalFieldAccessInUnionType1();\n    testOptionalFieldAccessInUnionType2();\n}\nand here just do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Test\n          \n          \n            \n                public void testOptionalFieldAccessInUnionType1() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType1\");\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Test\n          \n          \n            \n                public void testOptionalFieldAccessInUnionType2() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType2\");\n          \n          \n            \n                }\n          \n          \n            \n                @Test\n          \n          \n            \n                public void testFieldAccessInUnionType() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testFieldAccessInUnionType\");\n          \n          \n            \n                }", "author": "MaryamZi", "createdAt": "2020-04-21T05:41:57Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java", "diffHunk": "@@ -132,4 +132,14 @@ public void testOptionalFieldAccessOnInvocation(String function) {\n                 { \"testJsonOptionalFieldAccessOnInvocation\" }\n         };\n     }\n+\n+    @Test\n+    public void testOptionalFieldAccessInUnionType1() {\n+        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType1\");\n+    }\n+\n+    @Test\n+    public void testOptionalFieldAccessInUnionType2() {\n+        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType2\");\n+    }", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java\nindex b65e5fc8f54..be5978309c5 100644\n--- a/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java\n+++ b/tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java\n\n@@ -134,12 +134,7 @@ public class OptionalFieldAccessTest {\n     }\n \n     @Test\n-    public void testOptionalFieldAccessInUnionType1() {\n-        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType1\");\n-    }\n-\n-    @Test\n-    public void testOptionalFieldAccessInUnionType2() {\n-        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType2\");\n+    public void testOptionalFieldAccessInUnionType() {\n+        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType\");\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5NTExMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411895110", "bodyText": "Shall we rename \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n    \n    \n         Line 4255\n      in\n      8b26828\n    \n    \n    \n    \n\n        \n          \n           private BType addNilForNillableIndexBasedAccess(BType actualType) { \n        \n    \n  \n\n and use that instead?", "author": "MaryamZi", "createdAt": "2020-04-21T06:06:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4381,16 +4381,23 @@ private BType checkOptionalRecordFieldAccessExpr(BLangFieldBasedAccess fieldAcce\n \n         LinkedHashSet<BType> fieldTypeMembers = new LinkedHashSet<>();\n \n+        boolean nonMatchedRecordExists = false;\n+\n         for (BType memType : memberTypes) {\n             BType individualFieldType = checkOptionalRecordFieldAccessExpr(fieldAccessExpr, memType, fieldName);\n \n             if (individualFieldType == symTable.semanticError) {\n+                nonMatchedRecordExists = true;\n                 continue;\n             }\n \n             fieldTypeMembers.add(individualFieldType);\n         }\n \n+        if (nonMatchedRecordExists) {\n+            fieldTypeMembers.add(symTable.nilType);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTY4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413699687", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5NTExMA=="}], "type": "inlineReview", "revised_code": {"commit": "d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\nindex 41ad0f50cd3..d35053cdecf 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n\n@@ -4379,10 +4612,12 @@ public class TypeChecker extends BLangNodeVisitor {\n         // Resultant field type is calculated here.\n         Set<BType> memberTypes = ((BUnionType) varRefType).getMemberTypes();\n \n-        LinkedHashSet<BType> fieldTypeMembers = new LinkedHashSet<>();\n+        BType fieldType;\n \n         boolean nonMatchedRecordExists = false;\n \n+        LinkedHashSet<BType> fieldTypeMembers = new LinkedHashSet<>();\n+\n         for (BType memType : memberTypes) {\n             BType individualFieldType = checkOptionalRecordFieldAccessExpr(fieldAccessExpr, memType, fieldName);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5Njc4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411896782", "bodyText": "Can we work with a LinkedHashSet instead? We don't need the union type right?", "author": "MaryamZi", "createdAt": "2020-04-21T06:10:35Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTQ3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413699479", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5Njc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -5882,8 +5882,7 @@ public class Desugar extends BLangNodeVisitor {\n         BLangMatchTypedBindingPatternClause successPattern = null;\n         Name field = getFieldName(accessExpr);\n         if (field == Names.EMPTY) {\n-            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n-                    accessExpr.errorSafeNavigation);\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n             matchStmt.patternClauses.add(successPattern);\n             pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMDIzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411900238", "bodyText": "IMO the method name does not say much about what the method actually does, and the variable name kinda implies the check returns if all the members are records, which from the impl. doesn't seem to be the case. Can we rename?", "author": "MaryamZi", "createdAt": "2020-04-21T06:18:16Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -5882,8 +5882,7 @@ public class Desugar extends BLangNodeVisitor {\n         BLangMatchTypedBindingPatternClause successPattern = null;\n         Name field = getFieldName(accessExpr);\n         if (field == Names.EMPTY) {\n-            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n-                    accessExpr.errorSafeNavigation);\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n             matchStmt.patternClauses.add(successPattern);\n             pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMjE2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411902165", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        successPattern = getSuccessPattern(accessExpr, tempResultVar,\n          \n          \n            \n                                accessExpr.errorSafeNavigation);\n          \n          \n            \n                        successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);", "author": "MaryamZi", "createdAt": "2020-04-21T06:22:07Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -5882,8 +5882,7 @@ public class Desugar extends BLangNodeVisitor {\n         BLangMatchTypedBindingPatternClause successPattern = null;\n         Name field = getFieldName(accessExpr);\n         if (field == Names.EMPTY) {\n-            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n-                    accessExpr.errorSafeNavigation);\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n             matchStmt.patternClauses.add(successPattern);\n             pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411904688", "bodyText": "Do we need to do this? Can we not just iterate through the fields of the BRecordType and figure out if the field exists?\nsymResolver.resolveStructField could log errors right, even thought it may not atm?", "author": "MaryamZi", "createdAt": "2020-04-21T06:27:13Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);\n+            matchStmt.patternClauses.add(successPattern);\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n+        }\n \n+        if (allRecords) {\n+            for (BType memberType : errorLiftedType.getMemberTypes()) {\n+                BSymbol fieldSymbol = symResolver.resolveStructField(accessExpr.pos, this.env, field,\n+                        memberType.tsymbol);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDc4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411904785", "bodyText": "@pubudu91 thoughts?", "author": "MaryamZi", "createdAt": "2020-04-21T06:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkzNTE0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411935146", "bodyText": "This would log an error if at least one record type doesn't have the field name given by field right?", "author": "pubudu91", "createdAt": "2020-04-21T07:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MzQ5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411953492", "bodyText": "And yeah, we don't usually use this to lookup whether the a record has a field by the specified name.", "author": "pubudu91", "createdAt": "2020-04-21T07:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIzOTgyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r419239823", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-05-04T06:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -5882,8 +5882,7 @@ public class Desugar extends BLangNodeVisitor {\n         BLangMatchTypedBindingPatternClause successPattern = null;\n         Name field = getFieldName(accessExpr);\n         if (field == Names.EMPTY) {\n-            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n-                    accessExpr.errorSafeNavigation);\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n             matchStmt.patternClauses.add(successPattern);\n             pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNjI2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411906267", "bodyText": "Shall we rename this to indicate it returns () on match all?", "author": "MaryamZi", "createdAt": "2020-04-21T06:30:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5939,6 +6000,25 @@ private BLangMatchTypedBindingPatternClause getMatchNullPattern(BLangExpression\n         return nullPattern;\n     }\n \n+    private BLangMatchStaticBindingPatternClause getMatchAllPattern(BLangExpression expr,", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -6009,14 +6008,14 @@ public class Desugar extends BLangNodeVisitor {\n                         symTable.nilType, Names.NIL_VALUE), false);\n         BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(expr.pos, Lists.of(assignmentStmt));\n \n-        BLangMatchStaticBindingPatternClause c =\n+        BLangMatchStaticBindingPatternClause matchAllPattern =\n                 (BLangMatchStaticBindingPatternClause) TreeBuilder.createMatchStatementStaticBindingPattern();\n         String matchAllVarName = \"_\";\n-        c.literal = ASTBuilderUtil.createVariableRef(expr.pos, new BVarSymbol(0, names.fromString(matchAllVarName),\n-                this.env.scope.owner.pkgID, symTable.anyType, this.env.scope.owner));\n-        c.body = patternBody;\n+        matchAllPattern.literal = ASTBuilderUtil.createVariableRef(expr.pos, new BVarSymbol(0,\n+                names.fromString(matchAllVarName), this.env.scope.owner.pkgID, symTable.anyType, this.env.scope.owner));\n+        matchAllPattern.body = patternBody;\n \n-        return c;\n+        return matchAllPattern;\n     }\n \n     private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpression accessExpr,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNjM4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411906387", "bodyText": "Variable name. :)", "author": "MaryamZi", "createdAt": "2020-04-21T06:30:30Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5939,6 +6000,25 @@ private BLangMatchTypedBindingPatternClause getMatchNullPattern(BLangExpression\n         return nullPattern;\n     }\n \n+    private BLangMatchStaticBindingPatternClause getMatchAllPattern(BLangExpression expr,\n+                                                                    BLangSimpleVariable tempResultVar) {\n+\n+        BLangVariableReference tempResultVarRef = ASTBuilderUtil.createVariableRef(expr.pos, tempResultVar.symbol);\n+        BLangAssignment assignmentStmt =\n+                ASTBuilderUtil.createAssignmentStmt(expr.pos, tempResultVarRef, createLiteral(expr.pos,\n+                        symTable.nilType, Names.NIL_VALUE), false);\n+        BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(expr.pos, Lists.of(assignmentStmt));\n+\n+        BLangMatchStaticBindingPatternClause c =", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -6009,14 +6008,14 @@ public class Desugar extends BLangNodeVisitor {\n                         symTable.nilType, Names.NIL_VALUE), false);\n         BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(expr.pos, Lists.of(assignmentStmt));\n \n-        BLangMatchStaticBindingPatternClause c =\n+        BLangMatchStaticBindingPatternClause matchAllPattern =\n                 (BLangMatchStaticBindingPatternClause) TreeBuilder.createMatchStatementStaticBindingPattern();\n         String matchAllVarName = \"_\";\n-        c.literal = ASTBuilderUtil.createVariableRef(expr.pos, new BVarSymbol(0, names.fromString(matchAllVarName),\n-                this.env.scope.owner.pkgID, symTable.anyType, this.env.scope.owner));\n-        c.body = patternBody;\n+        matchAllPattern.literal = ASTBuilderUtil.createVariableRef(expr.pos, new BVarSymbol(0,\n+                names.fromString(matchAllVarName), this.env.scope.owner.pkgID, symTable.anyType, this.env.scope.owner));\n+        matchAllPattern.body = patternBody;\n \n-        return c;\n+        return matchAllPattern;\n     }\n \n     private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpression accessExpr,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwOTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411909524", "bodyText": "This seems to be duplicating quite a bit of code from getSuccessPattern. Can we try and refactor getSuccessPattern instead to handle the record scenario?", "author": "MaryamZi", "createdAt": "2020-04-21T06:36:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5987,6 +6067,62 @@ private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpress\n         return successPattern;\n     }\n \n+    private BLangMatchTypedBindingPatternClause getSuccessPatternRecordMatch(BType type,", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5ODY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413698694", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwOTUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..66dcc00c63b 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -6036,89 +6050,44 @@ public class Desugar extends BLangNodeVisitor {\n         BLangSimpleVariable successPatternVar = ASTBuilderUtil.createVariable(accessExpr.pos, successPatternVarName,\n                 type, null, successPatternSymbol);\n \n-        // Create x.foo, by replacing the varRef expr of the current expression, with the new temp var ref\n-        accessExpr.expr = ASTBuilderUtil.createVariableRef(accessExpr.pos, successPatternVar.symbol);\n-        accessExpr.errorSafeNavigation = false;\n-        accessExpr.nilSafeNavigation = false;\n-\n-        // Type of the field access expression should be always taken from the child type.\n-        // Because the type assigned to expression contains the inherited error/nil types,\n-        // and may not reflect the actual type of the child/field expr.\n-        if (TypeTags.isXMLTypeTag(accessExpr.expr.type.tag)) {\n-            // todo: add discription why this is special here\n-            accessExpr.type = BUnionType.create(null, accessExpr.originalType, symTable.errorType, symTable.nilType);\n-        } else {\n-            accessExpr.type = accessExpr.originalType;\n+        BLangAccessExpression tempAccessExpr = nodeCloner.clone(accessExpr);\n+        if (accessExpr.getKind() == NodeKind.INDEX_BASED_ACCESS_EXPR) {\n+            ((BLangIndexBasedAccess) tempAccessExpr).indexExpr = ((BLangIndexBasedAccess) accessExpr).indexExpr;\n         }\n-\n-        BLangVariableReference tempResultVarRef =\n-                ASTBuilderUtil.createVariableRef(accessExpr.pos, tempResultVar.symbol);\n-\n-        BLangExpression assignmentRhsExpr = addConversionExprIfRequired(accessExpr, tempResultVarRef.type);\n-        BLangAssignment assignmentStmt =\n-                ASTBuilderUtil.createAssignmentStmt(accessExpr.pos, tempResultVarRef, assignmentRhsExpr, false);\n-        BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(accessExpr.pos, Lists.of(assignmentStmt));\n-\n-        // Create the pattern\n-        // R b => a = x.foo;\n-        BLangMatchTypedBindingPatternClause successPattern =\n-                ASTBuilderUtil.createMatchStatementPattern(accessExpr.pos, successPatternVar, patternBody);\n-        this.safeNavigationAssignment = assignmentStmt;\n-        return successPattern;\n-    }\n-\n-    private BLangMatchTypedBindingPatternClause getSuccessPatternRecordMatch(BType type,\n-                                                                             BLangAccessExpression accessExpr,\n-                                                                             BLangSimpleVariable tempResultVar) {\n-        String successPatternVarName = GEN_VAR_PREFIX.value + \"t_match_success\" + type.toString();\n-\n-        BVarSymbol  successPatternSymbol;\n-        if (type.tag == TypeTags.INVOKABLE) {\n-            successPatternSymbol = new BInvokableSymbol(SymTag.VARIABLE, 0, names.fromString(successPatternVarName),\n-                    this.env.scope.owner.pkgID, type, this.env.scope.owner);\n-        } else {\n-            successPatternSymbol = new BVarSymbol(0, names.fromString(successPatternVarName),\n-                    this.env.scope.owner.pkgID, type, this.env.scope.owner);\n+        if (accessExpr instanceof BLangFieldBasedAccess.BLangNSPrefixedFieldBasedAccess) {\n+            ((BLangFieldBasedAccess.BLangNSPrefixedFieldBasedAccess) tempAccessExpr).nsSymbol =\n+                    ((BLangFieldBasedAccess.BLangNSPrefixedFieldBasedAccess) accessExpr).nsSymbol;\n         }\n \n-        BLangSimpleVariable successPatternVar = ASTBuilderUtil.createVariable(accessExpr.pos, successPatternVarName,\n-                type, null, successPatternSymbol);\n-\n-        BLangAccessExpression tempAccessExpr = null;\n-        if (accessExpr.getKind() == NodeKind.FIELD_BASED_ACCESS_EXPR) {\n-            tempAccessExpr =\n-                    ASTBuilderUtil.createFieldAccessExpr(ASTBuilderUtil.createVariableRef(accessExpr.pos,\n-                            successPatternVar.symbol), ((BLangFieldBasedAccess) accessExpr).field);\n-        } else if (accessExpr.getKind() == NodeKind.INDEX_BASED_ACCESS_EXPR) {\n-            tempAccessExpr =\n-                    ASTBuilderUtil.createIndexAccessExpr(ASTBuilderUtil.createVariableRef(accessExpr.pos,\n-                            successPatternVar.symbol), ((BLangIndexBasedAccess) accessExpr).indexExpr);\n-        }\n+        tempAccessExpr.expr = ASTBuilderUtil.createVariableRef(accessExpr.pos, successPatternVar.symbol);\n         tempAccessExpr.errorSafeNavigation = false;\n         tempAccessExpr.nilSafeNavigation = false;\n+        accessExpr.cloneRef = null;\n \n         // Type of the field access expression should be always taken from the child type.\n         // Because the type assigned to expression contains the inherited error/nil types,\n         // and may not reflect the actual type of the child/field expr.\n         if (TypeTags.isXMLTypeTag(tempAccessExpr.expr.type.tag)) {\n+            // todo: add discription why this is special here\n             tempAccessExpr.type = BUnionType.create(null, accessExpr.originalType, symTable.errorType,\n                     symTable.nilType);\n         } else {\n             tempAccessExpr.type = accessExpr.originalType;\n         }\n+        tempAccessExpr.optionalFieldAccess = accessExpr.optionalFieldAccess;\n \n         BLangVariableReference tempResultVarRef =\n-                ASTBuilderUtil.createVariableRef(tempAccessExpr.pos, tempResultVar.symbol);\n+                ASTBuilderUtil.createVariableRef(accessExpr.pos, tempResultVar.symbol);\n \n         BLangExpression assignmentRhsExpr = addConversionExprIfRequired(tempAccessExpr, tempResultVarRef.type);\n         BLangAssignment assignmentStmt =\n                 ASTBuilderUtil.createAssignmentStmt(accessExpr.pos, tempResultVarRef, assignmentRhsExpr, false);\n-        BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(tempAccessExpr.pos, Lists.of(assignmentStmt));\n+        BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(accessExpr.pos, Lists.of(assignmentStmt));\n \n         // Create the pattern\n         // R b => a = x.foo;\n         BLangMatchTypedBindingPatternClause successPattern =\n-                ASTBuilderUtil.createMatchStatementPattern(tempAccessExpr.pos, successPatternVar, patternBody);\n+                ASTBuilderUtil.createMatchStatementPattern(accessExpr.pos, successPatternVar, patternBody);\n         this.safeNavigationAssignment = assignmentStmt;\n         return successPattern;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk0NTkzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411945930", "bodyText": "What's this condition about?", "author": "pubudu91", "createdAt": "2020-04-21T07:37:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);\n+            matchStmt.patternClauses.add(successPattern);\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n+        }\n \n+        if (allRecords) {\n+            for (BType memberType : errorLiftedType.getMemberTypes()) {\n+                BSymbol fieldSymbol = symResolver.resolveStructField(accessExpr.pos, this.env, field,\n+                        memberType.tsymbol);\n+                if (fieldSymbol != symTable.notFoundSymbol) {\n+                    successPattern = getSuccessPatternRecordMatch(memberType, accessExpr, tempResultVar);\n+                    matchStmt.patternClauses.add(successPattern);\n+                }\n+            }\n+            matchStmt.patternClauses.add(getMatchAllPattern(accessExpr, tempResultVar));\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n         }\n \n         // Create the pattern for success scenario. i.e: not null and not error (if applicable).\n-        BLangMatchTypedBindingPatternClause successPattern =\n+        successPattern =\n                 getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n         matchStmt.patternClauses.add(successPattern);\n+        pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+    }\n+\n+    private void pushToMatchStatementStack(BLangMatch matchStmt, BLangAccessExpression accessExpr,\n+                                           BLangMatchTypedBindingPatternClause successPattern) {\n         this.matchStmtStack.push(matchStmt);\n         if (this.successPattern != null) {\n             this.successPattern.body = ASTBuilderUtil.createBlockStmt(accessExpr.pos, Lists.of(matchStmt));\n         }\n         this.successPattern = successPattern;\n     }\n \n+    private Name getFieldName(BLangAccessExpression accessExpr) {\n+        Name field = Names.EMPTY;\n+        if (accessExpr.getKind() == NodeKind.FIELD_BASED_ACCESS_EXPR) {\n+            field = new Name(((BLangFieldBasedAccess) accessExpr).field.value);\n+        } else if (accessExpr.getKind() == NodeKind.INDEX_BASED_ACCESS_EXPR) {\n+            BLangExpression indexBasedExpression = ((BLangIndexBasedAccess) accessExpr).indexExpr;\n+            if (indexBasedExpression.getKind() == NodeKind.LITERAL) {\n+                field = new Name(((BLangLiteral) indexBasedExpression).value.toString());\n+            }\n+        }\n+        return field;\n+    }\n+\n+    private boolean checkForRecords(LinkedHashSet<BType> memTypes) {\n+        for (BType memType : memTypes) {\n+            int typeTag = memType.tag;\n+            if (typeTag != TypeTags.RECORD && typeTag != TypeTags.ERROR && typeTag != TypeTags.NIL) {", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI4ODgzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r414288836", "bodyText": "This method check whether all types are records except error type and nil type.", "author": "KavinduZoysa", "createdAt": "2020-04-24T04:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk0NTkzMA=="}], "type": "inlineReview", "revised_code": {"commit": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\nindex 4f8cf97e90c..1b4c93fbe0e 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java\n\n@@ -5882,8 +5882,7 @@ public class Desugar extends BLangNodeVisitor {\n         BLangMatchTypedBindingPatternClause successPattern = null;\n         Name field = getFieldName(accessExpr);\n         if (field == Names.EMPTY) {\n-            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n-                    accessExpr.errorSafeNavigation);\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n             matchStmt.patternClauses.add(successPattern);\n             pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n             return;\n"}}, {"oid": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "message": "Fix suggested changes", "committedDate": "2020-04-21T08:20:36Z", "type": "forcePushed"}, {"oid": "1a058edadeb763ac6f8e6541531163a73dd96bdd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a058edadeb763ac6f8e6541531163a73dd96bdd", "message": "Fix error in optional field access", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "56e73221aee3fff7fa317c2c94c5ab9411f0f399", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56e73221aee3fff7fa317c2c94c5ab9411f0f399", "message": "Fix suggested changes", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "7ba9be60dd3460dd5abe34cacbb1cd7ffa7eae2b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ba9be60dd3460dd5abe34cacbb1cd7ffa7eae2b", "message": "Refactor tests", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "message": "Refactor desugering", "committedDate": "2020-04-23T17:38:40Z", "type": "forcePushed"}, {"oid": "c11c154a47857501b654661381ae453f1809e9d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c11c154a47857501b654661381ae453f1809e9d0", "message": "Refactor desugering", "committedDate": "2020-04-23T17:58:43Z", "type": "commit"}, {"oid": "c11c154a47857501b654661381ae453f1809e9d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c11c154a47857501b654661381ae453f1809e9d0", "message": "Refactor desugering", "committedDate": "2020-04-23T17:58:43Z", "type": "forcePushed"}, {"oid": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "message": "Find the existance of record field in another function", "committedDate": "2020-04-24T09:07:53Z", "type": "commit"}, {"oid": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "message": "Find the existance of record field in another function", "committedDate": "2020-04-24T09:07:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyODE5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r424628194", "bodyText": "IMO isAllTypesAreRecordsInUnion still doesn't reflect the actual check. Can we rename?", "author": "MaryamZi", "createdAt": "2020-05-13T17:59:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5869,31 +5869,99 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean isAllTypesRecords = false;\n+        LinkedHashSet<BType> memTypes = new LinkedHashSet<>();\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            isAllTypesRecords = isAllTypesAreRecordsInUnion(memTypes);", "originalCommit": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzODA5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r424638095", "bodyText": "Why do we need a clone?", "author": "MaryamZi", "createdAt": "2020-05-13T18:16:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5969,25 +6057,36 @@ private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpress\n         BLangSimpleVariable successPatternVar = ASTBuilderUtil.createVariable(accessExpr.pos, successPatternVarName,\n                 type, null, successPatternSymbol);\n \n-        // Create x.foo, by replacing the varRef expr of the current expression, with the new temp var ref\n-        accessExpr.expr = ASTBuilderUtil.createVariableRef(accessExpr.pos, successPatternVar.symbol);\n-        accessExpr.errorSafeNavigation = false;\n-        accessExpr.nilSafeNavigation = false;\n+        BLangAccessExpression tempAccessExpr = nodeCloner.clone(accessExpr);", "originalCommit": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}