{"pr_number": 22165, "pr_title": "Initial incremental parser test utils", "pr_createdAt": "2020-03-25T01:26:56Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22165", "timeline": [{"oid": "e94ca81c2b428767f50f9812263c72de75d14fc3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e94ca81c2b428767f50f9812263c72de75d14fc3", "message": "Refactor parser test packages", "committedDate": "2020-03-25T01:16:39Z", "type": "commit"}, {"oid": "514c61e91b48e7578d97eb943e4faeae76db2f0e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/514c61e91b48e7578d97eb943e4faeae76db2f0e", "message": "Update class comments", "committedDate": "2020-03-25T01:21:10Z", "type": "commit"}, {"oid": "ef78573a17f4d74194cbd07d377a647927a0539c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ef78573a17f4d74194cbd07d377a647927a0539c", "message": "Create public tree in some interal nodes", "committedDate": "2020-03-25T01:22:25Z", "type": "commit"}, {"oid": "eba3bb6d209b752f1fc3c205f95cda8424e896c1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eba3bb6d209b752f1fc3c205f95cda8424e896c1", "message": "Add public tree nodes", "committedDate": "2020-03-25T01:24:46Z", "type": "commit"}, {"oid": "aad7f4690123361c89e2eaf24775f2d56a656996", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aad7f4690123361c89e2eaf24775f2d56a656996", "message": "Refactor incr. parser logic to a new class", "committedDate": "2020-03-25T01:25:23Z", "type": "commit"}, {"oid": "7e672493d54b4422beeaf6293039cf6bee0e712e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e672493d54b4422beeaf6293039cf6bee0e712e", "message": "Add the initial incr. parser test utils", "committedDate": "2020-03-25T01:27:33Z", "type": "commit"}, {"oid": "f1370cfb8d1013cd3e001735189bb1311ae8ae8c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1370cfb8d1013cd3e001735189bb1311ae8ae8c", "message": "Update IncrementalParser.java", "committedDate": "2020-03-25T01:32:45Z", "type": "commit"}, {"oid": "d9690cbd7864ba83634298362943c8d553925963", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d9690cbd7864ba83634298362943c8d553925963", "message": "Update function_name_new.bal", "committedDate": "2020-03-25T01:33:36Z", "type": "commit"}, {"oid": "c3da8ed8703d44bf86b8c1179ee00576f20119cb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3da8ed8703d44bf86b8c1179ee00576f20119cb", "message": "Update function_name_old.bal", "committedDate": "2020-03-25T01:33:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NTkxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22165#discussion_r397575915", "bodyText": "Can we use the range here, since there will be lots of statements in future?", "author": "SupunS", "createdAt": "2020-03-25T02:34:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/incremental/IncrementalParser.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerinalang.compiler.internal.parser.incremental;\n+\n+import io.ballerinalang.compiler.internal.parser.AbstractTokenReader;\n+import io.ballerinalang.compiler.internal.parser.BallerinaParser;\n+import io.ballerinalang.compiler.internal.parser.tree.STNode;\n+import io.ballerinalang.compiler.internal.parser.tree.SyntaxKind;\n+\n+import java.util.function.Predicate;\n+\n+/**\n+ * An incremental parser for Ballerina.\n+ * <p>\n+ * Reuses nodes and tokens from the old tree.\n+ *\n+ * @since 1.3.0\n+ */\n+public class IncrementalParser extends BallerinaParser {\n+    private final UnmodifiedSubtreeSupplier subtreeSupplier;\n+\n+    public IncrementalParser(AbstractTokenReader tokenReader, UnmodifiedSubtreeSupplier subtreeSupplier) {\n+        super(tokenReader);\n+        this.subtreeSupplier = subtreeSupplier;\n+    }\n+\n+    protected STNode parseTopLevelNodeWithModifier(SyntaxKind tokenKind) {\n+        STNode modelLevelDecl = getIfReusable(subtreeSupplier.peek(), isModelLevelDeclaration);\n+        return modelLevelDecl != null ? modelLevelDecl : super.parseTopLevelNodeWithModifier(tokenKind);\n+    }\n+\n+    protected STNode parseFunctionBody(SyntaxKind tokenKind) {\n+        STNode funcBodyNode = getIfReusable(subtreeSupplier.peek(), isFunctionBody);\n+        return funcBodyNode != null ? funcBodyNode : super.parseFunctionBody(tokenKind);\n+    }\n+\n+    protected STNode parseStatement() {\n+        STNode stmtNode = getIfReusable(subtreeSupplier.peek(), isStatement);\n+        return stmtNode != null ? stmtNode : super.parseStatement();\n+    }\n+\n+    private STNode getIfReusable(STNode node, Predicate<SyntaxKind> predicate) {\n+        if (node != null && predicate.test(node.kind)) {\n+            this.subtreeSupplier.consume();\n+        }\n+        return node;\n+    }\n+\n+    private Predicate<SyntaxKind> isModelLevelDeclaration = kind -> kind == SyntaxKind.FUNCTION_DEFINITION ||\n+            kind == SyntaxKind.TYPE_DEFINITION;\n+\n+    private Predicate<SyntaxKind> isFunctionBody = kind ->\n+            kind == SyntaxKind.BLOCK_STATEMENT || // TODO I am not too sure about this.\n+                    kind == SyntaxKind.EXTERNAL_FUNCTION_BODY;\n+\n+    private Predicate<SyntaxKind> isStatement = kind -> kind == SyntaxKind.BLOCK_STATEMENT ||\n+            kind == SyntaxKind.IF_ELSE_STATEMENT ||\n+            kind == SyntaxKind.CALL_STATEMENT ||\n+            kind == SyntaxKind.LOCAL_VARIABLE_DECL ||\n+            kind == SyntaxKind.ASSIGNMENT_STATEMENT ||\n+            kind == SyntaxKind.WHILE_STATEMENT;", "originalCommit": "c3da8ed8703d44bf86b8c1179ee00576f20119cb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NzY0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22165#discussion_r397577645", "bodyText": "Ideally we would not need the internalToken == null check. If something is coming as null, then thats probably a bug in the parser.", "author": "SupunS", "createdAt": "2020-03-25T02:41:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NonTerminalNode.java", "diffHunk": "@@ -85,12 +86,13 @@ protected int getChildPosition(int bucket) {\n \n     // Create a Token for the TextChange token in the given bucket\n     protected Token createToken(int bucket) {\n-        STNode internaltoken = this.node.childInBucket(bucket);\n-        if (internaltoken == null) {\n-            return null;\n+        STNode internalToken = this.node.childInBucket(bucket);\n+        if (internalToken == null || internalToken.kind == SyntaxKind.NONE) {\n+            // TODO Verify this change\n+            return new EmptyToken(internalToken, 0, this);", "originalCommit": "c3da8ed8703d44bf86b8c1179ee00576f20119cb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}