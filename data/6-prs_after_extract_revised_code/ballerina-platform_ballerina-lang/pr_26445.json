{"pr_number": 26445, "pr_title": "Migrate Code Actions into Semantic API", "pr_createdAt": "2020-10-21T02:36:12Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445", "timeline": [{"oid": "7c99cf1911b72f199133c0984aa50839a937429a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c99cf1911b72f199133c0984aa50839a937429a", "message": "Move code-action implementations into /impl package\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-08T03:43:14Z", "type": "commit"}, {"oid": "d9188e5b00361148f8a0dfe69f1944c009723349", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d9188e5b00361148f8a0dfe69f1944c009723349", "message": "Pack compiler-api for the distribution zip\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-08T03:43:14Z", "type": "commit"}, {"oid": "8441f140f208508df84d41f478b4a9a87084545e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8441f140f208508df84d41f478b4a9a87084545e", "message": "Merge branch 'master'", "committedDate": "2020-10-20T08:33:44Z", "type": "commit"}, {"oid": "fcbadc0f5c7959ef9dc036c7eeac69400b0e3c73", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fcbadc0f5c7959ef9dc036c7eeac69400b0e3c73", "message": "Migrate type-guard code-action into semantic-api\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-20T14:15:11Z", "type": "commit"}, {"oid": "685917e4d074b2c7118e425d64e240d010a69408", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/685917e4d074b2c7118e425d64e240d010a69408", "message": "Migrate create-function code-action into semantic-api\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-20T14:15:13Z", "type": "commit"}, {"oid": "551f2d5753ebe3363c6ad0309e6373c25b0e5333", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/551f2d5753ebe3363c6ad0309e6373c25b0e5333", "message": "Migrate create-variable code-actions into semantic-api\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-20T14:15:36Z", "type": "commit"}, {"oid": "d74351f39ba12e37156e19b65b7c6e828a37eb39", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d74351f39ba12e37156e19b65b7c6e828a37eb39", "message": "Make signature() print fully-qualified module-id\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-20T14:22:36Z", "type": "commit"}, {"oid": "08a9f8699b5e71bef943918d1afb350a42bd82d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08a9f8699b5e71bef943918d1afb350a42bd82d3", "message": "Fix code action tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T02:05:10Z", "type": "commit"}, {"oid": "a21987541a958a454ec9b02b1b1b590af922a6b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a21987541a958a454ec9b02b1b1b590af922a6b6", "message": "Migrate code-actions to semantic-api\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T02:12:13Z", "type": "commit"}, {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6060891b04e74d9abbf05ee82c90bc1a91221eea", "message": "Fix completion tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T02:33:36Z", "type": "commit"}, {"oid": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6060891b04e74d9abbf05ee82c90bc1a91221eea", "message": "Fix completion tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T02:33:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MzM0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508963349", "bodyText": "Do we still depend on the AST models? We should depend on the Syntax Tree, since we have the particular APIs", "author": "nadeeshaan", "createdAt": "2020-10-21T03:14:43Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -80,38 +68,38 @@ private CodeActionUtil() {\n      * @return {@link String}   Top level node type\n      */\n     public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocumentIdentifier identifier,\n-                                                        int cursorLine, WorkspaceDocumentManager docManager) {\n+                                                        int cursorLine, WorkspaceDocumentManager docManager)\n+            throws CompilationFailedException {\n         Optional<Path> filePath = CommonUtil.getPathFromURI(identifier.getUri());\n-        if (!filePath.isPresent()) {\n+        if (filePath.isEmpty()) {\n             return null;\n         }\n \n-        try {\n-            BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n-            String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n-            BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n-            List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n-            context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n+        BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n+        String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n+        BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n+        List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n+        context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n \n-            Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n-                    .filter(cUnit -> cUnit.getPosition().getSource()\n-                            .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n-                            .equals(relativeSourcePath))\n-                    .findAny();\n+        Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n+                .filter(cUnit -> cUnit.getPosition().getSource()\n+                        .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n+                        .equals(relativeSourcePath))\n+                .findAny();\n \n-            if (!filteredCUnit.isPresent()) {\n-                return null;\n-            }\n+        if (filteredCUnit.isEmpty()) {\n+            return null;\n+        }\n \n-            for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {\n-                DiagnosticPos diagnosticPos = CommonUtil.toZeroBasedPosition(((BLangNode) topLevelNode).pos);\n-                if (topLevelNode instanceof BLangService) {\n-                    if (diagnosticPos.sLine == cursorLine) {\n-                        return CodeActionNodeType.SERVICE;\n-                    }\n-                    if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n-                        // Cursor within the service\n-                        for (BLangFunction resourceFunction : ((BLangService) topLevelNode).resourceFunctions) {\n+        for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAxMzE5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r509013195", "bodyText": "Ack, will migrate this. Earlier tried but couldn't achieve due to limitations in semantic-api. now we should be able to migrate.", "author": "rasika", "createdAt": "2020-10-21T06:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "52b51c505bc8e9d5ff601a5cdb56b1d2f5f0e9f4", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java\nindex 560c0e071ec..97df4ce746a 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java\n\n@@ -76,86 +74,74 @@ public class CodeActionUtil {\n         }\n \n         BLangPackage bLangPackage = LSModuleCompiler.getBLangPackage(context, docManager, false, false);\n-        String relativeSourcePath = context.get(DocumentServiceKeys.RELATIVE_FILE_PATH_KEY);\n-        BLangPackage evalPkg = CommonUtil.getSourceOwnerBLangPackage(relativeSourcePath, bLangPackage);\n         List<Diagnostic> diagnostics = bLangPackage.getDiagnostics();\n         context.put(CodeActionKeys.DIAGNOSTICS_KEY, CodeActionUtil.toDiagnostics(diagnostics));\n \n-        Optional<BLangCompilationUnit> filteredCUnit = evalPkg.compUnits.stream()\n-                .filter(cUnit -> cUnit.getPosition().getSource()\n-                        .cUnitName.replace(\"/\", CommonUtil.FILE_SEPARATOR)\n-                        .equals(relativeSourcePath))\n-                .findAny();\n-\n-        if (filteredCUnit.isEmpty()) {\n+        ModulePartNode modulePartNode;\n+        try {\n+            modulePartNode = docManager.getTree(filePath.get()).rootNode();\n+        } catch (WorkspaceDocumentException e) {\n             return null;\n         }\n \n-        for (TopLevelNode topLevelNode : filteredCUnit.get().getTopLevelNodes()) {\n-            DiagnosticPos diagnosticPos = CommonUtil.toZeroBasedPosition(((BLangNode) topLevelNode).pos);\n-            if (topLevelNode instanceof BLangService) {\n-                if (diagnosticPos.sLine == cursorLine) {\n+        List<ModuleMemberDeclarationNode> members = modulePartNode.members().stream().collect(Collectors.toList());\n+        for (ModuleMemberDeclarationNode member : members) {\n+            boolean isSameLine = member.lineRange().startLine().line() == cursorLine;\n+            boolean isWithinLines = cursorLine > member.lineRange().startLine().line() &&\n+                    cursorLine < member.lineRange().endLine().line();\n+            if (member.kind() == SyntaxKind.SERVICE_DECLARATION) {\n+                if (isSameLine) {\n+                    // Cursor on the service\n                     return CodeActionNodeType.SERVICE;\n-                }\n-                if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n+                } else if (isWithinLines) {\n                     // Cursor within the service\n-                    for (BLangFunction resourceFunction : ((BLangService) topLevelNode).resourceFunctions) {\n-                            diagnosticPos = CommonUtil.toZeroBasedPosition(resourceFunction.getName().pos);\n-                            if (diagnosticPos.sLine == cursorLine) {\n-                                return CodeActionNodeType.RESOURCE;\n-                            }\n+                    ServiceDeclarationNode serviceDeclrNode = (ServiceDeclarationNode) member;\n+                    for (Node resourceNode : ((ServiceBodyNode) serviceDeclrNode.serviceBody()).resources()) {\n+                        boolean isSameResLine = resourceNode.lineRange().startLine().line() == cursorLine;\n+                        if (isSameResLine && resourceNode.kind() == SyntaxKind.FUNCTION_DEFINITION) {\n+                            // Cursor on the resource function\n+                            return CodeActionNodeType.RESOURCE;\n                         }\n                     }\n                 }\n-\n-                if (topLevelNode instanceof BLangImportPackage && cursorLine == diagnosticPos.sLine) {\n-                    return CodeActionNodeType.IMPORTS;\n-                }\n-\n-                if (topLevelNode instanceof BLangFunction\n-                        && !((BLangFunction) topLevelNode).flagSet.contains(Flag.ANONYMOUS)\n-                        && cursorLine == diagnosticPos.sLine) {\n-                    return CodeActionNodeType.FUNCTION;\n-                }\n-\n-                if (topLevelNode instanceof BLangTypeDefinition\n-                        && ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangRecordTypeNode\n-                        && cursorLine == diagnosticPos.sLine) {\n-                    return CodeActionNodeType.RECORD;\n-                }\n-\n-                if (topLevelNode instanceof BLangClassDefinition) {\n-                    if (diagnosticPos.sLine == cursorLine) {\n-                        return CodeActionNodeType.CLASS;\n+            } else if (isSameLine && member.kind() == SyntaxKind.FUNCTION_DEFINITION) {\n+                return CodeActionNodeType.FUNCTION;\n+            } else if (member.kind() == SyntaxKind.TYPE_DEFINITION) {\n+                TypeDefinitionNode definitionNode = (TypeDefinitionNode) member;\n+                Node typeDesc = definitionNode.typeDescriptor();\n+                if (isSameLine) {\n+                    if (typeDesc.kind() == SyntaxKind.RECORD_TYPE_DESC) {\n+                        return CodeActionNodeType.RECORD;\n+                    } else if (typeDesc.kind() == SyntaxKind.OBJECT_TYPE_DESC) {\n+                        return CodeActionNodeType.OBJECT;\n                     }\n-                    if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n-                        // Cursor within the class\n-                        for (BLangFunction function : ((BLangClassDefinition) topLevelNode).functions) {\n-                            diagnosticPos = CommonUtil.toZeroBasedPosition(function.getName().pos);\n-                            if (diagnosticPos.sLine == cursorLine) {\n-                                return CodeActionNodeType.CLASS_FUNCTION;\n-                            }\n+                } else if (isWithinLines && typeDesc.kind() == SyntaxKind.OBJECT_TYPE_DESC) {\n+                    ObjectTypeDescriptorNode objectTypeDescNode = (ObjectTypeDescriptorNode) typeDesc;\n+                    for (Node memberNode : objectTypeDescNode.members()) {\n+                        boolean isSameResLine = memberNode.lineRange().startLine().line() == cursorLine;\n+                        if (isSameResLine && memberNode.kind() == SyntaxKind.METHOD_DECLARATION) {\n+                            // Cursor on the object function\n+                            return CodeActionNodeType.OBJECT_FUNCTION;\n                         }\n                     }\n                 }\n-\n-                if (topLevelNode instanceof BLangTypeDefinition\n-                        && ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangObjectTypeNode) {\n-                    if (diagnosticPos.sLine == cursorLine) {\n-                        return CodeActionNodeType.OBJECT;\n-                    }\n-                    if (cursorLine > diagnosticPos.sLine && cursorLine < diagnosticPos.eLine) {\n-                        // Cursor within the object\n-                        for (BLangFunction resourceFunction\n-                                : ((BLangObjectTypeNode) ((BLangTypeDefinition) topLevelNode).typeNode).functions) {\n-                            diagnosticPos = CommonUtil.toZeroBasedPosition(resourceFunction.getName().pos);\n-                            if (diagnosticPos.sLine == cursorLine) {\n-                                return CodeActionNodeType.OBJECT_FUNCTION;\n-                            }\n+            } else if (member.kind() == SyntaxKind.CLASS_DEFINITION) {\n+                if (isSameLine) {\n+                    // Cursor on the class\n+                    return CodeActionNodeType.CLASS;\n+                } else if (isWithinLines) {\n+                    // Cursor within the class\n+                    ClassDefinitionNode classDefNode = (ClassDefinitionNode) member;\n+                    for (Node memberNode : classDefNode.members()) {\n+                        boolean isSameResLine = memberNode.lineRange().startLine().line() == cursorLine;\n+                        if (isSameResLine && memberNode.kind() == SyntaxKind.OBJECT_METHOD_DEFINITION) {\n+                            // Cursor on the class function\n+                            return CodeActionNodeType.CLASS_FUNCTION;\n                         }\n                     }\n                 }\n             }\n+        }\n         return null;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2ODMzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508968338", "bodyText": "May be we can omit the variable here, if we need more clarification, let's put a comment", "author": "nadeeshaan", "createdAt": "2020-10-21T03:32:30Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/CreateFunctionCodeAction.java", "diffHunk": "@@ -74,30 +60,19 @@\n         List<Object> args = Arrays.asList(lineArg, colArg, uriArg);\n         Matcher matcher = CommandConstants.UNDEFINED_FUNCTION_PATTERN.matcher(diagnosticMessage);\n         String functionName = (matcher.find() && matcher.groupCount() > 0) ? matcher.group(1) + \"(...)\" : \"\";\n-        WorkspaceDocumentManager docManager = context.get(DocumentServiceKeys.DOC_MANAGER_KEY);\n-        String diagnosedContent = getDiagnosedContent(diagnostic, context, document);\n         try {\n-            LSDocumentIdentifier lsDocument = docManager.getLSDocument(CommonUtil.getPathFromURI(uri).get());\n-            context.put(ReferencesKeys.OFFSET_CURSOR_N_TRY_NEXT_BEST, true);\n-            context.put(ReferencesKeys.DO_NOT_SKIP_NULL_SYMBOLS, true);\n-            Position afterAliasPos = offsetPositionToInvocation(diagnosedContent, position);\n-            // TODO: Try to use referenceAtCursor\n-            SymbolReferencesModel.Reference refAtCursor = getReferenceAtCursor(context, lsDocument, afterAliasPos);\n-            BLangNode bLangNode = refAtCursor.getbLangNode();\n-            BLangInvocation node = null;\n-            if (bLangNode instanceof BLangInvocation) {\n-                node = (BLangInvocation) bLangNode;\n+            Position diagPos = diagnostic.getRange().getStart();\n+            NonTerminalNode cursorNode = CommonUtil.findNode(context, diagPos, CommonUtil.getPathFromURI(uri).get());\n+            while (cursorNode != null &&\n+                    cursorNode.kind() != SyntaxKind.MODULE_PART &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_DEFINITION &&\n+                    cursorNode.kind() != SyntaxKind.FUNCTION_CALL) {\n+                cursorNode = cursorNode.parent();\n             }\n-            if (node != null && node.pkgAlias.value.isEmpty()) {\n-                boolean isWithinProject = (node.expr == null);\n-                if (node.expr != null) {\n-                    BLangPackage bLangPackage = context.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-                    List<String> currentModules = document.getProjectModules();\n-                    PackageID nodePkgId = node.expr.type.tsymbol.pkgID;\n-                    isWithinProject = bLangPackage.packageID.orgName.equals(nodePkgId.orgName) &&\n-                            currentModules.contains(nodePkgId.name.value);\n-                }\n-                if (isWithinProject) {\n+            if (cursorNode != null && cursorNode.kind() == SyntaxKind.FUNCTION_CALL) {\n+                FunctionCallExpressionNode callExpr = (FunctionCallExpressionNode) cursorNode;\n+                boolean isWithinFile = callExpr.functionName().kind() == SyntaxKind.SIMPLE_NAME_REFERENCE;", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5MjU0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508992544", "bodyText": "Since the name FunctionCallExpressionNode is bit longer; it wraps the statement into multiple lines. Thus, introduced this local variable.\nboolean isWithinFile = ((FunctionCallExpressionNode) cursorNode).functionName().kind() == SyntaxKind.SIMPLE_NAME_REFERENCE;", "author": "rasika", "createdAt": "2020-10-21T05:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2ODMzOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2OTc4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508969782", "bodyText": "Are these checks valid? We are comparing two different hierarchies, semantic API against the AST.\nPlease revisit the if-else ladder", "author": "nadeeshaan", "createdAt": "2020-10-21T03:37:58Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3OTM2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508979368", "bodyText": "No, this has to revamped when we get type-info for literals. Kept it intact since for the reference of code-migration and it doesn't affect the other flow. Should we remove these checks?", "author": "rasika", "createdAt": "2020-10-21T04:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2OTc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e96c2e486c40bca9dfd17e4b70e7257365cf2981", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\nindex 76a5f18fe88..b47369adb80 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\n\n@@ -138,6 +138,7 @@ public interface DiagBasedCodeAction {\n                 for (BType type : tupleType.tupleTypes) {\n                     String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n                                                                               context);\n+                    // TODO: Fix this\n //                    if (prevType != null && !prevType.equals(newType)) {\n //                        isArrayCandidate = false;\n //                    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508970167", "bodyText": "If commenting the code section is intentional, let's add a TODO as well", "author": "nadeeshaan", "createdAt": "2020-10-21T03:39:29Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.langserver.codeaction.impl;\n+\n+import io.ballerina.compiler.api.types.BallerinaTypeDescriptor;\n+import org.ballerinalang.langserver.common.ImportsAcceptor;\n+import org.ballerinalang.langserver.common.utils.FunctionGenerator;\n+import org.ballerinalang.langserver.commons.LSContext;\n+import org.ballerinalang.langserver.commons.codeaction.LSCodeActionProviderException;\n+import org.ballerinalang.langserver.compiler.DocumentServiceKeys;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.Types;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BTupleType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Interface for diagnostics based code actions.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface DiagBasedCodeAction {\n+\n+    List<CodeAction> get(Diagnostic diagnostic, List<Diagnostic> allDiagnostics, LSContext context)\n+            throws LSCodeActionProviderException;\n+\n+\n+    static List<String> getPossibleTypes(LSContext context,\n+                                         BallerinaTypeDescriptor typeDescriptor,\n+                                         List<TextEdit> edits,\n+                                         CompilerContext compilerContext) {\n+        ImportsAcceptor importsAcceptor = new ImportsAcceptor(context);\n+\n+        List<String> types = new ArrayList<>();\n+\n+        String variableType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+        if (typeDescriptor instanceof BLangInvocation) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangFieldBasedAccess) {\n+            types.add(variableType);\n+        } else if (typeDescriptor instanceof BLangRecordLiteral) {\n+            // Record\n+            List<BLangPackage> bLangPackages = context.get(DocumentServiceKeys.BLANG_PACKAGES_CONTEXT_KEY);\n+            BRecordType matchingRecordType = null;\n+            Types typesChk = Types.getInstance(compilerContext);\n+            for (BLangPackage pkg : bLangPackages) {\n+                for (TopLevelNode topLevelNode : pkg.topLevelNodes) {\n+                    if (topLevelNode instanceof BLangTypeDefinition &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode instanceof BLangRecordTypeNode &&\n+                            ((BLangTypeDefinition) topLevelNode).typeNode.type instanceof BRecordType) {\n+                        BRecordType type = (BRecordType) ((BLangTypeDefinition) topLevelNode).typeNode.type;\n+                        if (typesChk.checkStructEquivalency(((BLangRecordLiteral) typeDescriptor).type, type) &&\n+                                !type.tsymbol.name.value.startsWith(\"$\")) {\n+                            matchingRecordType = type;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Matching Record\n+            if (matchingRecordType != null) {\n+                String recType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+                types.add(recType);\n+            }\n+\n+            // Anon Record\n+            String rType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor, context);\n+            BLangRecordLiteral recordLiteral = (BLangRecordLiteral) typeDescriptor;\n+            types.add((recordLiteral.fields.size() > 0) ? rType : \"record {}\");\n+\n+            // JSON\n+            types.add(\"json\");\n+\n+            // Map\n+            BType prevType = null;\n+            boolean isConstrainedMap = true;\n+            for (RecordLiteralNode.RecordField recordField : recordLiteral.fields) {\n+                if (recordField instanceof BLangRecordLiteral.BLangRecordKeyValueField) {\n+                    BLangRecordLiteral.BLangRecordKeyValueField kvField =\n+                            (BLangRecordLiteral.BLangRecordKeyValueField) recordField;\n+                    BType type = kvField.valueExpr.type;\n+                    if (prevType != null &&\n+                            !prevType.tsymbol.name.getValue().equals(type.tsymbol.name.getValue())) {\n+                        isConstrainedMap = false;\n+                    }\n+                    prevType = type;\n+                }\n+            }\n+            if (isConstrainedMap && prevType != null) {\n+                String type = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                       context);\n+                types.add(\"map<\" + type + \">\");\n+            } else {\n+                types.add(\"map<any>\");\n+            }\n+        } else if (typeDescriptor instanceof BLangListConstructorExpr) {\n+            BLangListConstructorExpr listExpr = (BLangListConstructorExpr) typeDescriptor;\n+            if (listExpr.expectedType instanceof BTupleType) {\n+                BTupleType tupleType = (BTupleType) listExpr.expectedType;\n+                String arrayType = null;\n+//                String prevType = null;\n+//                String prevInnerType = null;\n+                boolean isArrayCandidate = !tupleType.tupleTypes.isEmpty();\n+                StringJoiner tupleJoiner = new StringJoiner(\", \");\n+                for (BType type : tupleType.tupleTypes) {\n+                    String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n+                                                                              context);\n+//                    if (prevType != null && !prevType.equals(newType)) {", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3OTk5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508979990", "bodyText": "Yes, whole method getPossibleTypes need to revamp after literals type-info is avaialble", "author": "rasika", "createdAt": "2020-10-21T04:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE1MDAwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r509150001", "bodyText": "Added a TODO", "author": "rasika", "createdAt": "2020-10-21T10:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MDE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e96c2e486c40bca9dfd17e4b70e7257365cf2981", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\nindex 76a5f18fe88..b47369adb80 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/DiagBasedCodeAction.java\n\n@@ -138,6 +138,7 @@ public interface DiagBasedCodeAction {\n                 for (BType type : tupleType.tupleTypes) {\n                     String newType = FunctionGenerator.generateTypeDefinition(importsAcceptor, typeDescriptor,\n                                                                               context);\n+                    // TODO: Fix this\n //                    if (prevType != null && !prevType.equals(newType)) {\n //                        isArrayCandidate = false;\n //                    }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508971854", "bodyText": "let's use a meaningful variable name", "author": "nadeeshaan", "createdAt": "2020-10-21T03:45:43Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/impl/OptimizeImportsCodeAction.java", "diffHunk": "@@ -126,9 +137,12 @@\n         }\n \n         // Re-order imports\n-        List<BLangImportPackage> orderedImports = fileImports.stream()\n-                .sorted(Comparator.comparing((Function<BLangImportPackage, String>) o -> o.orgName.value)\n-                                .thenComparing(o -> o.getAlias().value))\n+        List<ImportDeclarationNode> allImports = new ArrayList<>();\n+        fileImports.iterator().forEachRemaining(allImports::add);\n+        final List<ImportDeclarationNode> orderedImports = allImports.stream()\n+                .sorted(Comparator.comparing((Function<ImportDeclarationNode, String>) o -> o.orgName().isPresent() ?", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk4ODY0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508988643", "bodyText": "i think we have one letter names for lambdas in many places. otherwise it will be lengthy and need to wrap for multiple lines. wdyt?", "author": "rasika", "createdAt": "2020-10-21T04:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk5Njc0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508996747", "bodyText": "+1", "author": "nadeeshaan", "createdAt": "2020-10-21T05:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3MTg1NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk3NzEzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26445#discussion_r508977138", "bodyText": "Let's add a doc comment for the public APIs", "author": "nadeeshaan", "createdAt": "2020-10-21T04:07:11Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java", "diffHunk": "@@ -814,6 +824,47 @@ public static String getPackagePrefix(ImportsAcceptor importsAcceptor, PackageID\n         return pkgPrefix;\n     }\n \n+    public static String getModulePrefix(ImportsAcceptor importsAcceptor, ModuleID currentModuleId,", "originalCommit": "6060891b04e74d9abbf05ee82c90bc1a91221eea", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e96c2e486c40bca9dfd17e4b70e7257365cf2981", "chunk": "diff --git a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java\nindex 79fc7d24a09..774bc31fdb4 100644\n--- a/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java\n+++ b/language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/common/utils/CommonUtil.java\n\n@@ -808,27 +807,20 @@ public class CommonUtil {\n         return null;\n     }\n \n-    public static String getPackagePrefix(ImportsAcceptor importsAcceptor, PackageID currentPkgId,\n-                                          PackageID typePkgId, LSContext context) {\n-        String pkgPrefix = \"\";\n-        if (!typePkgId.equals(currentPkgId) && !BUILT_IN_PACKAGE_PREFIX.equals(typePkgId.name.value)) {\n-            String moduleName = escapeModuleName(context, typePkgId.orgName.value + \"/\" + typePkgId.name.value);\n-            String[] moduleParts = moduleName.split(\"/\");\n-            String orgName = moduleParts[0];\n-            String alias = moduleParts[1];\n-            pkgPrefix = alias.replaceAll(\".*\\\\.\", \"\") + \":\";\n-            if (importsAcceptor != null) {\n-                importsAcceptor.getAcceptor().accept(orgName, alias);\n-            }\n-        }\n-        return pkgPrefix;\n-    }\n-\n+    /**\n+     * Returns module prefix and process imports required.\n+     *\n+     * @param importsAcceptor   import acceptor\n+     * @param currentModuleId   current module id\n+     * @param moduleID      module id\n+     * @param context   {@link LSContext}\n+     * @return  module prefix\n+     */\n     public static String getModulePrefix(ImportsAcceptor importsAcceptor, ModuleID currentModuleId,\n-                                         ModuleID typeModuleId, LSContext context) {\n+                                         ModuleID moduleID, LSContext context) {\n         String pkgPrefix = \"\";\n-        if (!typeModuleId.equals(currentModuleId) && !BUILT_IN_PACKAGE_PREFIX.equals(typeModuleId.moduleName())) {\n-            String moduleName = escapeModuleName(context, typeModuleId.orgName() + \"/\" + typeModuleId.moduleName());\n+        if (!moduleID.equals(currentModuleId) && !BUILT_IN_PACKAGE_PREFIX.equals(moduleID.moduleName())) {\n+            String moduleName = escapeModuleName(context, moduleID.orgName() + \"/\" + moduleID.moduleName());\n             String[] moduleParts = moduleName.split(\"/\");\n             String orgName = moduleParts[0];\n             String alias = moduleParts[1];\n"}}, {"oid": "e96c2e486c40bca9dfd17e4b70e7257365cf2981", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e96c2e486c40bca9dfd17e4b70e7257365cf2981", "message": "Fix style issues\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T04:51:28Z", "type": "commit"}, {"oid": "52b51c505bc8e9d5ff601a5cdb56b1d2f5f0e9f4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/52b51c505bc8e9d5ff601a5cdb56b1d2f5f0e9f4", "message": "Migrate top-level-node() method into semantic-api\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T07:47:41Z", "type": "commit"}, {"oid": "716e420e98e97c01be01064bddc7854a4133f12f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/716e420e98e97c01be01064bddc7854a4133f12f", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into code-action-migration", "committedDate": "2020-10-21T09:55:45Z", "type": "commit"}, {"oid": "716e420e98e97c01be01064bddc7854a4133f12f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/716e420e98e97c01be01064bddc7854a4133f12f", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into code-action-migration", "committedDate": "2020-10-21T09:55:45Z", "type": "forcePushed"}, {"oid": "2294a5fba5a15110d320734c100e2d08df2a0773", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2294a5fba5a15110d320734c100e2d08df2a0773", "message": "Fix completion tests\n\nSigned-off-by: Rasika <info.rasika@gmail.com>", "committedDate": "2020-10-21T10:31:14Z", "type": "commit"}]}