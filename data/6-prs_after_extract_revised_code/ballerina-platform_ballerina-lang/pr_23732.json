{"pr_number": 23732, "pr_title": "Fix expressions are supported as function-call lhs", "pr_createdAt": "2020-06-04T11:04:26Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732", "timeline": [{"oid": "0128b4f86331e9d37562e6b19e25c825977651e5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0128b4f86331e9d37562e6b19e25c825977651e5", "message": "Change functional call parsing", "committedDate": "2020-06-04T12:51:56Z", "type": "forcePushed"}, {"oid": "d3d741d0c9805bb2c7752cf442049d85319f1518", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3d741d0c9805bb2c7752cf442049d85319f1518", "message": "Change function call parsing", "committedDate": "2020-06-04T12:54:08Z", "type": "forcePushed"}, {"oid": "4a859a3c6507a2582e6fd5a847fa18fa3500b981", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4a859a3c6507a2582e6fd5a847fa18fa3500b981", "message": "Revamp function call parsing", "committedDate": "2020-06-05T09:35:06Z", "type": "commit"}, {"oid": "20a1af404b552bed3dd8f0e099cb243b4d6f030f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/20a1af404b552bed3dd8f0e099cb243b4d6f030f", "message": "Revamp function call recovery and add recovery tests", "committedDate": "2020-06-05T09:36:09Z", "type": "commit"}, {"oid": "20a1af404b552bed3dd8f0e099cb243b4d6f030f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/20a1af404b552bed3dd8f0e099cb243b4d6f030f", "message": "Revamp function call recovery and add recovery tests", "committedDate": "2020-06-05T09:36:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDkxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r435820914", "bodyText": "Under ARG_LIST context, ARG_LIST_START is always there as an alternative.\nIn other contexts, ARG_LIST_START is added as an alternative only if allowFuncCall is true.", "author": "lochana-chathura", "createdAt": "2020-06-05T10:02:42Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1765,82 +1768,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);", "originalCommit": "20a1af404b552bed3dd8f0e099cb243b4d6f030f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2ODY2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436468667", "bodyText": "Why is that needed?\nWhat if I write expr() inside func-args?", "author": "SupunS", "createdAt": "2020-06-08T05:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "fa1d174fc5c1382b3a5383bc152ef201db598582", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex 66d90ee028e..04673fff17e 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -1764,18 +1769,9 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n      * @param currentDepth Amount of distance traveled so far\n      * @param currentMatches Matching tokens found so far\n      * @param isEntryPoint\n+     * @param allowFuncCall Whether function call is allowed or not\n      * @return Recovery result\n      */\n-    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n-        ParserRuleContext parentCtx = getParentContext();\n-        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n-            endContext();\n-            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n-        } else {\n-            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n-        }\n-    }\n-\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n                                             boolean allowFuncCall) {\n         ParserRuleContext parentCtx = getParentContext();\n"}}, {"oid": "04654775ff71bda4e848de10915aef00b0ffc477", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04654775ff71bda4e848de10915aef00b0ffc477", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "committedDate": "2020-06-08T04:00:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MzY3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436463670", "bodyText": "Shouldn't this be merged with isValidExprRhsStart?\nBecause there are other places where we use isValidExprRhsStart for the same purpose, and those should behave the same way right?", "author": "SupunS", "createdAt": "2020-06-08T05:28:58Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4299,6 +4299,15 @@ private boolean isValidExprRhsStart(SyntaxKind tokenKind) {\n         }\n     }\n \n+    private boolean isInvalidFunctionCallStart(SyntaxKind tokenKind, STNode lhsExpr) {", "originalCommit": "04654775ff71bda4e848de10915aef00b0ffc477", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa1d174fc5c1382b3a5383bc152ef201db598582", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 8925bb3ab8b..1c190171cfb 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -4299,15 +4302,6 @@ public class BallerinaParser extends AbstractParser {\n         }\n     }\n \n-    private boolean isInvalidFunctionCallStart(SyntaxKind tokenKind, STNode lhsExpr) {\n-        if (tokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n-            // Only an identifier or a qualified identifier is followed by a function call.\n-            return lhsExpr.kind != SyntaxKind.QUALIFIED_NAME_REFERENCE &&\n-                    lhsExpr.kind != SyntaxKind.SIMPLE_NAME_REFERENCE;\n-        }\n-        return false;\n-    }\n-\n     /**\n      * Parse member access expression.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2NzE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436467191", "bodyText": "This operation is a bit expensive. Can we avoid this?", "author": "SupunS", "createdAt": "2020-06-08T05:43:04Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1875,16 +1893,24 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n             throw new IllegalStateException(parentCtx.toString());\n         }\n \n-        ParserRuleContext[] alternatives =\n-                { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD, ParserRuleContext.DOT,\n-                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n-                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.RIGHT_ARROW,\n-                        ParserRuleContext.SYNC_SEND_TOKEN, nextContext, ParserRuleContext.ARG_LIST_START };\n+        alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.IS_KEYWORD,\n+                ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n+                ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n+                ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n+                ParserRuleContext.RIGHT_ARROW, ParserRuleContext.SYNC_SEND_TOKEN, nextContext };\n \n+        if (allowFuncCall) {\n+            alternatives = addNewAlternative(alternatives, ParserRuleContext.ARG_LIST_START);\n+        }\n         return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n     }\n \n+    private ParserRuleContext[] addNewAlternative(ParserRuleContext[] alternatives, ParserRuleContext newAlternative) {\n+        List<ParserRuleContext> alternativesList = new ArrayList<>(Arrays.asList(alternatives));\n+        alternativesList.add(newAlternative);\n+        return alternativesList.toArray(alternatives);", "originalCommit": "04654775ff71bda4e848de10915aef00b0ffc477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE3NjA4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437176089", "bodyText": "Used System.arraycopy() instead of arrayLists. HBT?", "author": "lochana-chathura", "createdAt": "2020-06-09T06:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2NzE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa1d174fc5c1382b3a5383bc152ef201db598582", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex ab6a8876fc5..04673fff17e 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -1900,15 +1891,16 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                 ParserRuleContext.RIGHT_ARROW, ParserRuleContext.SYNC_SEND_TOKEN, nextContext };\n \n         if (allowFuncCall) {\n-            alternatives = addNewAlternative(alternatives, ParserRuleContext.ARG_LIST_START);\n+            alternatives = modifyAlternativesWithArgListStart(alternatives);\n         }\n         return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n     }\n \n-    private ParserRuleContext[] addNewAlternative(ParserRuleContext[] alternatives, ParserRuleContext newAlternative) {\n-        List<ParserRuleContext> alternativesList = new ArrayList<>(Arrays.asList(alternatives));\n-        alternativesList.add(newAlternative);\n-        return alternativesList.toArray(alternatives);\n+    private ParserRuleContext[] modifyAlternativesWithArgListStart(ParserRuleContext[] alternatives) {\n+        ParserRuleContext[] newAlternatives = new ParserRuleContext[alternatives.length + 1];\n+        System.arraycopy(alternatives, 0, newAlternatives, 0, alternatives.length);\n+        newAlternatives[alternatives.length] = ParserRuleContext.ARG_LIST_START;\n+        return newAlternatives;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436470981", "bodyText": "Can we do it without starting a context? because it is also an expensive operation. Should use that only if theres no other way.\nWhat if we give an alias, say \"VARIABLE_REF_RHS\", and that will call the seekMatchInExpressionRhs with the flag on/off", "author": "SupunS", "createdAt": "2020-06-08T05:57:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3522,6 +3548,22 @@ private ParserRuleContext getNextRuleForExpr() {\n         return ParserRuleContext.EXPRESSION_RHS;\n     }\n \n+    private ParserRuleContext getNextRuleForExprStartsWithIdentifier() {\n+        ParserRuleContext parentCtx;\n+        parentCtx = getParentContext();\n+        if (parentCtx == ParserRuleContext.CONSTANT_EXPRESSION) {\n+            endContext();\n+            return getNextRuleForConstExpr();\n+        }\n+        return getNextRuleForExprWithFuncCallEnabled();\n+    }\n+\n+    private ParserRuleContext getNextRuleForExprWithFuncCallEnabled() {\n+        // Here we start a new context so that expr-rhs will allow function calls\n+        startContext(ParserRuleContext.FUNCTION_CALL_START);", "originalCommit": "04654775ff71bda4e848de10915aef00b0ffc477", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa1d174fc5c1382b3a5383bc152ef201db598582", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex ab6a8876fc5..04673fff17e 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -3548,20 +3540,14 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n         return ParserRuleContext.EXPRESSION_RHS;\n     }\n \n-    private ParserRuleContext getNextRuleForExprStartsWithIdentifier() {\n+    private ParserRuleContext getNextRuleForExprStartsWithVarRef() {\n         ParserRuleContext parentCtx;\n         parentCtx = getParentContext();\n         if (parentCtx == ParserRuleContext.CONSTANT_EXPRESSION) {\n             endContext();\n             return getNextRuleForConstExpr();\n         }\n-        return getNextRuleForExprWithFuncCallEnabled();\n-    }\n-\n-    private ParserRuleContext getNextRuleForExprWithFuncCallEnabled() {\n-        // Here we start a new context so that expr-rhs will allow function calls\n-        startContext(ParserRuleContext.FUNCTION_CALL_START);\n-        return ParserRuleContext.EXPRESSION_RHS;\n+        return ParserRuleContext.VARIABLE_REF_RHS;\n     }\n \n     private ParserRuleContext getNextRuleForConstExpr() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r436471350", "bodyText": "Will the above logic be simplified, if we take the common things out, similar to the second switch-case?", "author": "SupunS", "createdAt": "2020-06-08T05:58:46Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1770,82 +1773,97 @@ private Result seekInAccessExpression(ParserRuleContext currentCtx, int lookahea\n      */\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n         ParserRuleContext parentCtx = getParentContext();\n-        ParserRuleContext[] next;\n+        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n+            endContext();\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n+        } else {\n+            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n+        }\n+    }\n+\n+    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n+                                            boolean allowFuncCall) {\n+        ParserRuleContext parentCtx = getParentContext();\n+        ParserRuleContext[] alternatives = null;\n         switch (parentCtx) {\n             case ARG_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n                         ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA,\n                         ParserRuleContext.ARG_LIST_START, ParserRuleContext.ARG_LIST_END };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, alternatives, isEntryPoint);\n             case MAPPING_CONSTRUCTOR:\n             case MULTI_WAIT_FIELDS:\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.COMMA, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACE,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.COMMA };\n+                break;\n             case COMPUTED_FIELD_NAME:\n                 // Here we give high priority to the comma. Therefore order of the below array matters.\n-                next = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.BINARY_OPERATOR,\n-                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n-                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n-                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.OPEN_BRACKET,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_BRACKET,\n+                        ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                        ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n+                        ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n+                        ParserRuleContext.OPEN_BRACKET };\n+                break;\n             case LISTENERS_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.OPEN_BRACE, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.OPEN_BRACE };\n+                break;\n             case LIST_CONSTRUCTOR:\n             case MEMBER_ACCESS_KEY_EXPR:\n             case BRACKETED_LIST:\n             case STMT_START_BRACKETED_LIST:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.CLOSE_BRACKET, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.CLOSE_BRACKET };\n+                break;\n             case LET_EXPR_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.IN_KEYWORD, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.IN_KEYWORD };\n+                break;\n             case LET_CLAUSE_LET_VAR_DECL:\n-                next = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n                         ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n                         ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n-                        ParserRuleContext.LET_CLAUSE_END, ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.LET_CLAUSE_END };\n+                break;\n             case QUERY_EXPRESSION:\n-                next = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.BINARY_OPERATOR, ParserRuleContext.DOT,\n                         ParserRuleContext.ANNOT_CHAINING_TOKEN, ParserRuleContext.OPTIONAL_CHAINING_TOKEN,\n                         ParserRuleContext.CONDITIONAL_EXPRESSION, ParserRuleContext.XML_NAVIGATE_EXPR,\n-                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS,\n-                        ParserRuleContext.ARG_LIST_START };\n-                return seekInAlternativesPaths(lookahead, currentDepth, currentMatches, next, isEntryPoint);\n+                        ParserRuleContext.MEMBER_ACCESS_KEY_EXPR, ParserRuleContext.QUERY_PIPELINE_RHS };\n+                break;\n             default:\n                 if (isParameter(parentCtx)) {\n-                    next = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,\n+                    alternatives = new ParserRuleContext[] { ParserRuleContext.CLOSE_PARENTHESIS,", "originalCommit": "04654775ff71bda4e848de10915aef00b0ffc477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE3NzI2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437177260", "bodyText": "Common alternatives are located in the middle of array. Number of alternatives before common and after common, are different for each ctx. So are we going to add the common ones at the end?", "author": "lochana-chathura", "createdAt": "2020-06-09T06:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4MDMxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23732#discussion_r437180314", "bodyText": "btw MEMBER_ACCESS_KEY_EXPR is missing as an alternative under COMPUTED_FIELD_NAME ctx. I think it's a mistake", "author": "lochana-chathura", "createdAt": "2020-06-09T07:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "fa1d174fc5c1382b3a5383bc152ef201db598582", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex ab6a8876fc5..04673fff17e 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -1769,18 +1769,9 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n      * @param currentDepth Amount of distance traveled so far\n      * @param currentMatches Matching tokens found so far\n      * @param isEntryPoint\n+     * @param allowFuncCall Whether function call is allowed or not\n      * @return Recovery result\n      */\n-    private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint) {\n-        ParserRuleContext parentCtx = getParentContext();\n-        if (parentCtx == ParserRuleContext.FUNCTION_CALL_START) {\n-            endContext();\n-            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, true);\n-        } else {\n-            return seekMatchInExpressionRhs(lookahead, currentDepth, currentMatches, isEntryPoint, false);\n-        }\n-    }\n-\n     private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int currentMatches, boolean isEntryPoint,\n                                             boolean allowFuncCall) {\n         ParserRuleContext parentCtx = getParentContext();\n"}}, {"oid": "fa1d174fc5c1382b3a5383bc152ef201db598582", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa1d174fc5c1382b3a5383bc152ef201db598582", "message": "Revamp function call parsing", "committedDate": "2020-06-09T06:34:19Z", "type": "commit"}, {"oid": "e2dd815545f1b18dbdaa92d10d3aca95766d8663", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2dd815545f1b18dbdaa92d10d3aca95766d8663", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/test/resources/expressions/func-call/func_call_assert_12.json", "committedDate": "2020-06-09T06:35:23Z", "type": "commit"}, {"oid": "6d07c3320e16287f82093ac49b8514cd0f380714", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6d07c3320e16287f82093ac49b8514cd0f380714", "message": "Resolve a json file conflict", "committedDate": "2020-06-09T06:47:18Z", "type": "commit"}, {"oid": "804f5ef0aad7e12fde796ea5d3cfd7f8c7fd75c5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/804f5ef0aad7e12fde796ea5d3cfd7f8c7fd75c5", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "committedDate": "2020-06-09T09:28:32Z", "type": "commit"}, {"oid": "e6bc95b4beb73012061545f7fbf8248a66555767", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e6bc95b4beb73012061545f7fbf8248a66555767", "message": "Merge branch 'fix-parser-issues' of https://github.com/SupunS/ballerina into incremental-parser\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "committedDate": "2020-06-09T10:03:04Z", "type": "commit"}, {"oid": "2dab293032e94dbec70fe242a7a6bb8ad8296509", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2dab293032e94dbec70fe242a7a6bb8ad8296509", "message": "Fix checkStyle", "committedDate": "2020-06-09T10:15:26Z", "type": "commit"}, {"oid": "2dab293032e94dbec70fe242a7a6bb8ad8296509", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2dab293032e94dbec70fe242a7a6bb8ad8296509", "message": "Fix checkStyle", "committedDate": "2020-06-09T10:15:26Z", "type": "forcePushed"}, {"oid": "b85af3e9dd6c0238ccac05ff87eb40865861a2b0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b85af3e9dd6c0238ccac05ff87eb40865861a2b0", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser", "committedDate": "2020-06-10T04:08:54Z", "type": "commit"}]}