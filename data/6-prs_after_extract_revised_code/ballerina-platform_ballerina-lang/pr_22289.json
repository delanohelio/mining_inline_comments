{"pr_number": 22289, "pr_title": "Fix hasfiller value for BFiniteType created for const literals", "pr_createdAt": "2020-03-29T16:17:50Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0Mjc5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401142792", "bodyText": "Why are we doing these changes? IINM some of them are as per the style guidelines.", "author": "MaryamZi", "createdAt": "2020-03-31T18:57:29Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -1887,18 +1843,15 @@ public Boolean visit(BServiceType t, BType s) {\n \n         @Override\n         public Boolean visit(BTypedescType t, BType s) {\n-\n             if (s.tag != TypeTags.TYPEDESC) {\n                 return false;\n             }\n             BTypedescType sType = ((BTypedescType) s);\n             return isSameType(sType.constraint, t.constraint, this.unresolvedTypes);\n         }\n \n-\n         @Override\n         public Boolean visit(BFiniteType t, BType s) {\n-", "originalCommit": "31c43acf21d221d5b0a60df10e82b5801493ccac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI0NzU3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401247576", "bodyText": "Leave your code better than you found it. Boy Scout Rule.\nreverted.  I will check the guidelines.", "author": "KRVPerera", "createdAt": "2020-03-31T22:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0Mjc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9360d49bd743b890cd22ec8132cb12474c389dc5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 580b630828a..bbe1c485559 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -1640,325 +1669,132 @@ public class Types {\n         return fieldType.isNullable();\n     }\n \n-    private class BSameTypeVisitor implements BTypeVisitor<BType, Boolean> {\n-\n-        Set<TypePair> unresolvedTypes;\n+    private boolean checkFieldEquivalency(BRecordType lhsType, BRecordType rhsType, Set<TypePair> unresolvedTypes) {\n+        Map<Name, BField> rhsFields = rhsType.fields.stream().collect(Collectors.toMap(BField::getName, f -> f));\n \n-        BSameTypeVisitor(Set<TypePair> unresolvedTypes) {\n-            this.unresolvedTypes = unresolvedTypes;\n-        }\n+        // Check if the RHS record has corresponding fields to those of the LHS record.\n+        for (BField lhsField : lhsType.fields) {\n+            BField rhsField = rhsFields.get(lhsField.name);\n \n-        @Override\n-        public Boolean visit(BType t, BType s) {\n+            // There should be a corresponding RHS field\n+            if (rhsField == null) {\n+                return false;\n+            }\n \n-            if (t == s) {\n-                return true;\n+            // If LHS field is required, so should the RHS field\n+            if (!Symbols.isOptional(lhsField.symbol) && Symbols.isOptional(rhsField.symbol)) {\n+                return false;\n             }\n-            switch (t.tag) {\n-                case TypeTags.INT:\n-                case TypeTags.BYTE:\n-                case TypeTags.FLOAT:\n-                case TypeTags.DECIMAL:\n-                case TypeTags.STRING:\n-                case TypeTags.BOOLEAN:\n-                case TypeTags.ANY:\n-                case TypeTags.ANYDATA:\n-                    return t.tag == s.tag\n-                            && (TypeParamAnalyzer.isTypeParam(t) || TypeParamAnalyzer.isTypeParam(s));\n-                default:\n-                    break;\n+\n+            // The corresponding RHS field should be assignable to the LHS field.\n+            if (!isAssignable(rhsField.type, lhsField.type, unresolvedTypes)) {\n+                return false;\n             }\n-            return false;\n \n+            rhsFields.remove(lhsField.name);\n         }\n \n-        @Override\n-        public Boolean visit(BBuiltInRefType t, BType s) {\n-            return t == s;\n-        }\n+        // If there are any remaining RHS fields, the types of those should be assignable to the rest field type of\n+        // the LHS record.\n+        return rhsFields.entrySet().stream().allMatch(\n+                fieldEntry -> isAssignable(fieldEntry.getValue().type, lhsType.restFieldType, unresolvedTypes));\n+    }\n \n-        @Override\n-        public Boolean visit(BAnyType t, BType s) {\n-            return t == s;\n-        }\n+    ;\n \n-        @Override\n-        public Boolean visit(BAnydataType t, BType s) {\n-            return t == s;\n+    private boolean equalityIntersectionExists(Set<BType> lhsTypes, Set<BType> rhsTypes) {\n+        if ((lhsTypes.contains(symTable.anydataType) &&\n+                rhsTypes.stream().anyMatch(type -> type.tag != TypeTags.ERROR)) ||\n+                (rhsTypes.contains(symTable.anydataType) &&\n+                        lhsTypes.stream().anyMatch(type -> type.tag != TypeTags.ERROR))) {\n+            return true;\n         }\n \n-        @Override\n-        public Boolean visit(BMapType t, BType s) {\n-            if (s.tag != TypeTags.MAP) {\n-                return false;\n-            }\n-            // At this point both source and target types are of map types. Inorder to be equal in type as whole\n-            // constraints should be in equal type.\n-            BMapType sType = ((BMapType) s);\n-            return isSameType(sType.constraint, t.constraint, this.unresolvedTypes);\n-        }\n+        boolean matchFound = lhsTypes\n+                .stream()\n+                .anyMatch(s -> rhsTypes\n+                        .stream()\n+                        .anyMatch(t -> isSameType(s, t)));\n \n-        @Override\n-        public Boolean visit(BFutureType t, BType s) {\n-            return s.tag == TypeTags.FUTURE && t.constraint.tag == ((BFutureType) s).constraint.tag;\n+        if (!matchFound) {\n+            matchFound = equalityIntersectionExistsForComplexTypes(lhsTypes, rhsTypes);\n         }\n \n-        @Override\n-        public Boolean visit(BXMLType t, BType s) {\n-            return visit((BBuiltInRefType) t, s);\n-        }\n+        return matchFound;\n+    }\n \n-        @Override\n-        public Boolean visit(BJSONType t, BType s) {\n-            return s.tag == TypeTags.JSON;\n-        }\n+    private BAttachedFunction getMatchingInvokableType(List<BAttachedFunction> rhsFuncList, BAttachedFunction lhsFunc,\n+                                                       Set<TypePair> unresolvedTypes) {\n+        return rhsFuncList.stream()\n+                .filter(rhsFunc -> lhsFunc.funcName.equals(rhsFunc.funcName))\n+                .filter(rhsFunc -> isFunctionTypeAssignable(rhsFunc.type, lhsFunc.type, unresolvedTypes))\n+                .findFirst()\n+                .orElse(null);\n+    }\n \n-        @Override\n-        public Boolean visit(BArrayType t, BType s) {\n-            return s.tag == TypeTags.ARRAY && checkArrayEquality(s, t, new HashSet<>());\n+    private boolean isInSameVisibilityRegion(BSymbol lhsSym, BSymbol rhsSym) {\n+        if (Symbols.isPrivate(lhsSym)) {\n+            return Symbols.isPrivate(rhsSym) && lhsSym.pkgID.equals(rhsSym.pkgID)\n+                    && lhsSym.owner.name.equals(rhsSym.owner.name);\n+        } else if (Symbols.isPublic(lhsSym)) {\n+            return Symbols.isPublic(rhsSym);\n         }\n+        return !Symbols.isPrivate(rhsSym) && !Symbols.isPublic(rhsSym) && lhsSym.pkgID.equals(rhsSym.pkgID);\n+    }\n \n-        @Override\n-        public Boolean visit(BObjectType t, BType s) {\n-            if (t == s) {\n-                return true;\n-            }\n+    private boolean isAssignableToUnionType(BType source, BType target, Set<TypePair> unresolvedTypes) {\n+        Set<BType> sourceTypes = new LinkedHashSet<>();\n+        Set<BType> targetTypes = new LinkedHashSet<>();\n \n-            if (s.tag != TypeTags.OBJECT) {\n-                return false;\n-            }\n+        if (source.tag == TypeTags.UNION) {\n+            BUnionType sourceUnionType = (BUnionType) source;\n+            sourceTypes.addAll(sourceUnionType.getMemberTypes());\n+        } else {\n+            sourceTypes.add(source);\n+        }\n \n-            return t.tsymbol.pkgID.equals(s.tsymbol.pkgID) && t.tsymbol.name.equals(s.tsymbol.name);\n+        if (target.tag == TypeTags.UNION) {\n+            BUnionType targetUnionType = (BUnionType) target;\n+            targetTypes.addAll(targetUnionType.getMemberTypes());\n+        } else {\n+            targetTypes.add(target);\n         }\n \n-        @Override\n-        public Boolean visit(BRecordType t, BType s) {\n-            if (t == s) {\n-                return true;\n-            }\n-            if (s.tag != TypeTags.RECORD) {\n-                return false;\n-            }\n-            BRecordType source = (BRecordType) s;\n-            if (source.fields.size() != t.fields.size()) {\n-                return false;\n-            }\n+        return sourceTypes.stream()\n+                .allMatch(s -> (targetTypes.stream().anyMatch(t -> isAssignable(s, t, unresolvedTypes)))\n+                        || (s.tag == TypeTags.FINITE  && isAssignable(s, target, unresolvedTypes))\n+                        || (s.tag == TypeTags.XML\n+                            && isAssignableToUnionType(expandedXMLBuiltinSubtypes, target, unresolvedTypes)));\n+    }\n \n-            boolean notSameType = source.fields\n-                    .stream()\n-                    .map(fs -> t.fields.stream()\n-                            .anyMatch(ft -> fs.name.equals(ft.name)\n-                                    && isSameType(fs.type, ft.type, this.unresolvedTypes)\n-                                    && hasSameOptionalFlag(fs.symbol, ft.symbol)))\n-                    .anyMatch(foundSameType -> !foundSameType);\n-            if (notSameType) {\n-                return false;\n-            }\n-            return isSameType(source.restFieldType, t.restFieldType, unresolvedTypes);\n+    private boolean isFiniteTypeAssignable(BFiniteType finiteType, BType targetType, Set<TypePair> unresolvedTypes) {\n+        if (targetType.tag == TypeTags.FINITE) {\n+            return finiteType.getValueSpace().stream()\n+                    .allMatch(expression -> isAssignableToFiniteType(targetType, (BLangLiteral) expression));\n         }\n \n-        private boolean hasSameOptionalFlag(BVarSymbol s, BVarSymbol t) {\n-            return ((s.flags & Flags.OPTIONAL) ^ (t.flags & Flags.OPTIONAL)) != Flags.OPTIONAL;\n+        if (targetType.tag == TypeTags.UNION) {\n+            List<BType> unionMemberTypes = getAllTypes(targetType);\n+            return finiteType.getValueSpace().stream()\n+                    .allMatch(valueExpr ->  unionMemberTypes.stream()\n+                            .anyMatch(targetMemType -> targetMemType.tag == TypeTags.FINITE ?\n+                                    isAssignableToFiniteType(targetMemType, (BLangLiteral) valueExpr) :\n+                                    isAssignable(valueExpr.type, targetType, unresolvedTypes)));\n         }\n \n-        @Override\n-        public Boolean visit(BTableType t, BType s) {\n-            return t == s;\n+        return finiteType.getValueSpace().stream()\n+                .allMatch(expression -> isAssignable(expression.type, targetType, unresolvedTypes));\n+    }\n+\n+    boolean isAssignableToFiniteType(BType type, BLangLiteral literalExpr) {\n+        if (type.tag != TypeTags.FINITE) {\n+            return false;\n         }\n \n-        public Boolean visit(BTupleType t, BType s) {\n-            if (s.tag != TypeTags.TUPLE) {\n-                return false;\n-            }\n-            BTupleType source = (BTupleType) s;\n-            if (source.tupleTypes.size() != t.tupleTypes.size()) {\n-                return false;\n-            }\n-            for (int i = 0; i < source.tupleTypes.size(); i++) {\n-                if (t.getTupleTypes().get(i) == symTable.noType) {\n-                    continue;\n-                }\n-                if (!isSameType(source.getTupleTypes().get(i), t.tupleTypes.get(i), this.unresolvedTypes)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public Boolean visit(BStreamType t, BType s) {\n-            return t == s;\n-        }\n-\n-        @Override\n-        public Boolean visit(BInvokableType t, BType s) {\n-            return s.tag == TypeTags.INVOKABLE && isSameFunctionType((BInvokableType) s, t, new HashSet<>());\n-        }\n-\n-        @Override\n-        public Boolean visit(BUnionType tUnionType, BType s) {\n-            if (s.tag != TypeTags.UNION) {\n-                return false;\n-            }\n-            BUnionType sUnionType = (BUnionType) s;\n-            if (sUnionType.getMemberTypes().size()\n-                    != tUnionType.getMemberTypes().size()) {\n-                return false;\n-            }\n-\n-            Set<BType> sourceTypes = new LinkedHashSet<>(sUnionType.getMemberTypes());\n-            Set<BType> targetTypes = new LinkedHashSet<>(tUnionType.getMemberTypes());\n-\n-            boolean notSameType = sourceTypes\n-                    .stream()\n-                    .map(sT -> targetTypes\n-                            .stream()\n-                            .anyMatch(it -> isSameType(it, sT, this.unresolvedTypes)))\n-                    .anyMatch(foundSameType -> !foundSameType);\n-            return !notSameType;\n-        }\n-\n-        @Override\n-        public Boolean visit(BErrorType t, BType s) {\n-            if (s.tag != TypeTags.ERROR) {\n-                return false;\n-            }\n-            BErrorType source = (BErrorType) s;\n-\n-            if (!isSameType(source.reasonType, t.reasonType, this.unresolvedTypes)) {\n-                return false;\n-            }\n-\n-            if (source.detailType == t.detailType) {\n-                return true;\n-            }\n-\n-            return isSameType(source.detailType, t.detailType, this.unresolvedTypes);\n-        }\n-\n-        @Override\n-        public Boolean visit(BServiceType t, BType s) {\n-            return t == s || t.tag == s.tag;\n-        }\n-\n-        @Override\n-        public Boolean visit(BTypedescType t, BType s) {\n-            if (s.tag != TypeTags.TYPEDESC) {\n-                return false;\n-            }\n-            BTypedescType sType = ((BTypedescType) s);\n-            return isSameType(sType.constraint, t.constraint, this.unresolvedTypes);\n-        }\n-\n-        @Override\n-        public Boolean visit(BFiniteType t, BType s) {\n-            return s == t;\n-        }\n-\n-    };\n-\n-    private boolean checkFieldEquivalency(BRecordType lhsType, BRecordType rhsType, Set<TypePair> unresolvedTypes) {\n-        Map<Name, BField> rhsFields = rhsType.fields.stream().collect(Collectors.toMap(BField::getName, f -> f));\n-\n-        // Check if the RHS record has corresponding fields to those of the LHS record.\n-        for (BField lhsField : lhsType.fields) {\n-            BField rhsField = rhsFields.get(lhsField.name);\n-\n-            // There should be a corresponding RHS field\n-            if (rhsField == null) {\n-                return false;\n-            }\n-\n-            // If LHS field is required, so should the RHS field\n-            if (!Symbols.isOptional(lhsField.symbol) && Symbols.isOptional(rhsField.symbol)) {\n-                return false;\n-            }\n-\n-            // The corresponding RHS field should be assignable to the LHS field.\n-            if (!isAssignable(rhsField.type, lhsField.type, unresolvedTypes)) {\n-                return false;\n-            }\n-            rhsFields.remove(lhsField.name);\n-        }\n-\n-        // If there are any remaining RHS fields, the types of those should be assignable to the rest field type of\n-        // the LHS record.\n-        return rhsFields.entrySet().stream().allMatch(\n-                fieldEntry -> isAssignable(fieldEntry.getValue().type, lhsType.restFieldType, unresolvedTypes));\n-    }\n-\n-    private BAttachedFunction getMatchingInvokableType(List<BAttachedFunction> rhsFuncList, BAttachedFunction lhsFunc,\n-                                                       Set<TypePair> unresolvedTypes) {\n-        return rhsFuncList.stream()\n-                .filter(rhsFunc -> lhsFunc.funcName.equals(rhsFunc.funcName))\n-                .filter(rhsFunc -> isFunctionTypeAssignable(rhsFunc.type, lhsFunc.type, unresolvedTypes))\n-                .findFirst()\n-                .orElse(null);\n-    }\n-\n-    private boolean isInSameVisibilityRegion(BSymbol lhsSym, BSymbol rhsSym) {\n-        if (Symbols.isPrivate(lhsSym)) {\n-            return Symbols.isPrivate(rhsSym) && lhsSym.pkgID.equals(rhsSym.pkgID)\n-                    && lhsSym.owner.name.equals(rhsSym.owner.name);\n-        } else if (Symbols.isPublic(lhsSym)) {\n-            return Symbols.isPublic(rhsSym);\n-        }\n-        return !Symbols.isPrivate(rhsSym) && !Symbols.isPublic(rhsSym) && lhsSym.pkgID.equals(rhsSym.pkgID);\n-    }\n-\n-    private boolean isAssignableToUnionType(BType source, BType target, Set<TypePair> unresolvedTypes) {\n-        Set<BType> sourceTypes = new LinkedHashSet<>();\n-        Set<BType> targetTypes = new LinkedHashSet<>();\n-\n-        if (source.tag == TypeTags.UNION) {\n-            BUnionType sourceUnionType = (BUnionType) source;\n-            sourceTypes.addAll(sourceUnionType.getMemberTypes());\n-        } else {\n-            sourceTypes.add(source);\n-        }\n-\n-        if (target.tag == TypeTags.UNION) {\n-            BUnionType targetUnionType = (BUnionType) target;\n-            targetTypes.addAll(targetUnionType.getMemberTypes());\n-        } else {\n-            targetTypes.add(target);\n-        }\n-\n-        return sourceTypes.stream()\n-                .allMatch(s -> (targetTypes.stream().anyMatch(t -> isAssignable(s, t, unresolvedTypes)))\n-                        || (s.tag == TypeTags.FINITE  && isAssignable(s, target, unresolvedTypes))\n-                        || (s.tag == TypeTags.XML\n-                            && isAssignableToUnionType(expandedXMLBuiltinSubtypes, target, unresolvedTypes)));\n-    }\n-\n-    private boolean isFiniteTypeAssignable(BFiniteType finiteType, BType targetType, Set<TypePair> unresolvedTypes) {\n-        if (targetType.tag == TypeTags.FINITE) {\n-            return finiteType.getValueSpace().stream()\n-                    .allMatch(expression -> isAssignableToFiniteType(targetType, (BLangLiteral) expression));\n-        }\n-\n-        if (targetType.tag == TypeTags.UNION) {\n-            List<BType> unionMemberTypes = getAllTypes(targetType);\n-            return finiteType.getValueSpace().stream()\n-                    .allMatch(valueExpr ->  unionMemberTypes.stream()\n-                            .anyMatch(targetMemType -> targetMemType.tag == TypeTags.FINITE ?\n-                                    isAssignableToFiniteType(targetMemType, (BLangLiteral) valueExpr) :\n-                                    isAssignable(valueExpr.type, targetType, unresolvedTypes)));\n-        }\n-\n-        return finiteType.getValueSpace().stream()\n-                .allMatch(expression -> isAssignable(expression.type, targetType, unresolvedTypes));\n-    }\n-\n-    boolean isAssignableToFiniteType(BType type, BLangLiteral literalExpr) {\n-        if (type.tag != TypeTags.FINITE) {\n-            return false;\n-        }\n-\n-        BFiniteType expType = (BFiniteType) type;\n-        return expType.getValueSpace().stream().anyMatch(memberLiteral -> {\n-            if (((BLangLiteral) memberLiteral).value == null) {\n-                return literalExpr.value == null;\n+        BFiniteType expType = (BFiniteType) type;\n+        return expType.getValueSpace().stream().anyMatch(memberLiteral -> {\n+            if (((BLangLiteral) memberLiteral).value == null) {\n+                return literalExpr.value == null;\n             }\n             // Check whether the literal that needs to be tested is assignable to any of the member literal in the\n             // value space.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0NTg0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401145849", "bodyText": "Type tags mean something else for the compiler right? Shall we use a different name?", "author": "MaryamZi", "createdAt": "2020-03-31T19:02:34Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2893,14 +2843,27 @@ private boolean checkFillerValue(BUnionType type) {\n         if (type.isNullable()) {\n             return true;\n         }\n-        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        Set<BType> typeTags = new HashSet<>();", "originalCommit": "31c43acf21d221d5b0a60df10e82b5801493ccac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9360d49bd743b890cd22ec8132cb12474c389dc5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 580b630828a..bbe1c485559 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -2839,31 +2682,231 @@ public class Types {\n         return defaultFillValuePresent;\n     }\n \n-    private boolean checkFillerValue(BUnionType type) {\n-        if (type.isNullable()) {\n+    private Set<BType> getUniqueValues(BFiniteType member) {\n+        Set<BType> uniqueType = new HashSet<>();\n+        for (BLangExpression expression : member.getValueSpace()) {\n+            uniqueType.add(expression.type);\n+        }\n+        return uniqueType;\n+    }\n+\n+    private class BSameTypeVisitor implements BTypeVisitor<BType, Boolean> {\n+\n+        Set<TypePair> unresolvedTypes;\n+\n+        BSameTypeVisitor(Set<TypePair> unresolvedTypes) {\n+            this.unresolvedTypes = unresolvedTypes;\n+        }\n+\n+        @Override\n+        public Boolean visit(BType t, BType s) {\n+\n+            if (t == s) {\n+                return true;\n+            }\n+            switch (t.tag) {\n+                case TypeTags.INT:\n+                case TypeTags.BYTE:\n+                case TypeTags.FLOAT:\n+                case TypeTags.DECIMAL:\n+                case TypeTags.STRING:\n+                case TypeTags.BOOLEAN:\n+                case TypeTags.ANY:\n+                case TypeTags.ANYDATA:\n+                    return t.tag == s.tag\n+                            && (TypeParamAnalyzer.isTypeParam(t) || TypeParamAnalyzer.isTypeParam(s));\n+                default:\n+                    break;\n+            }\n+            return false;\n+\n+        }\n+\n+        @Override\n+        public Boolean visit(BBuiltInRefType t, BType s) {\n+            return t == s;\n+        }\n+\n+        @Override\n+        public Boolean visit(BAnyType t, BType s) {\n+            return t == s;\n+        }\n+\n+        @Override\n+        public Boolean visit(BAnydataType t, BType s) {\n+            return t == s;\n+        }\n+\n+        @Override\n+        public Boolean visit(BMapType t, BType s) {\n+            if (s.tag != TypeTags.MAP) {\n+                return false;\n+            }\n+            // At this point both source and target types are of map types. Inorder to be equal in type as whole\n+            // constraints should be in equal type.\n+            BMapType sType = ((BMapType) s);\n+            return isSameType(sType.constraint, t.constraint, this.unresolvedTypes);\n+        }\n+\n+        @Override\n+        public Boolean visit(BFutureType t, BType s) {\n+            return s.tag == TypeTags.FUTURE && t.constraint.tag == ((BFutureType) s).constraint.tag;\n+        }\n+\n+        @Override\n+        public Boolean visit(BXMLType t, BType s) {\n+            return visit((BBuiltInRefType) t, s);\n+        }\n+\n+        @Override\n+        public Boolean visit(BJSONType t, BType s) {\n+            return s.tag == TypeTags.JSON;\n+        }\n+\n+        @Override\n+        public Boolean visit(BArrayType t, BType s) {\n+            return s.tag == TypeTags.ARRAY && checkArrayEquality(s, t, new HashSet<>());\n+        }\n+\n+        @Override\n+        public Boolean visit(BObjectType t, BType s) {\n+            if (t == s) {\n+                return true;\n+            }\n+\n+            if (s.tag != TypeTags.OBJECT) {\n+                return false;\n+            }\n+\n+            return t.tsymbol.pkgID.equals(s.tsymbol.pkgID) && t.tsymbol.name.equals(s.tsymbol.name);\n+        }\n+\n+        @Override\n+        public Boolean visit(BRecordType t, BType s) {\n+\n+            if (t == s) {\n+                return true;\n+            }\n+            if (s.tag != TypeTags.RECORD) {\n+                return false;\n+            }\n+            BRecordType source = (BRecordType) s;\n+\n+            if (source.fields.size() != t.fields.size()) {\n+                return false;\n+            }\n+\n+            boolean notSameType = source.fields\n+                    .stream()\n+                    .map(fs -> t.fields.stream()\n+                            .anyMatch(ft -> fs.name.equals(ft.name)\n+                                    && isSameType(fs.type, ft.type, this.unresolvedTypes)\n+                                    && hasSameOptionalFlag(fs.symbol, ft.symbol)))\n+                    .anyMatch(foundSameType -> !foundSameType);\n+            if (notSameType) {\n+                return false;\n+            }\n+            return isSameType(source.restFieldType, t.restFieldType, unresolvedTypes);\n+        }\n+\n+        private boolean hasSameOptionalFlag(BVarSymbol s, BVarSymbol t) {\n+            return ((s.flags & Flags.OPTIONAL) ^ (t.flags & Flags.OPTIONAL)) != Flags.OPTIONAL;\n+        }\n+\n+        public Boolean visit(BTupleType t, BType s) {\n+            if (s.tag != TypeTags.TUPLE) {\n+                return false;\n+            }\n+            BTupleType source = (BTupleType) s;\n+            if (source.tupleTypes.size() != t.tupleTypes.size()) {\n+                return false;\n+            }\n+            for (int i = 0; i < source.tupleTypes.size(); i++) {\n+                if (t.getTupleTypes().get(i) == symTable.noType) {\n+                    continue;\n+                }\n+                if (!isSameType(source.getTupleTypes().get(i), t.tupleTypes.get(i), this.unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n             return true;\n         }\n-        Set<BType> typeTags = new HashSet<>();\n-        boolean hasFillerValue = false;\n-        for (BType member : type.getMemberTypes()) {\n-            if (member.tag == TypeTags.FINITE) {\n-                Set<BType> uniqueValues = ((BFiniteType) member).getUniqueValues();\n-                typeTags.addAll(uniqueValues);\n-            } else {\n-                typeTags.add(member);\n+\n+        @Override\n+        public Boolean visit(BStreamType t, BType s) {\n+            return t == s;\n+        }\n+\n+        @Override\n+        public Boolean visit(BInvokableType t, BType s) {\n+            return s.tag == TypeTags.INVOKABLE && isSameFunctionType((BInvokableType) s, t, new HashSet<>());\n+        }\n+\n+        @Override\n+        public Boolean visit(BUnionType tUnionType, BType s) {\n+            if (s.tag != TypeTags.UNION) {\n+                return false;\n             }\n-            if (!hasFillerValue && hasFillerValue(member)) {\n-                hasFillerValue = true;\n+\n+            BUnionType sUnionType = (BUnionType) s;\n+\n+            if (sUnionType.getMemberTypes().size()\n+                    != tUnionType.getMemberTypes().size()) {\n+                return false;\n             }\n+\n+            Set<BType> sourceTypes = new LinkedHashSet<>(sUnionType.getMemberTypes());\n+            Set<BType> targetTypes = new LinkedHashSet<>(tUnionType.getMemberTypes());\n+\n+            boolean notSameType = sourceTypes\n+                    .stream()\n+                    .map(sT -> targetTypes\n+                            .stream()\n+                            .anyMatch(it -> isSameType(it, sT, this.unresolvedTypes)))\n+                    .anyMatch(foundSameType -> !foundSameType);\n+            return !notSameType;\n         }\n-        Iterator<BType> iterator = typeTags.iterator();\n-        BType firstMember = iterator.next();\n-        while (iterator.hasNext()) {\n-            if (!isSameType(firstMember, iterator.next())) {\n+\n+        @Override\n+        public Boolean visit(BErrorType t, BType s) {\n+            if (s.tag != TypeTags.ERROR) {\n+                return false;\n+            }\n+            BErrorType source = (BErrorType) s;\n+\n+            if (!isSameType(source.reasonType, t.reasonType, this.unresolvedTypes)) {\n                 return false;\n             }\n+\n+            if (source.detailType == t.detailType) {\n+                return true;\n+            }\n+\n+            return isSameType(source.detailType, t.detailType, this.unresolvedTypes);\n         }\n-        return isValueType(firstMember) && hasFillerValue;\n+\n+        @Override\n+        public Boolean visit(BServiceType t, BType s) {\n+            return t == s || t.tag == s.tag;\n+        }\n+\n+        @Override\n+        public Boolean visit(BTypedescType t, BType s) {\n+\n+            if (s.tag != TypeTags.TYPEDESC) {\n+                return false;\n+            }\n+            BTypedescType sType = ((BTypedescType) s);\n+            return isSameType(sType.constraint, t.constraint, this.unresolvedTypes);\n+        }\n+\n+\n+        @Override\n+        public Boolean visit(BFiniteType t, BType s) {\n+\n+            return s == t;\n+        }\n+\n     }\n \n     private boolean isImplicitDefaultValue(BLangExpression expression) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0OTI2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401149266", "bodyText": "The name of the function is not accurate right?\nAlso, this is like a specific scenario so I think this shouldn't be a method in BFiniteType.java. We can maybe introduce a method in the Types.java class itself instead.", "author": "MaryamZi", "createdAt": "2020-03-31T19:08:36Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -115,4 +116,16 @@ public void addValue(BLangExpression value) {\n             nullable = true;\n         }\n     }\n+\n+    public Set<BType> getUniqueValues() {", "originalCommit": "31c43acf21d221d5b0a60df10e82b5801493ccac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9360d49bd743b890cd22ec8132cb12474c389dc5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\nindex 8e56a95a70f..5a7f05556da 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n\n@@ -116,16 +116,4 @@ public class BFiniteType extends BType implements FiniteType {\n             nullable = true;\n         }\n     }\n-\n-    public Set<BType> getUniqueValues() {\n-        Set<BType> uniqueType = new HashSet<>();\n-        for (BLangExpression expression : this.valueSpace) {\n-            if (expression.type.tag != TypeTags.FINITE) {\n-                uniqueType.add(expression.type);\n-            } else {\n-                uniqueType.addAll(((BFiniteType) expression.type).getUniqueValues());\n-            }\n-        }\n-        return uniqueType;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MTQ2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401151462", "bodyText": "Can you please share an example where the member in the value space of a finite type is another finite type?", "author": "MaryamZi", "createdAt": "2020-03-31T19:12:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -115,4 +116,16 @@ public void addValue(BLangExpression value) {\n             nullable = true;\n         }\n     }\n+\n+    public Set<BType> getUniqueValues() {\n+        Set<BType> uniqueType = new HashSet<>();\n+        for (BLangExpression expression : this.valueSpace) {\n+            if (expression.type.tag != TypeTags.FINITE) {\n+                uniqueType.add(expression.type);\n+            } else {\n+                uniqueType.addAll(((BFiniteType) expression.type).getUniqueValues());", "originalCommit": "31c43acf21d221d5b0a60df10e82b5801493ccac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI0NTQxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22289#discussion_r401245413", "bodyText": "Think I have confused this with the union type", "author": "KRVPerera", "createdAt": "2020-03-31T22:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MTQ2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9360d49bd743b890cd22ec8132cb12474c389dc5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\nindex 8e56a95a70f..5a7f05556da 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java\n\n@@ -116,16 +116,4 @@ public class BFiniteType extends BType implements FiniteType {\n             nullable = true;\n         }\n     }\n-\n-    public Set<BType> getUniqueValues() {\n-        Set<BType> uniqueType = new HashSet<>();\n-        for (BLangExpression expression : this.valueSpace) {\n-            if (expression.type.tag != TypeTags.FINITE) {\n-                uniqueType.add(expression.type);\n-            } else {\n-                uniqueType.addAll(((BFiniteType) expression.type).getUniqueValues());\n-            }\n-        }\n-        return uniqueType;\n-    }\n }\n"}}, {"oid": "9360d49bd743b890cd22ec8132cb12474c389dc5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9360d49bd743b890cd22ec8132cb12474c389dc5", "message": "Fix code formatting suggestions in code review\n\nRemoved recursive finite flattening as bad logic. Refactor variable\nnames for clarity.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-03-31T22:09:42Z", "type": "forcePushed"}, {"oid": "8ca2e8ba069d94e0511bc97bef7a82057638a72d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ca2e8ba069d94e0511bc97bef7a82057638a72d", "message": "Fix code conflicts\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-03-31T22:28:36Z", "type": "forcePushed"}, {"oid": "0b912eccfa70fe70490e19528e531ee4496cfbe6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b912eccfa70fe70490e19528e531ee4496cfbe6", "message": "Fix code conflicts\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-03-31T22:31:13Z", "type": "forcePushed"}, {"oid": "7d8c6b9b8a27dc232f9f3996ed8307c27ae87208", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7d8c6b9b8a27dc232f9f3996ed8307c27ae87208", "message": "Fix code formatting suggestions in code review\n\nRemoved recursive finite flattening as bad logic. Refactor variable\nnames for clarity. Revert unwanted code changes.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-03-31T22:32:43Z", "type": "forcePushed"}, {"oid": "3f4b9c7ac9d2d224db4fe2216944593d3cb0d9bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f4b9c7ac9d2d224db4fe2216944593d3cb0d9bf", "message": "Add test cases for union filling\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "e8d4a6c8202c9906d53e53d27d2981e8d77da2bc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8d4a6c8202c9906d53e53d27d2981e8d77da2bc", "message": "Fix list-expr filler value check for Union\n\nConst Types or singleton values were comparison does not check the type\nbut does a `==` check for BFiniteType.\n\nNow filler value check will specially handle Unions with BFiniteType.\nIts Types will be flattened and collected together and check for is same\ntype on the collected list. Default filler value check still process\nBFiniteType without flattening it.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "d8fd0cee4f0f4a2ffa37ea2be14773597c5a7cc2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8fd0cee4f0f4a2ffa37ea2be14773597c5a7cc2", "message": "Fix code formatting suggestions in code review\n\nRemoved recursive finite flattening as bad logic. Refactor variable\nnames for clarity. Revert unwanted code changes.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "93d8caaef728a03fafe25ff808dce87c03ef8116", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93d8caaef728a03fafe25ff808dce87c03ef8116", "message": "Add default filler value check for const unions\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "880e7af4ac473ae93b81aa57dfcc4882476b0142", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/880e7af4ac473ae93b81aa57dfcc4882476b0142", "message": "Fix code style\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "a0928ea34135e755b6a15bfb17ec1911b97e83d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a0928ea34135e755b6a15bfb17ec1911b97e83d3", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-Authored-By: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "60789aac7dbc9847a8c14fc2f082b9a153187c6a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60789aac7dbc9847a8c14fc2f082b9a153187c6a", "message": "Add test int literal int - filler value check\n[no ci]\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "a9002903d01ad1d3c3655a31b9da67d0467190d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a9002903d01ad1d3c3655a31b9da67d0467190d0", "message": "Code refactor hasFillerValue area\n[no ci]\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "3935c00a60cf8d02f2be3328ba188faf57d32fd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3935c00a60cf8d02f2be3328ba188faf57d32fd4", "message": "Add int subtype union\n[ci skip]\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "ed9d97de7b35f83b85b098db7961c55ce8e9421a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ed9d97de7b35f83b85b098db7961c55ce8e9421a", "message": "Fix int subtype union filler value check issue\n[ci skip]\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "54766e1f9a45f17fd32a7be39fede4c6f6e4987f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54766e1f9a45f17fd32a7be39fede4c6f6e4987f", "message": "Add mistakenly removed test cases\n[ci skip]\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "63ca6e27a95701192a37d569969ab15705d7ff4e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63ca6e27a95701192a37d569969ab15705d7ff4e", "message": "Add integer,string,xml subtypes filler value check\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "6717a280495752afa6459e355c717906021923e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6717a280495752afa6459e355c717906021923e2", "message": "Remove xml subtypes and byte string\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "e2737276d251ce378ce2ff09242685b692045ae1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2737276d251ce378ce2ff09242685b692045ae1", "message": "Code style fix\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "commit"}, {"oid": "e2737276d251ce378ce2ff09242685b692045ae1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2737276d251ce378ce2ff09242685b692045ae1", "message": "Code style fix\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T10:30:27Z", "type": "forcePushed"}, {"oid": "bb39e254ae3b399a9536b9f39dfdfb18df240303", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bb39e254ae3b399a9536b9f39dfdfb18df240303", "message": "Enable createSealedArraysOfIntSubtypes test case\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-04-02T11:00:16Z", "type": "commit"}, {"oid": "6190f385252dbc6dcf85c1086975a3d762e2b483", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6190f385252dbc6dcf85c1086975a3d762e2b483", "message": "Remove xml subtype commented filler value code", "committedDate": "2020-04-15T06:31:44Z", "type": "commit"}]}