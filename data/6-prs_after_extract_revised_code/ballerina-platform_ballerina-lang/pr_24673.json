{"pr_number": 24673, "pr_title": "Add query clause for sorting", "pr_createdAt": "2020-07-09T08:18:01Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673", "timeline": [{"oid": "ed9ae3daf617e2f207b4516d12fa9a35a5d81b10", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ed9ae3daf617e2f207b4516d12fa9a35a5d81b10", "message": "Merge pull request #9 from ballerina-platform/master\n\nUpdate master", "committedDate": "2020-06-20T01:46:28Z", "type": "commit"}, {"oid": "f5db9af15c0d8a08e6b1a563d53cafe49217928e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5db9af15c0d8a08e6b1a563d53cafe49217928e", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang", "committedDate": "2020-06-21T06:36:39Z", "type": "commit"}, {"oid": "de9d450841b360886f97a4be97f72287024c2d87", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de9d450841b360886f97a4be97f72287024c2d87", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-07T13:20:57Z", "type": "commit"}, {"oid": "592e87b837b5ed76d3026a4674966c5f6e87c3fe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/592e87b837b5ed76d3026a4674966c5f6e87c3fe", "message": "Add grammar for order by clause", "committedDate": "2020-07-07T14:52:18Z", "type": "commit"}, {"oid": "86dd0252363c9fc3117fb3f2c7472d1982f7bbd5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86dd0252363c9fc3117fb3f2c7472d1982f7bbd5", "message": "Add nodes and visitors for order by clause", "committedDate": "2020-07-07T14:53:38Z", "type": "commit"}, {"oid": "d8b8cb38c7a160e6d137cab0d58cdb90f5bfc1a2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8b8cb38c7a160e6d137cab0d58cdb90f5bfc1a2", "message": "Add visitor for order by clause", "committedDate": "2020-07-07T14:55:00Z", "type": "commit"}, {"oid": "933fcc16e611c7ee30c14a48f16aa82ba0ad4289", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/933fcc16e611c7ee30c14a48f16aa82ba0ad4289", "message": "Add nodes and impl for order by clause", "committedDate": "2020-07-07T14:55:35Z", "type": "commit"}, {"oid": "0a18c440095eaefa82bcbf2520b6853afd67d410", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a18c440095eaefa82bcbf2520b6853afd67d410", "message": "Add desugar for order by clause", "committedDate": "2020-07-07T14:55:57Z", "type": "commit"}, {"oid": "e0adce54d6f7ccd2a2dcf068e4db97c1024a9e2b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e0adce54d6f7ccd2a2dcf068e4db97c1024a9e2b", "message": "Update comment", "committedDate": "2020-07-07T15:01:06Z", "type": "commit"}, {"oid": "1ada6591b3ba786540c118237d87fce5ac951411", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ada6591b3ba786540c118237d87fce5ac951411", "message": "Update sorting function", "committedDate": "2020-07-08T11:07:42Z", "type": "commit"}, {"oid": "41d90d5a75e5cb64feea1d17b9821a0d793880a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41d90d5a75e5cb64feea1d17b9821a0d793880a6", "message": "Add simple test for order by", "committedDate": "2020-07-08T11:08:05Z", "type": "commit"}, {"oid": "3eb20c518fb9727f3330b1003c4f730641e8fa1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3eb20c518fb9727f3330b1003c4f730641e8fa1b", "message": "Update query desugar", "committedDate": "2020-07-08T11:25:58Z", "type": "commit"}, {"oid": "a2642d86e59ce1fa653fcce0ca9dced5ee5c833e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2642d86e59ce1fa653fcce0ca9dced5ee5c833e", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tlanglib/lang.query/src/main/ballerina/src/lang.query/helpers.bal", "committedDate": "2020-07-09T08:10:02Z", "type": "commit"}, {"oid": "d5b6c2427c9dedeebd3804d519e18c9e1412ea77", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d5b6c2427c9dedeebd3804d519e18c9e1412ea77", "message": "Resolve conflict in helpers", "committedDate": "2020-07-09T08:10:43Z", "type": "commit"}, {"oid": "29790e190eb133ed4cd0d31dcc877227ff977909", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/29790e190eb133ed4cd0d31dcc877227ff977909", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-10T03:25:20Z", "type": "commit"}, {"oid": "927a9a13528063e3fa99f052a6f1096270c07805", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/927a9a13528063e3fa99f052a6f1096270c07805", "message": "Add new parser support for order by clause", "committedDate": "2020-07-10T09:29:53Z", "type": "commit"}, {"oid": "073acb1dc07286f3a4c755ba05de3b0d737abf8a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/073acb1dc07286f3a4c755ba05de3b0d737abf8a", "message": "Fix check style issues", "committedDate": "2020-07-10T09:30:43Z", "type": "commit"}, {"oid": "ab307c7282c542e757f6e575a0900cc5f1537d9b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ab307c7282c542e757f6e575a0900cc5f1537d9b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "committedDate": "2020-07-10T09:32:55Z", "type": "commit"}, {"oid": "528efe74f2aee8f3a188ffd80de6db149db5fb1f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/528efe74f2aee8f3a188ffd80de6db149db5fb1f", "message": "Resolve conflict in SyntaxKind", "committedDate": "2020-07-10T09:34:17Z", "type": "commit"}, {"oid": "6b96fd0577f922d53d7578a1b459f68e09088105", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b96fd0577f922d53d7578a1b459f68e09088105", "message": "Resolve conflict in SyntaxKind\nAdd tests for order by clause", "committedDate": "2020-07-10T13:32:32Z", "type": "commit"}, {"oid": "910da4603836b04b2364b6a555ca9d5b57475010", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/910da4603836b04b2364b6a555ca9d5b57475010", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-14T05:07:00Z", "type": "commit"}, {"oid": "bb7eb8beaeed76f3bdee4b650c969c48b1ef443a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bb7eb8beaeed76f3bdee4b650c969c48b1ef443a", "message": "Fix issue in handling result type in order by", "committedDate": "2020-07-14T07:38:15Z", "type": "commit"}, {"oid": "b33d4fa130b33cdab76ee7b590e00e4f17e610f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b33d4fa130b33cdab76ee7b590e00e4f17e610f3", "message": "Add tests for order by clause", "committedDate": "2020-07-14T07:38:42Z", "type": "commit"}, {"oid": "08cac2a6e67748a119d13d19479797079e1c3f7c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08cac2a6e67748a119d13d19479797079e1c3f7c", "message": "Fix lang-server tests", "committedDate": "2020-07-14T07:39:12Z", "type": "commit"}, {"oid": "8c9fff25717b6559afccd361e0b2da7bc529ab1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c9fff25717b6559afccd361e0b2da7bc529ab1b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STTreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-07-14T08:52:05Z", "type": "commit"}, {"oid": "67b76dbfd43f7751b34cd610dc0382d8c1f00222", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67b76dbfd43f7751b34cd610dc0382d8c1f00222", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-16T06:48:10Z", "type": "commit"}, {"oid": "f5d138b601a40c7bf2c13557c352246565d23b26", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5d138b601a40c7bf2c13557c352246565d23b26", "message": "Add suggested changes to order by impl", "committedDate": "2020-07-16T07:01:27Z", "type": "commit"}, {"oid": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51c98ac3dd40db0337e5598d365ee10a4af7215a", "message": "Fix checkstyle", "committedDate": "2020-07-16T07:17:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MDgyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455690820", "bodyText": "remove new line", "author": "pcnfernando", "createdAt": "2020-07-16T10:36:18Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java", "diffHunk": "@@ -772,6 +776,15 @@ public static OnClauseNode createOnClauseNode() {\n         return new BLangOnClause();\n     }\n \n+    public static OrderKeyNode createOrderKeyNode() {\n+        return new BLangOrderKey();\n+    }\n+\n+    public static OrderByClauseNode createOrderByClauseNode() {\n+        return new BLangOrderByClause();\n+    }\n+\n+", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java\nindex b80c3036989..46195322701 100644\n--- a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java\n+++ b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java\n\n@@ -784,7 +790,6 @@ public class TreeBuilder {\n         return new BLangOrderByClause();\n     }\n \n-\n     public static SelectClauseNode createSelectClauseNode() {\n         return new BLangSelectClause();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjA4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692086", "bodyText": "it should be since swan lake. Check other places as well for classes you introduced", "author": "pcnfernando", "createdAt": "2020-07-16T10:38:46Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the \"order by\" clause.\n+ *\n+ * @since 2.0.0", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java\nindex acedb385f27..162df65526b 100644\n--- a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java\n+++ b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderByClauseNode.java\n\n@@ -25,7 +25,7 @@ import java.util.List;\n /**\n  * The interface with the APIs to implement the \"order by\" clause.\n  *\n- * @since 2.0.0\n+ * @since Swan Lake\n  */\n public interface OrderByClauseNode extends Node {\n     void addOrderKey(OrderKeyNode orderKeyNode);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5MjYyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455692622", "bodyText": "Try to group this with query errors", "author": "pcnfernando", "createdAt": "2020-07-16T10:39:45Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "diffHunk": "@@ -431,6 +431,8 @@\n     ERROR_TYPE_EXPECTED(\"error.type.expected\"),\n     MISSING_REQUIRED_METHOD_NEXT(\"missing.required.method.next\"),\n \n+    ORDER_BY_NOT_SUPPORTED(\"order.by.not.supported\"),", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java b/compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java\nindex ef4206ebde1..84a7cae64c9 100644\n--- a/compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java\n+++ b/compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java\n\n@@ -430,7 +432,6 @@ public enum DiagnosticCode {\n     NOT_ALLOWED_STREAM_USAGE_WITH_FROM(\"invalid.stream.usage.with.from\"),\n     ERROR_TYPE_EXPECTED(\"error.type.expected\"),\n     MISSING_REQUIRED_METHOD_NEXT(\"missing.required.method.next\"),\n-\n     ORDER_BY_NOT_SUPPORTED(\"order.by.not.supported\"),\n \n     // Table related codes\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NTc2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455695761", "bodyText": "why are we filtering again? can't we have just the \"t\"? When can orElse be executed?", "author": "pcnfernando", "createdAt": "2020-07-16T10:45:49Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +310,54 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) type).getMemberTypes()\n+                            .stream().filter(m -> m.tag == TypeTags.STREAM)\n+                            .findFirst().orElse(symTable.streamType);\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (t.tag == TypeTags.TABLE) {\n+                    returnType = ((BUnionType) type).getMemberTypes()", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\nindex 983fc68d1f7..a23f0302109 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n\n@@ -325,32 +326,16 @@ public class QueryDesugar extends BLangNodeVisitor {\n             return ((BArrayType) type).eType;\n         } else if (type.tag == TypeTags.UNION) {\n             List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n-            for (BType t : exprTypes) {\n-                BType returnType;\n-                if (t.tag == TypeTags.STREAM) {\n-                    returnType = ((BUnionType) type).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.STREAM)\n-                            .findFirst().orElse(symTable.streamType);\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n                     return ((BStreamType) returnType).constraint;\n-                } else if (t.tag == TypeTags.TABLE) {\n-                    returnType = ((BUnionType) type).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.TABLE)\n-                            .findFirst().orElse(symTable.tableType);\n+                } else if (returnType.tag == TypeTags.TABLE) {\n                     return ((BTableType) returnType).constraint;\n-                }  else if (t.tag == TypeTags.ARRAY) {\n-                    returnType = ((BUnionType) type).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.ARRAY)\n-                            .findFirst().orElse(symTable.arrayType);\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n                     return ((BArrayType) returnType).eType;\n-                } else if (t.tag == TypeTags.STRING) {\n-                    returnType = ((BUnionType) type).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.STRING)\n-                            .findFirst().orElse(symTable.stringType);\n+                } else if (returnType.tag == TypeTags.STRING) {\n                     return returnType;\n-                } else if (t.tag == TypeTags.XML) {\n-                    returnType = ((BUnionType) type).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.XML)\n-                            .findFirst().orElse(symTable.xmlType);\n+                } else if (returnType.tag == TypeTags.XML) {\n                     return returnType;\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NjIwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455696203", "bodyText": "Add class comment", "author": "pcnfernando", "createdAt": "2020-07-16T10:46:43Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.model.clauses;\n+\n+import org.ballerinalang.model.tree.Node;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+\n+/**", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java\nindex 4cdad439884..8cfbcbe5f11 100644\n--- a/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java\n+++ b/compiler/ballerina-lang/src/main/java/org/ballerinalang/model/clauses/OrderKeyNode.java\n\n@@ -22,7 +22,9 @@ import org.ballerinalang.model.tree.Node;\n import org.ballerinalang.model.tree.expressions.ExpressionNode;\n \n /**\n- * @since 2.0.0\n+ * The interface with the APIs to implement the order key in \"order by\" clause.\n+ *\n+ * @since Swan Lake\n  */\n public interface OrderKeyNode extends Node {\n     void setOrderKey(ExpressionNode orderVar);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5ODA3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455698075", "bodyText": "Try to add the ballerina statements you are introducing as comments during desugaring", "author": "pcnfernando", "createdAt": "2020-07-16T10:50:24Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -241,6 +247,12 @@ BLangStatementExpression desugar(BLangQueryExpr queryExpr, SymbolEnv env) {\n         BLangBlockStmt queryBlock = ASTBuilderUtil.createBlockStmt(pos);\n         BLangVariableReference streamRef = buildStream(clauses, queryExpr.type, env, queryBlock);\n         BLangStatementExpression streamStmtExpr;\n+        if (orderByClause != null) {", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\nindex 983fc68d1f7..a23f0302109 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n\n@@ -248,6 +248,7 @@ public class QueryDesugar extends BLangNodeVisitor {\n         BLangVariableReference streamRef = buildStream(clauses, queryExpr.type, env, queryBlock);\n         BLangStatementExpression streamStmtExpr;\n         if (orderByClause != null) {\n+            // Type[] arr passed to order by helper\n             BLangArrayLiteral orderArr = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n             orderArr.exprs = new ArrayList<>();\n             orderArr.type = new BArrayType(resolveExprType(queryExpr.type));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTMzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r455699333", "bodyText": "you can simplify this if", "author": "pcnfernando", "createdAt": "2020-07-16T10:52:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3274,6 +3278,30 @@ public BLangNode transform(JoinClauseNode joinClauseNode) {\n         return joinClause;\n     }\n \n+    @Override\n+    public BLangNode transform(OrderByClauseNode orderByClauseNode) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.pos = getPosition(orderByClauseNode);\n+        for (OrderKeyNode orderKeyNode : orderByClauseNode.orderKey()) {\n+            orderByClause.addOrderKey(createOrderKey(orderKeyNode));\n+        }\n+        return orderByClause;\n+    }\n+\n+    public BLangOrderKey createOrderKey(OrderKeyNode orderKeyNode) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = getPosition(orderKeyNode);\n+        orderKey.expression = createExpression(orderKeyNode.expression());\n+        if (orderKeyNode.ascendingKeyword().isPresent()) {\n+            orderKey.isAscending = true;", "originalCommit": "51c98ac3dd40db0337e5598d365ee10a4af7215a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\nindex 439bc9da4d7..8af71982927 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\n\n@@ -3292,9 +3302,7 @@ public class BLangNodeTransformer extends NodeTransformer<BLangNode> {\n         BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n         orderKey.pos = getPosition(orderKeyNode);\n         orderKey.expression = createExpression(orderKeyNode.expression());\n-        if (orderKeyNode.ascendingKeyword().isPresent()) {\n-            orderKey.isAscending = true;\n-        } else if (orderKeyNode.descendingKeyword().isPresent()) {\n+        if (orderKeyNode.descendingKeyword().isPresent()) {\n             orderKey.isAscending = false;\n         } else {\n             orderKey.isAscending = true;\n"}}, {"oid": "9ea4f5674df6ebfa2d19e6c864c4ff0771a5ed34", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ea4f5674df6ebfa2d19e6c864c4ff0771a5ed34", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaLexer.java\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaLexer.tokens\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.java\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.tokens\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java", "committedDate": "2020-07-16T11:47:49Z", "type": "commit"}, {"oid": "b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b116dd3f3e2be4acb36edb8ca19da102d5507ba5", "message": "Add suggested changes", "committedDate": "2020-07-16T12:31:25Z", "type": "commit"}, {"oid": "577fc0045e224a0d25c53aeccbed4149ee017bf7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/577fc0045e224a0d25c53aeccbed4149ee017bf7", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/iterableOperation1.json\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/iterableOperation2.json\n\u0001\tlanguage-server/modules/langserver-core/src/test/resources/completion/function/variableBoundItemSuggestions2.json", "committedDate": "2020-07-17T02:50:19Z", "type": "commit"}, {"oid": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57bf9f2e7d952ed4dd19cd54153df9ffb585a629", "message": "Resolve conflicts in LS tests", "committedDate": "2020-07-17T03:17:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzNDIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456234223", "bodyText": "Same as before, check whether OrElse() will be executed?", "author": "pcnfernando", "createdAt": "2020-07-17T05:57:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,84 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) resultType).getMemberTypes());\n+            for (BType t : exprTypes) {\n+                BType returnType;\n+                if (t.tag == TypeTags.STREAM) {\n+                    returnType = ((BUnionType) resultType).getMemberTypes()", "originalCommit": "57bf9f2e7d952ed4dd19cd54153df9ffb585a629", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "182ed4f795674a1e6c2c49f463d7ed020b5165cf", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\nindex 69c562e5751..87c4eca7454 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n\n@@ -2731,22 +2731,12 @@ public class CodeAnalyzer extends BLangNodeVisitor {\n         } else if (resultType.tag == TypeTags.UNION) {\n             List<BType> exprTypes = new ArrayList<>(((BUnionType) resultType).getMemberTypes());\n             for (BType t : exprTypes) {\n-                BType returnType;\n                 if (t.tag == TypeTags.STREAM) {\n-                    returnType = ((BUnionType) resultType).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.STREAM)\n-                            .findFirst().orElse(symTable.streamType);\n-                    resultType = ((BStreamType) returnType).constraint;\n+                    resultType = ((BStreamType) t).constraint;\n                 } else if (t.tag == TypeTags.TABLE) {\n-                    returnType = ((BUnionType) resultType).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.TABLE)\n-                            .findFirst().orElse(symTable.tableType);\n-                    resultType = ((BTableType) returnType).constraint;\n+                    resultType = ((BTableType) t).constraint;\n                 } else if (t.tag == TypeTags.ARRAY) {\n-                    returnType = ((BUnionType) resultType).getMemberTypes()\n-                            .stream().filter(m -> m.tag == TypeTags.ARRAY)\n-                            .findFirst().orElse(symTable.arrayType);\n-                    resultType = ((BArrayType) returnType).eType;\n+                    resultType = ((BArrayType) t).eType;\n                 }\n             }\n         }\n"}}, {"oid": "182ed4f795674a1e6c2c49f463d7ed020b5165cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/182ed4f795674a1e6c2c49f463d7ed020b5165cf", "message": "Add review changes", "committedDate": "2020-07-17T06:08:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzM3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983375", "bodyText": "Why don't we have to check string, xml cases here?", "author": "grainier", "createdAt": "2020-07-20T01:22:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2711,11 +2714,74 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        if (resultType.tag == TypeTags.ARRAY) {\n+            resultType = ((BArrayType) resultType).eType;\n+        } else if (resultType.tag == TypeTags.TABLE) {\n+            resultType = ((BTableType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.STREAM) {\n+            resultType = ((BStreamType) resultType).constraint;\n+        } else if (resultType.tag == TypeTags.UNION) {", "originalCommit": "182ed4f795674a1e6c2c49f463d7ed020b5165cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\nindex 87c4eca7454..b0077cde01c 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n\n@@ -2722,24 +2722,7 @@ public class CodeAnalyzer extends BLangNodeVisitor {\n     }\n \n     private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n-        if (resultType.tag == TypeTags.ARRAY) {\n-            resultType = ((BArrayType) resultType).eType;\n-        } else if (resultType.tag == TypeTags.TABLE) {\n-            resultType = ((BTableType) resultType).constraint;\n-        } else if (resultType.tag == TypeTags.STREAM) {\n-            resultType = ((BStreamType) resultType).constraint;\n-        } else if (resultType.tag == TypeTags.UNION) {\n-            List<BType> exprTypes = new ArrayList<>(((BUnionType) resultType).getMemberTypes());\n-            for (BType t : exprTypes) {\n-                if (t.tag == TypeTags.STREAM) {\n-                    resultType = ((BStreamType) t).constraint;\n-                } else if (t.tag == TypeTags.TABLE) {\n-                    resultType = ((BTableType) t).constraint;\n-                } else if (t.tag == TypeTags.ARRAY) {\n-                    resultType = ((BArrayType) t).eType;\n-                }\n-            }\n-        }\n+        resultType = types.resolveExprType(resultType);\n         if (resultType.tag == TypeTags.RECORD) {\n             BRecordType recordType = (BRecordType) resultType;\n             Map<String, BField> recordFields = recordType.fields;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4Mzc1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r456983754", "bodyText": "You've written a similar function in CodeAnalyzer as well (but without string, XML checks). Is there a way to refactor both into one. Maybe we can but in Types?", "author": "grainier", "createdAt": "2020-07-20T01:24:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java", "diffHunk": "@@ -298,6 +311,38 @@ BLangStatementExpression desugar(BLangQueryAction queryAction, SymbolEnv env) {\n         return stmtExpr;\n     }\n \n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    private BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }", "originalCommit": "182ed4f795674a1e6c2c49f463d7ed020b5165cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\nindex a23f0302109..3cbe2fd5976 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/QueryDesugar.java\n\n@@ -311,38 +310,6 @@ public class QueryDesugar extends BLangNodeVisitor {\n         return stmtExpr;\n     }\n \n-    /**\n-     * Get result type of the query output.\n-     *\n-     * @param type type of query expression.\n-     * @return result type.\n-     */\n-    private BType resolveExprType(BType type) {\n-        if (type.tag == TypeTags.STREAM) {\n-            return ((BStreamType) type).constraint;\n-        } else if (type.tag == TypeTags.TABLE) {\n-            return ((BTableType) type).constraint;\n-        } else if (type.tag == TypeTags.ARRAY) {\n-            return ((BArrayType) type).eType;\n-        } else if (type.tag == TypeTags.UNION) {\n-            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n-            for (BType returnType : exprTypes) {\n-                if (returnType.tag == TypeTags.STREAM) {\n-                    return ((BStreamType) returnType).constraint;\n-                } else if (returnType.tag == TypeTags.TABLE) {\n-                    return ((BTableType) returnType).constraint;\n-                }  else if (returnType.tag == TypeTags.ARRAY) {\n-                    return ((BArrayType) returnType).eType;\n-                } else if (returnType.tag == TypeTags.STRING) {\n-                    return returnType;\n-                } else if (returnType.tag == TypeTags.XML) {\n-                    return returnType;\n-                }\n-            }\n-        }\n-        return type;\n-    }\n-\n     /**\n      * Write the pipeline to the given `block` and return the reference to the resulting stream.\n      *\n"}}, {"oid": "7b6186f15b73503ca8317f5255e2ff7c1e5f6fde", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b6186f15b73503ca8317f5255e2ff7c1e5f6fde", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-20T02:52:36Z", "type": "commit"}, {"oid": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "message": "Fix review suggestions", "committedDate": "2020-07-20T03:35:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NDM4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457194380", "bodyText": "Do we need to pass the context as a param?", "author": "SupunS", "createdAt": "2020-07-20T08:56:59Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMDU3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457200578", "bodyText": "Need to update resumeParsing method with each of these newly added methods (if they are calling the recover method)", "author": "SupunS", "createdAt": "2020-07-20T09:05:06Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10179,6 +10188,66 @@ private STNode parseOuterKeyword() {\n         }\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..52eb83e9747 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10188,66 +10289,6 @@ public class BallerinaParser extends AbstractParser {\n         }\n     }\n \n-    /**\n-     * Parse order-keyword.\n-     *\n-     * @return Order-keyword node\n-     */\n-    private STNode parseOrderKeyword() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n-            return consume();\n-        } else {\n-            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n-            return sol.recoveredNode;\n-        }\n-    }\n-\n-    /**\n-     * Parse by-keyword.\n-     *\n-     * @return By-keyword node\n-     */\n-    private STNode parseByKeyword() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.BY_KEYWORD) {\n-            return consume();\n-        } else {\n-            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n-            return sol.recoveredNode;\n-        }\n-    }\n-\n-    /**\n-     * Parse ascending-keyword.\n-     *\n-     * @return Ascending-keyword node\n-     */\n-    private STNode parseAscendingKeyword() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n-            return consume();\n-        } else {\n-            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n-            return sol.recoveredNode;\n-        }\n-    }\n-\n-    /**\n-     * Parse descending-keyword.\n-     *\n-     * @return Descending-keyword node\n-     */\n-    private STNode parseDescendingKeyword() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n-            return consume();\n-        } else {\n-            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n-            return sol.recoveredNode;\n-        }\n-    }\n-\n     private boolean isEndOfIntermediateClause(SyntaxKind tokenKind, SyntaxKind precedingNodeKind) {\n         switch (tokenKind) {\n             case CLOSE_BRACE_TOKEN:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMjM0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457202340", "bodyText": "When a comma separated list is parsed, theres a possibility of having some extraneous token after a member, that is not captured by isEndOfOrderKeys.\nTherefore we check the token before parsing the separator - because after recovering, we could even reach the end of the list. So we have to do something similar to parseListConstructorMemberEnd()/parseArgEnd() methods.", "author": "SupunS", "createdAt": "2020-07-20T09:07:20Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwMzA0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457203049", "bodyText": "Can you explain the reason for checking !isTypeStartingToken()?", "author": "SupunS", "createdAt": "2020-07-20T09:08:23Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNDI0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457204240", "bodyText": "Add case EOF", "author": "SupunS", "createdAt": "2020-07-20T09:10:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwNjQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457206495", "bodyText": "A switch-case would better suite for this.\nWe may have to go for error-recovery if the next token is neither ascending,descending nor a valid-token that is possible to come after the  order-key", "author": "SupunS", "createdAt": "2020-07-20T09:13:16Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIwODU5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457208599", "bodyText": "theres an overlap in the numbers (another set of keywords starts with 250) - shall we update the \"Type keywords\" (the ones that are below) to start with 300?", "author": "SupunS", "createdAt": "2020-07-20T09:16:02Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -98,6 +98,10 @@\n     JOIN_KEYWORD(244, \"join\"),\n     OUTER_KEYWORD(245, \"outer\"),\n     EQUALS_KEYWORD(246, \"equals\"),\n+    ORDER_KEYWORD(247, \"order\"),\n+    BY_KEYWORD(248, \"by\"),\n+    ASCENDING_KEYWORD(249, \"ascending\"),\n+    DESCENDING_KEYWORD(250, \"descending\"),", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\nindex fdc965bb9c2..efbfad0c8bf 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\n@@ -104,27 +104,27 @@ public enum SyntaxKind {\n     DESCENDING_KEYWORD(250, \"descending\"),\n \n     // Type keywords\n-    INT_KEYWORD(250, \"int\"),\n-    BYTE_KEYWORD(251, \"byte\"),\n-    FLOAT_KEYWORD(252, \"float\"),\n-    DECIMAL_KEYWORD(253, \"decimal\"),\n-    STRING_KEYWORD(254, \"string\"),\n-    BOOLEAN_KEYWORD(255, \"boolean\"),\n-    XML_KEYWORD(256, \"xml\"),\n-    JSON_KEYWORD(257, \"json\"),\n-    HANDLE_KEYWORD(258, \"handle\"),\n-    ANY_KEYWORD(259, \"any\"),\n-    ANYDATA_KEYWORD(260, \"anydata\"),\n-    NEVER_KEYWORD(261, \"never\"),\n-    VAR_KEYWORD(262, \"var\"),\n-    MAP_KEYWORD(263, \"map\"),\n-    FUTURE_KEYWORD(264, \"future\"),\n-    TYPEDESC_KEYWORD(265, \"typedesc\"),\n-    ERROR_KEYWORD(266, \"error\"),\n-    STREAM_KEYWORD(267, \"stream\"),\n-    READONLY_KEYWORD(268, \"readonly\"),\n-    DISTINCT_KEYWORD(269, \"distinct\"),\n-    FAIL_KEYWORD(270, \"fail\"),\n+    INT_KEYWORD(300, \"int\"),\n+    BYTE_KEYWORD(301, \"byte\"),\n+    FLOAT_KEYWORD(302, \"float\"),\n+    DECIMAL_KEYWORD(303, \"decimal\"),\n+    STRING_KEYWORD(304, \"string\"),\n+    BOOLEAN_KEYWORD(305, \"boolean\"),\n+    XML_KEYWORD(306, \"xml\"),\n+    JSON_KEYWORD(307, \"json\"),\n+    HANDLE_KEYWORD(308, \"handle\"),\n+    ANY_KEYWORD(309, \"any\"),\n+    ANYDATA_KEYWORD(310, \"anydata\"),\n+    NEVER_KEYWORD(311, \"never\"),\n+    VAR_KEYWORD(312, \"var\"),\n+    MAP_KEYWORD(313, \"map\"),\n+    FUTURE_KEYWORD(314, \"future\"),\n+    TYPEDESC_KEYWORD(315, \"typedesc\"),\n+    ERROR_KEYWORD(316, \"error\"),\n+    STREAM_KEYWORD(317, \"stream\"),\n+    READONLY_KEYWORD(318, \"readonly\"),\n+    DISTINCT_KEYWORD(319, \"distinct\"),\n+    FAIL_KEYWORD(320, \"fail\"),\n \n     // Separators\n     OPEN_BRACE_TOKEN(500, \"{\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyMzU4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457223580", "bodyText": "I think we can avoid this check. If first token is not ORDER_KEYWORD it will be handled inside parseOrderKeyword()", "author": "lochana-chathura", "createdAt": "2020-07-20T09:35:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNDkwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457224907", "bodyText": "this looks more cleaner to me. order-by-clause := order by (expression (ascending | descending)?)+\nWDYT?", "author": "lochana-chathura", "createdAt": "2020-07-20T09:37:19Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyNzEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457227124", "bodyText": "Shall we add order-clause to documentation above; intermediate-clause := from-clause | where-clause | let-clause", "author": "lochana-chathura", "createdAt": "2020-07-20T09:40:27Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10129,6 +10133,11 @@ private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsEx\n             case JOIN_KEYWORD:\n             case OUTER_KEYWORD:\n                 return parseJoinClause(isRhsExpr);\n+            case ORDER_KEYWORD:\n+            case BY_KEYWORD:\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                return parseOrderByClause(isRhsExpr);", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..52eb83e9747 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10133,11 +10239,6 @@ public class BallerinaParser extends AbstractParser {\n             case JOIN_KEYWORD:\n             case OUTER_KEYWORD:\n                 return parseJoinClause(isRhsExpr);\n-            case ORDER_KEYWORD:\n-            case BY_KEYWORD:\n-            case ASCENDING_KEYWORD:\n-            case DESCENDING_KEYWORD:\n-                return parseOrderByClause(isRhsExpr);\n             case DO_KEYWORD:\n             case SEMICOLON_TOKEN:\n             case ON_KEYWORD:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIyODIxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r457228219", "bodyText": "Let's use STNodeFactory.createEmptyNode(); instead of passing null, in all places", "author": "SupunS", "createdAt": "2020-07-20T09:41:55Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10287,6 +10356,98 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STToken nextToken = peek();\n+        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n+            return STNodeFactory.createEmptyNode();\n+        }\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(ParserRuleContext context, boolean isRhsExpr) {\n+        startContext(context);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present\n+        if (isEndOfOrderKeys(nextToken.kind)) {\n+            endContext();\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        // Parse first order key, that has no leading comma\n+        STNode orderKey = parseOrderKey(isRhsExpr);\n+        orderKeys.add(orderKey);\n+\n+        // Parse the remaining order keys\n+        nextToken = peek();\n+        STNode leadingComma;\n+        while (!isEndOfOrderKeys(nextToken.kind)) {\n+            leadingComma = parseComma();\n+            orderKeys.add(leadingComma);\n+            orderKey = parseOrderKey(isRhsExpr);\n+            orderKeys.add(orderKey);\n+            nextToken = peek();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(orderKeys);\n+    }\n+\n+    private boolean isEndOfOrderKeys(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case COMMA_TOKEN:\n+                return false;\n+            case IN_KEYWORD:\n+                return true;\n+            default:\n+                return !isTypeStartingToken(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key := expression (ascending | descending)?</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKey(boolean isRhsExpr) {\n+        STNode expression = parseExpression(OperatorPrecedence.QUERY, isRhsExpr, false);\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            STNode ascendingKeyword = parseAscendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, ascendingKeyword, null);\n+        } else if (nextToken.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            STNode descendingKeyword = parseDescendingKeyword();\n+            return STNodeFactory.createOrderKeyNode(expression, null, descendingKeyword);\n+        } else {\n+            return STNodeFactory.createOrderKeyNode(expression, null, null);", "originalCommit": "bc635f60e0d9f24bcd4d97af86cf6cf074e482fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex be6a4acdc8e..69b74851e41 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10359,22 +10372,18 @@ public class BallerinaParser extends AbstractParser {\n     /**\n      * Parse order by clause.\n      * <p>\n-     * <code>order-by-clause := order by expression (ascending | descending)? (expression (ascending | descending)?)*\n+     * <code>order-by-clause := order by order-key-list\n      * </code>\n      *\n      * @return Parsed node\n      */\n     private STNode parseOrderByClause(boolean isRhsExpr) {\n-        STToken nextToken = peek();\n-        if (nextToken.kind != SyntaxKind.ORDER_KEYWORD) {\n-            return STNodeFactory.createEmptyNode();\n-        }\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n-        STNode orderKeys = parseOrderKeyList(ParserRuleContext.ORDER_KEY, isRhsExpr);\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n \n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n-                DiagnosticErrorCode.ERROR_MISSING_EXPRESSION);\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n         return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n     }\n"}}, {"oid": "985bbb2e864a57c5d1c528102ebcabf40195147b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/985bbb2e864a57c5d1c528102ebcabf40195147b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-21T03:09:38Z", "type": "commit"}, {"oid": "af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af9a3880cc3b95ce4f8bd395144ea33c04801ab3", "message": "Add parser tests for order by", "committedDate": "2020-07-22T08:46:35Z", "type": "forcePushed"}, {"oid": "b12529edb2207e5d8bacd22fa9cc19336923edf7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b12529edb2207e5d8bacd22fa9cc19336923edf7", "message": "Add suggested parser changes", "committedDate": "2020-07-22T08:51:11Z", "type": "commit"}, {"oid": "bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "message": "Add parser tests for order by", "committedDate": "2020-07-22T08:51:55Z", "type": "commit"}, {"oid": "bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf463ccbaf59499c3ed92a45f23fd8e28335b7de", "message": "Add parser tests for order by", "committedDate": "2020-07-22T08:51:55Z", "type": "forcePushed"}, {"oid": "7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fe11d09825d1d23906b5bd48ef85e95cb58e4a1", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/antlr4/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/diagnostics/DiagnosticErrorCode.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java", "committedDate": "2020-07-22T09:03:06Z", "type": "commit"}, {"oid": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "message": "Resolve conflicts", "committedDate": "2020-07-22T09:16:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDQ1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740454", "bodyText": "Would be better to replace this with a switch-case. It'l be faster and neat than the if-else, since there many conditions.\nCan do the same for the above method as well.", "author": "SupunS", "createdAt": "2020-07-22T12:02:13Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 72f16f62f6a..f6b8bb745c9 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -3440,29 +3440,31 @@ public class Types {\n      * @return result type.\n      */\n     public BType resolveExprType(BType type) {\n-        if (type.tag == TypeTags.STREAM) {\n-            return ((BStreamType) type).constraint;\n-        } else if (type.tag == TypeTags.TABLE) {\n-            return ((BTableType) type).constraint;\n-        } else if (type.tag == TypeTags.ARRAY) {\n-            return ((BArrayType) type).eType;\n-        } else if (type.tag == TypeTags.UNION) {\n-            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n-            for (BType returnType : exprTypes) {\n-                if (returnType.tag == TypeTags.STREAM) {\n-                    return ((BStreamType) returnType).constraint;\n-                } else if (returnType.tag == TypeTags.TABLE) {\n-                    return ((BTableType) returnType).constraint;\n-                }  else if (returnType.tag == TypeTags.ARRAY) {\n-                    return ((BArrayType) returnType).eType;\n-                } else if (returnType.tag == TypeTags.STRING) {\n-                    return returnType;\n-                } else if (returnType.tag == TypeTags.XML) {\n-                    return returnType;\n-                }\n-            }\n-        }\n-        return type;\n+        switch (type.tag) {\n+            case TypeTags.STREAM:\n+                return ((BStreamType) type).constraint;\n+            case TypeTags.TABLE:\n+                return ((BTableType) type).constraint;\n+            case TypeTags.ARRAY:\n+                return ((BArrayType) type).eType;\n+            case TypeTags.UNION:\n+                List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+                for (BType returnType : exprTypes) {\n+                    switch (returnType.tag) {\n+                        case TypeTags.STREAM:\n+                            return ((BStreamType) returnType).constraint;\n+                        case TypeTags.TABLE:\n+                            return ((BTableType) returnType).constraint;\n+                        case TypeTags.ARRAY:\n+                            return ((BArrayType) returnType).eType;\n+                        case TypeTags.STRING:\n+                        case TypeTags.XML:\n+                            return returnType;\n+                    }\n+                }\n+            default:\n+                return type;\n+        }\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MDY5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458740692", "bodyText": "Should BYTE type also go here?", "author": "SupunS", "createdAt": "2020-07-22T12:02:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3432,4 +3432,65 @@ private boolean checkFillerValue(BArrayType type) {\n         }\n         return hasFillerValue(type.eType);\n     }\n+\n+    /**\n+     * Get result type of the query output.\n+     *\n+     * @param type type of query expression.\n+     * @return result type.\n+     */\n+    public BType resolveExprType(BType type) {\n+        if (type.tag == TypeTags.STREAM) {\n+            return ((BStreamType) type).constraint;\n+        } else if (type.tag == TypeTags.TABLE) {\n+            return ((BTableType) type).constraint;\n+        } else if (type.tag == TypeTags.ARRAY) {\n+            return ((BArrayType) type).eType;\n+        } else if (type.tag == TypeTags.UNION) {\n+            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+            for (BType returnType : exprTypes) {\n+                if (returnType.tag == TypeTags.STREAM) {\n+                    return ((BStreamType) returnType).constraint;\n+                } else if (returnType.tag == TypeTags.TABLE) {\n+                    return ((BTableType) returnType).constraint;\n+                }  else if (returnType.tag == TypeTags.ARRAY) {\n+                    return ((BArrayType) returnType).eType;\n+                } else if (returnType.tag == TypeTags.STRING) {\n+                    return returnType;\n+                } else if (returnType.tag == TypeTags.XML) {\n+                    return returnType;\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Check whether a type is a basic type.\n+     *\n+     * @param type type of the field.\n+     * @return boolean whether the type is basic type or not.\n+     */\n+    public boolean checkBasicType(BType type) {\n+        if (type.tag == TypeTags.INT) {\n+            return true;\n+        } else if (type.tag == TypeTags.FLOAT) {\n+            return true;\n+        } else if (type.tag == TypeTags.DECIMAL) {\n+            return true;\n+        } else if (type.tag == TypeTags.STRING) {\n+            return true;\n+        } else if (type.tag == TypeTags.BOOLEAN) {\n+            return true;\n+        } else if (type.tag == TypeTags.NIL) {\n+            return true;\n+        } else if (type.tag == TypeTags.UNION) {", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\nindex 72f16f62f6a..f6b8bb745c9 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\n@@ -3440,29 +3440,31 @@ public class Types {\n      * @return result type.\n      */\n     public BType resolveExprType(BType type) {\n-        if (type.tag == TypeTags.STREAM) {\n-            return ((BStreamType) type).constraint;\n-        } else if (type.tag == TypeTags.TABLE) {\n-            return ((BTableType) type).constraint;\n-        } else if (type.tag == TypeTags.ARRAY) {\n-            return ((BArrayType) type).eType;\n-        } else if (type.tag == TypeTags.UNION) {\n-            List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n-            for (BType returnType : exprTypes) {\n-                if (returnType.tag == TypeTags.STREAM) {\n-                    return ((BStreamType) returnType).constraint;\n-                } else if (returnType.tag == TypeTags.TABLE) {\n-                    return ((BTableType) returnType).constraint;\n-                }  else if (returnType.tag == TypeTags.ARRAY) {\n-                    return ((BArrayType) returnType).eType;\n-                } else if (returnType.tag == TypeTags.STRING) {\n-                    return returnType;\n-                } else if (returnType.tag == TypeTags.XML) {\n-                    return returnType;\n-                }\n-            }\n-        }\n-        return type;\n+        switch (type.tag) {\n+            case TypeTags.STREAM:\n+                return ((BStreamType) type).constraint;\n+            case TypeTags.TABLE:\n+                return ((BTableType) type).constraint;\n+            case TypeTags.ARRAY:\n+                return ((BArrayType) type).eType;\n+            case TypeTags.UNION:\n+                List<BType> exprTypes = new ArrayList<>(((BUnionType) type).getMemberTypes());\n+                for (BType returnType : exprTypes) {\n+                    switch (returnType.tag) {\n+                        case TypeTags.STREAM:\n+                            return ((BStreamType) returnType).constraint;\n+                        case TypeTags.TABLE:\n+                            return ((BTableType) returnType).constraint;\n+                        case TypeTags.ARRAY:\n+                            return ((BArrayType) returnType).eType;\n+                        case TypeTags.STRING:\n+                        case TypeTags.XML:\n+                            return returnType;\n+                    }\n+                }\n+            default:\n+                return type;\n+        }\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTE5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741198", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-07-22T12:03:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTIyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458741229", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-07-22T12:03:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -1395,6 +1397,23 @@ public void visit(BLangOnClause source) {\n         clone.expression = clone(source.expression);\n     }\n \n+    @Override\n+    public void visit(BLangOrderKey source) {\n+\n+        BLangOrderKey clone = new BLangOrderKey();\n+        source.cloneRef = clone;\n+        clone.expression = clone(source.expression);\n+        clone.isAscending = source.isAscending;\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause source) {\n+", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MjQyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458742426", "bodyText": "shall we invert the condition and do an early-exit? That way we can avoid one level of right-indentations.\neg:\nif (resultType.tag != TypeTags.RECORD) {\n    return;\n}", "author": "SupunS", "createdAt": "2020-07-22T12:06:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,34 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag == TypeTags.RECORD) {", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\nindex 841e1a9d533..9076d214041 100644\n--- a/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n+++ b/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java\n\n@@ -2724,20 +2724,21 @@ public class CodeAnalyzer extends BLangNodeVisitor {\n \n     private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n         resultType = types.resolveExprType(resultType);\n-        if (resultType.tag == TypeTags.RECORD) {\n-            BRecordType recordType = (BRecordType) resultType;\n-            Map<String, BField> recordFields = recordType.fields;\n-            for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n-                if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+                dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n+                        DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n+                        ((BLangOrderKey) orderKeyNode).expression, resultType);\n+            } else if (orderKeyNode.getOrderKey().toString() != null) {\n+                BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;\n+                if (!types.checkBasicType(exprType)) {\n                     dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n-                            DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n-                            ((BLangOrderKey) orderKeyNode).expression, resultType);\n-                } else if (orderKeyNode.getOrderKey().toString() != null) {\n-                    BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;\n-                    if (!types.checkBasicType(exprType)) {\n-                        dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n-                                DiagnosticCode.ORDER_BY_NOT_SUPPORTED);\n-                    }\n+                            DiagnosticCode.ORDER_BY_NOT_SUPPORTED);\n                 }\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzIyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743228", "bodyText": "can remove these extra newlines", "author": "SupunS", "createdAt": "2020-07-22T12:07:57Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 46d1838c014..295709e0f79 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10489,7 +10489,6 @@ public class BallerinaParser extends AbstractParser {\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n         STNode orderKeys = parseOrderKeyList(isRhsExpr);\n-\n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n                 DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MzgwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458743800", "bodyText": "comment is sort of not correct, since we don't do any validation here..", "author": "SupunS", "createdAt": "2020-07-22T12:09:03Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10397,6 +10417,201 @@ private STNode parseLetClause(boolean isRhsExpr) {\n         return STNodeFactory.createLetClauseNode(letKeyword, letVarDeclarations);\n     }\n \n+    /**\n+     * Parse order-keyword.\n+     *\n+     * @return Order-keyword node\n+     */\n+    private STNode parseOrderKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ORDER_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ORDER_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse by-keyword.\n+     *\n+     * @return By-keyword node\n+     */\n+    private STNode parseByKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BY_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BY_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse ascending-keyword.\n+     *\n+     * @return Ascending-keyword node\n+     */\n+    private STNode parseAscendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.ASCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse descending-keyword.\n+     *\n+     * @return Descending-keyword node\n+     */\n+    private STNode parseDescendingKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DESCENDING_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.DESCENDING_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse order by clause.\n+     * <p>\n+     * <code>order-by-clause := order by order-key-list\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderByClause(boolean isRhsExpr) {\n+        STNode orderKeyword = parseOrderKeyword();\n+        STNode byKeyword = parseByKeyword();\n+        STNode orderKeys = parseOrderKeyList(isRhsExpr);\n+\n+        byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n+                DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n+\n+        return STNodeFactory.createOrderByClauseNode(orderKeyword, byKeyword, orderKeys);\n+    }\n+\n+    /**\n+     * Parse order key.\n+     * <p>\n+     * <code>order-key-list := order-key [, order-key]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOrderKeyList(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.ORDER_KEY);\n+        List<STNode> orderKeys = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Make sure at least one order key is present", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\nindex 46d1838c014..295709e0f79 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\n@@ -10489,7 +10489,6 @@ public class BallerinaParser extends AbstractParser {\n         STNode orderKeyword = parseOrderKeyword();\n         STNode byKeyword = parseByKeyword();\n         STNode orderKeys = parseOrderKeyList(isRhsExpr);\n-\n         byKeyword = cloneWithDiagnosticIfListEmpty(orderKeys, byKeyword,\n                 DiagnosticErrorCode.ERROR_MISSING_ORDER_KEY);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTYyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458745620", "bodyText": "since this list has only one member, we can remove the list and directly use EXPRESSION as the next rule, where ORDER_KEY_LIST_START is used. Can remove it from hasAlternativePaths() methods also, since it has only one path", "author": "SupunS", "createdAt": "2020-07-22T12:12:34Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -558,6 +559,12 @@\n     private static final ParserRuleContext[] NAMED_ARG_MATCH_PATTERN_RHS =\n             { ParserRuleContext.NAMED_ARG_MATCH_PATTERN, ParserRuleContext.REST_MATCH_PATTERN };\n \n+    private static final ParserRuleContext[] ORDER_KEY_LIST_START =", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -559,9 +559,6 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n     private static final ParserRuleContext[] NAMED_ARG_MATCH_PATTERN_RHS =\n             { ParserRuleContext.NAMED_ARG_MATCH_PATTERN, ParserRuleContext.REST_MATCH_PATTERN };\n \n-    private static final ParserRuleContext[] ORDER_KEY_LIST_START =\n-            { ParserRuleContext.EXPRESSION };\n-\n     private static final ParserRuleContext[] ORDER_KEY_LIST_END =\n             { ParserRuleContext.COMMA, ParserRuleContext.ORDER_CLAUSE_END };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NjM0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458746346", "bodyText": "Need to update the isProductionWithAlternatives with the same.", "author": "SupunS", "createdAt": "2020-07-22T12:13:55Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1174,6 +1185,8 @@ private boolean hasAlternativePaths(ParserRuleContext currentCtx) {\n             case TABLE_KEY_RHS:\n             case ERROR_TYPE_PARAMS:\n             case LET_VAR_DECL_START:\n+            case ORDER_KEY_LIST_START:\n+            case ORDER_KEY_LIST_END:", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -1185,7 +1183,6 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n             case TABLE_KEY_RHS:\n             case ERROR_TYPE_PARAMS:\n             case LET_VAR_DECL_START:\n-            case ORDER_KEY_LIST_START:\n             case ORDER_KEY_LIST_END:\n             case STREAM_TYPE_FIRST_PARAM_RHS:\n             case TEMPLATE_MEMBER:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MTUyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458751520", "bodyText": "Here we states which tokens can occur after some expression.\neg: ... order by foo <cursor>\nsince what follows after by keyword is an expression, we can put many tokens inplace of <cursor>, such as a binary operator (foo + bar), a dot (foo.bar), etc. So we need to add all those.\nYou can check for the common things compared to the other cases in the switch-case. Additionally, there can be ParserRuleContext.ORDER_CLAUSE_END.", "author": "SupunS", "createdAt": "2020-07-22T12:23:45Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1906,6 +1925,11 @@ private Result seekMatchInExpressionRhs(int lookahead, int currentDepth, int cur\n                         ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n                         ParserRuleContext.LET_CLAUSE_END };\n                 break;\n+            case ORDER_KEY:\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.EXPRESSION,\n+                        ParserRuleContext.ASCENDING_KEYWORD, ParserRuleContext.DESCENDING_KEYWORD,\n+                        ParserRuleContext.ORDER_CLAUSE_END };\n+                break;", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -1926,8 +1920,10 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                         ParserRuleContext.LET_CLAUSE_END };\n                 break;\n             case ORDER_KEY:\n-                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.EXPRESSION,\n-                        ParserRuleContext.ASCENDING_KEYWORD, ParserRuleContext.DESCENDING_KEYWORD,\n+                alternatives = new ParserRuleContext[] { ParserRuleContext.COMMA, ParserRuleContext.BINARY_OPERATOR,\n+                        ParserRuleContext.DOT, ParserRuleContext.ANNOT_CHAINING_TOKEN,\n+                        ParserRuleContext.OPTIONAL_CHAINING_TOKEN, ParserRuleContext.CONDITIONAL_EXPRESSION,\n+                        ParserRuleContext.XML_NAVIGATE_EXPR, ParserRuleContext.MEMBER_ACCESS_KEY_EXPR,\n                         ParserRuleContext.ORDER_CLAUSE_END };\n                 break;\n             case QUERY_EXPRESSION:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzAyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458753027", "bodyText": "I think we shouldn't need to add it here, since an order-keyword cannot exist inside a let-var-decl.", "author": "SupunS", "createdAt": "2020-07-22T12:26:23Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -2718,19 +2714,12 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                 }\n                 return ParserRuleContext.EXPRESSION;\n             case ORDER_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n-                    endContext(); // end let-clause-let-var-decl\n-                }\n                 return ParserRuleContext.BY_KEYWORD;\n             case BY_KEYWORD:\n                 return ParserRuleContext.ORDER_KEY;\n             case ASCENDING_KEYWORD:\n             case DESCENDING_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n-                    endContext(); // end order-key\n-                }\n+                endContext();\n                 return ParserRuleContext.ORDER_KEY;\n             case FROM_KEYWORD:\n                 parentCtx = getParentContext();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzM3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757371", "bodyText": "Looks like a new context is not started for ORDER_CLAUSE_END, so this condition may never be true?\nI think a better approach would be to say, next token context after the ascending/descending keywords is ORDER_KEY_RHS. And it has alternative paths - ORDER_KEY and ORDER_CLAUSE_END", "author": "SupunS", "createdAt": "2020-07-22T12:34:04Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -2718,19 +2714,12 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                 }\n                 return ParserRuleContext.EXPRESSION;\n             case ORDER_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n-                    endContext(); // end let-clause-let-var-decl\n-                }\n                 return ParserRuleContext.BY_KEYWORD;\n             case BY_KEYWORD:\n                 return ParserRuleContext.ORDER_KEY;\n             case ASCENDING_KEYWORD:\n             case DESCENDING_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n-                    endContext(); // end order-key\n-                }\n+                endContext();\n                 return ParserRuleContext.ORDER_KEY;\n             case FROM_KEYWORD:\n                 parentCtx = getParentContext();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1Nzc5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458757793", "bodyText": "I think you'll have to end the context which-ever path it takes, otherwise there will be nested contexts started without ending them", "author": "SupunS", "createdAt": "2020-07-22T12:34:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2688,6 +2717,21 @@ private ParserRuleContext getNextRuleForKeywords(ParserRuleContext currentCtx, i\n                     endContext(); // end let-clause-let-var-decl\n                 }\n                 return ParserRuleContext.EXPRESSION;\n+            case ORDER_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n+                    endContext(); // end let-clause-let-var-decl\n+                }\n+                return ParserRuleContext.BY_KEYWORD;\n+            case BY_KEYWORD:\n+                return ParserRuleContext.ORDER_KEY;\n+            case ASCENDING_KEYWORD:\n+            case DESCENDING_KEYWORD:\n+                parentCtx = getParentContext();\n+                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n+                    endContext(); // end order-key", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\nindex fbe2b675726..6fd2f9244ca 100644\n--- a/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n+++ b/compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\n@@ -2718,19 +2714,12 @@ public class BallerinaParserErrorHandler extends AbstractParserErrorHandler {\n                 }\n                 return ParserRuleContext.EXPRESSION;\n             case ORDER_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.LET_CLAUSE_LET_VAR_DECL) {\n-                    endContext(); // end let-clause-let-var-decl\n-                }\n                 return ParserRuleContext.BY_KEYWORD;\n             case BY_KEYWORD:\n                 return ParserRuleContext.ORDER_KEY;\n             case ASCENDING_KEYWORD:\n             case DESCENDING_KEYWORD:\n-                parentCtx = getParentContext();\n-                if (parentCtx == ParserRuleContext.ORDER_CLAUSE_END) {\n-                    endContext(); // end order-key\n-                }\n+                endContext();\n                 return ParserRuleContext.ORDER_KEY;\n             case FROM_KEYWORD:\n                 parentCtx = getParentContext();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MjA1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r458762058", "bodyText": "does this includes negative tests (tests with incorrect syntaxes) also?\n\nIf yes - shall we split it in to two? There are separate sections in the same test file for positive tests and negative tests\nIf not - shall we add some?", "author": "SupunS", "createdAt": "2020-07-22T12:42:20Z", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java", "diffHunk": "@@ -169,4 +169,16 @@ public void testQueryWithOperatorPrecedenceWithExtraClauses() {\n         test(\"from int a in b select c let int a = b + from int f in g select h\",\n                 \"query-expr/query_expr_assert_38.json\");\n     }\n+\n+    @Test\n+    public void testQueryWithOrderByClause() {\n+        test(\"from int a in b where c let int d = e order by f select g\", \"query-expr/query_expr_assert_39.json\");\n+        test(\"from int a in b where c let int d = e order by f ascending, g select h\", \"query-expr\" +\n+                \"/query_expr_assert_40.json\");\n+        test(\"from int a in b order by c ascending, d descending select e\", \"query-expr\" +\n+                \"/query_expr_assert_41.json\");\n+        test(\"from int a in b order by select c\", \"query-expr/query_expr_assert_42.json\");\n+        test(\"from int a in b order c select d\", \"query-expr/query_expr_assert_43.json\");\n+        test(\"from int a in b order by c ascending d select e\", \"query-expr/query_expr_assert_44.json\");\n+    }", "originalCommit": "4500b550b4b38ebcf432e84af6615fdf37f8c7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "chunk": "diff --git a/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java b/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java\nindex 9467af9e2b7..63007eb9d73 100644\n--- a/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java\n+++ b/compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/QueryExpressionTest.java\n\n@@ -171,12 +180,7 @@ public class QueryExpressionTest extends AbstractExpressionsTest {\n     }\n \n     @Test\n-    public void testQueryWithOrderByClause() {\n-        test(\"from int a in b where c let int d = e order by f select g\", \"query-expr/query_expr_assert_39.json\");\n-        test(\"from int a in b where c let int d = e order by f ascending, g select h\", \"query-expr\" +\n-                \"/query_expr_assert_40.json\");\n-        test(\"from int a in b order by c ascending, d descending select e\", \"query-expr\" +\n-                \"/query_expr_assert_41.json\");\n+    public void testQueryWithOrderByClauseRecovery() {\n         test(\"from int a in b order by select c\", \"query-expr/query_expr_assert_42.json\");\n         test(\"from int a in b order c select d\", \"query-expr/query_expr_assert_43.json\");\n         test(\"from int a in b order by c ascending d select e\", \"query-expr/query_expr_assert_44.json\");\n"}}, {"oid": "58dfc6c222bbbb04b121ac786046074a2f87d868", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58dfc6c222bbbb04b121ac786046074a2f87d868", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-22T17:56:50Z", "type": "commit"}, {"oid": "b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0ac97e40ffa9e9514c5b8dfbe23ab2907608643", "message": "Add suggested changes", "committedDate": "2020-07-22T17:58:12Z", "type": "commit"}, {"oid": "7a92cd644050b80a0d22c0ac8a735d36ac940bcd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a92cd644050b80a0d22c0ac8a735d36ac940bcd", "message": "Add alternative paths for order direction", "committedDate": "2020-07-24T03:28:41Z", "type": "commit"}, {"oid": "80a50c338ba24a1fe76958900307a11142f5acc1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/80a50c338ba24a1fe76958900307a11142f5acc1", "message": "Add alternative paths for order direction", "committedDate": "2020-07-24T03:29:35Z", "type": "commit"}, {"oid": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/65deb30390b1ecb766a7c27a44a6f8c4175fb266", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into fix-24423-orderby", "committedDate": "2020-07-24T03:29:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODU0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888543", "bodyText": "try to use .isEmpty() rather when ever possible. these provided functions are more optimized", "author": "pcnfernando", "createdAt": "2020-12-17T08:10:22Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangPackageBuilder.java", "diffHunk": "@@ -2091,6 +2095,25 @@ void createOnClause(DiagnosticPos pos, Set<Whitespace> ws) {\n         joinClause.onClause = onClause;\n     }\n \n+    void createOrderByKey(DiagnosticPos pos, Set<Whitespace> ws, boolean isAscending) {\n+        BLangOrderKey orderKey = (BLangOrderKey) TreeBuilder.createOrderKeyNode();\n+        orderKey.pos = pos;\n+        orderKey.setOrderKey(this.exprNodeStack.pop());\n+        orderKey.setOrderDirection(isAscending);\n+        orderKeyListStack.push(orderKey);\n+    }\n+\n+    void createOrderByClause(DiagnosticPos pos, Set<Whitespace> ws) {\n+        BLangOrderByClause orderByClause = (BLangOrderByClause) TreeBuilder.createOrderByClauseNode();\n+        orderByClause.addWS(ws);\n+        orderByClause.pos = pos;\n+        Collections.reverse(orderKeyListStack);\n+        while (orderKeyListStack.size() > 0) {", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMDA3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544910075", "bodyText": "Will do. Unbale to address this here since BLangPackageBuilder.java is no longer used", "author": "lasinicl", "createdAt": "2020-12-17T08:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODU0Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODkwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544888908", "bodyText": "merge the two ifs", "author": "pcnfernando", "createdAt": "2020-12-17T08:11:02Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangParserListener.java", "diffHunk": "@@ -2933,6 +2933,31 @@ public void exitBinaryEqualsExpression(BallerinaParser.BinaryEqualsExpressionCon\n         this.pkgBuilder.createBinaryExpr(getCurrentPos(ctx), getWS(ctx), ctx.getChild(1).getText());\n     }\n \n+    @Override\n+    public void exitOrderKey(BallerinaParser.OrderKeyContext ctx) {\n+        if (isInErrorState) {\n+            return;\n+        }\n+\n+        boolean isAscending = true;\n+        if (ctx.orderDirection() != null) {", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxMzA5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544913095", "bodyText": "BLangParserListener.java is no longer used.", "author": "lasinicl", "createdAt": "2020-12-17T08:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg4ODkwOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MDY1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544890656", "bodyText": "You can move orderKeyNode.getOrderKey().toString() as common local var", "author": "pcnfernando", "createdAt": "2020-12-17T08:14:09Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxNjgzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544916830", "bodyText": "This was removed in a later PR (#25108)", "author": "lasinicl", "createdAt": "2020-12-17T08:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MDY1Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MTg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544891846", "bodyText": "You can get this as common var and check !null instead of contains and use commonly for both if/else", "author": "pcnfernando", "createdAt": "2020-12-17T08:16:06Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2712,11 +2715,35 @@ public void visit(BLangQueryExpr queryExpr) {\n                         this.dlog.error(collection.pos, DiagnosticCode.NOT_ALLOWED_STREAM_USAGE_WITH_FROM);\n                     }\n                 }\n+            } else if (clause.getKind() == NodeKind.ORDER_BY) {\n+                checkOrderFieldValidity(queryExpr.type, (BLangOrderByClause) clause);\n             }\n             analyzeNode(clause, env);\n         }\n     }\n \n+    private void checkOrderFieldValidity(BType resultType, BLangOrderByClause clause) {\n+        resultType = types.resolveExprType(resultType);\n+        if (resultType.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) resultType;\n+        Map<String, BField> recordFields = recordType.fields;\n+        for (OrderKeyNode orderKeyNode : clause.getOrderKeyList()) {\n+            if (!recordFields.containsKey(orderKeyNode.getOrderKey().toString())) {\n+                dlog.error(((BLangOrderKey) orderKeyNode).expression.pos,\n+                        DiagnosticCode.UNDEFINED_FIELD_IN_RECORD,\n+                        ((BLangOrderKey) orderKeyNode).expression, resultType);\n+            } else if (orderKeyNode.getOrderKey().toString() != null) {\n+                BType exprType = recordFields.get(orderKeyNode.getOrderKey().toString()).type;", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkxNzU2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544917564", "bodyText": "This was removed in a later PR (#25108)", "author": "lasinicl", "createdAt": "2020-12-17T08:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MTg0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MzY0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544893642", "bodyText": "Unnecessary new line", "author": "pcnfernando", "createdAt": "2020-12-17T08:19:07Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyNTMyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544925325", "bodyText": "Fixed in b9ca2c1", "author": "lasinicl", "createdAt": "2020-12-17T09:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5MzY0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkwMDEyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24673#discussion_r544900128", "bodyText": "You can use java streams api for joinning as well. No need to update it here. Just a suggestion for later since it's more descriptive.\neg:\norderByKeyList.stream()\n      .map(key -> key.toString())\n      .collect(Collectors.joining(\",\"));", "author": "pcnfernando", "createdAt": "2020-12-17T08:29:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/clauses/BLangOrderByClause.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.clauses;\n+\n+import org.ballerinalang.model.clauses.OrderByClauseNode;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+/**\n+ * Implementation of \"order by\" clause statement.\n+ *\n+ * @since Swan Lake\n+ */\n+public class BLangOrderByClause extends BLangNode implements OrderByClauseNode {\n+    public List<OrderKeyNode> orderByKeyList = new ArrayList<>();\n+\n+    public BLangOrderByClause() {\n+\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.ORDER_BY;\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public void addOrderKey(OrderKeyNode orderKeyNode) {\n+        orderByKeyList.add(orderKeyNode);\n+    }\n+\n+    @Override\n+    public List<OrderKeyNode> getOrderKeyList() {\n+        return orderByKeyList;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringJoiner declarations = new StringJoiner(\", \");", "originalCommit": "65deb30390b1ecb766a7c27a44a6f8c4175fb266", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}