{"pr_number": 1055, "pr_title": "Propagate current span to http client callback thread", "pr_createdAt": "2020-01-15T07:45:32Z", "pr_url": "https://github.com/openzipkin/brave/pull/1055", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczMzI2OQ==", "url": "https://github.com/openzipkin/brave/pull/1055#discussion_r366733269", "bodyText": "the tracecontext here in currentSpan should be the same as what's above set in context.setAttribute right? as there's some cost to fetching it, I think we should remember or reuse the context value.", "author": "codefromthecrypt", "createdAt": "2020-01-15T07:53:07Z", "path": "instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java", "diffHunk": "@@ -131,7 +134,7 @@ static void parseTargetAddress(HttpHost target, Span span) {\n         new TracingAsyncRequestProducer(requestProducer, context),\n         new TracingAsyncResponseConsumer<>(responseConsumer, context),\n         context,\n-        callback\n+        new FutureCallbackWithCurrentSpan(tracer.currentSpan(), callback)", "originalCommit": "62bc918d29092285f41bd11f7b0f9e50bc838638", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "943e2a9a479b9d9ccdc7bc423138106446bf0242", "chunk": "diff --git a/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java b/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\nindex 040b0656c..a57518699 100644\n--- a/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\n+++ b/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\n\n@@ -129,12 +130,13 @@ public final class TracingHttpAsyncClientBuilder extends HttpAsyncClientBuilder\n     @Override public <T> Future<T> execute(HttpAsyncRequestProducer requestProducer,\n       HttpAsyncResponseConsumer<T> responseConsumer, HttpContext context,\n       FutureCallback<T> callback) {\n-      context.setAttribute(TraceContext.class.getName(), currentTraceContext.get());\n+      TraceContext traceCtx = currentTraceContext.get();\n+      context.setAttribute(TraceContext.class.getName(), traceCtx);\n       return delegate.execute(\n         new TracingAsyncRequestProducer(requestProducer, context),\n         new TracingAsyncResponseConsumer<>(responseConsumer, context),\n         context,\n-        new FutureCallbackWithCurrentSpan(tracer.currentSpan(), callback)\n+        new TraceContextAwareFutureCallback(currentTraceContext, traceCtx, callback)\n       );\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczMzU2Ng==", "url": "https://github.com/openzipkin/brave/pull/1055#discussion_r366733566", "bodyText": "I'd reduce the cost of this by making it a static final, passing the CurrentTraceContext, TraceContext, and the callback. CurrentTraceContext scope commands are a bit cheaper than tracer based ones.", "author": "codefromthecrypt", "createdAt": "2020-01-15T07:54:03Z", "path": "instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java", "diffHunk": "@@ -148,6 +151,37 @@ static void parseTargetAddress(HttpHost target, Span span) {\n     }\n   }\n \n+  final class FutureCallbackWithCurrentSpan<T> implements FutureCallback<T> {", "originalCommit": "62bc918d29092285f41bd11f7b0f9e50bc838638", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "943e2a9a479b9d9ccdc7bc423138106446bf0242", "chunk": "diff --git a/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java b/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\nindex 040b0656c..a57518699 100644\n--- a/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\n+++ b/instrumentation/httpasyncclient/src/main/java/brave/httpasyncclient/TracingHttpAsyncClientBuilder.java\n\n@@ -151,32 +153,31 @@ public final class TracingHttpAsyncClientBuilder extends HttpAsyncClientBuilder\n     }\n   }\n \n-  final class FutureCallbackWithCurrentSpan<T> implements FutureCallback<T> {\n+  static final class TraceContextAwareFutureCallback<T> implements FutureCallback<T> {\n+    private final CurrentTraceContext currentTraceContext;\n+    private final TraceContext traceCtx;\n     private final FutureCallback<T> callback;\n-    private final Span span;\n \n-    FutureCallbackWithCurrentSpan(Span span, FutureCallback<T> callback) {\n-      this.span = span;\n+    TraceContextAwareFutureCallback(CurrentTraceContext currentTraceContext, TraceContext traceCtx, FutureCallback<T> callback) {\n+      this.currentTraceContext = currentTraceContext;\n+      this.traceCtx = traceCtx;\n       this.callback = callback;\n     }\n \n-    @Override\n-    public void completed(T t) {\n-      try (Tracer.SpanInScope s = tracer.withSpanInScope(span)) {\n+    @Override public void completed(T t) {\n+      try (Scope scope = currentTraceContext.maybeScope(traceCtx)) {\n         callback.completed(t);\n       }\n     }\n \n-    @Override\n-    public void failed(Exception e) {\n-      try (Tracer.SpanInScope s = tracer.withSpanInScope(span)) {\n+    @Override public void failed(Exception e) {\n+      try (Scope scope = currentTraceContext.maybeScope(traceCtx)) {\n         callback.failed(e);\n       }\n     }\n \n-    @Override\n-    public void cancelled() {\n-      try (Tracer.SpanInScope s = tracer.withSpanInScope(span)) {\n+    @Override public void cancelled() {\n+      try (Scope scope = currentTraceContext.maybeScope(traceCtx)) {\n         callback.cancelled();\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NDA0OA==", "url": "https://github.com/openzipkin/brave/pull/1055#discussion_r367744048", "bodyText": "I would go a bit farther, because you are not only setting a current span, but specifically the invocation context. Ex if you change spanIsVisible to something that catches the current tracecontext, you can compare it against the one in line 124", "author": "codefromthecrypt", "createdAt": "2020-01-17T02:30:52Z", "path": "instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java", "diffHunk": "@@ -92,4 +98,54 @@ protected void post(CloseableHttpAsyncClient client, String pathIncludingQuery,\n     \n     takeSpan();\n   }\n+\n+  @Test public void currentSpanIsVisibleInCallbackThread() throws Exception {", "originalCommit": "d67ad9f3539c0beff8f6dbb7b49cff05ddb07315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "053b4e611d044c38c2ddbbede68b6099d4f3a130", "chunk": "diff --git a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\nindex 670044a0a..e563f46ec 100644\n--- a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n+++ b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n\n@@ -97,7 +97,6 @@ public class ITTracingHttpAsyncClientBuilder extends ITHttpAsyncClient<Closeable\n     assertThat(currentTraceContext.get()).isNull();\n     \n     takeSpan();\n-  }\n \n   @Test public void currentSpanIsVisibleInCallbackThread() throws Exception {\n     Tracer tracer = httpTracing.tracing().tracer();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2NDc4MA==", "url": "https://github.com/openzipkin/brave/pull/1055#discussion_r367864780", "bodyText": "I think what's left here (besides nit on formatting) is to simplify the code and remove the wait loop. For example, if we use a countdownlatch instead of AtomicBoolean for callbackCompleted. You can search for references to CountdownLatch in brave for similar examples.\nnext, the assertion in 117 may actually occur off the main thread, which is why you are saving a boolean there. I think it is a bit cleaner to have an atomic reference of TraceContext, then you can do assertThat(callbackTraceContext.get()).isSameAs(expected) right after your countdown latch is done.", "author": "codefromthecrypt", "createdAt": "2020-01-17T10:23:43Z", "path": "instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java", "diffHunk": "@@ -92,4 +99,52 @@ protected void post(CloseableHttpAsyncClient client, String pathIncludingQuery,\n     \n     takeSpan();\n   }\n+\n+  @Test public void currentTraceContextIsVisibleInCallbackThread() throws Exception {\n+    Tracer tracer = httpTracing.tracing().tracer();\n+    AtomicBoolean callbackHasTraceCtx = new AtomicBoolean(false);\n+    AtomicBoolean callbackCompleted = new AtomicBoolean(false);\n+    server.enqueue(new MockResponse());\n+    closeClient(client);\n+    client = TracingHttpAsyncClientBuilder.create(httpTracing).build();\n+    client.start();\n+    ScopedSpan span = tracer.startScopedSpan(\"test\");\n+    TraceContext expectedTraceCtx = span.context();\n+\n+    try { ", "originalCommit": "1089793ce68d80d7cf8e46241caaac40011bfc3e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "053b4e611d044c38c2ddbbede68b6099d4f3a130", "chunk": "diff --git a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\nindex 9085f801d..e563f46ec 100644\n--- a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n+++ b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n\n@@ -98,40 +97,41 @@ public class ITTracingHttpAsyncClientBuilder extends ITHttpAsyncClient<Closeable\n     assertThat(currentTraceContext.get()).isNull();\n     \n     takeSpan();\n-  }\n \n-  @Test public void currentTraceContextIsVisibleInCallbackThread() throws Exception {\n+  @Test public void currentSpanIsVisibleInCallbackThread() throws Exception {\n     Tracer tracer = httpTracing.tracing().tracer();\n-    AtomicBoolean callbackHasTraceCtx = new AtomicBoolean(false);\n-    AtomicBoolean callbackCompleted = new AtomicBoolean(false);\n+    AtomicBoolean spanIsVisible = new AtomicBoolean();\n+    AtomicBoolean callbackCompleted = new AtomicBoolean();\n+    FutureCallback<HttpResponse> callback = new FutureCallback<HttpResponse>() {\n+      @Override public void completed(HttpResponse result) {\n+        spanIsVisible.set(tracer.currentSpan() != null);\n+        callbackCompleted.set(true);\n+      }\n+      @Override public void failed(Exception ex) {\n+        callbackCompleted.set(true);\n+      }\n+      @Override public void cancelled() {\n+        callbackCompleted.set(true);\n+      }\n+    };\n+\n     server.enqueue(new MockResponse());\n     closeClient(client);\n     client = TracingHttpAsyncClientBuilder.create(httpTracing).build();\n     client.start();\n-    ScopedSpan span = tracer.startScopedSpan(\"test\");\n-    TraceContext expectedTraceCtx = span.context();\n \n+    ScopedSpan span = tracer.startScopedSpan(\"test\");\n     try { \n-      getAsyncWithCallback(client, \"/foo\", new FutureCallback<HttpResponse>() {\n-        @Override public void completed(HttpResponse result) {\n-          callbackHasTraceCtx.set(expectedTraceCtx == currentTraceContext.get());\n-          callbackCompleted.set(true);\n-        }\n-        @Override public void failed(Exception ex) {\n-          callbackCompleted.set(true);\n-        }\n-        @Override public void cancelled() {\n-          callbackCompleted.set(true);\n-        }\n-      });\n+      getAsyncWithCallback(client, \"/foo\", callback);\n     } finally {\n       span.finish();\n     }\n+\n     server.takeRequest();\n     waitForCallbackCompletion(callbackCompleted);\n-    takeSpan(); takeSpan();\n+    assertTrue(\"Span was not visible in callback thread\", spanIsVisible.get());\n \n-    assertTrue(\"Callback thread did not have expected trace ctx\", callbackHasTraceCtx.get());\n+    takeSpan(); takeSpan();\n   }\n \n   private void getAsyncWithCallback(CloseableHttpAsyncClient client, String pathIncludingQuery, FutureCallback<HttpResponse> callback) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg2NTQxNw==", "url": "https://github.com/openzipkin/brave/pull/1055#discussion_r367865417", "bodyText": "is restarting the client needed here? what happens if you don't close it? it looks like it would be the same as what you're doing. maybe try without lines 108-110 or add a comment above why we have to recreate it.", "author": "codefromthecrypt", "createdAt": "2020-01-17T10:25:22Z", "path": "instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java", "diffHunk": "@@ -92,4 +99,52 @@ protected void post(CloseableHttpAsyncClient client, String pathIncludingQuery,\n     \n     takeSpan();\n   }\n+\n+  @Test public void currentTraceContextIsVisibleInCallbackThread() throws Exception {\n+    Tracer tracer = httpTracing.tracing().tracer();\n+    AtomicBoolean callbackHasTraceCtx = new AtomicBoolean(false);\n+    AtomicBoolean callbackCompleted = new AtomicBoolean(false);\n+    server.enqueue(new MockResponse());\n+    closeClient(client);", "originalCommit": "1089793ce68d80d7cf8e46241caaac40011bfc3e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "053b4e611d044c38c2ddbbede68b6099d4f3a130", "chunk": "diff --git a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\nindex 9085f801d..e563f46ec 100644\n--- a/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n+++ b/instrumentation/httpasyncclient/src/test/java/brave/httpasyncclient/ITTracingHttpAsyncClientBuilder.java\n\n@@ -98,40 +97,41 @@ public class ITTracingHttpAsyncClientBuilder extends ITHttpAsyncClient<Closeable\n     assertThat(currentTraceContext.get()).isNull();\n     \n     takeSpan();\n-  }\n \n-  @Test public void currentTraceContextIsVisibleInCallbackThread() throws Exception {\n+  @Test public void currentSpanIsVisibleInCallbackThread() throws Exception {\n     Tracer tracer = httpTracing.tracing().tracer();\n-    AtomicBoolean callbackHasTraceCtx = new AtomicBoolean(false);\n-    AtomicBoolean callbackCompleted = new AtomicBoolean(false);\n+    AtomicBoolean spanIsVisible = new AtomicBoolean();\n+    AtomicBoolean callbackCompleted = new AtomicBoolean();\n+    FutureCallback<HttpResponse> callback = new FutureCallback<HttpResponse>() {\n+      @Override public void completed(HttpResponse result) {\n+        spanIsVisible.set(tracer.currentSpan() != null);\n+        callbackCompleted.set(true);\n+      }\n+      @Override public void failed(Exception ex) {\n+        callbackCompleted.set(true);\n+      }\n+      @Override public void cancelled() {\n+        callbackCompleted.set(true);\n+      }\n+    };\n+\n     server.enqueue(new MockResponse());\n     closeClient(client);\n     client = TracingHttpAsyncClientBuilder.create(httpTracing).build();\n     client.start();\n-    ScopedSpan span = tracer.startScopedSpan(\"test\");\n-    TraceContext expectedTraceCtx = span.context();\n \n+    ScopedSpan span = tracer.startScopedSpan(\"test\");\n     try { \n-      getAsyncWithCallback(client, \"/foo\", new FutureCallback<HttpResponse>() {\n-        @Override public void completed(HttpResponse result) {\n-          callbackHasTraceCtx.set(expectedTraceCtx == currentTraceContext.get());\n-          callbackCompleted.set(true);\n-        }\n-        @Override public void failed(Exception ex) {\n-          callbackCompleted.set(true);\n-        }\n-        @Override public void cancelled() {\n-          callbackCompleted.set(true);\n-        }\n-      });\n+      getAsyncWithCallback(client, \"/foo\", callback);\n     } finally {\n       span.finish();\n     }\n+\n     server.takeRequest();\n     waitForCallbackCompletion(callbackCompleted);\n-    takeSpan(); takeSpan();\n+    assertTrue(\"Span was not visible in callback thread\", spanIsVisible.get());\n \n-    assertTrue(\"Callback thread did not have expected trace ctx\", callbackHasTraceCtx.get());\n+    takeSpan(); takeSpan();\n   }\n \n   private void getAsyncWithCallback(CloseableHttpAsyncClient client, String pathIncludingQuery, FutureCallback<HttpResponse> callback) throws Exception {\n"}}, {"oid": "053b4e611d044c38c2ddbbede68b6099d4f3a130", "url": "https://github.com/openzipkin/brave/commit/053b4e611d044c38c2ddbbede68b6099d4f3a130", "message": "Propagate current span to http client callback thread", "committedDate": "2020-01-17T23:02:37Z", "type": "commit"}, {"oid": "943e2a9a479b9d9ccdc7bc423138106446bf0242", "url": "https://github.com/openzipkin/brave/commit/943e2a9a479b9d9ccdc7bc423138106446bf0242", "message": "Reuse current trace ctx instead of getting the current span", "committedDate": "2020-01-17T23:02:40Z", "type": "commit"}, {"oid": "c29712edd34a8b81c9b84a97763ffa1ff3b5c38c", "url": "https://github.com/openzipkin/brave/commit/c29712edd34a8b81c9b84a97763ffa1ff3b5c38c", "message": "Fix test failure", "committedDate": "2020-01-17T23:02:40Z", "type": "commit"}, {"oid": "9a3562bbd97158ec08a52d14c7566bc28cd19d21", "url": "https://github.com/openzipkin/brave/commit/9a3562bbd97158ec08a52d14c7566bc28cd19d21", "message": "Test now checks for expected TraceContext instead of Span", "committedDate": "2020-01-17T23:02:40Z", "type": "commit"}, {"oid": "16afd945a6cc1440ac8fdd6247ac38cd9131d97a", "url": "https://github.com/openzipkin/brave/commit/16afd945a6cc1440ac8fdd6247ac38cd9131d97a", "message": "Test cleanup based on review comments", "committedDate": "2020-01-18T01:49:39Z", "type": "commit"}]}