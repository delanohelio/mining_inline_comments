{"pr_number": 1147, "pr_title": "Reverts defensiveness in generic params and shares a buffer", "pr_createdAt": "2020-04-10T07:54:10Z", "pr_url": "https://github.com/openzipkin/brave/pull/1147", "timeline": [{"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "url": "https://github.com/openzipkin/brave/commit/bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "message": "Reverts defensiveness in generic params and shares a buffer\n\nit was a relic of an older JDK, or complete fantasy. This reverts it.\n\nThis also fixes where we accidentally didn't share a buffer.", "committedDate": "2020-04-10T07:50:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk4MA==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406648980", "bodyText": "note this is not really much different than before.. I can revert it.. I was just playing around.", "author": "codefromthecrypt", "createdAt": "2020-04-10T07:56:13Z", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "originalCommit": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "51aec8fc2ed3573d610c23ee2c31395080d9dcce", "chunk": "diff --git a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\nindex ef35c212b..441cba940 100644\n--- a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n+++ b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n\n@@ -92,15 +94,27 @@ public class ThreadLocalCurrentTraceContext extends CurrentTraceContext { // not\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    Scope result = new ThreadLocalScope(local, previous);\n+    Scope result = previous != null ? new RevertToPreviousScope(local, previous) : revertToNull;\n     return decorateScope(currentSpan, result);\n   }\n \n-  static final class ThreadLocalScope implements Scope {\n+  static final class RevertToNullScope implements Scope {\n+    final ThreadLocal<TraceContext> local;\n+\n+    RevertToNullScope(ThreadLocal<TraceContext> local) {\n+      this.local = local;\n+    }\n+\n+    @Override public void close() {\n+      local.set(null);\n+    }\n+  }\n+\n+  static final class RevertToPreviousScope implements Scope {\n     final ThreadLocal<TraceContext> local;\n     final TraceContext previous;\n \n-    ThreadLocalScope(ThreadLocal<TraceContext> local, TraceContext previous) {\n+    RevertToPreviousScope(ThreadLocal<TraceContext> local, TraceContext previous) {\n       this.local = local;\n       this.previous = previous;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTA0OQ==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649049", "bodyText": "Agree - the JVM has no idea what's in these brackets anyways without reflection", "author": "anuraaga", "createdAt": "2020-04-10T07:56:27Z", "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -49,8 +49,7 @@\n  * for example via spring or when mocking.\n  */\n public abstract class Tracing implements Closeable {\n-  // AtomicReference<Object> instead of AtomicReference<Tracing> to ensure unloadable\n-  static final AtomicReference<Object> CURRENT = new AtomicReference<>();\n+  static final AtomicReference<Tracing> CURRENT = new AtomicReference<>();", "originalCommit": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649661", "bodyText": "This seems nice - seems like it could fix something?", "author": "anuraaga", "createdAt": "2020-04-10T07:58:12Z", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "originalCommit": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1MDkyMw==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406650923", "bodyText": "well  I'll update.. with where I was going.. basically revert to null can be a singleton. I still can't get the thing to unload when leaked as the cover type is brave's.", "author": "codefromthecrypt", "createdAt": "2020-04-10T08:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1MjYyOQ==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406652629", "bodyText": "ptal", "author": "codefromthecrypt", "createdAt": "2020-04-10T08:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "51aec8fc2ed3573d610c23ee2c31395080d9dcce", "chunk": "diff --git a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\nindex ef35c212b..441cba940 100644\n--- a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n+++ b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n\n@@ -92,15 +94,27 @@ public class ThreadLocalCurrentTraceContext extends CurrentTraceContext { // not\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    Scope result = new ThreadLocalScope(local, previous);\n+    Scope result = previous != null ? new RevertToPreviousScope(local, previous) : revertToNull;\n     return decorateScope(currentSpan, result);\n   }\n \n-  static final class ThreadLocalScope implements Scope {\n+  static final class RevertToNullScope implements Scope {\n+    final ThreadLocal<TraceContext> local;\n+\n+    RevertToNullScope(ThreadLocal<TraceContext> local) {\n+      this.local = local;\n+    }\n+\n+    @Override public void close() {\n+      local.set(null);\n+    }\n+  }\n+\n+  static final class RevertToPreviousScope implements Scope {\n     final ThreadLocal<TraceContext> local;\n     final TraceContext previous;\n \n-    ThreadLocalScope(ThreadLocal<TraceContext> local, TraceContext previous) {\n+    RevertToPreviousScope(ThreadLocal<TraceContext> local, TraceContext previous) {\n       this.local = local;\n       this.previous = previous;\n     }\n"}}, {"oid": "51aec8fc2ed3573d610c23ee2c31395080d9dcce", "url": "https://github.com/openzipkin/brave/commit/51aec8fc2ed3573d610c23ee2c31395080d9dcce", "message": "special case null", "committedDate": "2020-04-10T08:07:09Z", "type": "commit"}, {"oid": "34bac2e6595dbe13352efed93bebd032000e2eeb", "url": "https://github.com/openzipkin/brave/commit/34bac2e6595dbe13352efed93bebd032000e2eeb", "message": "leaked scopes that revert to null are unloadable", "committedDate": "2020-04-10T08:17:29Z", "type": "commit"}, {"oid": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d", "url": "https://github.com/openzipkin/brave/commit/d984a69aeec9d0687a6fd5de9f00abd91cd69b3d", "message": "clarifies TODO", "committedDate": "2020-04-10T08:28:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY2MjgwOQ==", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406662809", "bodyText": "Doesn't block this PR at all, just to record my thought and maybe @felixbarny has some ideas too.\nI haven't worked with unloading scenarios much but wonder whether this is so odd - since most things get cleaned up when GC happens, it seems natural to me for unloaded classes to also wait until GC to be cleaned up.", "author": "anuraaga", "createdAt": "2020-04-10T08:36:38Z", "path": "brave-tests/src/test/java/brave/propagation/ThreadLocalCurrentTraceContextClassLoaderTest.java", "diffHunk": "@@ -43,9 +43,24 @@\n     }\n   }\n \n+  @Test public void leakedNullScope() {\n+    assertRunIsUnloadable(LeakedNullScope.class, getClass().getClassLoader());\n+  }\n+\n+  static class LeakedNullScope implements Runnable {\n+    @Override public void run() {\n+      CurrentTraceContext current = ThreadLocalCurrentTraceContext.newBuilder().build();\n+      current.newScope(null);\n+    }\n+  }\n+\n   /**\n-   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant, for example\n-   * considering weak references or similar.\n+   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant.\n+   *\n+   * <p>The current design problem is we don't know a reference type we can use that clears when\n+   * the classloader is unloaded, regardless of GC. For example, having {@link Scope} extend {@link\n+   * java.lang.ref.WeakReference} to hold the value to revert. This would only help if GC happened", "originalCommit": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}