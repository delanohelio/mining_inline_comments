{"pr_number": 1188, "pr_title": "Adds StringPropagationAdapter to migrate off non-string propagation keys", "pr_createdAt": "2020-05-05T11:46:20Z", "pr_url": "https://github.com/openzipkin/brave/pull/1188", "timeline": [{"oid": "9e09a0fd6d182b049abbf9800a0860264f0851b8", "url": "https://github.com/openzipkin/brave/commit/9e09a0fd6d182b049abbf9800a0860264f0851b8", "message": "Adds StringPropagationAdapter to migrate off non-string propagation keys\n\nWe formerly deprecated propagation factory methods that return non string\ninstances. This stops us from using them internally, and provides a bridge\nfor tools like zipkin-aws and zipkin-gcp to migrate with.", "committedDate": "2020-05-05T11:45:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0ODIzNg==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420048236", "bodyText": "this is needed for secondary sampling to set localSampled conditionally. A future PR will integrate that... just I needed to make sure only String keys are possible before proceeding.", "author": "codefromthecrypt", "createdAt": "2020-05-05T11:47:32Z", "path": "brave/src/main/java/brave/internal/baggage/ExtraHandler.java", "diffHunk": "@@ -89,8 +90,13 @@ protected ExtraHandler(Object initialState) {\n    * @see TraceContext.Extractor#extract(Object)\n    */\n   // This operates on the builder directly to allow us to hide newExtra and potential bugs\n-  public final E provisionExtra(TraceContextOrSamplingFlags.Builder builder, Object request) {\n+  public final <R> E provisionExtra(\n+      TraceContextOrSamplingFlags.Builder builder,\n+      Getter<R, String> getter,", "originalCommit": "9e09a0fd6d182b049abbf9800a0860264f0851b8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2b5240e4a082c302a2ac90a663a4e124780fb979", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/ExtraHandler.java b/brave/src/main/java/brave/internal/baggage/ExtraHandler.java\nindex 5f3e0dca2..e6096a774 100644\n--- a/brave/src/main/java/brave/internal/baggage/ExtraHandler.java\n+++ b/brave/src/main/java/brave/internal/baggage/ExtraHandler.java\n\n@@ -63,54 +61,44 @@ public abstract class ExtraHandler<E extends Extra<E, H>, H extends ExtraHandler\n    * Creates a new instance of {@link #<E>}, with this handler's initial state.\n    *\n    * <p>This is only called in two scenarios:\n+   * <ul>\n+   *   <li>During extraction: {@link #provisionExtra(TraceContextOrSamplingFlags.Builder)}</li>\n+   *   <li>For a new local root, {@link #ensureContainsExtra(TraceContext)}</li>\n+   * </ul>\n    *\n-   * <p>During extraction, {@link #provisionExtra(TraceContextOrSamplingFlags.Builder, Getter,\n-   * Object)} invokes this method with a non-{@code null} {@code request} parameter.\n-   *\n-   * <p>For a new local root, {@link #ensureContainsExtra(TraceContext)} invokes this method with a\n-   * {@code null} {@code request} parameter.\n-   *\n-   * @param request possibly {@code null} request\n    * @return a new instance which will be assigned this decorator's {@linkplain\n    * ExtraHandler#initialState initial state}.\n-   * @see #provisionExtra(TraceContextOrSamplingFlags.Builder, Getter, Object)\n+   * @see #provisionExtra(TraceContextOrSamplingFlags.Builder)\n    * @see #ensureContainsExtra(TraceContext)\n    */\n   // protected to prevent unwanted callers from creating multiple instances per context\n-  protected abstract E newExtra(@Nullable Object request);\n+  protected abstract E provisionExtra();\n \n   /**\n    * Provisions a new instance of {@link #<E>} and adds it to the builder. Integrate this via {@link\n    * TraceContext.Extractor#extract(Object)}.\n    *\n-   * @param request the request parameter of {@link TraceContext.Extractor#extract(Object)}\n    * @return the instance already added to the builder.\n-   * @see #newExtra(Object)\n+   * @see #provisionExtra()\n    * @see #ensureContainsExtra(TraceContext)\n    * @see TraceContext.Extractor#extract(Object)\n    */\n   // This operates on the builder directly to allow us to hide newExtra and potential bugs\n-  public final <R> E provisionExtra(\n-      TraceContextOrSamplingFlags.Builder builder,\n-      Getter<R, String> getter,\n-      R request\n-  ) {\n+  public final E provisionExtra(TraceContextOrSamplingFlags.Builder builder) {\n     if (builder == null) throw new NullPointerException(\"builder == null\");\n-    if (getter == null) throw new NullPointerException(\"getter == null\");\n-    if (request == null) throw new NullPointerException(\"request == null\");\n-    E result = newExtra(request);\n-    if (result == null) throw new RuntimeException(\"BUG: provision(request) returned null\");\n+    E result = provisionExtra();\n+    if (result == null) throw new RuntimeException(\"BUG: provisionExtra() returned null\");\n     builder.addExtra(result);\n     return result;\n   }\n \n   /**\n-   * Backfills an instance of {@link #<E>} to {@link TraceContext#extra()} if needed, after ensuring\n-   * it is associated with the {@code context}. Integrate this via a hook that operates on every new\n-   * trace context, such as {@link Propagation.Factory#decorate(TraceContext)}.\n+   * Back fills an instance of {@link #<E>} to {@link TraceContext#extra()} if needed, after\n+   * ensuring it is associated with the {@code context}. Integrate this via a hook that operates on\n+   * every new trace context, such as {@link Propagation.Factory#decorate(TraceContext)}.\n    *\n-   * @see #newExtra(Object)\n-   * @see #provisionExtra(TraceContextOrSamplingFlags.Builder, Getter, Object)\n+   * @see #provisionExtra(TraceContextOrSamplingFlags.Builder)\n+   * @see #provisionExtra()\n    * @see Propagation.Factory#decorate(TraceContext)\n    */\n   public final TraceContext ensureContainsExtra(TraceContext context) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0ODU0Nw==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420048547", "bodyText": "this is the adapter", "author": "codefromthecrypt", "createdAt": "2020-05-05T11:48:13Z", "path": "brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.propagation;\n+\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This supports the deprecated {@link Propagation.Factory#create(KeyFactory)}.\n+ *\n+ * <p>Here's how to integrate:\n+ *\n+ * <p>First, override {@link Propagation.Factory#get()} with your actual implementation. Then,\n+ * dispatch {@link Propagation.Factory#create(KeyFactory)} to your implementation via {@link\n+ * #create(Propagation, KeyFactory)}:\n+ *\n+ * <p><pre>{@code\n+ * @Override public Propagation<String> get() {\n+ *   return new YourPropagation(this);\n+ * }\n+ *\n+ * @Deprecated public <K> Propagation<K> create(KeyFactory<K> keyFactory) {\n+ *   return StringPropagationAdapter.create(get(), keyFactory)\n+ * }\n+ * }</pre>\n+ *\n+ * <p><em>This is internal, and will be removed in Brave 6</em>. However, it won't be removed\n+ * before Brave 6. If you wish to use this, use \"maven-shade-plugin\" with the following\n+ * configuration, or something similar.\n+ *\n+ * <pre>{@code\n+ * <configuration>\n+ * <createDependencyReducedPom>false</createDependencyReducedPom>\n+ * <artifactSet>\n+ *   <includes>\n+ *     <include>io.zipkin.brave:brave</include>\n+ *   </includes>\n+ * </artifactSet>\n+ * <filters>\n+ *   <filter>\n+ *     <artifact>io.zipkin.brave:brave</artifact>\n+ *     <includes>\n+ *       <include>brave/internal/propagation/StringPropagationAdapter*.class</include>\n+ *     </includes>\n+ *   </filter>\n+ * </filters>\n+ * <relocations>\n+ *   <relocation>\n+ *     <pattern>brave.internal.propagation</pattern>\n+ *     <shadedPattern>YOUR_PACKAGE.brave_internal</shadedPattern>\n+ *   </relocation>\n+ * </relocations>\n+ * }</pre>\n+ *\n+ * @since 5.12\n+ */\n+public final class StringPropagationAdapter<K> implements Propagation<K> {", "originalCommit": "9e09a0fd6d182b049abbf9800a0860264f0851b8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ffa1f1ab45a2e91b695de1c81e98cbdd00da219", "chunk": "diff --git a/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java b/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\nindex 47c05b38e..d9e250b35 100644\n--- a/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\n+++ b/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\n\n@@ -199,4 +199,4 @@ public final class StringPropagationAdapter<K> implements Propagation<K> {\n       return false;\n     }\n   }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0ODY1NQ==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420048655", "bodyText": "this is the adapter's test", "author": "codefromthecrypt", "createdAt": "2020-05-05T11:48:27Z", "path": "brave/src/test/java/brave/internal/propagation/StringPropagationAdapterTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.propagation;\n+\n+import brave.internal.propagation.StringPropagationAdapter.GetterAdapter;\n+import brave.internal.propagation.StringPropagationAdapter.SetterAdapter;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.Getter;\n+import brave.propagation.Propagation.KeyFactory;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import org.assertj.core.api.InstanceOfAssertFactories;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static java.util.Arrays.asList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.isA;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class StringPropagationAdapterTest {", "originalCommit": "9e09a0fd6d182b049abbf9800a0860264f0851b8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "2b5240e4a082c302a2ac90a663a4e124780fb979", "url": "https://github.com/openzipkin/brave/commit/2b5240e4a082c302a2ac90a663a4e124780fb979", "message": "scrub out hanlder parameters as not that helpful", "committedDate": "2020-05-05T14:32:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4Mjk1Nw==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420182957", "bodyText": "Intellij? :P", "author": "anuraaga", "createdAt": "2020-05-05T15:06:58Z", "path": "brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.propagation;\n+\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This supports the deprecated {@link Propagation.Factory#create(KeyFactory)}.\n+ *\n+ * <p>Here's how to integrate:\n+ *\n+ * <p>First, override {@link Propagation.Factory#get()} with your actual implementation. Then,\n+ * dispatch {@link Propagation.Factory#create(KeyFactory)} to your implementation via {@link\n+ * #create(Propagation, KeyFactory)}:\n+ *\n+ * <p><pre>{@code\n+ * @Override public Propagation<String> get() {\n+ *   return new YourPropagation(this);\n+ * }\n+ *\n+ * @Deprecated public <K> Propagation<K> create(KeyFactory<K> keyFactory) {\n+ *   return StringPropagationAdapter.create(get(), keyFactory)\n+ * }\n+ * }</pre>\n+ *\n+ * <p><em>This is internal, and will be removed in Brave 6</em>. However, it won't be removed\n+ * before Brave 6. If you wish to use this, use \"maven-shade-plugin\" with the following\n+ * configuration, or something similar.\n+ *\n+ * <pre>{@code\n+ * <configuration>\n+ * <createDependencyReducedPom>false</createDependencyReducedPom>\n+ * <artifactSet>\n+ *   <includes>\n+ *     <include>io.zipkin.brave:brave</include>\n+ *   </includes>\n+ * </artifactSet>\n+ * <filters>\n+ *   <filter>\n+ *     <artifact>io.zipkin.brave:brave</artifact>\n+ *     <includes>\n+ *       <include>brave/internal/propagation/StringPropagationAdapter*.class</include>\n+ *     </includes>\n+ *   </filter>\n+ * </filters>\n+ * <relocations>\n+ *   <relocation>\n+ *     <pattern>brave.internal.propagation</pattern>\n+ *     <shadedPattern>YOUR_PACKAGE.brave_internal</shadedPattern>\n+ *   </relocation>\n+ * </relocations>\n+ * }</pre>\n+ *\n+ * @since 5.12\n+ */\n+public final class StringPropagationAdapter<K> implements Propagation<K> {\n+  public static <K> Propagation<K> create(Propagation<String> delegate, KeyFactory<K> keyFactory) {\n+    if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+    if (keyFactory == null) throw new NullPointerException(\"keyFactory == null\");\n+    if (keyFactory == KeyFactory.STRING) return (Propagation<K>) delegate;\n+    return new StringPropagationAdapter<>(delegate, keyFactory);\n+  }\n+\n+  final Propagation<String> delegate;\n+  final KeyFactory<K> keyFactory;\n+  final Map<String, K> map;\n+  final List<K> keysList;\n+\n+  StringPropagationAdapter(Propagation<String> delegate, KeyFactory<K> keyFactory) {\n+    this.delegate = delegate;\n+    this.keyFactory = keyFactory;\n+    this.map = new LinkedHashMap<>();\n+    this.keysList = toKeyList(delegate.keys(), keyFactory);\n+  }\n+\n+  List<K> toKeyList(List<String> keyNames, KeyFactory<K> keyFactory) {\n+    int length = keyNames.size();\n+    K[] keys = (K[]) new Object[length];\n+    for (int i = 0; i < length; i++) {\n+      String keyName = keyNames.get(i);\n+      K key = keyFactory.create(keyName);\n+      keys[i] = key;\n+      map.put(keyName, key);\n+    }\n+    return Collections.unmodifiableList(Arrays.asList(keys));\n+  }\n+\n+  @Override public List<K> keys() {\n+    return keysList;\n+  }\n+\n+  @Override public <R> Injector<R> injector(Setter<R, K> setter) {\n+    return delegate.injector(new SetterAdapter<>(setter, map));\n+  }\n+\n+  @Override public <R> Extractor<R> extractor(Getter<R, K> getter) {\n+    return delegate.extractor(new GetterAdapter<>(getter, map));\n+  }\n+\n+  @Override public int hashCode() {\n+    return delegate.hashCode();\n+  }\n+\n+  @Override public String toString() {\n+    return delegate.toString();\n+  }\n+\n+  @Override public boolean equals(Object obj) {\n+    if (obj instanceof StringPropagationAdapter) {\n+      return delegate.equals(((StringPropagationAdapter) obj).delegate);\n+    } else if (obj instanceof Propagation) {\n+      return delegate.equals(obj);\n+    }\n+    return false;\n+  }\n+\n+  static final class GetterAdapter<R, K> implements Getter<R, String> {\n+    final Getter<R, K> getter;\n+    final Map<String, K> map;\n+\n+    GetterAdapter(Getter<R, K> getter, Map<String, K> map) {\n+      if (getter == null) throw new NullPointerException(\"getter == null\");\n+      this.getter = getter;\n+      this.map = map;\n+    }\n+\n+    @Override public String get(R request, String keyName) {\n+      K key = map.get(keyName);\n+      if (key == null) return null;\n+      return getter.get(request, key);\n+    }\n+\n+    @Override public int hashCode() {\n+      return getter.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return getter.toString();\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+      if (obj instanceof GetterAdapter) {\n+        return getter.equals(((GetterAdapter) obj).getter);\n+      } else if (obj instanceof Getter) {\n+        return getter.equals(obj);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  static final class SetterAdapter<R, K> implements Setter<R, String> {\n+    final Setter<R, K> setter;\n+    final Map<String, K> map;\n+\n+    SetterAdapter(Setter<R, K> setter, Map<String, K> map) {\n+      if (setter == null) throw new NullPointerException(\"setter == null\");\n+      this.setter = setter;\n+      this.map = map;\n+    }\n+\n+    @Override public void put(R request, String keyName, String value) {\n+      K key = map.get(keyName);\n+      if (key == null) return;\n+      setter.put(request, key, value);\n+    }\n+\n+    @Override public int hashCode() {\n+      return setter.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return setter.toString();\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+      if (obj instanceof SetterAdapter) {\n+        return setter.equals(((SetterAdapter) obj).setter);\n+      } else if (obj instanceof Setter) {\n+        return setter.equals(obj);\n+      }\n+      return false;\n+    }\n+  }\n+}", "originalCommit": "2b5240e4a082c302a2ac90a663a4e124780fb979", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ffa1f1ab45a2e91b695de1c81e98cbdd00da219", "chunk": "diff --git a/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java b/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\nindex 47c05b38e..d9e250b35 100644\n--- a/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\n+++ b/brave/src/main/java/brave/internal/propagation/StringPropagationAdapter.java\n\n@@ -199,4 +199,4 @@ public final class StringPropagationAdapter<K> implements Propagation<K> {\n       return false;\n     }\n   }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4NDQwMg==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420184402", "bodyText": "Probably just dejavu but I feel as if I've seen this if statement on the right hand side of 3 PRs now :O", "author": "anuraaga", "createdAt": "2020-05-05T15:08:51Z", "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -331,54 +320,55 @@ public FactoryBuilder add(BaggagePropagationConfig config) {\n       BaggageFields extra = context.findExtra(BaggageFields.class);\n       if (extra == null) return;\n       Map<String, String> values =\n-          extra.toMapFilteringFieldNames(propagation.factory.localFieldNames);\n+          extra.toMapFilteringFieldNames(factory.localFieldNames);\n       if (values.isEmpty()) return;\n \n-      for (BaggageCodecWithKeys<K> baggageCodecWithKeys : propagation.baggageCodecWithKeys) {\n-        String value = baggageCodecWithKeys.baggageCodec.encode(values, context, request);\n+      for (BaggagePropagationConfig config : factory.configs) {\n+        if (config.baggageCodec == BaggageCodec.NOOP) continue; // local field", "originalCommit": "2b5240e4a082c302a2ac90a663a4e124780fb979", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NDY4Mg==", "url": "https://github.com/openzipkin/brave/pull/1188#discussion_r420484682", "bodyText": "haha tell me about it.. cleanup of this will come.. I just wanted to get rid of the K first. thanks for your patience with the road work!", "author": "codefromthecrypt", "createdAt": "2020-05-06T00:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4NDQwMg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "0ffa1f1ab45a2e91b695de1c81e98cbdd00da219", "url": "https://github.com/openzipkin/brave/commit/0ffa1f1ab45a2e91b695de1c81e98cbdd00da219", "message": "EOL before EOF", "committedDate": "2020-05-06T01:15:16Z", "type": "commit"}]}