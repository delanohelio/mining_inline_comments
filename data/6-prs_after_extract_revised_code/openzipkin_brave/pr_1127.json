{"pr_number": 1127, "pr_title": "Makes StrictScopeDecorator stricter without renaming it", "pr_createdAt": "2020-03-26T11:46:42Z", "pr_url": "https://github.com/openzipkin/brave/pull/1127", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTkxOA==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398511918", "bodyText": "I made a bug somewhere where I called this twice and expected different results :)", "author": "codefromthecrypt", "createdAt": "2020-03-26T11:50:18Z", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -60,19 +60,22 @@\n \n   /** Returns a trace context for use in propagation tests. */\n   protected TraceContext newTraceContext(SamplingFlags flags) {\n+    long id = System.nanoTime(); // Random enough as tests are run serially anyway\n     TraceContext result = TraceContext.newBuilder()\n-      .traceIdHigh(1L).traceId(2L).parentId(3L).spanId(1L)\n+      .traceIdHigh(id).traceId(id + 1).parentId(id + 2).spanId(id + 3)", "originalCommit": "4e0914633632f92381a59ac26635acf5825b63a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f", "chunk": "diff --git a/brave-tests/src/main/java/brave/test/ITRemote.java b/brave-tests/src/main/java/brave/test/ITRemote.java\nindex 25faf262d..093943c5b 100644\n--- a/brave-tests/src/main/java/brave/test/ITRemote.java\n+++ b/brave-tests/src/main/java/brave/test/ITRemote.java\n\n@@ -73,7 +74,7 @@ public abstract class ITRemote {\n   final StrictScopeDecorator strictScopeDecorator = StrictScopeDecorator.create();\n \n   // field because this allows subclasses to initialize a field Tracing\n-  protected final CurrentTraceContext currentTraceContext =\n+  protected final ThreadLocalCurrentTraceContext currentTraceContext =\n     ThreadLocalCurrentTraceContext.newBuilder()\n       .addScopeDecorator(strictScopeDecorator)\n       .build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMjM1NQ==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398512355", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @throws AssertionError if any scopes were left unclosed.\n          \n          \n            \n               * @throws IllegalStateException if any scopes were left unclosed.", "author": "codefromthecrypt", "createdAt": "2020-03-26T11:51:01Z", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!\n+public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n+  public static StrictScopeDecorator create() {\n     return new StrictScopeDecorator();\n   }\n \n-  /** Identifies problems by throwing assertion errors when a scope is closed on a different thread. */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\",\n-      Thread.currentThread().getName(), currentSpan)));\n+  final Queue<CallerStackTrace> currentCallers = new ConcurrentLinkedQueue<>();\n+\n+  /**\n+   * Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a\n+   * different thread.\n+   */\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+  }\n+\n+  /**\n+   * @throws AssertionError if any scopes were left unclosed.", "originalCommit": "4e0914633632f92381a59ac26635acf5825b63a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b542f541338439227ef2ac3504c6245fc2659546", "chunk": "diff --git a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\nindex 9fea94c38..50a1b8fe1 100644\n--- a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n\n@@ -48,17 +50,45 @@ public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n    * different thread.\n    */\n   @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n-    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+    CallerStackTrace caller = new CallerStackTrace(context);\n+    StackTraceElement[] stackTrace = caller.getStackTrace();\n+\n+    // \"new CallerStackTrace(context)\" isn't the line we want to start the caller stack trace with\n+    int i = 1;\n+\n+    // This skips internal utilities in this jar. Notably, this will not skip utilities outside it.\n+    // For example, HTTP or messaging handlers will become the caller, as would wrappers over Brave,\n+    // such as brave-opentracing. This is ok, as if they have bugs, they will show up as the caller!\n+    while (i < stackTrace.length) {\n+      String className = stackTrace[i].getClassName();\n+      if (className.equals(Tracer.class.getName())\n+        || className.endsWith(\"CurrentTraceContext\") // subtypes with conventional names\n+        || className.equals(ThreadLocalSpan.class.getName())) {\n+        i++;\n+      } else {\n+        break;\n+      }\n+    }\n+    int from = i;\n+\n+    stackTrace = Arrays.copyOfRange(stackTrace, from, stackTrace.length);\n+    caller.setStackTrace(stackTrace);\n+\n+    return new StrictScope(scope, caller, currentCallers);\n   }\n \n   /**\n-   * @throws AssertionError if any scopes were left unclosed.\n+   * @throws IllegalStateException if any scopes were left unclosed.\n    * @since 5.11\n    */\n   @Override public void close() {\n     for (CallerStackTrace caller : currentCallers) {\n-      throw new IllegalStateException(\n-        \"Thread [\" + caller.threadName + \"] opened scope, but never closed it\", caller);\n+      // Sometimes unit test runners truncate the cause of the exception.\n+      // This flattens the exception as the caller of close() isn't important vs the one that leaked\n+      IllegalStateException toThrow = new IllegalStateException(\n+        \"Thread [\" + caller.threadName + \"] leaked a scope of \" + caller.context + \" here:\");\n+      toThrow.setStackTrace(caller.getStackTrace());\n+      throw toThrow;\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxNDE2Ng==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398514166", "bodyText": "This is a neat trick.. Let's say some instrumentation you didn't write might be leaking a scope. If you add a bean of this type to an app with sleuth.. when you ctrl-c it should expose any leak problem automatically.", "author": "codefromthecrypt", "createdAt": "2020-03-26T11:54:18Z", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!", "originalCommit": "daf53a8425b72457c702ab2096dd683915c6977f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b542f541338439227ef2ac3504c6245fc2659546", "chunk": "diff --git a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\nindex e1ee871dd..50a1b8fe1 100644\n--- a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n\n@@ -48,7 +50,31 @@ public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n    * different thread.\n    */\n   @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n-    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+    CallerStackTrace caller = new CallerStackTrace(context);\n+    StackTraceElement[] stackTrace = caller.getStackTrace();\n+\n+    // \"new CallerStackTrace(context)\" isn't the line we want to start the caller stack trace with\n+    int i = 1;\n+\n+    // This skips internal utilities in this jar. Notably, this will not skip utilities outside it.\n+    // For example, HTTP or messaging handlers will become the caller, as would wrappers over Brave,\n+    // such as brave-opentracing. This is ok, as if they have bugs, they will show up as the caller!\n+    while (i < stackTrace.length) {\n+      String className = stackTrace[i].getClassName();\n+      if (className.equals(Tracer.class.getName())\n+        || className.endsWith(\"CurrentTraceContext\") // subtypes with conventional names\n+        || className.equals(ThreadLocalSpan.class.getName())) {\n+        i++;\n+      } else {\n+        break;\n+      }\n+    }\n+    int from = i;\n+\n+    stackTrace = Arrays.copyOfRange(stackTrace, from, stackTrace.length);\n+    caller.setStackTrace(stackTrace);\n+\n+    return new StrictScope(scope, caller, currentCallers);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwMzcyMg==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399003722", "bodyText": "Probably don't care about performance of this but just in case, can consider using a LinkedBlockingDeque to just remove the last element instead of iterating to the end.", "author": "anuraaga", "createdAt": "2020-03-27T02:40:20Z", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!\n+public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n+  public static StrictScopeDecorator create() {\n     return new StrictScopeDecorator();\n   }\n \n-  /** Identifies problems by throwing assertion errors when a scope is closed on a different thread. */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\",\n-      Thread.currentThread().getName(), currentSpan)));\n+  final Queue<CallerStackTrace> currentCallers = new ConcurrentLinkedQueue<>();\n+\n+  /**\n+   * Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a\n+   * different thread.\n+   */\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+  }\n+\n+  /**\n+   * @throws IllegalStateException if any scopes were left unclosed.\n+   * @since 5.11\n+   */\n+  @Override public void close() {\n+    for (CallerStackTrace caller : currentCallers) {\n+      throw new IllegalStateException(\n+        \"Thread [\" + caller.threadName + \"] opened scope, but never closed it\", caller);\n+    }\n   }\n \n   static final class StrictScope implements Scope {\n     final Scope delegate;\n-    final Throwable caller;\n-    final long threadId = Thread.currentThread().getId();\n+    final Queue<CallerStackTrace> currentCallers;\n+    final CallerStackTrace caller;\n \n-    StrictScope(Scope delegate, Throwable caller) {\n+    StrictScope(Scope delegate, CallerStackTrace caller, Queue<CallerStackTrace> currentCallers) {\n       this.delegate = delegate;\n+      this.currentCallers = currentCallers;\n       this.caller = caller;\n+      this.currentCallers.add(caller);\n     }\n \n     @Override public void close() {\n-      if (Thread.currentThread().getId() != threadId) {\n-        throw new IllegalStateException(\n-          \"scope closed in a different thread: \" + Thread.currentThread().getName(),\n-          caller);\n+      currentCallers.remove(caller);", "originalCommit": "daf53a8425b72457c702ab2096dd683915c6977f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAxMTMzNw==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399011337", "bodyText": "I so wanted to, but that's Java 1.7 plus (animal sniffer found this)", "author": "codefromthecrypt", "createdAt": "2020-03-27T03:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwMzcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "b542f541338439227ef2ac3504c6245fc2659546", "chunk": "diff --git a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\nindex e1ee871dd..50a1b8fe1 100644\n--- a/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/StrictScopeDecorator.java\n\n@@ -48,7 +50,31 @@ public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n    * different thread.\n    */\n   @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n-    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+    CallerStackTrace caller = new CallerStackTrace(context);\n+    StackTraceElement[] stackTrace = caller.getStackTrace();\n+\n+    // \"new CallerStackTrace(context)\" isn't the line we want to start the caller stack trace with\n+    int i = 1;\n+\n+    // This skips internal utilities in this jar. Notably, this will not skip utilities outside it.\n+    // For example, HTTP or messaging handlers will become the caller, as would wrappers over Brave,\n+    // such as brave-opentracing. This is ok, as if they have bugs, they will show up as the caller!\n+    while (i < stackTrace.length) {\n+      String className = stackTrace[i].getClassName();\n+      if (className.equals(Tracer.class.getName())\n+        || className.endsWith(\"CurrentTraceContext\") // subtypes with conventional names\n+        || className.equals(ThreadLocalSpan.class.getName())) {\n+        i++;\n+      } else {\n+        break;\n+      }\n+    }\n+    int from = i;\n+\n+    stackTrace = Arrays.copyOfRange(stackTrace, from, stackTrace.length);\n+    caller.setStackTrace(stackTrace);\n+\n+    return new StrictScope(scope, caller, currentCallers);\n   }\n \n   /**\n"}}, {"oid": "b542f541338439227ef2ac3504c6245fc2659546", "url": "https://github.com/openzipkin/brave/commit/b542f541338439227ef2ac3504c6245fc2659546", "message": "Makes StrictScopeDecorator stricter without renaming it\n\nThis fixes some fuzz in tests, but notably makes `StrictScopeDecorator`\n`Closeable`. In doing so, this will expose any instrumentation that\nleaked scopes as opposed to before which could only show if something\nclosed on the wrong thread.\n\nThis type was only ever documented for development, so there should be\nno harm in updating this in a way that could OOM in extreme leak\ncircumstances (due to hard references).", "committedDate": "2020-03-27T05:38:26Z", "type": "forcePushed"}, {"oid": "b542f541338439227ef2ac3504c6245fc2659546", "url": "https://github.com/openzipkin/brave/commit/b542f541338439227ef2ac3504c6245fc2659546", "message": "Makes StrictScopeDecorator stricter without renaming it\n\nThis fixes some fuzz in tests, but notably makes `StrictScopeDecorator`\n`Closeable`. In doing so, this will expose any instrumentation that\nleaked scopes as opposed to before which could only show if something\nclosed on the wrong thread.\n\nThis type was only ever documented for development, so there should be\nno harm in updating this in a way that could OOM in extreme leak\ncircumstances (due to hard references).", "committedDate": "2020-03-27T05:38:26Z", "type": "commit"}, {"oid": "f15e001ac904645af3f4ae417ee12ae1eccc33bc", "url": "https://github.com/openzipkin/brave/commit/f15e001ac904645af3f4ae417ee12ae1eccc33bc", "message": "license", "committedDate": "2020-03-27T05:40:28Z", "type": "commit"}, {"oid": "bb955accab85be7691ce4f486b55f88a9433b99e", "url": "https://github.com/openzipkin/brave/commit/bb955accab85be7691ce4f486b55f88a9433b99e", "message": "more in console", "committedDate": "2020-03-27T06:24:48Z", "type": "commit"}, {"oid": "62c97387c70b8650f713dd5aa0bb2a8ece19746d", "url": "https://github.com/openzipkin/brave/commit/62c97387c70b8650f713dd5aa0bb2a8ece19746d", "message": "quiet spring-web", "committedDate": "2020-03-27T06:45:45Z", "type": "commit"}, {"oid": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f", "url": "https://github.com/openzipkin/brave/commit/a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f", "message": "Adds and uses ThreadLocalCurrentTraceContext.clear()", "committedDate": "2020-03-27T06:47:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399064210", "bodyText": "Is it worth adding something like \"This is generally only useful in tests\"?", "author": "anuraaga", "createdAt": "2020-03-27T06:48:05Z", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -42,13 +42,27 @@ public static CurrentTraceContext create() {\n     return new Builder().build();\n   }\n \n-  public static CurrentTraceContext.Builder newBuilder() {\n+  public static Builder newBuilder() {\n     return new Builder();\n   }\n \n-  static final class Builder extends CurrentTraceContext.Builder {\n+  /**\n+   * This component is backed by a possibly static shared thread local. Call this to clear the\n+   * reference when you are sure any residual state is due to a leak.", "originalCommit": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDk0Mw==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399064943", "bodyText": "sure", "author": "codefromthecrypt", "createdAt": "2020-03-27T06:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NTg4MQ==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399065881", "bodyText": "well it is being done in a hack way in sleuth...\nhere\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/web/TraceWebFilter.java#L123-L126\nand also here\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/scheduling/TraceSchedulingAspect.java#L63-L65\nWhile I can't say either are correct, it might be that some bad instrumentation (ex written by an end user) leaks, and someone wants to correct it.", "author": "codefromthecrypt", "createdAt": "2020-03-27T06:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NjAwNA==", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399066004", "bodyText": "regardless, your statement is correct.. this should (not must) be only used in tests.", "author": "codefromthecrypt", "createdAt": "2020-03-27T06:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}], "type": "inlineReview", "revised_code": {"commit": "a18cb898353fc334b680d9d0a510ad51343da1fe", "chunk": "diff --git a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\nindex 94e8576ff..c1538dd05 100644\n--- a/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n+++ b/brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java\n\n@@ -48,7 +48,8 @@ public class ThreadLocalCurrentTraceContext extends CurrentTraceContext { // not\n \n   /**\n    * This component is backed by a possibly static shared thread local. Call this to clear the\n-   * reference when you are sure any residual state is due to a leak.\n+   * reference when you are sure any residual state is due to a leak. This is generally only useful\n+   * in tests.\n    *\n    * @since 5.11\n    */\n"}}, {"oid": "a18cb898353fc334b680d9d0a510ad51343da1fe", "url": "https://github.com/openzipkin/brave/commit/a18cb898353fc334b680d9d0a510ad51343da1fe", "message": "feedback", "committedDate": "2020-03-27T06:55:11Z", "type": "commit"}, {"oid": "e0fd4432dd2d05bca65a1cd3ddd2922d13fa5eea", "url": "https://github.com/openzipkin/brave/commit/e0fd4432dd2d05bca65a1cd3ddd2922d13fa5eea", "message": "try assertionerror", "committedDate": "2020-03-27T06:57:03Z", "type": "commit"}, {"oid": "478523b890c17f91599cb5a00d70188e66e1f7d8", "url": "https://github.com/openzipkin/brave/commit/478523b890c17f91599cb5a00d70188e66e1f7d8", "message": "pares down logging so that we can see real errors", "committedDate": "2020-03-27T07:32:24Z", "type": "commit"}, {"oid": "a8f3d510bdfc5b6837b89deeb8ee2c3a82c3a35a", "url": "https://github.com/openzipkin/brave/commit/a8f3d510bdfc5b6837b89deeb8ee2c3a82c3a35a", "message": "don't decorate noop", "committedDate": "2020-03-27T07:39:48Z", "type": "commit"}, {"oid": "1faf09fceda448a4e557ac76608d1baed91e8dc2", "url": "https://github.com/openzipkin/brave/commit/1faf09fceda448a4e557ac76608d1baed91e8dc2", "message": "restore maven config", "committedDate": "2020-03-27T08:04:48Z", "type": "commit"}, {"oid": "2115262c653926939f062a3dc3bc313c6cd9685b", "url": "https://github.com/openzipkin/brave/commit/2115262c653926939f062a3dc3bc313c6cd9685b", "message": "more quiet okhttp console", "committedDate": "2020-03-27T08:32:45Z", "type": "commit"}, {"oid": "c11786acd18c62e3aaa66d99f4672cc3758499bd", "url": "https://github.com/openzipkin/brave/commit/c11786acd18c62e3aaa66d99f4672cc3758499bd", "message": "Uses a simpler collection", "committedDate": "2020-03-27T08:59:50Z", "type": "commit"}, {"oid": "3d7008cf81433708ecb5931166658963565bd9d8", "url": "https://github.com/openzipkin/brave/commit/3d7008cf81433708ecb5931166658963565bd9d8", "message": "more info on okhttp invoker fail", "committedDate": "2020-03-27T09:25:50Z", "type": "commit"}, {"oid": "717ea52eca5a096f0731c51f458d6883b8590451", "url": "https://github.com/openzipkin/brave/commit/717ea52eca5a096f0731c51f458d6883b8590451", "message": "ensures apache async client is closed", "committedDate": "2020-03-27T10:30:46Z", "type": "commit"}, {"oid": "8ae5447be08805c346f07193db45d087a30548c9", "url": "https://github.com/openzipkin/brave/commit/8ae5447be08805c346f07193db45d087a30548c9", "message": "cleaner okhttp3 shutdown", "committedDate": "2020-03-28T00:02:31Z", "type": "commit"}, {"oid": "e03e32486ff50c3f0006cc40173c26fe582e8d45", "url": "https://github.com/openzipkin/brave/commit/e03e32486ff50c3f0006cc40173c26fe582e8d45", "message": "actually await termination", "committedDate": "2020-03-28T00:23:57Z", "type": "commit"}, {"oid": "1ce7a82c5b1bbffedc695dba1bc36711ea4ac6d9", "url": "https://github.com/openzipkin/brave/commit/1ce7a82c5b1bbffedc695dba1bc36711ea4ac6d9", "message": "clarifies instructions", "committedDate": "2020-03-28T00:58:28Z", "type": "commit"}, {"oid": "89c38a1b1bd20555a8c0e1726f0d8780cdaddfcb", "url": "https://github.com/openzipkin/brave/commit/89c38a1b1bd20555a8c0e1726f0d8780cdaddfcb", "message": "another one", "committedDate": "2020-03-28T01:23:10Z", "type": "commit"}]}