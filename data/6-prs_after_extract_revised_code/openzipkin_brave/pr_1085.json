{"pr_number": 1085, "pr_title": "Introduces `Response.error()` and uses it in HTTP abstraction", "pr_createdAt": "2020-02-18T08:36:36Z", "pr_url": "https://github.com/openzipkin/brave/pull/1085", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380532639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * The error raised during response processing or null if there was none.\n          \n          \n            \n               * The error raised during response processing or {@code null} if there was none.", "author": "anuraaga", "createdAt": "2020-02-18T08:56:26Z", "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * The error raised during response processing or null if there was none.", "originalCommit": "e58d0170be3eac056b5ab7b2c5910d983492d6a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/brave/src/main/java/brave/Response.java b/brave/src/main/java/brave/Response.java\nindex 03ab866dd..9e4a28391 100644\n--- a/brave/src/main/java/brave/Response.java\n+++ b/brave/src/main/java/brave/Response.java\n\n@@ -32,10 +32,10 @@ public abstract class Response {\n   public abstract Span.Kind spanKind();\n \n   /**\n-   * The error raised during response processing or null if there was none.\n+   * The error raised during response processing or {@code null} if there was none.\n    *\n-   * <p>Lack of a throwable does not mean success. For example, in HTTP, there could be a 409\n-   * status code with no corresponding Java exception.\n+   * <p>Lack of throwable, {@code null}, does not mean success. For example, in HTTP, there could be\n+   * a 409 status code with no corresponding Java exception.\n    *\n    * <h3>Handling errors</h3>\n    * Handlers invoke {@link Span#error(Throwable)} prior to passing control to user-defined response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjk4OQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380532989", "bodyText": "Maybe instead of Lack of throwable, {@code null}", "author": "anuraaga", "createdAt": "2020-02-18T08:57:02Z", "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * The error raised during response processing or null if there was none.\n+   *\n+   * <p>Lack of a throwable does not mean success. For example, in HTTP, there could be a 409", "originalCommit": "e58d0170be3eac056b5ab7b2c5910d983492d6a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/brave/src/main/java/brave/Response.java b/brave/src/main/java/brave/Response.java\nindex 03ab866dd..9e4a28391 100644\n--- a/brave/src/main/java/brave/Response.java\n+++ b/brave/src/main/java/brave/Response.java\n\n@@ -32,10 +32,10 @@ public abstract class Response {\n   public abstract Span.Kind spanKind();\n \n   /**\n-   * The error raised during response processing or null if there was none.\n+   * The error raised during response processing or {@code null} if there was none.\n    *\n-   * <p>Lack of a throwable does not mean success. For example, in HTTP, there could be a 409\n-   * status code with no corresponding Java exception.\n+   * <p>Lack of throwable, {@code null}, does not mean success. For example, in HTTP, there could be\n+   * a 409 status code with no corresponding Java exception.\n    *\n    * <h3>Handling errors</h3>\n    * Handlers invoke {@link Span#error(Throwable)} prior to passing control to user-defined response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNDAwNw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380534007", "bodyText": "Nice", "author": "anuraaga", "createdAt": "2020-02-18T08:58:55Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -298,6 +301,27 @@ public void reportsServerAddress() throws Exception {\n     checkReportsSpanOnTransportException();\n   }\n \n+  /**\n+   * This ensures custom finished span handlers can see the actual exception thrown, not just the\n+   * \"error\" tag value.\n+   */\n+  @Test public void finishedSpanHandlerSeesException() throws Exception {", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75369c851637b43c1ef5b3a7a3874469569c8869", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\nindex b5027bdfc..ff140ca63 100644\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\n+++ b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\n\n@@ -297,15 +298,42 @@ public abstract class ITHttpClient<C> extends ITHttp {\n       .isEqualTo(\"post\");\n   }\n \n+  @Test public void httpPathTagExcludesQueryParams() throws Exception {\n+    String path = \"/foo?z=2&yAA=1\";\n+\n+    server.enqueue(new MockResponse());\n+    get(client, path);\n+\n+    Span span = takeSpan();\n+    assertThat(span.tags())\n+      .containsEntry(\"http.path\", \"/foo\");\n+  }\n+\n+  @Test public void finishedSpanHandlerSeesException() throws Exception {\n+    finishedSpanHandlerSeesException(get());\n+  }\n+\n   @Test public void reportsSpanOnTransportException() throws Exception {\n-    checkReportsSpanOnTransportException();\n+    checkReportsSpanOnTransportException(get());\n+  }\n+\n+  @Test public void errorTag_onTransportException() throws Exception {\n+    Span span = checkReportsSpanOnTransportException(get());\n+    assertThat(span.tags()).containsKey(\"error\");\n+  }\n+\n+  Callable<Void> get() {\n+    return () -> {\n+      get(client, \"/foo\");\n+      return null;\n+    };\n   }\n \n   /**\n    * This ensures custom finished span handlers can see the actual exception thrown, not just the\n    * \"error\" tag value.\n    */\n-  @Test public void finishedSpanHandlerSeesException() throws Exception {\n+  void finishedSpanHandlerSeesException(Callable<Void> get) throws Exception {\n     AtomicReference<Throwable> caughtThrowable = new AtomicReference<>();\n     close();\n     httpTracing = HttpTracing.create(tracingBuilder(Sampler.ALWAYS_SAMPLE)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTE4Mw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380535183", "bodyText": "Just to confirm, we're adding this but may remove it later if we find it works well to pass the request into the response parser?", "author": "anuraaga", "createdAt": "2020-02-18T09:01:02Z", "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {\n+  /**\n+   * Like {@link HttpRequest#method()} except used in response parsing.\n+   *\n+   * <p>Notably, this is used to create a route-based span name.\n+   *\n+   * @since 5.10\n+   */\n+  @Nullable public String method() {", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwODg1Nw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380608857", "bodyText": "good point.. I'll put a TODO!", "author": "codefromthecrypt", "createdAt": "2020-02-18T11:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/http/src/main/java/brave/http/HttpResponse.java b/instrumentation/http/src/main/java/brave/http/HttpResponse.java\nindex 77d8dc083..a825ff1a5 100644\n--- a/instrumentation/http/src/main/java/brave/http/HttpResponse.java\n+++ b/instrumentation/http/src/main/java/brave/http/HttpResponse.java\n\n@@ -34,6 +34,7 @@ public abstract class HttpResponse extends Response {\n    *\n    * @since 5.10\n    */\n+  // TODO: see if we can return HttpRequest instead before cutting 5.10\n   @Nullable public String method() {\n     return null;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNTk1OA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380535958", "bodyText": "linkplain when rendering a code link as a normal English word.", "author": "anuraaga", "createdAt": "2020-02-18T09:02:28Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\nindex 8c74e84ba..67e0370ed 100644\n--- a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n+++ b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n\n@@ -40,14 +40,14 @@ public abstract class HttpServerRequest extends HttpRequest {\n \n   /**\n    * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n-   * information about the client from the {@link #unwrap() delegate}.\n+   * information about the client from the {@linkplain #unwrap() delegate}.\n    *\n-   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded\n-   * IP}. Override to add client socket information when forwarded info is not available.\n+   * <p>By default, this tries to parse the {@linkplain #parseClientIpFromXForwardedFor(Span)\n+   * forwarded IP}. Override to add client socket information when forwarded info is not available.\n    *\n-   * <p>Aside: the ability to parse socket information on server request objects is likely even if\n-   * it is not as likely on the client side. This is because client requests are often parsed before\n-   * a network route is chosen, whereas server requests are parsed after the network layer.\n+   * <p>Aside: It is more likely a server request object will be able to parse socket information\n+   * as opposed to a client object. This is because client requests are often parsed before a\n+   * network route is chosen, whereas server requests are parsed after the network layer.\n    *\n    * @return true if parsing was successful.\n    * @since 5.7\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjAxMA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380536010", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-02-18T09:02:34Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.\n    *\n-   * @see HttpServerAdapter#parseClientIpAndPort(Object, Span)\n+   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\nindex 8c74e84ba..67e0370ed 100644\n--- a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n+++ b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n\n@@ -40,14 +40,14 @@ public abstract class HttpServerRequest extends HttpRequest {\n \n   /**\n    * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n-   * information about the client from the {@link #unwrap() delegate}.\n+   * information about the client from the {@linkplain #unwrap() delegate}.\n    *\n-   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded\n-   * IP}. Override to add client socket information when forwarded info is not available.\n+   * <p>By default, this tries to parse the {@linkplain #parseClientIpFromXForwardedFor(Span)\n+   * forwarded IP}. Override to add client socket information when forwarded info is not available.\n    *\n-   * <p>Aside: the ability to parse socket information on server request objects is likely even if\n-   * it is not as likely on the client side. This is because client requests are often parsed before\n-   * a network route is chosen, whereas server requests are parsed after the network layer.\n+   * <p>Aside: It is more likely a server request object will be able to parse socket information\n+   * as opposed to a client object. This is because client requests are often parsed before a\n+   * network route is chosen, whereas server requests are parsed after the network layer.\n    *\n    * @return true if parsing was successful.\n    * @since 5.7\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjU1MQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380536551", "bodyText": "Not sure I parse this sentence well. Is it the same as It is more likely a server request object will be able to parse socket information as opposed to a client object.", "author": "anuraaga", "createdAt": "2020-02-18T09:03:35Z", "path": "instrumentation/http/src/main/java/brave/http/HttpServerRequest.java", "diffHunk": "@@ -39,13 +39,34 @@\n   }\n \n   /**\n-   * Override and return true when it is possible to parse the {@link Span#remoteIpAndPort(String,\n-   * int) remote IP and port} from the {@link #unwrap() delegate}. Defaults to false.\n+   * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n+   * information about the client from the {@link #unwrap() delegate}.\n    *\n-   * @see HttpServerAdapter#parseClientIpAndPort(Object, Span)\n+   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded\n+   * IP}. Override to add client socket information when forwarded info is not available.\n+   *\n+   * <p>Aside: the ability to parse socket information on server request objects is likely even if", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYxMDI2OA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380610268", "bodyText": "thanks for the help!", "author": "codefromthecrypt", "createdAt": "2020-02-18T11:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNjU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\nindex 8c74e84ba..67e0370ed 100644\n--- a/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n+++ b/instrumentation/http/src/main/java/brave/http/HttpServerRequest.java\n\n@@ -40,14 +40,14 @@ public abstract class HttpServerRequest extends HttpRequest {\n \n   /**\n    * Used by {@link HttpServerHandler#handleReceive(HttpServerRequest)} to add remote socket\n-   * information about the client from the {@link #unwrap() delegate}.\n+   * information about the client from the {@linkplain #unwrap() delegate}.\n    *\n-   * <p>By default, this tries to parse the {@link #parseClientIpFromXForwardedFor(Span) forwarded\n-   * IP}. Override to add client socket information when forwarded info is not available.\n+   * <p>By default, this tries to parse the {@linkplain #parseClientIpFromXForwardedFor(Span)\n+   * forwarded IP}. Override to add client socket information when forwarded info is not available.\n    *\n-   * <p>Aside: the ability to parse socket information on server request objects is likely even if\n-   * it is not as likely on the client side. This is because client requests are often parsed before\n-   * a network route is chosen, whereas server requests are parsed after the network layer.\n+   * <p>Aside: It is more likely a server request object will be able to parse socket information\n+   * as opposed to a client object. This is because client requests are often parsed before a\n+   * network route is chosen, whereas server requests are parsed after the network layer.\n    *\n    * @return true if parsing was successful.\n    * @since 5.7\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzODMxOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r380538319", "bodyText": "Almost commented this should be StringBuilder but realized it's not our API...", "author": "anuraaga", "createdAt": "2020-02-18T09:06:59Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/HttpServletRequestWrapper.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.servlet;\n+\n+import brave.Span;\n+import brave.http.HttpServerRequest;\n+import javax.servlet.http.HttpServletRequest;\n+\n+/**\n+ * Besides delegating to {@link HttpServletRequest} methods, this also parses the remote IP of the\n+ * client.\n+ *\n+ * @since 5.10\n+ */\n+// Public for use in sparkjava or other frameworks that re-use servlet types\n+public final class HttpServletRequestWrapper extends HttpServerRequest {\n+  /** @since 5.10 */\n+  public static HttpServerRequest create(HttpServletRequest request) {\n+    return new HttpServletRequestWrapper(request);\n+  }\n+\n+  final HttpServletRequest delegate;\n+\n+  HttpServletRequestWrapper(HttpServletRequest delegate) {\n+    if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+    this.delegate = delegate;\n+  }\n+\n+  /**\n+   * This sets the client IP:port to the {@linkplain HttpServletRequest#getRemoteAddr() remote\n+   * address} if the {@link #parseClientIpAndPort default parsing} fails.\n+   */\n+  @Override public boolean parseClientIpAndPort(Span span) {\n+    if (parseClientIpFromXForwardedFor(span)) return true;\n+    return span.remoteIpAndPort(delegate.getRemoteAddr(), delegate.getRemotePort());\n+  }\n+\n+  @Override public final String method() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override public final String path() {\n+    return delegate.getRequestURI();\n+  }\n+\n+  // not final as some implementations may be able to do this more efficiently\n+  @Override public String url() {\n+    StringBuffer url = delegate.getRequestURL();", "originalCommit": "e10bc86048561fb9e8814f98373ebd860de33b92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3ODA0Nw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381278047", "bodyText": "TODO: make this test as hard as the server ones (eventhough it will hurt). Right now, this only looks for existance of the \"error\" tag, which in the case of server, hid bugs.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:07:48Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -310,10 +334,15 @@ protected Span checkReportsSpanOnTransportException() throws InterruptedExceptio\n     return takeSpan();\n   }\n \n-  @Test public void addsErrorTagOnTransportException() throws Exception {\n+  @Test public void errorTag_onTransportException() throws Exception {", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75369c851637b43c1ef5b3a7a3874469569c8869", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\nindex b5027bdfc..ff140ca63 100644\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\n+++ b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java\n\n@@ -318,15 +346,15 @@ public abstract class ITHttpClient<C> extends ITHttp {\n       .build());\n     client = newClient(server.getPort());\n \n-    checkReportsSpanOnTransportException();\n+    checkReportsSpanOnTransportException(get);\n     assertThat(caughtThrowable.get()).isNotNull();\n   }\n \n-  protected Span checkReportsSpanOnTransportException() throws InterruptedException {\n+  Span checkReportsSpanOnTransportException(Callable<Void> get) throws InterruptedException {\n     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));\n \n     try {\n-      get(client, \"/foo\");\n+      get.call();\n     } catch (Exception e) {\n       // ok, but the span should include an error!\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3ODcxMQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381278711", "bodyText": "when I made the assertion actually look at content, I found most of our code didn't return what we thought it would.. rather it just set the http status.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:09:11Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -386,30 +390,82 @@ public void addsStatusCode_badRequest() throws Exception {\n       .containsEntry(\"error\", \"400\");\n   }\n \n+  /**\n+   * Some synchronous frameworks have limited means to adjust the HTTP status code upon raising an\n+   * exception. When this is the case, use the following built-in exception:\n+   *\n+   * <p><pre>{@code\n+   *   throw new UnavailableException(\"not ready\", 1); // implies 503\n+   * }</pre>\n+   */\n+  @Test\n+  public void httpStatusCodeTagMatchesResponse_onException() throws Exception {\n+    httpStatusCodeTagMatchesResponse_onException(\"/exception\");\n+  }\n+\n+  @Test\n+  public void httpStatusCodeTagMatchesResponse_onException_async() throws Exception {\n+    httpStatusCodeTagMatchesResponse_onException(\"/exceptionAsync\");\n+  }\n+\n+  Span httpStatusCodeTagMatchesResponse_onException(String path) throws Exception {\n+    Response response = get(path);\n+\n+    Span span = takeSpan();\n+    assertThat(span.tags())\n+      .containsEntry(\"http.status_code\", String.valueOf(response.code()));\n+\n+    return span;\n+  }\n+\n   @Test\n-  public void reportsSpanOnException() throws Exception {\n-    reportsSpanOnException(\"/exception\");\n+  public void errorTag_exceptionOverridesHttpStatus() throws Exception {\n+    errorTag_exceptionOverridesHttpStatus(\"/exception\");\n   }\n \n   @Test\n-  public void reportsSpanOnException_async() throws Exception {\n-    reportsSpanOnException(\"/exceptionAsync\");\n+  public void errorTag_exceptionOverridesHttpStatus_async() throws Exception {\n+    errorTag_exceptionOverridesHttpStatus(\"/exceptionAsync\");\n   }\n \n-  Span reportsSpanOnException(String path) throws Exception {\n+  void errorTag_exceptionOverridesHttpStatus(String path) throws Exception {\n     get(path);\n \n-    return takeSpan();\n+    Span span = takeSpan();\n+    assertThat(span.tags().get(\"error\"))\n+      .contains(\"not ready\"); // some controllers format the exception", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java\nindex cf4555a13..f3cb4c979 100644\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java\n+++ b/instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java\n\n@@ -390,31 +390,35 @@ public abstract class ITHttpServer extends ITHttp {\n       .containsEntry(\"error\", \"400\");\n   }\n \n-  /**\n-   * Some synchronous frameworks have limited means to adjust the HTTP status code upon raising an\n-   * exception. When this is the case, use the following built-in exception:\n-   *\n-   * <p><pre>{@code\n-   *   throw new UnavailableException(\"not ready\", 1); // implies 503\n-   * }</pre>\n-   */\n   @Test\n-  public void httpStatusCodeTagMatchesResponse_onException() throws Exception {\n-    httpStatusCodeTagMatchesResponse_onException(\"/exception\");\n+  public void reportsSpanOnException() throws Exception {\n+    reportsSpanOnException(\"/exception\");\n   }\n \n   @Test\n-  public void httpStatusCodeTagMatchesResponse_onException_async() throws Exception {\n-    httpStatusCodeTagMatchesResponse_onException(\"/exceptionAsync\");\n+  public void reportsSpanOnException_async() throws Exception {\n+    reportsSpanOnException(\"/exceptionAsync\");\n   }\n \n-  Span httpStatusCodeTagMatchesResponse_onException(String path) throws Exception {\n-    Response response = get(path);\n+  Span reportsSpanOnException(String path) throws Exception {\n+    get(path);\n \n-    Span span = takeSpan();\n-    assertThat(span.tags())\n-      .containsEntry(\"http.status_code\", String.valueOf(response.code()));\n+    return takeSpan();\n+  }\n+\n+  @Test\n+  public void errorTag_onException() throws Exception {\n+    errorTag_onException(\"/exception\");\n+  }\n \n+  @Test\n+  public void errorTag_onException_async() throws Exception {\n+    errorTag_onException(\"/exceptionAsync\");\n+  }\n+\n+  Span errorTag_onException(String path) throws Exception {\n+    Span span = reportsSpanOnException(path);\n+    assertThat(span.tags()).containsKey(\"error\");\n     return span;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3OTM5NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381279394", "bodyText": "this was a lot of time lost trying to figure out where it clobbers the code, only in sync errors, not async ones! :P", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:10:33Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java", "diffHunk": "@@ -71,9 +77,13 @@\n   }\n \n   static class ExceptionServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n-      throw new IOException(); // null exception message!\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+      throws UnavailableException {\n+      // Change the status from 500 to 503\n+      req.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, 503);\n+      // TODO: org.eclipse.jetty.server.HttpChannelState.onError() clobbers ^^ and hard-codes", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java b/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java\nindex 4f7c67859..4ffb9ab3c 100644\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java\n+++ b/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet25Container.java\n\n@@ -77,13 +71,9 @@ public abstract class ITServlet25Container extends ITServletContainer {\n   }\n \n   static class ExceptionServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n-      throws UnavailableException {\n-      // Change the status from 500 to 503\n-      req.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, 503);\n-      // TODO: org.eclipse.jetty.server.HttpChannelState.onError() clobbers ^^ and hard-codes\n-      // status based on servlet types.\n-      throw new UnavailableException(\"not ready\", 1 /* temporary implies 503 */);\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n+      throw new IOException(); // null exception message!\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4MDIwOQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381280209", "bodyText": "I have seen some tests out there that say they are testing onError when they are really testing timeout. beware!\nbelow, I prove onError works by switching the http status", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:12:11Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java", "diffHunk": "@@ -30,59 +34,88 @@\n public abstract class ITServlet3Container extends ITServlet25Container {\n   static ExecutorService executor = Executors.newCachedThreadPool();\n \n-  @AfterClass\n-  public static void shutdownExecutor() {\n-    executor.shutdownNow();\n+  public ITServlet3Container() {\n+    super(new Jetty9ServerController());\n   }\n \n-  static class AsyncServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n-      if (Tracing.currentTracer().currentSpan() == null) {\n-        throw new IllegalStateException(\"couldn't read current span!\");\n-      }\n-      AsyncContext ctx = req.startAsync();\n-      ctx.start(ctx::complete);\n-    }\n+  @AfterClass public static void shutdownExecutor() {\n+    executor.shutdownNow();\n   }\n \n-  @Test\n-  public void forward() throws Exception {\n+  @Test public void forward() throws Exception {\n     get(\"/forward\");\n \n     takeSpan();\n   }\n \n-  @Test\n-  public void forwardAsync() throws Exception {\n+  @Test public void forwardAsync() throws Exception {\n     get(\"/forwardAsync\");\n \n     takeSpan();\n   }\n \n   static class ForwardServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n       throws ServletException, IOException {\n       req.getServletContext().getRequestDispatcher(\"/foo\").forward(req, resp);\n     }\n   }\n \n   static class AsyncForwardServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n       AsyncContext asyncContext = req.startAsync(req, resp);\n       executor.execute(() -> asyncContext.dispatch(\"/async\"));\n     }\n   }\n \n+  static class AsyncServlet extends HttpServlet {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+      if (Tracing.currentTracer().currentSpan() == null) {\n+        throw new IllegalStateException(\"couldn't read current span!\");\n+      }\n+      AsyncContext ctx = req.startAsync();\n+      ctx.start(ctx::complete);\n+    }\n+  }\n+\n   static class ExceptionAsyncServlet extends HttpServlet {\n-    @Override\n-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+      if (DispatcherType.ERROR.equals(req.getDispatcherType())) return; // don't loop\n+\n+      AsyncContext async = req.startAsync();\n+      // unless we add a listener, the onError hook will never occur", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java b/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java\nindex f67accad5..63977975c 100644\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java\n+++ b/instrumentation/http-tests/src/main/java/brave/test/http/ITServlet3Container.java\n\n@@ -34,88 +30,59 @@ import org.junit.Test;\n public abstract class ITServlet3Container extends ITServlet25Container {\n   static ExecutorService executor = Executors.newCachedThreadPool();\n \n-  public ITServlet3Container() {\n-    super(new Jetty9ServerController());\n+  @AfterClass\n+  public static void shutdownExecutor() {\n+    executor.shutdownNow();\n   }\n \n-  @AfterClass public static void shutdownExecutor() {\n-    executor.shutdownNow();\n+  static class AsyncServlet extends HttpServlet {\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+      if (Tracing.currentTracer().currentSpan() == null) {\n+        throw new IllegalStateException(\"couldn't read current span!\");\n+      }\n+      AsyncContext ctx = req.startAsync();\n+      ctx.start(ctx::complete);\n+    }\n   }\n \n-  @Test public void forward() throws Exception {\n+  @Test\n+  public void forward() throws Exception {\n     get(\"/forward\");\n \n     takeSpan();\n   }\n \n-  @Test public void forwardAsync() throws Exception {\n+  @Test\n+  public void forwardAsync() throws Exception {\n     get(\"/forwardAsync\");\n \n     takeSpan();\n   }\n \n   static class ForwardServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n       throws ServletException, IOException {\n       req.getServletContext().getRequestDispatcher(\"/foo\").forward(req, resp);\n     }\n   }\n \n   static class AsyncForwardServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n       AsyncContext asyncContext = req.startAsync(req, resp);\n       executor.execute(() -> asyncContext.dispatch(\"/async\"));\n     }\n   }\n \n-  static class AsyncServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n-      if (Tracing.currentTracer().currentSpan() == null) {\n-        throw new IllegalStateException(\"couldn't read current span!\");\n-      }\n-      AsyncContext ctx = req.startAsync();\n-      ctx.start(ctx::complete);\n-    }\n-  }\n-\n   static class ExceptionAsyncServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n-      if (DispatcherType.ERROR.equals(req.getDispatcherType())) return; // don't loop\n-\n-      AsyncContext async = req.startAsync();\n-      // unless we add a listener, the onError hook will never occur\n-      async.addListener(new AsyncListener() {\n-        @Override public void onComplete(AsyncEvent event) {\n-        }\n-\n-        @Override public void onTimeout(AsyncEvent event) {\n-        }\n-\n-        @Override public void onError(AsyncEvent event) {\n-          // Change the status from 500 to 503\n-          req.setAttribute(RequestDispatcher.ERROR_STATUS_CODE, 503);\n-        }\n-\n-        @Override public void onStartAsync(AsyncEvent event) {\n-        }\n-      });\n-      throw new IllegalStateException(\"not ready\");\n-    }\n-  }\n-\n-  @Test public void errorTag_onException_asyncTimeout() throws Exception {\n-    httpStatusCodeTagMatchesResponse_onException(\"/exceptionAsyncTimeout\");\n-  }\n-\n-  static class TimeoutExceptionAsyncServlet extends HttpServlet {\n-    @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n-      if (DispatcherType.ERROR.equals(req.getDispatcherType())) return; // don't loop\n-\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n       AsyncContext ctx = req.startAsync();\n       ctx.setTimeout(1);\n       ctx.start(\n         () -> {\n-          resp.setStatus(504);\n           try {\n             Thread.sleep(10L);\n           } catch (InterruptedException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4MDY1NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381280654", "bodyText": "jetty 7 and 9 don't like eachother.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:13:05Z", "path": "instrumentation/http-tests/src/main/java/brave/test/http/Jetty9ServerController.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.test.http;\n+\n+import brave.test.http.ServletContainer.ServerController;\n+import org.eclipse.jetty.server.Connector;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+\n+public final class Jetty9ServerController implements ServerController {", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "chunk": "diff --git a/instrumentation/http-tests/src/main/java/brave/test/http/Jetty9ServerController.java b/instrumentation/http-tests/src/main/java/brave/test/http/Jetty9ServerController.java\ndeleted file mode 100644\nindex 568ceeb10..000000000\n--- a/instrumentation/http-tests/src/main/java/brave/test/http/Jetty9ServerController.java\n+++ /dev/null\n\n@@ -1,34 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.test.http;\n-\n-import brave.test.http.ServletContainer.ServerController;\n-import org.eclipse.jetty.server.Connector;\n-import org.eclipse.jetty.server.Server;\n-import org.eclipse.jetty.server.ServerConnector;\n-\n-public final class Jetty9ServerController implements ServerController {\n-  @Override public Server newServer(int port) {\n-    Server result = new Server();\n-    ServerConnector connector = new ServerConnector(result);\n-    connector.setPort(port);\n-    connector.setIdleTimeout(1000 * 60 * 60);\n-    result.setConnectors(new Connector[] {connector});\n-    return result;\n-  }\n-\n-  @Override public int getLocalPort(Server server) {\n-    return ((ServerConnector) server.getConnectors()[0]).getLocalPort();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NDEyNw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381284127", "bodyText": "this magically became needed when I upgraded from jetty 8 to 9.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:20:05Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.servlet;\n+\n+import brave.http.HttpServerResponse;\n+import brave.internal.Nullable;\n+import brave.servlet.internal.ServletRuntime;\n+import javax.servlet.UnavailableException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import static brave.servlet.internal.ServletRuntime.maybeError;\n+\n+/**\n+ * This delegates to {@link HttpServletResponse} methods, taking care to portably handle {@link\n+ * #statusCode()}.\n+ *\n+ * @since 5.10\n+ */\n+// Public for use in sparkjava or other frameworks that re-use servlet types\n+public class HttpServletResponseWrapper extends HttpServerResponse { // not final for inner subtype\n+  /**\n+   * Looks for the {@link HttpServletRequest#setAttribute(String, Object) request attributes}\n+   * \"http.route\" and \"error\" to customize the result.\n+   *\n+   * @param caught an exception caught serving the request.\n+   * @since 5.10\n+   */\n+  public static HttpServerResponse create(@Nullable HttpServletRequest req,\n+    HttpServletResponse res, @Nullable Throwable caught) {\n+    if (req == null) return new HttpServletResponseWrapper(res, caught);\n+    return new WithRequestProperties(req, res, caught);\n+  }\n+\n+  final HttpServletResponse delegate;\n+  @Nullable final Throwable caught;\n+\n+  HttpServletResponseWrapper(HttpServletResponse delegate, @Nullable Throwable caught) {\n+    if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+    this.delegate = delegate;\n+    this.caught = caught;\n+  }\n+\n+  @Override public int statusCode() {\n+    int result = ServletRuntime.get().status(delegate);\n+    if (caught != null && result == 200) { // We may have a potentially bad status due to defaults", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "chunk": "diff --git a/instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java b/instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java\nindex 1ae9a4735..dde6c544a 100644\n--- a/instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java\n+++ b/instrumentation/servlet/src/main/java/brave/servlet/HttpServletResponseWrapper.java\n\n@@ -16,7 +16,6 @@ package brave.servlet;\n import brave.http.HttpServerResponse;\n import brave.internal.Nullable;\n import brave.servlet.internal.ServletRuntime;\n-import javax.servlet.UnavailableException;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTI5Mw==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381285293", "bodyText": "This stuff addresses #851 thanks @nicmunroe @felixbarny @eyalkoren", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:22:23Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,54 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n+      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n       TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) return; // already completed\n+        HttpServletRequest req = (HttpServletRequest) e.getSuppliedRequest();\n+        HttpServletResponse res = (HttpServletResponse) e.getSuppliedResponse();\n+        HttpServerResponse response =\n+          brave.servlet.HttpServletResponseWrapper.create(req, res, e.getThrowable());\n+        handler.handleSend(response, response.error(), span);\n       }\n \n+      // Per Servlet 3 section 2.3.3.3, we can't see the final HTTP status, yet. defer to onComplete", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java b/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\nindex 8ec55b9d3..c2b5f0d3c 100644\n--- a/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\n+++ b/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\n\n@@ -103,10 +103,8 @@ public abstract class ServletRuntime {\n       final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n       final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n-      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n-      TracingAsyncListener(\n-        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n+      TracingAsyncListener(HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTczMg==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381285732", "bodyText": "I noticed timeout hitting many times in the same request, but I might double-check this before merge.", "author": "codefromthecrypt", "createdAt": "2020-02-19T13:23:14Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,54 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n+      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n       TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) return; // already completed\n+        HttpServletRequest req = (HttpServletRequest) e.getSuppliedRequest();\n+        HttpServletResponse res = (HttpServletResponse) e.getSuppliedResponse();\n+        HttpServerResponse response =\n+          brave.servlet.HttpServletResponseWrapper.create(req, res, e.getThrowable());\n+        handler.handleSend(response, response.error(), span);\n       }\n \n+      // Per Servlet 3 section 2.3.3.3, we can't see the final HTTP status, yet. defer to onComplete\n+      // https://download.oracle.com/otndocs/jcp/servlet-3.0-mrel-eval-oth-JSpec/\n       @Override public void onTimeout(AsyncEvent e) {\n-        if (complete) return;\n-        span.tag(\"error\", String.format(\"Timed out after %sms\", e.getAsyncContext().getTimeout()));\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!timeout.compareAndSet(false, true)) return; // already timed out", "originalCommit": "6b0b093a1f27b9922c14086d5786a6451613caf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMDY1NA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381630654", "bodyText": "we weren't and what we are doing in this callback isn't worth guarding", "author": "codefromthecrypt", "createdAt": "2020-02-20T00:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTczMg=="}], "type": "inlineReview", "revised_code": {"commit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "chunk": "diff --git a/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java b/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\nindex 8ec55b9d3..c2b5f0d3c 100644\n--- a/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\n+++ b/instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java\n\n@@ -103,10 +103,8 @@ public abstract class ServletRuntime {\n       final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n       final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n-      final AtomicBoolean timeout = new AtomicBoolean(); // multiple timeout events can occur\n \n-      TracingAsyncListener(\n-        HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n+      TracingAsyncListener(HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n"}}, {"oid": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "url": "https://github.com/openzipkin/brave/commit/5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "message": "polishing", "committedDate": "2020-02-20T00:26:55Z", "type": "forcePushed"}, {"oid": "9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "url": "https://github.com/openzipkin/brave/commit/9b27a5cdba3c86d962d713a3c8b830d4d648df8e", "message": "Introduces `Response.error()` and uses it in HTTP abstraction\n\nThis introduces `Response.error()`, present when there was an exception\ninvoking a client request, or processing a server request. This also\nensures that `FinishedSpanHandler` can read it independently of the\n\"error\" tag.\n\nThis implied retro-fitting this in the HTTP abstraction and backfilling\ntests that tell the difference between HTTP status and a parsed\nexception. This identified a gap in Servlet libraries which formerly\nswallowed application level exceptions. To bridge that gap, we now\nlook at the request attribute \"error\" when ending a server span.", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "b29bae0fe830385230e1266a64c2bc95421492ef", "url": "https://github.com/openzipkin/brave/commit/b29bae0fe830385230e1266a64c2bc95421492ef", "message": "also async eats it", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "79cd5099f3030c1ca2a3e52074db59e76b540578", "url": "https://github.com/openzipkin/brave/commit/79cd5099f3030c1ca2a3e52074db59e76b540578", "message": "spark over servlet needs work", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "da68ac4e8171c496fdeac3be46f50ada43db4ebb", "url": "https://github.com/openzipkin/brave/commit/da68ac4e8171c496fdeac3be46f50ada43db4ebb", "message": "because we love dates", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "6c41602c8e9d096ceeb301a8493e0fdd2d417b1c", "url": "https://github.com/openzipkin/brave/commit/6c41602c8e9d096ceeb301a8493e0fdd2d417b1c", "message": "spark bug", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "ef72f0cf2e5a7a966d840978ba876ee1e8ce5769", "url": "https://github.com/openzipkin/brave/commit/ef72f0cf2e5a7a966d840978ba876ee1e8ce5769", "message": "Update brave/src/main/java/brave/Response.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "97417231534db67ce204cd7819029bbb1f9aee7e", "url": "https://github.com/openzipkin/brave/commit/97417231534db67ce204cd7819029bbb1f9aee7e", "message": "feedback", "committedDate": "2020-02-20T00:26:54Z", "type": "commit"}, {"oid": "af16e223a4dbadd9ff5bf71c2ca50b9a63bb1fc2", "url": "https://github.com/openzipkin/brave/commit/af16e223a4dbadd9ff5bf71c2ca50b9a63bb1fc2", "message": "feedback", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "4fe976c36420845ed84791c140a3fa97d579cc29", "url": "https://github.com/openzipkin/brave/commit/4fe976c36420845ed84791c140a3fa97d579cc29", "message": "immense pain caused by asserting we don't return garbage", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "01f5285815f1c9685ec5fd8370b49f7753f1ac0c", "url": "https://github.com/openzipkin/brave/commit/01f5285815f1c9685ec5fd8370b49f7753f1ac0c", "message": "v is for vertx", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"oid": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "url": "https://github.com/openzipkin/brave/commit/5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "message": "polishing", "committedDate": "2020-02-20T00:26:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r381631155", "bodyText": "@nicmunroe @felixbarny PS I did something special to execute the entire suite and fail if this ever was the case.. it never was. Right now, I know I've been told this could be re-entrant, but I'd like to see what test we are missing. Or if any of you have a test that proves it is re-entrant?", "author": "codefromthecrypt", "createdAt": "2020-02-20T00:48:03Z", "path": "instrumentation/servlet/src/main/java/brave/servlet/internal/ServletRuntime.java", "diffHunk": "@@ -91,43 +92,55 @@ private static ServletRuntime findServletRuntime() {\n     }\n \n     @Override public void handleAsync(\n-      HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n       HttpServletRequest request, HttpServletResponse response, Span span) {\n       if (span.isNoop()) return; // don't add overhead when we aren't httpTracing\n       TracingAsyncListener listener = new TracingAsyncListener(handler, span);\n       request.getAsyncContext().addListener(listener, request, response);\n     }\n \n     static final class TracingAsyncListener implements AsyncListener {\n-      final HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler;\n+      final HttpServerHandler<HttpServerRequest, HttpServerResponse> handler;\n       final Span span;\n-      volatile boolean complete; // multiple async events can occur, only complete once\n+      final AtomicBoolean complete = new AtomicBoolean(); // multiple async events can occur\n \n-      TracingAsyncListener(\n-        HttpServerHandler<brave.http.HttpServerRequest, brave.http.HttpServerResponse> handler,\n+      TracingAsyncListener(HttpServerHandler<HttpServerRequest, HttpServerResponse> handler,\n         Span span\n       ) {\n         this.handler = handler;\n         this.span = span;\n       }\n \n       @Override public void onComplete(AsyncEvent e) {\n-        if (complete) return;\n-        handler.handleSend(httpServerResponse(e), null, span);\n-        complete = true;\n+        if (!complete.compareAndSet(false, true)) {\n+          // TODO: None of our tests reach this condition. Make a concrete case that re-enters the", "originalCommit": "5aa489ec70b6bdc80c3cd39967f0d974b8cf3d41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNzcwOA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r382707708", "bodyText": "@adriancole I can't remember if I've ever seen it be reentrant in practice. But it's servlet, so my cynical side says it's always possible. Even if you find something in the servlet spec that says impls shouldn't do it, I bet there's some framework that does either due to a bug or because they didn't realize they shouldn't or they feel like they have a use case that warrants it. That's all FUD - I don't have any concrete examples. But I wouldn't be surprised in the least. The question is whether it's worth the extra bulletproofing if we can't find a way to reproduce it. I don't have a good answer on that one.\nSo I don't really have any advice on this one, sorry. I think there are defensible arguments for going either way.", "author": "nicmunroe", "createdAt": "2020-02-21T17:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MjAwMA==", "url": "https://github.com/openzipkin/brave/pull/1085#discussion_r382862000", "bodyText": "Thanks for the feedback Nic! in our case, the only impact to doing this twice is overhead, because this is on the finish hook not the start hook (eg it won't leak a span). In this case, and as I can't reproduce it normally, I'm inclined to remove the bullet-proofing, maybe mentioning that there's no impact to calling twice (and a test to prove it)", "author": "codefromthecrypt", "createdAt": "2020-02-22T00:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYzMTE1NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "75369c851637b43c1ef5b3a7a3874469569c8869", "url": "https://github.com/openzipkin/brave/commit/75369c851637b43c1ef5b3a7a3874469569c8869", "message": "hardens http client tests", "committedDate": "2020-02-20T03:29:46Z", "type": "commit"}]}