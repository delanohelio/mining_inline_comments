{"pr_number": 1183, "pr_title": "Adds local field redaction and decouples \"extra\" handling from baggage", "pr_createdAt": "2020-05-02T08:02:55Z", "pr_url": "https://github.com/openzipkin/brave/pull/1183", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTIxMQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929211", "bodyText": "this is the best part of the change. Now the codec needn't do work BaggagePropagation should be doing. Notably, it shouldn't ever even see local fields.", "author": "codefromthecrypt", "createdAt": "2020-05-02T08:11:24Z", "path": "brave/src/test/java/brave/features/baggage/BaggageInSingleHeaderTest.java", "diffHunk": "@@ -38,10 +38,7 @@\n       .injectFormat(B3Propagation.Format.SINGLE).build())\n       .add(SingleBaggageField.remote(field1))\n       .add(SingleBaggageField.local(field2))\n-      .add(InternalBaggage.instance.newBaggagePropagationConfig(\n-          // BaggageCodec can see every baggage field, so it must be told what to not serialize\n-          SingleHeaderCodec.newBuilder().blacklistField(field2).build()\n-      ))\n+      .add(InternalBaggage.instance.newBaggagePropagationConfig(SingleHeaderCodec.get()))", "originalCommit": "618dc6d3cd282c4773bc911cf401c603d2c6104a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTQ1OQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929459", "bodyText": "It is important to understand that with or without dynamic fields, something like a consolidated header is possible. All \"dynamic does\" is allow you to use fields not whitelisted in BaggagePropagation setup. Encode/decode is decoupled from these details now, especially in a follow-up change that will remove the \"extra\" parameter from decode.", "author": "codefromthecrypt", "createdAt": "2020-05-02T08:14:13Z", "path": "brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java", "diffHunk": "@@ -77,7 +46,9 @@ public BaggageCodec build() {\n   }\n \n   @Override public boolean decode(ExtraBaggageFields extra, Object request, String value) {\n-    assert extra.isDynamic() : \"This is unlikely to work with fixed fields!\";\n+    if (!extra.isDynamic()) {", "originalCommit": "618dc6d3cd282c4773bc911cf401c603d2c6104a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java b/brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java\nindex df1851c3d..b73abbc76 100644\n--- a/brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java\n+++ b/brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java\n\n@@ -45,26 +44,20 @@ final class SingleHeaderCodec implements BaggageCodec {\n     return keyNames;\n   }\n \n-  @Override public boolean decode(ExtraBaggageFields extra, Object request, String value) {\n-    if (!extra.isDynamic()) {\n-      // This will drop values not in the whitelist!\n-    }\n+  @Override public boolean decode(ValueUpdater valueUpdater, Object request, String value) {\n     boolean decoded = false;\n-    for (String entry : value.split(\",\")) {\n+    for (String entry : value.split(\",\", -1)) {\n       String[] keyValue = entry.split(\"=\", 2);\n-      if (extra.updateValue(BaggageField.create(keyValue[0]), keyValue[1])) decoded = true;\n+      if (valueUpdater.updateValue(BaggageField.create(keyValue[0]), keyValue[1])) decoded = true;\n     }\n     return decoded;\n   }\n \n-  @Override\n-  public String encode(Map<BaggageField, String> values, TraceContext context, Object request) {\n+  @Override public String encode(Map<String, String> values, TraceContext context, Object request) {\n     StringBuilder result = new StringBuilder();\n-    for (Entry<BaggageField, String> entry : values.entrySet()) {\n-      if (entry.getValue() != null) {\n-        if (result.length() > 0) result.append(',');\n-        result.append(entry.getKey().name()).append('=').append(entry.getValue());\n-      }\n+    for (Map.Entry<String, String> entry : values.entrySet()) {\n+      if (result.length() > 0) result.append(',');\n+      result.append(entry.getKey()).append('=').append(entry.getValue());\n     }\n     return result.length() == 0 ? null : result.toString();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTgwNQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929805", "bodyText": "even though  UnsafeArrayMap is package private and only used to implement baggage fields. I kept it a generic map type as it makes testing easier. In other words, that this takes arbitrary generic type params != a plan to expose this. Mostly UnsafeArrayMap allows us to safely share views of all baggage state without copying arrays or values into new map.", "author": "codefromthecrypt", "createdAt": "2020-05-02T08:17:11Z", "path": "brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import org.assertj.core.api.AbstractMapAssert;\n+import org.junit.Test;\n+\n+import static java.util.Arrays.asList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class UnsafeArrayMapTest {", "originalCommit": "618dc6d3cd282c4773bc911cf401c603d2c6104a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java b/brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java\nindex 276d2513e..7816bf9b7 100644\n--- a/brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java\n+++ b/brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java\n\n@@ -14,10 +14,10 @@\n package brave.internal.baggage;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Set;\n-import org.assertj.core.api.AbstractMapAssert;\n import org.junit.Test;\n \n import static java.util.Arrays.asList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzgxMA==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418937810", "bodyText": "Would use !filtered instead of continue", "author": "anuraaga", "createdAt": "2020-05-02T09:45:21Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzk2MQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418937961", "bodyText": "Might use a counter instead too\nnumFiltered++;\nif (numFiltered == 0) return this;\nif (numFiltered == toIndex / 2) return EMPTY", "author": "anuraaga", "createdAt": "2020-05-02T09:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MjcwNg==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418942706", "bodyText": "I was hoping to figure out how to check a bitset masks N bits, which would avoid the need for another counter. until then, I think you are right, a counter is fine.", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODE1OQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938159", "bodyText": "Can we use Collections.emptyMap() instead and remove the size == 0 special casing?", "author": "anuraaga", "createdAt": "2020-05-02T09:48:50Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MjQ0Mg==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418942442", "bodyText": "I think we can now. before we had keyList() which wasnt on empty map. good eye", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MzgxNw==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418943817", "bodyText": "I can make things only return map as long as filterKeys becomes a static method. will do that as I think it is better.", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODM1Mg==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938352", "bodyText": "This this method is only called in one place. I'd remove it mainly since the toIndex shadow is a bit unclear (or otherwise would make this static and accept all the parameters instead)", "author": "anuraaga", "createdAt": "2020-05-02T09:50:51Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MjQ2Nw==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418942467", "bodyText": "I think you caught another relic of list :) will change", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODQ5MQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938491", "bodyText": "The element at array index i is array[i] by definition of arrays :) Perhaps entryIndex?", "author": "anuraaga", "createdAt": "2020-05-02T09:52:14Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MjUwOA==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418942508", "bodyText": "another list relic! there were indexOf methods before axing :)", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0MzA4Nw==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418943087", "bodyText": "oh this isn't a relic. This is a trick that lets you use the same array to handle different types. Will add a comment.", "author": "codefromthecrypt", "createdAt": "2020-05-02T10:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODgzOQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938839", "bodyText": "Believe you can use arrayIndexOfKey and check result + 1 equals that.getValue() since not a multimap. That will fix that this doesn't seem to take into account filtered keys too", "author": "anuraaga", "createdAt": "2020-05-02T09:55:44Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {\n+      return (V) array[i + 1];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+  }\n+\n+  final class EntrySetView extends CollectionView<Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+    EntrySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override Map.Entry<K, V> elementAtArrayIndex(int i) {\n+      return new Entry<>((K) array[i], (V) array[i + 1]);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      if (!(o instanceof Map.Entry) || ((Map.Entry) o).getKey() == null) return false;\n+      Map.Entry that = (Map.Entry) o;\n+      for (int i = 0; i < toIndex; i += 2) {", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDQ0MQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418944441", "bodyText": "good one!", "author": "codefromthecrypt", "createdAt": "2020-05-02T11:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzOTMxNQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418939315", "bodyText": "Didn't think about the performance implications, but what could we save and where would we lose some performance if implementing AbstractMap?", "author": "anuraaga", "createdAt": "2020-05-02T10:00:51Z", "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {\n+      return (V) array[i + 1];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+  }\n+\n+  final class EntrySetView extends CollectionView<Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+    EntrySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override Map.Entry<K, V> elementAtArrayIndex(int i) {\n+      return new Entry<>((K) array[i], (V) array[i + 1]);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      if (!(o instanceof Map.Entry) || ((Map.Entry) o).getKey() == null) return false;\n+      Map.Entry that = (Map.Entry) o;\n+      for (int i = 0; i < toIndex; i += 2) {\n+        if (that.getKey().equals(array[i]) && equal(that.getValue(), array[i + 1])) return true;\n+      }\n+      return false;\n+    }\n+  }\n+\n+  abstract class CollectionView<E> implements Collection<E> {\n+    final int fromIndex, toIndex, size;\n+\n+    protected CollectionView(int fromIndex, int toIndex) {\n+      this.fromIndex = fromIndex;\n+      this.toIndex = toIndex;\n+      this.size = calculateSize(fromIndex, toIndex);\n+    }\n+\n+    int advancePastFiltered(int i) {\n+      while (i < toIndex && isFilteredKey(i)) i += 2;\n+      return i;\n+    }\n+\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    abstract E elementAtArrayIndex(int i);\n+\n+    @Override public Iterator<E> iterator() {\n+      return new ReadOnlyIterator();\n+    }\n+\n+    @Override public Object[] toArray() {\n+      return copyTo(new Object[size]);\n+    }\n+\n+    @Override public <T> T[] toArray(T[] a) {\n+      T[] result = a.length >= size ? a\n+          : (T[]) Array.newInstance(a.getClass().getComponentType(), size());\n+      return copyTo(result);\n+    }\n+\n+    <T> T[] copyTo(T[] dest) {\n+      for (int i = fromIndex, d = 0; i < toIndex; i += 2) {\n+        if (isFilteredKey(i)) continue;\n+        dest[d++] = (T) elementAtArrayIndex(i);\n+      }\n+      return dest;\n+    }\n+\n+    final class ReadOnlyIterator implements Iterator<E> {\n+      int i = advancePastFiltered(fromIndex);\n+\n+      @Override public boolean hasNext() {\n+        i = advancePastFiltered(i);\n+        return i < toIndex;\n+      }\n+\n+      @Override public E next() {\n+        if (!hasNext()) throw new NoSuchElementException();\n+        E result = elementAtArrayIndex(i);\n+        i += 2;\n+        return result;\n+      }\n+\n+      @Override public void remove() {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+\n+    @Override public boolean containsAll(Collection<?> c) {\n+      if (c == null) return false;\n+      if (c.isEmpty()) return true;\n+\n+      for (Object element : c) {\n+        if (!contains(element)) return false;\n+      }\n+      return true;\n+    }\n+\n+    @Override public boolean isEmpty() {\n+      return size == 0;\n+    }\n+\n+    @Override public boolean add(E e) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean remove(Object o) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean addAll(Collection<? extends E> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean retainAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean removeAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public void clear() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  static final class Entry<K, V> implements Map.Entry<K, V> {", "originalCommit": "cb98a5a8164fe32f27a868650a60dcfae2a7733c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDMyOQ==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418944329", "bodyText": "yeah I think you answered your own question. we'd need to override their crappy impls like\n    public int size() {\n        return entrySet().size();\n    }\n\nanyway next change that clears all the last relics of list is much smaller, so it might be moot", "author": "codefromthecrypt", "createdAt": "2020-05-02T11:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzOTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NjI3MA==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418946270", "bodyText": "the longer answer I can put in RATIONALE also. Basically all operations in abstract map are criminally inefficient if we think we are providing a cheap view over an array. everything allocates something. The neat thing here is most things are lazy. ex \"containsX\" methods don't have to allocate anything. we don't do things like allocate both an entryset and an iterator to implement get() etc. Finally, not extending abstractmap allows us to better verify that the code is doing what it should be doing (especially now that there is less code thanks to you!)", "author": "codefromthecrypt", "createdAt": "2020-05-02T11:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzOTMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzMDIzNw==", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r419030237", "bodyText": "added rationale!", "author": "codefromthecrypt", "createdAt": "2020-05-03T01:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzOTMxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6967d775aa5548360bf0729796e88191cd3fe2ad", "chunk": "diff --git a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\nindex f9f7ffb19..9342e8f18 100644\n--- a/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n+++ b/brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java\n\n@@ -13,8 +13,8 @@\n  */\n package brave.internal.baggage;\n \n-import brave.internal.Nullable;\n import java.lang.reflect.Array;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n"}}, {"oid": "6967d775aa5548360bf0729796e88191cd3fe2ad", "url": "https://github.com/openzipkin/brave/commit/6967d775aa5548360bf0729796e88191cd3fe2ad", "message": "Adds local field redaction and decouples \"extra\" handling from baggage", "committedDate": "2020-05-04T07:07:09Z", "type": "forcePushed"}, {"oid": "6967d775aa5548360bf0729796e88191cd3fe2ad", "url": "https://github.com/openzipkin/brave/commit/6967d775aa5548360bf0729796e88191cd3fe2ad", "message": "Adds local field redaction and decouples \"extra\" handling from baggage", "committedDate": "2020-05-04T07:07:09Z", "type": "commit"}, {"oid": "bc5e1b5a207662bf9d598ff79d04123582ac2428", "url": "https://github.com/openzipkin/brave/commit/bc5e1b5a207662bf9d598ff79d04123582ac2428", "message": "rationale drift", "committedDate": "2020-05-04T07:29:42Z", "type": "commit"}]}