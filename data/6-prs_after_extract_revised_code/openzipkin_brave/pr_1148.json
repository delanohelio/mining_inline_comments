{"pr_number": 1148, "pr_title": "Adds SpanHandler", "pr_createdAt": "2020-04-10T10:32:28Z", "pr_url": "https://github.com/openzipkin/brave/pull/1148", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMjc1Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r406702757", "bodyText": "yay we can implement child_span_count in the future with a native brave SpanHandler for stackdriver\ncc @meltsufin @saturnism\nhttps://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span", "author": "codefromthecrypt", "createdAt": "2020-04-10T10:35:14Z", "path": "brave/src/test/java/brave/features/handler/CountingChildrenTest.java", "diffHunk": "@@ -103,7 +104,7 @@\n     assertThat(spans)\n       .extracting(Span::name, s -> s.tags().get(\"childCount\"))\n       .containsExactly(\n-        tuple(\"root1\", \"0\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")\n+        tuple(\"root1\", \"2\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")", "originalCommit": "b4bd7d0ae5ee4a81fb70a9958d7478506572b912", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NzU2Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r406987563", "bodyText": "neat!", "author": "saturnism", "createdAt": "2020-04-10T23:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMjc1Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "09c5bf58f41e59b7342a653c9024718027ca9b27", "url": "https://github.com/openzipkin/brave/commit/09c5bf58f41e59b7342a653c9024718027ca9b27", "message": "WIP span handler", "committedDate": "2020-04-11T09:33:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTAwNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407051005", "bodyText": "This is the important file", "author": "codefromthecrypt", "createdAt": "2020-04-11T11:12:40Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**", "originalCommit": "58e986d8c7b4bb3e3732f8184fa0eef4e5641e92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex 4ff619d95..c6a6685ed 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -20,18 +20,21 @@ import java.lang.ref.WeakReference;\n \n /**\n  * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a is created or abandoned. The purpose of this type is to allow tracking of children, or\n- * partitioning of data for backend that needs to see an entire {@linkplain\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n  * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n  * on the same thread as application code. That said, there are some rules to keep in mind below.\n  *\n- * <p>The {@link TraceContext} parameter will be the same reference for all callbacks, except\n- * {@link #onOrphan}, which has value, but not reference equality.\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n  *\n  * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n- * holding up garbage collection. Do not cache the {@link MutableSpan} parameter.\n+ * holding up garbage collection.\n  */\n public class SpanListener {\n   /** Use to avoid comparing against null references */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjcxNg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407052716", "bodyText": "PS I plan to shade @raphw's https://github.com/raphw/weak-lock-free/blob/master/src/main/java/com/blogspot/mydailyjava/weaklockfree/WeakConcurrentMap.java into the core jar to support orphan tracker as it is much nicer to use a weak map instead of a hacky field. The code is small (won't make the jar too big), has the same bytecode level as us (Java 6) and stable. We can cite it in the NOTICE file.\nIf you think this is a bad idea, do scream at some point :D", "author": "codefromthecrypt", "createdAt": "2020-04-11T11:31:40Z", "path": "brave/src/main/java/brave/internal/recorder/OrphanTracker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.recorder;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.InternalHandler;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+// TODO make a weak map of MutableSpan -> Throwable instead of a hacky field in MutableSpan", "originalCommit": "91900f1552c9be81a89bcc03443f77deffec30e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1ODk0OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407158948", "bodyText": "I started to do this, then realized we had hacked this quite a bit in PendingSpans, and also shading adds a lot of complexity and also the class is quite bigger than ours anyway. I cleaned up our variant instead here #1152", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "chunk": "diff --git a/brave/src/main/java/brave/internal/recorder/OrphanTracker.java b/brave/src/main/java/brave/internal/recorder/OrphanTracker.java\nindex f79fa08dd..323c04693 100644\n--- a/brave/src/main/java/brave/internal/recorder/OrphanTracker.java\n+++ b/brave/src/main/java/brave/internal/recorder/OrphanTracker.java\n\n@@ -13,21 +13,27 @@\n  */\n package brave.internal.recorder;\n \n+import brave.Tracing;\n import brave.handler.MutableSpan;\n import brave.handler.SpanListener;\n-import brave.internal.InternalHandler;\n import brave.internal.Platform;\n+import brave.internal.weaklockfree.WeakConcurrentMap;\n import brave.propagation.TraceContext;\n \n-// TODO make a weak map of MutableSpan -> Throwable instead of a hacky field in MutableSpan\n+/** Internal support class for {@link Tracing.Builder#trackOrphans()}. */\n public final class OrphanTracker extends SpanListener {\n-  @Override public void onCreate(TraceContext parent, TraceContext context, MutableSpan span) {\n-    InternalHandler.instance.caller(span,\n+  final WeakConcurrentMap<MutableSpan, Throwable> spanToCaller = new WeakConcurrentMap<>();\n+\n+  @Override\n+  public void onCreate(TraceContext parent, TraceContext context, MutableSpan span) {\n+    Throwable oldCaller = spanToCaller.putIfProbablyAbsent(span,\n       new Throwable(\"Thread \" + Thread.currentThread().getName() + \" allocated span here\"));\n+    assert oldCaller == null :\n+      \"Bug: unexpected to have an existing reference to a new MutableSpan!\";\n   }\n \n   @Override public void onOrphan(TraceContext context, MutableSpan span) {\n-    Throwable caller = InternalHandler.instance.caller(span);\n+    Throwable caller = spanToCaller.getIfPresent(span);\n     if (caller != null) {\n       String message = span.isEmpty()\n         ? \"Span \" + context + \" was allocated but never used\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzMxOA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143318", "bodyText": "abstract? Even in NOOP we subclass it :)", "author": "anuraaga", "createdAt": "2020-04-12T04:16:15Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1OTM4MA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407159380", "bodyText": "sgtm", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzMxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzU1Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143556", "bodyText": "is incomplete", "author": "anuraaga", "createdAt": "2020-04-12T04:19:33Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143619", "bodyText": "One of the following will be called later when the created span is no longer in use.", "author": "anuraaga", "createdAt": "2020-04-12T04:20:13Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY0Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143647", "bodyText": "Currently I was surprised since it reads like these are called right away", "author": "anuraaga", "createdAt": "2020-04-12T04:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY3Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143672", "bodyText": "I guess it instead of this", "author": "anuraaga", "createdAt": "2020-04-12T04:21:02Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143942", "bodyText": "Not sure if it's necessarily better, but I was sort of expecting there to just be one implementation of SafeSpanListener and this would actually be a SpanListener. We could possibly make it public too since it could be helpful for users to be able to combine multiple listeners but don't have to right now.", "author": "anuraaga", "createdAt": "2020-04-12T04:24:49Z", "path": "brave/src/main/java/brave/internal/handler/SafeSpanListener.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+import java.util.Arrays;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/** This logs exceptions instead of raising an error, as the supplied listener could have bugs. */\n+public abstract class SafeSpanListener extends SpanListener {\n+  // Array ensures no iterators are created at runtime\n+  public static SpanListener create(SpanListener[] handlers) {\n+    if (handlers.length == 0) return SpanListener.NOOP;\n+    if (handlers.length == 1) return new Single(handlers[0]);\n+    return new Multiple(handlers);\n+  }\n+\n+  @Override\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+    try {\n+      doOnCreate(parent, context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling create {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onAbandon(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnAbandon(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling abandon {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFlush(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFlush(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling flush {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onOrphan(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnOrphan(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling orphan {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFinish(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFinish(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling finish {0}\", context, t);\n+    }\n+  }\n+\n+  abstract void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span);\n+\n+  abstract void doOnAbandon(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFlush(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnOrphan(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFinish(TraceContext context, MutableSpan span);\n+\n+  static final class Single extends SafeSpanListener {\n+    final SpanListener delegate;\n+\n+    Single(SpanListener delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+      delegate.onCreate(parent, context, span);\n+    }\n+\n+    @Override void doOnAbandon(TraceContext context, MutableSpan span) {\n+      delegate.onAbandon(context, span);\n+    }\n+\n+    @Override void doOnFlush(TraceContext context, MutableSpan span) {\n+      delegate.onFlush(context, span);\n+    }\n+\n+    @Override void doOnOrphan(TraceContext context, MutableSpan span) {\n+      delegate.onOrphan(context, span);\n+    }\n+\n+    @Override void doOnFinish(TraceContext context, MutableSpan span) {\n+      delegate.onFinish(context, span);\n+    }\n+\n+    @Override public String toString() {\n+      return delegate.toString();\n+    }\n+  }\n+\n+  static final class Multiple extends SafeSpanListener {", "originalCommit": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1OTMzNw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407159337", "bodyText": "I see what you mean.. good idea on only one safe thing.. I can go back and address the others.\nI don't think we're ready to support user-side compositing as it is unlikely they will do a better job than we would. Probably better for us to just say \"don't composite on your own\" then wait for a scream? (this would apply to the several other places we do similar compositing). Not doing user-level compositing also keeps the api sprawl down.. brave's already collecting quite a number of public types...", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDAwMw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407160003", "bodyText": "Not exposing a compositing listener to public unless we find a use for it in the future sgtm", "author": "anuraaga", "createdAt": "2020-04-12T07:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4912b1fca4cbe81528794f19c06290c668b54a57", "chunk": "diff --git a/brave/src/main/java/brave/internal/handler/SafeSpanListener.java b/brave/src/main/java/brave/internal/handler/SafeSpanListener.java\nindex 0545ca412..5996f9d97 100644\n--- a/brave/src/main/java/brave/internal/handler/SafeSpanListener.java\n+++ b/brave/src/main/java/brave/internal/handler/SafeSpanListener.java\n\n@@ -23,18 +23,24 @@ import java.util.Arrays;\n import static brave.internal.Throwables.propagateIfFatal;\n \n /** This logs exceptions instead of raising an error, as the supplied listener could have bugs. */\n-public abstract class SafeSpanListener extends SpanListener {\n+public final class SafeSpanListener extends SpanListener {\n   // Array ensures no iterators are created at runtime\n   public static SpanListener create(SpanListener[] handlers) {\n     if (handlers.length == 0) return SpanListener.NOOP;\n-    if (handlers.length == 1) return new Single(handlers[0]);\n-    return new Multiple(handlers);\n+    if (handlers.length == 1) return new SafeSpanListener(handlers[0]);\n+    return new SafeSpanListener(new CompositeSpanListener(handlers));\n+  }\n+\n+  final SpanListener delegate;\n+\n+  SafeSpanListener(SpanListener delegate) {\n+    this.delegate = delegate;\n   }\n \n   @Override\n   public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n     try {\n-      doOnCreate(parent, context, span);\n+      delegate.onCreate(parent, context, span);\n     } catch (Throwable t) {\n       propagateIfFatal(t);\n       Platform.get().log(\"error handling create {0}\", context, t);\n"}}, {"oid": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "url": "https://github.com/openzipkin/brave/commit/dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "message": "WIP span handler", "committedDate": "2020-04-12T10:17:07Z", "type": "forcePushed"}, {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52", "url": "https://github.com/openzipkin/brave/commit/71413431db25b29d5724b7e0abb2e4be4802fc52", "message": "WIP span listener", "committedDate": "2020-04-12T10:36:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3OTQ1Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407179456", "bodyText": "note this now uses weak maps", "author": "codefromthecrypt", "createdAt": "2020-04-12T10:38:02Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenListener.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.weaklockfree.WeakConcurrentMap;\n+import brave.propagation.TraceContext;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenListener extends SpanListener {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent = new WeakConcurrentMap<>();", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE4NjQ2Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407186467", "bodyText": "oops forgot to switch this back to https://github.com/raphw/weak-lock-free as an example shouldn't use our internal types..", "author": "codefromthecrypt", "createdAt": "2020-04-12T11:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3OTQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4912b1fca4cbe81528794f19c06290c668b54a57", "chunk": "diff --git a/brave/src/test/java/brave/features/handler/FinishedChildrenListener.java b/brave/src/test/java/brave/features/handler/FinishedChildrenListener.java\nindex 921514b60..6fb55d8a8 100644\n--- a/brave/src/test/java/brave/features/handler/FinishedChildrenListener.java\n+++ b/brave/src/test/java/brave/features/handler/FinishedChildrenListener.java\n\n@@ -15,8 +15,8 @@ package brave.features.handler;\n \n import brave.handler.MutableSpan;\n import brave.handler.SpanListener;\n-import brave.internal.weaklockfree.WeakConcurrentMap;\n import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Set;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjcyMw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Throwable caller, error;\n          \n          \n            \n              Throwable error;", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:37:03Z", "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -72,7 +72,7 @@\n   ArrayList<String> tags;\n   /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n   ArrayList<Object> annotations;\n-  Throwable error;\n+  Throwable caller, error;", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/MutableSpan.java b/brave/src/main/java/brave/handler/MutableSpan.java\nindex 94a4f4a94..b7a713d4b 100644\n--- a/brave/src/main/java/brave/handler/MutableSpan.java\n+++ b/brave/src/main/java/brave/handler/MutableSpan.java\n\n@@ -72,143 +82,345 @@ public final class MutableSpan implements Cloneable {\n   ArrayList<String> tags;\n   /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n   ArrayList<Object> annotations;\n-  Throwable caller, error;\n+  Throwable error;\n \n+  /** @since 5.4 */\n   public MutableSpan() {\n-    // this cheats because it will not need to grow unless there are more than 5 tags\n-    tags = new ArrayList<>();\n-    // lazy initialize annotations\n-  }\n-\n-  /** Returns true if there was no data added. Usually this indicates an instrumentation bug. */\n-  public boolean isEmpty() {\n-    return kind == null\n-      && !shared\n-      && startTimestamp == 0L\n-      && finishTimestamp == 0L\n-      && name == null\n-      && localServiceName == null\n-      && localIp == null\n-      && remoteServiceName == null\n-      && remoteIp == null\n-      && localPort == 0\n-      && remotePort == 0\n-      && tags.isEmpty()\n-      && annotations == null\n-      && error == null;\n-  }\n-\n-  /** Returns the {@link brave.Span#name(String) span name} or null */\n+  }\n+\n+  /**\n+   * Creates a new instance from the given context, and defaults in the span.\n+   *\n+   * <p><em>Note:</em> It is unexpected to have context properties also in the span defaults. The\n+   * context will win in this case, as opposed to throwing an exception.\n+   *\n+   * @since 5.12\n+   */\n+  public MutableSpan(TraceContext context, @Nullable MutableSpan defaults) {\n+    this(defaults != null ? defaults : EMPTY);\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    traceId(context.traceIdString());\n+    localRootId(context.localRootIdString());\n+    parentId(context.parentIdString());\n+    id(context.spanIdString());\n+    flags = 0; // don't inherit flags from the span\n+    if (context.debug()) setDebug();\n+    if (context.shared()) setShared();\n+  }\n+\n+  /** @since 5.12 */\n+  public MutableSpan(MutableSpan toCopy) {\n+    if (toCopy == null) throw new NullPointerException(\"toCopy == null\");\n+    if (toCopy == EMPTY) return;\n+    traceId = toCopy.traceId;\n+    localRootId = toCopy.localRootId;\n+    parentId = toCopy.parentId;\n+    id = toCopy.id;\n+    kind = toCopy.kind;\n+    flags = toCopy.flags;\n+    startTimestamp = toCopy.startTimestamp;\n+    finishTimestamp = toCopy.finishTimestamp;\n+    name = toCopy.name;\n+    localServiceName = toCopy.localServiceName;\n+    localIp = toCopy.localIp;\n+    localPort = toCopy.localPort;\n+    remoteServiceName = toCopy.remoteServiceName;\n+    remoteIp = toCopy.remoteIp;\n+    remotePort = toCopy.remotePort;\n+    tags = toCopy.tags != null ? new ArrayList<>(toCopy.tags) : null;\n+    annotations = toCopy.annotations != null ? new ArrayList<>(toCopy.annotations) : null;\n+    error = toCopy.error;\n+  }\n+\n+  /**\n+   * @since 5.4\n+   * @deprecated Since 5.12 use {@link #equals(Object)} against a base value.\n+   */\n+  @Deprecated public boolean isEmpty() {\n+    return equals(EMPTY);\n+  }\n+\n+  /**\n+   * Returns the {@linkplain TraceContext#traceIdString() trace ID}\n+   *\n+   * @since 5.12\n+   */\n+  public String traceId() {\n+    return traceId;\n+  }\n+\n+  /**\n+   * Calling this overrides the {@linkplain TraceContext#traceIdString() trace ID}.\n+   *\n+   * @see #traceId()\n+   */\n+  public void traceId(String traceId) {\n+    if (traceId == null) throw new NullPointerException(\"traceId == null\");\n+    if (traceId.isEmpty()) throw new NullPointerException(\"traceId is empty\");\n+    this.traceId = traceId;\n+  }\n+\n+  /**\n+   * Returns the {@linkplain TraceContext#localRootIdString() local root ID}\n+   *\n+   * @since 5.12\n+   */\n+  @Nullable public String localRootId() {\n+    return localRootId;\n+  }\n+\n+  /**\n+   * Calling this overrides the {@linkplain TraceContext#localRootIdString() local root ID}.\n+   *\n+   * @see #localRootId()\n+   */\n+  public void localRootId(@Nullable String localRootId) {\n+    this.localRootId = localRootId == null || localRootId.isEmpty() ? null : localRootId;\n+  }\n+\n+  /**\n+   * Returns the {@linkplain TraceContext#parentIdString() parent ID} or {@code null}\n+   *\n+   * @since 5.12\n+   */\n+  @Nullable public String parentId() {\n+    return parentId;\n+  }\n+\n+  /**\n+   * Calling this overrides the {@linkplain TraceContext#parentIdString() parent ID}.\n+   *\n+   * @see #parentId()\n+   */\n+  public void parentId(@Nullable String parentId) {\n+    this.parentId = parentId == null || parentId.isEmpty() ? null : parentId;\n+  }\n+\n+  /**\n+   * Returns the {@linkplain TraceContext#spanId() span ID}.\n+   *\n+   * @since 5.12\n+   */\n+  public String id() {\n+    return id;\n+  }\n+\n+  /**\n+   * Calling this overrides the {@linkplain TraceContext#spanId() span ID}.\n+   *\n+   * @see #id()\n+   */\n+  public void id(String id) {\n+    if (id == null) throw new NullPointerException(\"id == null\");\n+    if (id.isEmpty()) throw new NullPointerException(\"id is empty\");\n+    this.id = id;\n+  }\n+\n+  /**\n+   * Returns the {@linkplain brave.SpanCustomizer#name(String) span name} or {@code null}\n+   *\n+   * @since 5.4\n+   */\n   @Nullable public String name() {\n     return name;\n   }\n \n-  /** @see brave.Span#name(String) */\n-  public void name(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    this.name = name;\n+  /**\n+   * Calling this overrides any previous value, such as{@link brave.SpanCustomizer#name(String)}.\n+   *\n+   * @see #name()\n+   */\n+  public void name(@Nullable String name) {\n+    this.name = name == null || name.isEmpty() ? null : name;\n   }\n \n-  /** Returns the {@link brave.Span#start(long) span start timestamp} or zero */\n+  /**\n+   * Returns the {@linkplain brave.Span#start(long) span start timestamp} or zero.\n+   *\n+   * @since 5.4\n+   */\n   public long startTimestamp() {\n     return startTimestamp;\n   }\n \n-  /** @see brave.Span#start(long) */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Span#start(long)} or {@link\n+   * brave.Tracer#startScopedSpan(String)}.\n+   *\n+   * @see #startTimestamp()\n+   */\n   public void startTimestamp(long startTimestamp) {\n     this.startTimestamp = startTimestamp;\n   }\n \n-  /** Returns the {@link brave.Span#finish(long) span finish timestamp} or zero */\n+  /**\n+   * Returns the {@linkplain brave.Span#finish(long) span finish timestamp} or zero.\n+   *\n+   * @since 5.4\n+   */\n   public long finishTimestamp() {\n     return finishTimestamp;\n   }\n \n-  /** @see brave.Span#finish(long) */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Span#finish(long)} or {@link\n+   * brave.ScopedSpan#finish()}.\n+   *\n+   * @see #finishTimestamp()\n+   */\n   public void finishTimestamp(long finishTimestamp) {\n     this.finishTimestamp = finishTimestamp;\n   }\n \n-  /** Returns the {@link brave.Span#kind(brave.Span.Kind) span kind} or null */\n+  /**\n+   * Returns the {@linkplain brave.Span#kind(brave.Span.Kind) span kind} or {@code null}.\n+   *\n+   * @since 5.4\n+   */\n   public Kind kind() {\n     return kind;\n   }\n \n-  /** @see brave.Span#kind(brave.Span.Kind) */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Span#kind(Kind).\n+   *\n+   * @see #kind()\n+   */\n   public void kind(@Nullable Kind kind) {\n     this.kind = kind;\n   }\n \n-  /** When null {@link brave.Tracing.Builder#localServiceName(String) default} is used. */\n+  /**\n+   * Returns the {@linkplain brave.Tracing.Builder#localIp(String) label of this node in the service\n+   * graph} or {@code null}.\n+   *\n+   * <p><em>Note</em>: This is initialized from {@link brave.Tracing.Builder#localServiceName(String)}.\n+   * {@linkplain FinishedSpanHandler handlers} that want to conditionally replace the value should\n+   * compare against the same value given to the tracing component.\n+   *\n+   * @since 5.4\n+   */\n   @Nullable public String localServiceName() {\n     return localServiceName;\n   }\n \n-  /** @see brave.Tracing.Builder#localServiceName(String) */\n-  public void localServiceName(String localServiceName) {\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Tracing.Builder#localServiceName(String)}.\n+   *\n+   * @see #localServiceName()\n+   */\n+  public void localServiceName(@Nullable String localServiceName) {\n     if (localServiceName == null || localServiceName.isEmpty()) {\n-      throw new NullPointerException(\"localServiceName is empty\");\n+      this.localServiceName = null;\n     }\n     this.localServiceName = localServiceName;\n   }\n \n-  /** When null {@link brave.Tracing.Builder#localIp(String) default} will be used for zipkin. */\n+  /**\n+   * Returns the {@linkplain brave.Tracing.Builder#localIp(String) primary IP address associated\n+   * with this service} or {@code null}.\n+   *\n+   * <p><em>Note</em>: This is initialized from {@link brave.Tracing.Builder#localIp(String)}.\n+   * {@linkplain FinishedSpanHandler handlers} that want to conditionally replace the value should\n+   * compare against the same value given to the tracing component.\n+   *\n+   * @since 5.4\n+   */\n   @Nullable public String localIp() {\n     return localIp;\n   }\n \n-  /** @see #localIp() */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Tracing.Builder#localIp(String)}.\n+   *\n+   * @see #localIp()\n+   */\n   public boolean localIp(@Nullable String localIp) {\n     this.localIp = IpLiteral.ipOrNull(localIp);\n     return localIp != null;\n   }\n \n-  /** When zero {@link brave.Tracing.Builder#localIp(String) default} will be used for zipkin. */\n+  /**\n+   * Returns the {@linkplain brave.Tracing.Builder#localPort(int) primary listen port associated\n+   * with this service} or zero.\n+   *\n+   * <p><em>Note</em>: This is initialized from {@link brave.Tracing.Builder#localPort(int)}.\n+   * {@linkplain FinishedSpanHandler handlers} that want to conditionally replace the value should\n+   * compare against the same value given to the tracing component.\n+   *\n+   * @since 5.4\n+   */\n   public int localPort() {\n     return localPort;\n   }\n \n-  /** @see #localPort() */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Tracing.Builder#localPort(int)}.\n+   *\n+   * @see #localPort()\n+   */\n   public void localPort(int localPort) {\n     if (localPort > 0xffff) throw new IllegalArgumentException(\"invalid port \" + localPort);\n     if (localPort < 0) localPort = 0;\n     this.localPort = localPort;\n   }\n \n-  /** @see brave.Span#remoteServiceName(String) */\n+  /**\n+   * Returns the {@linkplain brave.Span#remoteServiceName(String) primary label of the remote\n+   * service} or {@code null}.\n+   *\n+   * @see #remoteIp()\n+   * @see #remotePort()\n+   * @since 5.4\n+   */\n   @Nullable public String remoteServiceName() {\n     return remoteServiceName;\n   }\n \n-  /** @see brave.Span#remoteServiceName(String) */\n-  public void remoteServiceName(String remoteServiceName) {\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Span#remoteServiceName(String)}.\n+   *\n+   * @see #remoteServiceName()\n+   */\n+  public void remoteServiceName(@Nullable String remoteServiceName) {\n     if (remoteServiceName == null || remoteServiceName.isEmpty()) {\n-      throw new NullPointerException(\"remoteServiceName is empty\");\n+      this.remoteServiceName = null;\n     }\n     this.remoteServiceName = remoteServiceName;\n   }\n \n   /**\n-   * The text representation of the primary IPv4 or IPv6 address associated with the remote side of\n-   * this connection. Ex. 192.168.99.100 null if unknown.\n+   * Returns the {@linkplain brave.Span#remoteIpAndPort(String, int) IP of the remote service} or\n+   * {@code null}.\n    *\n-   * @see brave.Span#remoteIpAndPort(String, int)\n+   * @see #remoteServiceName()\n+   * @see #remotePort()\n+   * @since 5.4\n    */\n   @Nullable public String remoteIp() {\n     return remoteIp;\n   }\n \n   /**\n-   * Port of the remote IP's socket or 0, if not known.\n+   * Returns the {@linkplain brave.Span#remoteIpAndPort(String, int) port of the remote service} or\n+   * zero.\n    *\n-   * @see java.net.InetSocketAddress#getPort()\n-   * @see brave.Span#remoteIpAndPort(String, int)\n+   * @see #remoteServiceName()\n+   * @see #remoteIp()\n+   * @since 5.4\n    */\n   public int remotePort() {\n     return remotePort;\n   }\n \n-  /** @see brave.Span#remoteIpAndPort(String, int) */\n+  /**\n+   * Calling this overrides any previous value, such as {@link brave.Span#remoteIpAndPort(String,\n+   * int)}.\n+   *\n+   * @see #remoteServiceName()\n+   * @see #remoteIp()\n+   * @see #remotePort()\n+   */\n   public boolean remoteIpAndPort(@Nullable String remoteIp, int remotePort) {\n     if (remoteIp == null) return false;\n     this.remoteIp = IpLiteral.ipOrNull(remoteIp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3Mjg2MQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272861", "bodyText": "TODO move these changes to master as they aren't specific to this feature", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:37:57Z", "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/RealSpan.java b/brave/src/main/java/brave/RealSpan.java\nindex d08880c8f..68f9d2054 100644\n--- a/brave/src/main/java/brave/RealSpan.java\n+++ b/brave/src/main/java/brave/RealSpan.java\n\n@@ -145,9 +140,8 @@ final class RealSpan extends Span {\n \n   @Override public void finish(long timestamp) {\n     synchronized (state) {\n-      if (!pendingSpans.finish(context, timestamp)) return;\n+      pendingSpans.finish(context, timestamp);\n     }\n-    finishedSpanHandler.handle(context, state);\n   }\n \n   @Override public void abandon() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjkwMA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272900", "bodyText": "TODO move this change to master as it isn't specific to this feature", "author": "codefromthecrypt", "createdAt": "2020-04-13T00:38:21Z", "path": "brave/src/main/java/brave/RealScopedSpan.java", "diffHunk": "@@ -74,8 +74,7 @@\n \n   @Override public void finish() {\n     scope.close();\n-    if (pendingSpans.remove(context) == null) return; // don't double-report\n-    state.finishTimestamp(clock.currentTimeMicroseconds());\n+    if (!pendingSpans.finish(context, 0L)) return; // don't double-report", "originalCommit": "71413431db25b29d5724b7e0abb2e4be4802fc52", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/RealScopedSpan.java b/brave/src/main/java/brave/RealScopedSpan.java\nindex 19177cf9f..3dd746e48 100644\n--- a/brave/src/main/java/brave/RealScopedSpan.java\n+++ b/brave/src/main/java/brave/RealScopedSpan.java\n\n@@ -74,8 +70,7 @@ final class RealScopedSpan extends ScopedSpan {\n \n   @Override public void finish() {\n     scope.close();\n-    if (!pendingSpans.finish(context, 0L)) return; // don't double-report\n-    finishedSpanHandler.handle(context, state);\n+    pendingSpans.finish(context, 0L);\n   }\n \n   @Override public boolean equals(Object o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwODc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407608783", "bodyText": "nit: iirc this initial comment comes from an initial version where SpanHandler was extending FinishedSpanHandler. Could be updated to match rationale.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n          \n          \n            \n             * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.\n          \n          \n            \n             * This hooks into the span life-cycle covering all state transitions, including\n          \n          \n            \n             * when a span is created, abandoned, finished, or orphan. This is particularly different than \n          \n          \n            \n             * {@link FinishedSpanHandler} that only considers finished spans.\n          \n          \n            \n             * \n          \n          \n            \n             * <p>The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.", "author": "jeqo", "createdAt": "2020-04-13T17:37:34Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMTU4Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407611582", "bodyText": "Would make sense to consider onStart as well? Not that I have a use-case in mind, just wondering if having onStart and onFinish could be useful.", "author": "jeqo", "createdAt": "2020-04-13T17:42:27Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTExMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819111", "bodyText": "spans are sometimes never started or their start timestamp overwritten (ex \"start\" is not a state in a state diagram, just field manipulation)\nTODO: add this to rationale", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMTU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407617993", "bodyText": "For me is becoming a bit hard to follow the sequence and implications of span state transitions, finished span handler, and now span listeners.\nAdding some docs/diagrams about this could be helpful for users. I can help with this if make sense :)", "author": "jeqo", "createdAt": "2020-04-13T17:53:53Z", "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+   * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+   */\n+  public void onFlush(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called when the trace context was garbage collected prior to completion.\n+   *\n+   * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if {@linkplain", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxODk1MQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407818951", "bodyText": "your questions are helpful as I also feel uncomfortable.\nI'm wondering if the type shouldn't be called something else..\nWe are mostly talking about a binding between a trace context and a state object for the purpose of collection and when that binding is complete (for any reason). When there are\nonly two states it is simpler and no diagrams are needed.\nPlus we don't need to describe nuance (though we can in rationale), such as that spans are sometimes never started or their start timestamp overwritten (ex \"start\" is not a state in a state diagram, just field manipulation)\nEx\nSampledSpanListener {\n  enum Reason {\n    ABANDON,\n    FINISH,\n    FLUSH,\n    GC; // or ORPHAN which is the word we use more\n  }\n  void onBind(TraceContext, MutableSpan)\n  void onRelease(TraceContext, MutableSpan, Reason)\n}", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MzY4OQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407843689", "bodyText": "This interface does seem nicer since many use cases won't even care about the reason and it's more explicit that only one of those is called. That said, I don't know if conceptually it's so different, docs that would apply to the individual interface methods seem to just move into the Reason enum.\nAlso unsure of bind, the word isn't very intuitive for me. onStart / onEnd seem clear, with the caveat of end looking a lot like finish (but then again release I guess looks like GC \ud83e\udd23 ).\nWondering what happens if the methods return boolean? onBind can return secondary sampling decision (well maybe too late we already have a TraceContext), onRelease can replace FinishedSpanHandler so don't have to reason about that?", "author": "anuraaga", "createdAt": "2020-04-14T03:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NzQ1Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407847457", "bodyText": "I think the biggest difference the enum brings is that the state diagram becomes unambiguous.. whatever the begin hook has only one end hook and they are both always called. Those who care about the reason of the end can look at it. I agree docs will just move, but this obviates docs about a state diagram I think.\nnaming is not my favorite either.. was trying to avoid the word finish. I tried thinking through various things that suggest an association.\nex\nassociate/disassociate\nallocate/deallocate\nbind/unbind\nrandom words that just say start/stop\nbegin/end\nstart/finish (dangerous as conflated with span ops)\nI'm currently thinking..\nonSampled\nonCollected\nwrt to onCollected returning false, I think we could I guess yeah, just it would also imply that any finishedSpanListeners would need to be converted first to these in order to perform things like redaction. Another way is we can make this able to internally dispatch to finishedSpanHandlers... ex Whatever this is called exposes a factory that accepts a single (potentially composite) FinishedSpanHandler instance we give to it...", "author": "codefromthecrypt", "createdAt": "2020-04-14T03:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0ODI0Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407848246", "bodyText": "one possibility especially with the design as it is, is that we can deprecate FinishedSpanHandler. I feel one thing this design does is makes the relationships a whole lot more clear. So what would happen in this case is that we make a special SampledSpanListener that does a dispatch first to any FinishedSpanHandlers before calling its onCollected hook. that way we don't have to mention FinishedSpanHandler at all? It is a little sad that FinishedSpanHandler didn't live that long, but I feel this is becoming a much better conceptual model.", "author": "codefromthecrypt", "createdAt": "2020-04-14T03:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanListener.java b/brave/src/main/java/brave/handler/SpanListener.java\nindex c6a6685ed..9951d4bc6 100644\n--- a/brave/src/main/java/brave/handler/SpanListener.java\n+++ b/brave/src/main/java/brave/handler/SpanListener.java\n\n@@ -19,8 +19,11 @@ import brave.propagation.TraceContext;\n import java.lang.ref.WeakReference;\n \n /**\n- * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n- * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * This hooks into the span life-cycle covering all state transitions, including\n+ * when a span is created, abandoned, finished, or orphan. This is particularly different than \n+ * {@link FinishedSpanHandler} that only considers finished spans.\n+ * \n+ * <p>The purpose of this type is to allow tracking of children,\n  * or partitioning of data for backend that needs to see an entire {@linkplain\n  * TraceContext#localRootId() local root}.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407625220", "bodyText": "@adriancole would you mind sharing the reasoning behind 0L instead of #currentTimeMicroseconds()", "author": "jeqo", "createdAt": "2020-04-13T18:06:24Z", "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "originalCommit": "af6728c7e292b72daca379efe317c79e67e3abe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTM2OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819368", "bodyText": "to prevent overhead of using the clock when the span is already finished.", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgxOTY3Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407819677", "bodyText": "TODO: comment", "author": "codefromthecrypt", "createdAt": "2020-04-14T01:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNDE5Mw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407824193", "bodyText": "fixed upstream", "author": "codefromthecrypt", "createdAt": "2020-04-14T02:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/RealSpan.java b/brave/src/main/java/brave/RealSpan.java\nindex d08880c8f..68f9d2054 100644\n--- a/brave/src/main/java/brave/RealSpan.java\n+++ b/brave/src/main/java/brave/RealSpan.java\n\n@@ -145,9 +140,8 @@ final class RealSpan extends Span {\n \n   @Override public void finish(long timestamp) {\n     synchronized (state) {\n-      if (!pendingSpans.finish(context, timestamp)) return;\n+      pendingSpans.finish(context, timestamp);\n     }\n-    finishedSpanHandler.handle(context, state);\n   }\n \n   @Override public void abandon() {\n"}}, {"oid": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "url": "https://github.com/openzipkin/brave/commit/b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "message": "Update brave/RATIONALE.md\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>", "committedDate": "2020-04-14T04:44:19Z", "type": "forcePushed"}, {"oid": "4912b1fca4cbe81528794f19c06290c668b54a57", "url": "https://github.com/openzipkin/brave/commit/4912b1fca4cbe81528794f19c06290c668b54a57", "message": "polish", "committedDate": "2020-04-15T08:02:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408722529", "bodyText": "eventhough nostalgia for SpanCollector SpanHandler may still be better name I admit as we can't move the MutableSpan out of this package without certain chaos...", "author": "codefromthecrypt", "createdAt": "2020-04-15T09:56:13Z", "path": "brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import brave.handler.FinishedSpanHandler;\n import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczNjY0Ng==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408736646", "bodyText": "Also collector can cause confusion with server-side collectors.\nJust for reference, and to add one more alternative naming, in Kafka Clients interceptors have a similar function.", "author": "jeqo", "createdAt": "2020-04-15T10:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0OTU0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408749542", "bodyText": "good point on collector being conflated (I think  I recall now we dodged the word collector in the first place due to this..)\npersonally I like handler better, as usually interceptor means getting in the middle of something. ex\nvoid intercept(thing, chain){\n  return chain.proceed(thing);\n}", "author": "codefromthecrypt", "createdAt": "2020-04-15T10:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgzNjE1OA==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408836158", "bodyText": "Fair enough. I also prefer Handler instead of Listener..--naming is hard :)", "author": "jeqo", "createdAt": "2020-04-15T13:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java b/brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java\nindex 3c17bbb61..22fd55481 100644\n--- a/brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java\n+++ b/brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java\n\n@@ -13,11 +13,11 @@\n  */\n package brave.internal.recorder;\n \n-import brave.handler.FinishedSpanHandler;\n import brave.handler.MutableSpan;\n-import brave.handler.SpanCollector;\n+import brave.handler.SpanHandler;\n import brave.internal.InternalPropagation;\n import brave.internal.Platform;\n+import brave.internal.handler.OrphanTracker;\n import brave.propagation.SamplingFlags;\n import brave.propagation.TraceContext;\n import brave.test.util.GarbageCollectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDUxOQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408900519", "bodyText": "for an enum Cause i would linguistically expect past-tense constants, ABANDONED - FINISHED etc ?", "author": "jorgheymans", "createdAt": "2020-04-15T14:47:03Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTUwMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195501", "bodyText": "sgtm thanks", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanCollector.java b/brave/src/main/java/brave/handler/SpanHandler.java\nsimilarity index 81%\nrename from brave/src/main/java/brave/handler/SpanCollector.java\nrename to brave/src/main/java/brave/handler/SpanHandler.java\nindex 6b4ef3ff7..29248f6da 100644\n--- a/brave/src/main/java/brave/handler/SpanCollector.java\n+++ b/brave/src/main/java/brave/handler/SpanHandler.java\n\n@@ -23,8 +23,8 @@ import java.lang.ref.WeakReference;\n  * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n  *\n  * <h3>Relationship to Span lifecycle</h3>\n- * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n- * most cases it will be the same, but you cannot assume this.\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In most cases\n+ * it will be the same, but you cannot assume this.\n  *\n  * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n  * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTc5Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408901792", "bodyText": "the other constants are named linear to their Span methods, why ORPHAN for gc collected, are there other use cases leading to ORPHAN besides gc ?", "author": "jorgheymans", "createdAt": "2020-04-15T14:48:29Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTEyNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195125", "bodyText": "well GC is the side affect of orphaning your span (ex by creating it and dropping a reference to it). I think that's why we named it orphan back then, but I can look up notes if you like.\nMain thing is the fact that it is GC'ed is only because someone orphaned it. If they held a reference it would not become GC'ed. Possibly I can clarify the description somewhere.", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanCollector.java b/brave/src/main/java/brave/handler/SpanHandler.java\nsimilarity index 81%\nrename from brave/src/main/java/brave/handler/SpanCollector.java\nrename to brave/src/main/java/brave/handler/SpanHandler.java\nindex 6b4ef3ff7..29248f6da 100644\n--- a/brave/src/main/java/brave/handler/SpanCollector.java\n+++ b/brave/src/main/java/brave/handler/SpanHandler.java\n\n@@ -23,8 +23,8 @@ import java.lang.ref.WeakReference;\n  * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n  *\n  * <h3>Relationship to Span lifecycle</h3>\n- * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n- * most cases it will be the same, but you cannot assume this.\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In most cases\n+ * it will be the same, but you cannot assume this.\n  *\n  * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n  * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjU0Mg==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408906542", "bodyText": "does this need to be duplicated from Cause ?\nCalled when data collection completes on its own is enough, and maybe link in the cause parameter to the enum.", "author": "jorgheymans", "createdAt": "2020-04-15T14:54:23Z", "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN\n+  }\n+\n+  /** Use to avoid comparing against null references */\n+  SpanCollector NOOP = new SpanCollector() {\n+    @Override public void begin(TraceContext context, MutableSpan span, TraceContext parent) {\n+    }\n+\n+    @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+      return true;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopSpanCollector{}\";\n+    }\n+  };\n+\n+  /**\n+   * This is called when a span is sampled, but before it is started.\n+   *\n+   * @param context the trace context which is  {@link TraceContext#sampledLocal()}. This includes\n+   * identifiers and potentially {@link TraceContext#extra() extra propagated data} such as baggage\n+   * or extended sampling configuration.\n+   * @param span a mutable object that stores data recorded with span apis. Modifications are\n+   * visible to later collectors.\n+   * @param parent can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent);\n+\n+  /**\n+   * Called when data collection completes for one of the following reasons:\n+   *\n+   * <p><ol>\n+   * <li>{@link Cause#ABANDON} if it was a speculative context</li>\n+   * <li>{@link Cause#FINISH} if it was reported complete</li>\n+   * <li>{@link Cause#FLUSH} if it was intentionally reported incomplete</li>\n+   * <li>{@link Cause#ORPHAN} if it was reported incomplete due to garbage collection</li>", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTMxMQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195311", "bodyText": "sgtm I can put this on the type docs of Cause, as I do think an overview helps, but possibly not here..", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjU0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/main/java/brave/handler/SpanCollector.java b/brave/src/main/java/brave/handler/SpanHandler.java\nsimilarity index 81%\nrename from brave/src/main/java/brave/handler/SpanCollector.java\nrename to brave/src/main/java/brave/handler/SpanHandler.java\nindex 6b4ef3ff7..29248f6da 100644\n--- a/brave/src/main/java/brave/handler/SpanCollector.java\n+++ b/brave/src/main/java/brave/handler/SpanHandler.java\n\n@@ -23,8 +23,8 @@ import java.lang.ref.WeakReference;\n  * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n  *\n  * <h3>Relationship to Span lifecycle</h3>\n- * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n- * most cases it will be the same, but you cannot assume this.\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In most cases\n+ * it will be the same, but you cannot assume this.\n  *\n  * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n  * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTU2Nw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408935567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Kick-out if the this was not a normal finish\n          \n          \n            \n                // Kick-out if this was not a normal finish", "author": "jorgheymans", "createdAt": "2020-04-15T15:31:55Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent =\n+    new WeakConcurrentMap<>(false);\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override\n+  public void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent) {\n+    if (!context.isLocalRoot()) { // a child\n+      childToParent.putIfProbablyAbsent(context, parent);\n+      parentToChildren.add(parent, span);\n+    }\n+  }\n+\n+  @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+    // Kick-out if the this was not a normal finish", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java b/brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\nsimilarity index 89%\nrename from brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java\nrename to brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\nindex ee69f705b..a3a5c72c9 100644\n--- a/brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java\n+++ b/brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\n\n@@ -14,7 +14,7 @@\n package brave.features.handler;\n \n import brave.handler.MutableSpan;\n-import brave.handler.SpanCollector;\n+import brave.handler.SpanHandler;\n import brave.internal.Nullable;\n import brave.propagation.TraceContext;\n import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjMwNQ==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408936305", "bodyText": "does this need a type level javadoc ?", "author": "jorgheymans", "createdAt": "2020-04-15T15:32:51Z", "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {", "originalCommit": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTQxNw==", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r409195417", "bodyText": "test class, but sure", "author": "codefromthecrypt", "createdAt": "2020-04-15T23:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "chunk": "diff --git a/brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java b/brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\nsimilarity index 89%\nrename from brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java\nrename to brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\nindex ee69f705b..a3a5c72c9 100644\n--- a/brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java\n+++ b/brave/src/test/java/brave/features/handler/FinishedChildrenHandler.java\n\n@@ -14,7 +14,7 @@\n package brave.features.handler;\n \n import brave.handler.MutableSpan;\n-import brave.handler.SpanCollector;\n+import brave.handler.SpanHandler;\n import brave.internal.Nullable;\n import brave.propagation.TraceContext;\n import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n"}}, {"oid": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "url": "https://github.com/openzipkin/brave/commit/b4c7609e8fb6e635bd50367cba691e45c25468fc", "message": "typo", "committedDate": "2020-04-20T04:37:20Z", "type": "forcePushed"}, {"oid": "777176f8f0fe141126f09ae61876a3f736f19f5b", "url": "https://github.com/openzipkin/brave/commit/777176f8f0fe141126f09ae61876a3f736f19f5b", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T05:53:19Z", "type": "forcePushed"}, {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T08:59:50Z", "type": "forcePushed"}, {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-05-08T08:59:50Z", "type": "commit"}, {"oid": "c4ce99b43325bf3b330f5f517bb2819684b60308", "url": "https://github.com/openzipkin/brave/commit/c4ce99b43325bf3b330f5f517bb2819684b60308", "message": "deprecate and feedback", "committedDate": "2020-05-08T10:53:27Z", "type": "commit"}, {"oid": "91a49ee9163342cd2d9e5f216e3cf8675db56e56", "url": "https://github.com/openzipkin/brave/commit/91a49ee9163342cd2d9e5f216e3cf8675db56e56", "message": "more rationale", "committedDate": "2020-05-08T11:14:02Z", "type": "commit"}]}