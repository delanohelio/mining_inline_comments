{"pr_number": 2892, "pr_title": "ThrownPotionData - fix syntax not working", "pr_createdAt": "2020-03-28T08:21:35Z", "pr_url": "https://github.com/SkriptLang/Skript/pull/2892", "timeline": [{"oid": "6a35e0c56fe8a190aee1459de1eae9cc8b23b3b6", "url": "https://github.com/SkriptLang/Skript/commit/6a35e0c56fe8a190aee1459de1eae9cc8b23b3b6", "message": "ThrownPotionData - fix syntax not working", "committedDate": "2020-03-28T08:18:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NDUxMw==", "url": "https://github.com/SkriptLang/Skript/pull/2892#discussion_r421564513", "bodyText": "Don't do Material checks, put the corresponding alias in a constant through Aliases#javaItemtype instead.", "author": "SnowPyon", "createdAt": "2020-05-07T14:47:50Z", "path": "src/main/java/ch/njol/skript/entity/ThrownPotionData.java", "diffHunk": "@@ -46,34 +47,33 @@\n \t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\r\n \t}\r\n \t\r\n-\tprivate final static Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\r\n+\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\r\n+\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\r\n \t\r\n \t@Nullable\r\n \tprivate ItemType[] types;\r\n \t\r\n \t@Override\r\n \tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\r\n \t\tif (exprs.length > 0 && exprs[0] != null) {\r\n-\t\t\tif ((Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, new Converter<ItemType, ItemType>() {\r\n-\t\t\t\t@Override\r\n-\t\t\t\t@Nullable\r\n-\t\t\t\tpublic ItemType convert(final ItemType t) {\r\n-\t\t\t\t\tItemType r = null;\r\n-\t\t\t\t\tfor (final ItemData d : t.getTypes()) {\r\n-\t\t\t\t\t\tif (d.getType() == Material.POTION) {\r\n-\t\t\t\t\t\t\tif (r == null)\r\n-\t\t\t\t\t\t\t\tr = new ItemType(d);\r\n-\t\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\t\tr.add(d);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\treturn r;\r\n+\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\r\n+\t\t\t\tMaterial type = t.getMaterial();\r\n+\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\r\n+\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\r\n+\t\t\t\tif (type == Material.POTION || (type == Material.LINGERING_POTION && RUNNING_LEGACY)) {\r", "originalCommit": "6a35e0c56fe8a190aee1459de1eae9cc8b23b3b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NTk5Ng==", "url": "https://github.com/SkriptLang/Skript/pull/2892#discussion_r421755996", "bodyText": "Ah yes you're right, totally forgot about that thanks. Ill switch them up.", "author": "ShaneBeee", "createdAt": "2020-05-07T19:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NDUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4Nzg4Mw==", "url": "https://github.com/SkriptLang/Skript/pull/2892#discussion_r421787883", "bodyText": "Ok these have now been changed!", "author": "ShaneBeee", "createdAt": "2020-05-07T20:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NDUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "069bb787579996fdf0faceb86846868648ecd177", "chunk": "diff --git a/src/main/java/ch/njol/skript/entity/ThrownPotionData.java b/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\nindex 5ec3064b..6acee8f2 100644\n--- a/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\n+++ b/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\n\n@@ -1,186 +1,188 @@\n-/**\n- *   This file is part of Skript.\n- *\n- *  Skript is free software: you can redistribute it and/or modify\n- *  it under the terms of the GNU General Public License as published by\n- *  the Free Software Foundation, either version 3 of the License, or\n- *  (at your option) any later version.\n- *\n- *  Skript is distributed in the hope that it will be useful,\n- *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- *  GNU General Public License for more details.\n- *\n- *  You should have received a copy of the GNU General Public License\n- *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n- *\n- *\n- * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n- */\n-package ch.njol.skript.entity;\n-\n-import java.util.Arrays;\n-\n-import org.bukkit.Location;\n-import org.bukkit.Material;\n-import org.bukkit.entity.ThrownPotion;\n-import org.bukkit.inventory.ItemStack;\n-import org.bukkit.inventory.meta.ItemMeta;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-import ch.njol.skript.Skript;\n-import ch.njol.skript.aliases.ItemType;\n-import ch.njol.skript.lang.Literal;\n-import ch.njol.skript.lang.SkriptParser.ParseResult;\n-import ch.njol.skript.localization.Adjective;\n-import ch.njol.skript.localization.Language;\n-import ch.njol.skript.localization.Noun;\n-import ch.njol.skript.registrations.Classes;\n-import ch.njol.skript.registrations.Converters;\n-import ch.njol.util.coll.CollectionUtils;\n-\n-/**\n- * @author Peter G\u00fcttinger\n- */\n-public class ThrownPotionData extends EntityData<ThrownPotion> {\n-\tstatic {\n-\t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\n-\t}\n-\t\n-\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\n-\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\n-\t\n-\t@Nullable\n-\tprivate ItemType[] types;\n-\t\n-\t@Override\n-\tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\n-\t\tif (exprs.length > 0 && exprs[0] != null) {\n-\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\n-\t\t\t\tMaterial type = t.getMaterial();\n-\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\n-\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\n-\t\t\t\tif (type == Material.POTION || (type == Material.LINGERING_POTION && RUNNING_LEGACY)) {\n-\t\t\t\t\tItemMeta meta = t.getItemMeta();\n-\t\t\t\t\tItemType itemType = new ItemType(Material.SPLASH_POTION);\n-\t\t\t\t\titemType.setItemMeta(meta);\n-\t\t\t\t\treturn itemType;\n-\t\t\t\t} else if (type != Material.SPLASH_POTION && type != Material.LINGERING_POTION) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t\treturn t;\n-\t\t\t})).length != 0; // no error message - other things can be thrown as well\n-\t\t} else {\n-\t\t\ttypes = new ItemType[]{new ItemType(Material.SPLASH_POTION)};\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean init(final @Nullable Class<? extends ThrownPotion> c, final @Nullable ThrownPotion e) {\n-\t\tif (e != null) {\n-\t\t\tfinal ItemStack i = e.getItem();\n-\t\t\tif (i == null)\n-\t\t\t\treturn false;\n-\t\t\ttypes = new ItemType[] {new ItemType(i)};\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean match(final ThrownPotion entity) {\n-\t\tif (types != null) {\n-\t\t\tfor (final ItemType t : types) {\n-\t\t\t\tif (t.isOfType(entity.getItem()))\n-\t\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Nullable\n-\t@Override\n-\tpublic ThrownPotion spawn(Location loc) {\n-\t\tItemType t = CollectionUtils.getRandom(types);\n-\t\tassert t != null;\n-\t\tfinal ItemStack i = t.getRandom();\n-\t\tif (i == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tThrownPotion potion = loc.getWorld().spawn(loc, ThrownPotion.class);\n-\t\tpotion.setItem(i);\n-\t\treturn potion;\n-\t}\n-\t\n-\t@Override\n-\tpublic void set(final ThrownPotion entity) {\n-\t\tif (types != null) {\n-\t\t\tfinal ItemType t = CollectionUtils.getRandom(types);\n-\t\t\tassert t != null;\n-\t\t\tItemStack i = t.getRandom();\n-\t\t\tif (i == null)\n-\t\t\t\treturn; // Missing item, can't make thrown potion of it\n-\t\t\tentity.setItem(i);\n-\t\t}\n-\t\tassert false;\n-\t}\n-\t\n-\t@Override\n-\tpublic Class<? extends ThrownPotion> getType() {\n-\t\treturn ThrownPotion.class;\n-\t}\n-\t\n-\t@Override\n-\tpublic EntityData getSuperType() {\n-\t\treturn new ThrownPotionData();\n-\t}\n-\t\n-\t@Override\n-\tpublic boolean isSupertypeOf(final EntityData<?> e) {\n-\t\tif (!(e instanceof ThrownPotionData))\n-\t\t\treturn false;\n-\t\tfinal ThrownPotionData d = (ThrownPotionData) e;\n-\t\tif (types != null) {\n-\t\t\treturn d.types != null && ItemType.isSubset(types, d.types);\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tpublic String toString(final int flags) {\n-\t\tfinal ItemType[] types = this.types;\n-\t\tif (types == null)\n-\t\t\treturn super.toString(flags);\n-\t\tfinal StringBuilder b = new StringBuilder();\n-\t\tb.append(Noun.getArticleWithSpace(types[0].getTypes().get(0).getGender(), flags));\n-\t\tb.append(m_adjective.toString(types[0].getTypes().get(0).getGender(), flags));\n-\t\tb.append(\" \");\n-\t\tb.append(Classes.toString(types, flags & Language.NO_ARTICLE_MASK, false));\n-\t\treturn \"\" + b.toString();\n-\t}\n-\t\n-\t//\t\treturn ItemType.serialize(types);\n-\t@Override\n-\t@Deprecated\n-\tprotected boolean deserialize(final String s) {\n-\t\tthrow new UnsupportedOperationException(\"old serialization is no longer supported\");\n-//\t\tif (s.isEmpty())\n-//\t\t\treturn true;\n-//\t\ttypes = ItemType.deserialize(s);\n-//\t\treturn types != null;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean equals_i(final EntityData<?> obj) {\n-\t\tif (!(obj instanceof ThrownPotionData))\n-\t\t\treturn false;\n-\t\treturn Arrays.equals(types, ((ThrownPotionData) obj).types);\n-\t}\n-\t\n-\t@Override\n-\tprotected int hashCode_i() {\n-\t\treturn Arrays.hashCode(types);\n-\t}\n-\t\n-}\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.entity;\n+\n+import java.util.Arrays;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.ThrownPotion;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.Aliases;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Literal;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.localization.Adjective;\n+import ch.njol.skript.localization.Language;\n+import ch.njol.skript.localization.Noun;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+/**\n+ * @author Peter G\u00fcttinger\n+ */\n+public class ThrownPotionData extends EntityData<ThrownPotion> {\n+\tstatic {\n+\t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\n+\t}\n+\t\n+\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\n+\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\n+\tprivate static final ItemType POTION = Aliases.javaItemType(\"potion\");\n+\tprivate static final ItemType SPLASH_POTION = Aliases.javaItemType(\"splash potion\");\n+\tprivate static final ItemType LINGER_POTION = Aliases.javaItemType(\"lingering potion\");\n+\t\n+\t@Nullable\n+\tprivate ItemType[] types;\n+\t\n+\t@Override\n+\tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\n+\t\tif (exprs.length > 0 && exprs[0] != null) {\n+\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\n+\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\n+\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\n+\t\t\t\tif (t.isSupertypeOf(POTION) || (t.isSupertypeOf(LINGER_POTION) && RUNNING_LEGACY)) {\n+\t\t\t\t\tItemMeta meta = t.getItemMeta();\n+\t\t\t\t\tItemType itemType = SPLASH_POTION.clone();\n+\t\t\t\t\titemType.setItemMeta(meta);\n+\t\t\t\t\treturn itemType;\n+\t\t\t\t} else if (!t.isSupertypeOf(SPLASH_POTION ) && !t.isSupertypeOf(LINGER_POTION)) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\treturn t;\n+\t\t\t})).length != 0; // no error message - other things can be thrown as well\n+\t\t} else {\n+\t\t\ttypes = new ItemType[]{SPLASH_POTION.clone()};\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean init(final @Nullable Class<? extends ThrownPotion> c, final @Nullable ThrownPotion e) {\n+\t\tif (e != null) {\n+\t\t\tfinal ItemStack i = e.getItem();\n+\t\t\tif (i == null)\n+\t\t\t\treturn false;\n+\t\t\ttypes = new ItemType[] {new ItemType(i)};\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean match(final ThrownPotion entity) {\n+\t\tif (types != null) {\n+\t\t\tfor (final ItemType t : types) {\n+\t\t\t\tif (t.isOfType(entity.getItem()))\n+\t\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Nullable\n+\t@Override\n+\tpublic ThrownPotion spawn(Location loc) {\n+\t\tItemType t = CollectionUtils.getRandom(types);\n+\t\tassert t != null;\n+\t\tfinal ItemStack i = t.getRandom();\n+\t\tif (i == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tThrownPotion potion = loc.getWorld().spawn(loc, ThrownPotion.class);\n+\t\tpotion.setItem(i);\n+\t\treturn potion;\n+\t}\n+\t\n+\t@Override\n+\tpublic void set(final ThrownPotion entity) {\n+\t\tif (types != null) {\n+\t\t\tfinal ItemType t = CollectionUtils.getRandom(types);\n+\t\t\tassert t != null;\n+\t\t\tItemStack i = t.getRandom();\n+\t\t\tif (i == null)\n+\t\t\t\treturn; // Missing item, can't make thrown potion of it\n+\t\t\tentity.setItem(i);\n+\t\t}\n+\t\tassert false;\n+\t}\n+\t\n+\t@Override\n+\tpublic Class<? extends ThrownPotion> getType() {\n+\t\treturn ThrownPotion.class;\n+\t}\n+\t\n+\t@Override\n+\tpublic EntityData getSuperType() {\n+\t\treturn new ThrownPotionData();\n+\t}\n+\t\n+\t@Override\n+\tpublic boolean isSupertypeOf(final EntityData<?> e) {\n+\t\tif (!(e instanceof ThrownPotionData))\n+\t\t\treturn false;\n+\t\tfinal ThrownPotionData d = (ThrownPotionData) e;\n+\t\tif (types != null) {\n+\t\t\treturn d.types != null && ItemType.isSubset(types, d.types);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString(final int flags) {\n+\t\tfinal ItemType[] types = this.types;\n+\t\tif (types == null)\n+\t\t\treturn super.toString(flags);\n+\t\tfinal StringBuilder b = new StringBuilder();\n+\t\tb.append(Noun.getArticleWithSpace(types[0].getTypes().get(0).getGender(), flags));\n+\t\tb.append(m_adjective.toString(types[0].getTypes().get(0).getGender(), flags));\n+\t\tb.append(\" \");\n+\t\tb.append(Classes.toString(types, flags & Language.NO_ARTICLE_MASK, false));\n+\t\treturn \"\" + b.toString();\n+\t}\n+\t\n+\t//\t\treturn ItemType.serialize(types);\n+\t@Override\n+\t@Deprecated\n+\tprotected boolean deserialize(final String s) {\n+\t\tthrow new UnsupportedOperationException(\"old serialization is no longer supported\");\n+//\t\tif (s.isEmpty())\n+//\t\t\treturn true;\n+//\t\ttypes = ItemType.deserialize(s);\n+//\t\treturn types != null;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean equals_i(final EntityData<?> obj) {\n+\t\tif (!(obj instanceof ThrownPotionData))\n+\t\t\treturn false;\n+\t\treturn Arrays.equals(types, ((ThrownPotionData) obj).types);\n+\t}\n+\t\n+\t@Override\n+\tprotected int hashCode_i() {\n+\t\treturn Arrays.hashCode(types);\n+\t}\n+\t\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NTAxOQ==", "url": "https://github.com/SkriptLang/Skript/pull/2892#discussion_r421565019", "bodyText": "Same goes here, get the ItemType through Aliases#javaItemtype", "author": "SnowPyon", "createdAt": "2020-05-07T14:48:29Z", "path": "src/main/java/ch/njol/skript/entity/ThrownPotionData.java", "diffHunk": "@@ -46,34 +47,33 @@\n \t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\r\n \t}\r\n \t\r\n-\tprivate final static Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\r\n+\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\r\n+\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\r\n \t\r\n \t@Nullable\r\n \tprivate ItemType[] types;\r\n \t\r\n \t@Override\r\n \tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\r\n \t\tif (exprs.length > 0 && exprs[0] != null) {\r\n-\t\t\tif ((Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, new Converter<ItemType, ItemType>() {\r\n-\t\t\t\t@Override\r\n-\t\t\t\t@Nullable\r\n-\t\t\t\tpublic ItemType convert(final ItemType t) {\r\n-\t\t\t\t\tItemType r = null;\r\n-\t\t\t\t\tfor (final ItemData d : t.getTypes()) {\r\n-\t\t\t\t\t\tif (d.getType() == Material.POTION) {\r\n-\t\t\t\t\t\t\tif (r == null)\r\n-\t\t\t\t\t\t\t\tr = new ItemType(d);\r\n-\t\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\t\tr.add(d);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\treturn r;\r\n+\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\r\n+\t\t\t\tMaterial type = t.getMaterial();\r\n+\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\r\n+\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\r\n+\t\t\t\tif (type == Material.POTION || (type == Material.LINGERING_POTION && RUNNING_LEGACY)) {\r\n+\t\t\t\t\tItemMeta meta = t.getItemMeta();\r\n+\t\t\t\t\tItemType itemType = new ItemType(Material.SPLASH_POTION);\r", "originalCommit": "6a35e0c56fe8a190aee1459de1eae9cc8b23b3b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "069bb787579996fdf0faceb86846868648ecd177", "chunk": "diff --git a/src/main/java/ch/njol/skript/entity/ThrownPotionData.java b/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\nindex 5ec3064b..6acee8f2 100644\n--- a/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\n+++ b/src/main/java/ch/njol/skript/entity/ThrownPotionData.java\n\n@@ -1,186 +1,188 @@\n-/**\n- *   This file is part of Skript.\n- *\n- *  Skript is free software: you can redistribute it and/or modify\n- *  it under the terms of the GNU General Public License as published by\n- *  the Free Software Foundation, either version 3 of the License, or\n- *  (at your option) any later version.\n- *\n- *  Skript is distributed in the hope that it will be useful,\n- *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- *  GNU General Public License for more details.\n- *\n- *  You should have received a copy of the GNU General Public License\n- *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n- *\n- *\n- * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n- */\n-package ch.njol.skript.entity;\n-\n-import java.util.Arrays;\n-\n-import org.bukkit.Location;\n-import org.bukkit.Material;\n-import org.bukkit.entity.ThrownPotion;\n-import org.bukkit.inventory.ItemStack;\n-import org.bukkit.inventory.meta.ItemMeta;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-import ch.njol.skript.Skript;\n-import ch.njol.skript.aliases.ItemType;\n-import ch.njol.skript.lang.Literal;\n-import ch.njol.skript.lang.SkriptParser.ParseResult;\n-import ch.njol.skript.localization.Adjective;\n-import ch.njol.skript.localization.Language;\n-import ch.njol.skript.localization.Noun;\n-import ch.njol.skript.registrations.Classes;\n-import ch.njol.skript.registrations.Converters;\n-import ch.njol.util.coll.CollectionUtils;\n-\n-/**\n- * @author Peter G\u00fcttinger\n- */\n-public class ThrownPotionData extends EntityData<ThrownPotion> {\n-\tstatic {\n-\t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\n-\t}\n-\t\n-\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\n-\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\n-\t\n-\t@Nullable\n-\tprivate ItemType[] types;\n-\t\n-\t@Override\n-\tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\n-\t\tif (exprs.length > 0 && exprs[0] != null) {\n-\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\n-\t\t\t\tMaterial type = t.getMaterial();\n-\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\n-\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\n-\t\t\t\tif (type == Material.POTION || (type == Material.LINGERING_POTION && RUNNING_LEGACY)) {\n-\t\t\t\t\tItemMeta meta = t.getItemMeta();\n-\t\t\t\t\tItemType itemType = new ItemType(Material.SPLASH_POTION);\n-\t\t\t\t\titemType.setItemMeta(meta);\n-\t\t\t\t\treturn itemType;\n-\t\t\t\t} else if (type != Material.SPLASH_POTION && type != Material.LINGERING_POTION) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t\treturn t;\n-\t\t\t})).length != 0; // no error message - other things can be thrown as well\n-\t\t} else {\n-\t\t\ttypes = new ItemType[]{new ItemType(Material.SPLASH_POTION)};\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean init(final @Nullable Class<? extends ThrownPotion> c, final @Nullable ThrownPotion e) {\n-\t\tif (e != null) {\n-\t\t\tfinal ItemStack i = e.getItem();\n-\t\t\tif (i == null)\n-\t\t\t\treturn false;\n-\t\t\ttypes = new ItemType[] {new ItemType(i)};\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean match(final ThrownPotion entity) {\n-\t\tif (types != null) {\n-\t\t\tfor (final ItemType t : types) {\n-\t\t\t\tif (t.isOfType(entity.getItem()))\n-\t\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Nullable\n-\t@Override\n-\tpublic ThrownPotion spawn(Location loc) {\n-\t\tItemType t = CollectionUtils.getRandom(types);\n-\t\tassert t != null;\n-\t\tfinal ItemStack i = t.getRandom();\n-\t\tif (i == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tThrownPotion potion = loc.getWorld().spawn(loc, ThrownPotion.class);\n-\t\tpotion.setItem(i);\n-\t\treturn potion;\n-\t}\n-\t\n-\t@Override\n-\tpublic void set(final ThrownPotion entity) {\n-\t\tif (types != null) {\n-\t\t\tfinal ItemType t = CollectionUtils.getRandom(types);\n-\t\t\tassert t != null;\n-\t\t\tItemStack i = t.getRandom();\n-\t\t\tif (i == null)\n-\t\t\t\treturn; // Missing item, can't make thrown potion of it\n-\t\t\tentity.setItem(i);\n-\t\t}\n-\t\tassert false;\n-\t}\n-\t\n-\t@Override\n-\tpublic Class<? extends ThrownPotion> getType() {\n-\t\treturn ThrownPotion.class;\n-\t}\n-\t\n-\t@Override\n-\tpublic EntityData getSuperType() {\n-\t\treturn new ThrownPotionData();\n-\t}\n-\t\n-\t@Override\n-\tpublic boolean isSupertypeOf(final EntityData<?> e) {\n-\t\tif (!(e instanceof ThrownPotionData))\n-\t\t\treturn false;\n-\t\tfinal ThrownPotionData d = (ThrownPotionData) e;\n-\t\tif (types != null) {\n-\t\t\treturn d.types != null && ItemType.isSubset(types, d.types);\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\t@Override\n-\tpublic String toString(final int flags) {\n-\t\tfinal ItemType[] types = this.types;\n-\t\tif (types == null)\n-\t\t\treturn super.toString(flags);\n-\t\tfinal StringBuilder b = new StringBuilder();\n-\t\tb.append(Noun.getArticleWithSpace(types[0].getTypes().get(0).getGender(), flags));\n-\t\tb.append(m_adjective.toString(types[0].getTypes().get(0).getGender(), flags));\n-\t\tb.append(\" \");\n-\t\tb.append(Classes.toString(types, flags & Language.NO_ARTICLE_MASK, false));\n-\t\treturn \"\" + b.toString();\n-\t}\n-\t\n-\t//\t\treturn ItemType.serialize(types);\n-\t@Override\n-\t@Deprecated\n-\tprotected boolean deserialize(final String s) {\n-\t\tthrow new UnsupportedOperationException(\"old serialization is no longer supported\");\n-//\t\tif (s.isEmpty())\n-//\t\t\treturn true;\n-//\t\ttypes = ItemType.deserialize(s);\n-//\t\treturn types != null;\n-\t}\n-\t\n-\t@Override\n-\tprotected boolean equals_i(final EntityData<?> obj) {\n-\t\tif (!(obj instanceof ThrownPotionData))\n-\t\t\treturn false;\n-\t\treturn Arrays.equals(types, ((ThrownPotionData) obj).types);\n-\t}\n-\t\n-\t@Override\n-\tprotected int hashCode_i() {\n-\t\treturn Arrays.hashCode(types);\n-\t}\n-\t\n-}\n+/**\n+ *   This file is part of Skript.\n+ *\n+ *  Skript is free software: you can redistribute it and/or modify\n+ *  it under the terms of the GNU General Public License as published by\n+ *  the Free Software Foundation, either version 3 of the License, or\n+ *  (at your option) any later version.\n+ *\n+ *  Skript is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Skript.  If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ *\n+ * Copyright 2011-2017 Peter G\u00fcttinger and contributors\n+ */\n+package ch.njol.skript.entity;\n+\n+import java.util.Arrays;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.ThrownPotion;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import ch.njol.skript.Skript;\n+import ch.njol.skript.aliases.Aliases;\n+import ch.njol.skript.aliases.ItemType;\n+import ch.njol.skript.lang.Literal;\n+import ch.njol.skript.lang.SkriptParser.ParseResult;\n+import ch.njol.skript.localization.Adjective;\n+import ch.njol.skript.localization.Language;\n+import ch.njol.skript.localization.Noun;\n+import ch.njol.skript.registrations.Classes;\n+import ch.njol.skript.registrations.Converters;\n+import ch.njol.util.coll.CollectionUtils;\n+\n+/**\n+ * @author Peter G\u00fcttinger\n+ */\n+public class ThrownPotionData extends EntityData<ThrownPotion> {\n+\tstatic {\n+\t\tEntityData.register(ThrownPotionData.class, \"thrown potion\", ThrownPotion.class, \"thrown potion\");\n+\t}\n+\t\n+\tprivate static final Adjective m_adjective = new Adjective(\"entities.thrown potion.adjective\");\n+\tprivate static final boolean RUNNING_LEGACY = !Skript.isRunningMinecraft(1, 13);\n+\tprivate static final ItemType POTION = Aliases.javaItemType(\"potion\");\n+\tprivate static final ItemType SPLASH_POTION = Aliases.javaItemType(\"splash potion\");\n+\tprivate static final ItemType LINGER_POTION = Aliases.javaItemType(\"lingering potion\");\n+\t\n+\t@Nullable\n+\tprivate ItemType[] types;\n+\t\n+\t@Override\n+\tprotected boolean init(final Literal<?>[] exprs, final int matchedPattern, final ParseResult parseResult) {\n+\t\tif (exprs.length > 0 && exprs[0] != null) {\n+\t\t\treturn (types = Converters.convert((ItemType[]) exprs[0].getAll(), ItemType.class, t -> {\n+\t\t\t\t// If the itemtype is a potion, lets make it a splash potion (required by Bukkit)\n+\t\t\t\t// Due to an issue with 1.12.2 and below, we have to force a lingering potion to be a splash potion\n+\t\t\t\tif (t.isSupertypeOf(POTION) || (t.isSupertypeOf(LINGER_POTION) && RUNNING_LEGACY)) {\n+\t\t\t\t\tItemMeta meta = t.getItemMeta();\n+\t\t\t\t\tItemType itemType = SPLASH_POTION.clone();\n+\t\t\t\t\titemType.setItemMeta(meta);\n+\t\t\t\t\treturn itemType;\n+\t\t\t\t} else if (!t.isSupertypeOf(SPLASH_POTION ) && !t.isSupertypeOf(LINGER_POTION)) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\treturn t;\n+\t\t\t})).length != 0; // no error message - other things can be thrown as well\n+\t\t} else {\n+\t\t\ttypes = new ItemType[]{SPLASH_POTION.clone()};\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean init(final @Nullable Class<? extends ThrownPotion> c, final @Nullable ThrownPotion e) {\n+\t\tif (e != null) {\n+\t\t\tfinal ItemStack i = e.getItem();\n+\t\t\tif (i == null)\n+\t\t\t\treturn false;\n+\t\t\ttypes = new ItemType[] {new ItemType(i)};\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean match(final ThrownPotion entity) {\n+\t\tif (types != null) {\n+\t\t\tfor (final ItemType t : types) {\n+\t\t\t\tif (t.isOfType(entity.getItem()))\n+\t\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Nullable\n+\t@Override\n+\tpublic ThrownPotion spawn(Location loc) {\n+\t\tItemType t = CollectionUtils.getRandom(types);\n+\t\tassert t != null;\n+\t\tfinal ItemStack i = t.getRandom();\n+\t\tif (i == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tThrownPotion potion = loc.getWorld().spawn(loc, ThrownPotion.class);\n+\t\tpotion.setItem(i);\n+\t\treturn potion;\n+\t}\n+\t\n+\t@Override\n+\tpublic void set(final ThrownPotion entity) {\n+\t\tif (types != null) {\n+\t\t\tfinal ItemType t = CollectionUtils.getRandom(types);\n+\t\t\tassert t != null;\n+\t\t\tItemStack i = t.getRandom();\n+\t\t\tif (i == null)\n+\t\t\t\treturn; // Missing item, can't make thrown potion of it\n+\t\t\tentity.setItem(i);\n+\t\t}\n+\t\tassert false;\n+\t}\n+\t\n+\t@Override\n+\tpublic Class<? extends ThrownPotion> getType() {\n+\t\treturn ThrownPotion.class;\n+\t}\n+\t\n+\t@Override\n+\tpublic EntityData getSuperType() {\n+\t\treturn new ThrownPotionData();\n+\t}\n+\t\n+\t@Override\n+\tpublic boolean isSupertypeOf(final EntityData<?> e) {\n+\t\tif (!(e instanceof ThrownPotionData))\n+\t\t\treturn false;\n+\t\tfinal ThrownPotionData d = (ThrownPotionData) e;\n+\t\tif (types != null) {\n+\t\t\treturn d.types != null && ItemType.isSubset(types, d.types);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString(final int flags) {\n+\t\tfinal ItemType[] types = this.types;\n+\t\tif (types == null)\n+\t\t\treturn super.toString(flags);\n+\t\tfinal StringBuilder b = new StringBuilder();\n+\t\tb.append(Noun.getArticleWithSpace(types[0].getTypes().get(0).getGender(), flags));\n+\t\tb.append(m_adjective.toString(types[0].getTypes().get(0).getGender(), flags));\n+\t\tb.append(\" \");\n+\t\tb.append(Classes.toString(types, flags & Language.NO_ARTICLE_MASK, false));\n+\t\treturn \"\" + b.toString();\n+\t}\n+\t\n+\t//\t\treturn ItemType.serialize(types);\n+\t@Override\n+\t@Deprecated\n+\tprotected boolean deserialize(final String s) {\n+\t\tthrow new UnsupportedOperationException(\"old serialization is no longer supported\");\n+//\t\tif (s.isEmpty())\n+//\t\t\treturn true;\n+//\t\ttypes = ItemType.deserialize(s);\n+//\t\treturn types != null;\n+\t}\n+\t\n+\t@Override\n+\tprotected boolean equals_i(final EntityData<?> obj) {\n+\t\tif (!(obj instanceof ThrownPotionData))\n+\t\t\treturn false;\n+\t\treturn Arrays.equals(types, ((ThrownPotionData) obj).types);\n+\t}\n+\t\n+\t@Override\n+\tprotected int hashCode_i() {\n+\t\treturn Arrays.hashCode(types);\n+\t}\n+\t\n+}\n"}}, {"oid": "069bb787579996fdf0faceb86846868648ecd177", "url": "https://github.com/SkriptLang/Skript/commit/069bb787579996fdf0faceb86846868648ecd177", "message": "ThrownPotionData - remove material checks", "committedDate": "2020-05-07T20:54:17Z", "type": "commit"}, {"oid": "92813cd646e00813957c4f878c1a03696adb3bd2", "url": "https://github.com/SkriptLang/Skript/commit/92813cd646e00813957c4f878c1a03696adb3bd2", "message": "Merge branch 'master' into fix/throw-potion", "committedDate": "2020-07-09T19:13:01Z", "type": "commit"}]}