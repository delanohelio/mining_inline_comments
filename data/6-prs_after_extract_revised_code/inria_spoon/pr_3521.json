{"pr_number": 3521, "pr_title": "fix: fix handling of intersection types for lambda parameters", "pr_createdAt": "2020-08-08T09:19:13Z", "pr_url": "https://github.com/INRIA/spoon/pull/3521", "timeline": [{"oid": "fabe6947ffcc94e612b9a8ca8248a046c5c734c1", "url": "https://github.com/INRIA/spoon/commit/fabe6947ffcc94e612b9a8ca8248a046c5c734c1", "message": "test case for  #3520", "committedDate": "2020-08-08T09:11:24Z", "type": "commit"}, {"oid": "d816c9fe1ad55486267b051e2ce934ddf6e266e2", "url": "https://github.com/INRIA/spoon/commit/d816c9fe1ad55486267b051e2ce934ddf6e266e2", "message": "possible fix for #3520", "committedDate": "2020-08-08T09:16:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjU3MA==", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466570", "bodyText": "refactor the else block in getOverriddenMethodForIntersectionType?", "author": "monperrus", "createdAt": "2020-08-08T13:46:11Z", "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();", "originalCommit": "d816c9fe1ad55486267b051e2ce934ddf6e266e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c969acd74ea7e0ed70bcd3cd21c81f62ecd1ae51", "chunk": "diff --git a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\nindex 9cd860e6..2936cfbe 100644\n--- a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\n+++ b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\n\n@@ -105,30 +105,35 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtMethod<?> lambdaExecutableMethod = null;\n \t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n \t\t\treturn getOverriddenAux(lambdaTypeRef);\n-\t\t} else {\n-\t\t\tCtElement parent = lambdaTypeRef.getParent();\n-\t\t\tCtTypeReference<?> parentTypeReference = null;\n-\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n-\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n-\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n-\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n-\t\t\t}\n-\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n-\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n-\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n-\t\t\t\t\tlambdaExecutableMethod = tmp;\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n+\t\tCtMethod<?> lambdaExecutableMethod = getOverriddenMethodForIntersectionType(lambdaTypeRef);\n \t\tif (lambdaExecutableMethod == null) {\n \t\t\tthrow new SpoonException(\"The lambda can be based on interface, which has one method. But \" + lambdaTypeRef.getQualifiedName() + \" has no one\");\n \t\t}\n \t\treturn (CtMethod<R>) lambdaExecutableMethod;\n \t}\n \n+\tprivate CtMethod<?> getOverriddenMethodForIntersectionType(CtTypeReference<T> lambdaTypeRef)\n+\t\t\tthrows SpoonException {\n+\t\tCtMethod<?> lambdaExecutableMethod=null;\n+\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t}\n+\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t}\n+\t\t}\n+\t\treturn lambdaExecutableMethod;\n+\t}\n+\n \tprivate  <R> CtMethod<R> getOverriddenAux(CtTypeReference<?> lambdaTypeRef) throws SpoonException {\n \t\tCtType<?> lambdaType = lambdaTypeRef.getTypeDeclaration();\n \t\tif (lambdaType.isInterface() == false) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ==", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466655", "bodyText": "do we need to move this check here? could we keep it at the previous place?", "author": "monperrus", "createdAt": "2020-08-08T13:47:15Z", "path": "src/main/java/spoon/support/reflect/code/CtLambdaImpl.java", "diffHunk": "@@ -101,7 +105,32 @@ public String getSimpleName() {\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n+\t\tCtMethod<?> lambdaExecutableMethod = null;\n+\t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n+\t\t\treturn getOverriddenAux(lambdaTypeRef);\n+\t\t} else {\n+\t\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t\t}\n+\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (lambdaExecutableMethod == null) {", "originalCommit": "d816c9fe1ad55486267b051e2ce934ddf6e266e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU5MTc1Mw==", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r470591753", "bodyText": "It follows the standard compiler behavior.\nThat is, at least one interface should have one method,\nthus, some of these interfaces might not even declare any methods.\nBut as a side note, I just match the type that will be taken by the lambda in its parent,\nbut I did not implement a real type intersection, thus I am less strict than the compiler.\nA great improvement would be to implement this type intersection in spoon.\nBut it is too complicated for me :/ and I would not be useful for my use case.", "author": "quentinLeDilavrec", "createdAt": "2020-08-14T12:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1ODM2Mg==", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r470958362", "bodyText": "OK for me, thanks.", "author": "monperrus", "createdAt": "2020-08-15T09:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c969acd74ea7e0ed70bcd3cd21c81f62ecd1ae51", "chunk": "diff --git a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\nindex 9cd860e6..2936cfbe 100644\n--- a/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\n+++ b/src/main/java/spoon/support/reflect/code/CtLambdaImpl.java\n\n@@ -105,30 +105,35 @@ public class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T>\n \t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n \t\t\treturn null;\n \t\t}\n-\t\tCtMethod<?> lambdaExecutableMethod = null;\n \t\tif (!(lambdaTypeRef instanceof CtIntersectionTypeReference)) {\n \t\t\treturn getOverriddenAux(lambdaTypeRef);\n-\t\t} else {\n-\t\t\tCtElement parent = lambdaTypeRef.getParent();\n-\t\t\tCtTypeReference<?> parentTypeReference = null;\n-\t\t\tif (parent != null && parent instanceof CtLocalVariable) {\n-\t\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n-\t\t\t} else if (parent != null && parent instanceof CtAssignment) {\n-\t\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n-\t\t\t}\n-\t\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n-\t\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n-\t\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n-\t\t\t\t\tlambdaExecutableMethod = tmp;\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n+\t\tCtMethod<?> lambdaExecutableMethod = getOverriddenMethodForIntersectionType(lambdaTypeRef);\n \t\tif (lambdaExecutableMethod == null) {\n \t\t\tthrow new SpoonException(\"The lambda can be based on interface, which has one method. But \" + lambdaTypeRef.getQualifiedName() + \" has no one\");\n \t\t}\n \t\treturn (CtMethod<R>) lambdaExecutableMethod;\n \t}\n \n+\tprivate CtMethod<?> getOverriddenMethodForIntersectionType(CtTypeReference<T> lambdaTypeRef)\n+\t\t\tthrows SpoonException {\n+\t\tCtMethod<?> lambdaExecutableMethod=null;\n+\t\tCtElement parent = lambdaTypeRef.getParent();\n+\t\tCtTypeReference<?> parentTypeReference = null;\n+\t\tif (parent != null && parent instanceof CtLocalVariable) {\n+\t\t\tparentTypeReference = ((CtLocalVariable) parent).getType();\n+\t\t} else if (parent != null && parent instanceof CtAssignment) {\n+\t\t\tparentTypeReference = ((CtAssignment) parent).getAssigned().getType();\n+\t\t}\n+\t\tfor (CtTypeReference<?> ctTypeReference : ((CtIntersectionTypeReference<?>) lambdaTypeRef).getBounds()) {\n+\t\t\tCtMethod<?> tmp = getOverriddenAux(ctTypeReference);\n+\t\t\tif (tmp != null && (lambdaExecutableMethod == null || ctTypeReference.equals(parentTypeReference))) {\n+\t\t\t\tlambdaExecutableMethod = tmp;\n+\t\t\t}\n+\t\t}\n+\t\treturn lambdaExecutableMethod;\n+\t}\n+\n \tprivate  <R> CtMethod<R> getOverriddenAux(CtTypeReference<?> lambdaTypeRef) throws SpoonException {\n \t\tCtType<?> lambdaType = lambdaTypeRef.getTypeDeclaration();\n \t\tif (lambdaType.isInterface() == false) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ2NjgzNQ==", "url": "https://github.com/INRIA/spoon/pull/3521#discussion_r467466835", "bodyText": "could you add a one line comment stating the test intention in natural language:\n// contract: intersection types on lambda parameters are supported", "author": "monperrus", "createdAt": "2020-08-08T13:49:14Z", "path": "src/test/java/spoon/test/lambda/LambdaTest.java", "diffHunk": "@@ -458,6 +458,16 @@ public void testLambdaWithGenericExtendingMultipleInterfaces() {\n \t\tassertIsWellPrinted(\"( elt) -> elt.test()\", lambda);\n \t}\n \n+\t@Test\n+\tpublic void testCastLambdaWithIntersection() {\n+\t\tfinal CtLambda<?> lambda1 = intersection.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class)).get(1);", "originalCommit": "d816c9fe1ad55486267b051e2ce934ddf6e266e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8fc666094466e27b9a217187ce7b5f5bfd4cbbe6", "chunk": "diff --git a/src/test/java/spoon/test/lambda/LambdaTest.java b/src/test/java/spoon/test/lambda/LambdaTest.java\nindex ad8300f7..2f8631ba 100644\n--- a/src/test/java/spoon/test/lambda/LambdaTest.java\n+++ b/src/test/java/spoon/test/lambda/LambdaTest.java\n\n@@ -460,6 +460,7 @@ public class LambdaTest {\n \n \t@Test\n \tpublic void testCastLambdaWithIntersection() {\n+\t\t// contract: intersection types on lambda parameters are supported \n \t\tfinal CtLambda<?> lambda1 = intersection.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class)).get(1);\n \t\tlambda1.getReference();\n \t\tfinal CtLambda<?> lambda2 = intersection.getElements(new TypeFilter<CtLambda<?>>(CtLambda.class)).get(2);\n"}}, {"oid": "c969acd74ea7e0ed70bcd3cd21c81f62ecd1ae51", "url": "https://github.com/INRIA/spoon/commit/c969acd74ea7e0ed70bcd3cd21c81f62ecd1ae51", "message": "3521#discussion_r467466570", "committedDate": "2020-08-14T12:34:50Z", "type": "commit"}, {"oid": "8fc666094466e27b9a217187ce7b5f5bfd4cbbe6", "url": "https://github.com/INRIA/spoon/commit/8fc666094466e27b9a217187ce7b5f5bfd4cbbe6", "message": "3521#discussion_r467466835", "committedDate": "2020-08-14T12:35:11Z", "type": "commit"}, {"oid": "b4a8b4024501586f2454024279365ba072b009c1", "url": "https://github.com/INRIA/spoon/commit/b4a8b4024501586f2454024279365ba072b009c1", "message": "rename auxilary\nfrom getOverriddenMethodAux\nto getOverriddenMethodForIntersectionType", "committedDate": "2020-08-15T11:32:50Z", "type": "commit"}, {"oid": "9470c32d4f4dc762180c2ef0783370c31c94e592", "url": "https://github.com/INRIA/spoon/commit/9470c32d4f4dc762180c2ef0783370c31c94e592", "message": "please checkstyle", "committedDate": "2020-08-17T15:42:32Z", "type": "commit"}]}