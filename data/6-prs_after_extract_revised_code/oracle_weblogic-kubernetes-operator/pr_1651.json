{"pr_number": 1651, "pr_title": "Implement assertion that only maxUnavailable pods are replaced at a time", "pr_createdAt": "2020-05-15T03:54:57Z", "pr_url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651", "timeline": [{"oid": "5b2ae819b4ba7815a1c9a0613a43968ee66026a7", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5b2ae819b4ba7815a1c9a0613a43968ee66026a7", "message": "adding assertion to check pods in a given namespace are rolling restarted", "committedDate": "2020-05-14T23:20:33Z", "type": "commit"}, {"oid": "2f99f66b94714286f7bd1fb968f4da2c18279664", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/2f99f66b94714286f7bd1fb968f4da2c18279664", "message": "Fix the parameter orders", "committedDate": "2020-05-14T23:39:06Z", "type": "commit"}, {"oid": "5da038e34e5a89a37a783fab0f213367406d8bd6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5da038e34e5a89a37a783fab0f213367406d8bd6", "message": "Fix the pod terminating method", "committedDate": "2020-05-15T00:11:42Z", "type": "commit"}, {"oid": "5d749f9abb2223e66352fec9eff1c8386e3f3eb9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5d749f9abb2223e66352fec9eff1c8386e3f3eb9", "message": "wip", "committedDate": "2020-05-15T00:55:52Z", "type": "commit"}, {"oid": "e098f82282919b4ddabf87c2f31f20fc7929e64c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e098f82282919b4ddabf87c2f31f20fc7929e64c", "message": "wip", "committedDate": "2020-05-15T01:23:01Z", "type": "commit"}, {"oid": "c96ff7ae2ed6fa1723916bd8f2303e70d8acabdc", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c96ff7ae2ed6fa1723916bd8f2303e70d8acabdc", "message": "wip", "committedDate": "2020-05-15T02:20:19Z", "type": "commit"}, {"oid": "6d6ee593171202a8d1d2689ba41a3e1659460ba5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/6d6ee593171202a8d1d2689ba41a3e1659460ba5", "message": "wip", "committedDate": "2020-05-15T02:49:51Z", "type": "commit"}, {"oid": "a2941c09c0b2a392c48a1c10cb3165253230ee5d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/a2941c09c0b2a392c48a1c10cb3165253230ee5d", "message": "wip", "committedDate": "2020-05-15T02:52:51Z", "type": "commit"}, {"oid": "bbb114894538f078370bfa1cd7c8a84057f666ac", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/bbb114894538f078370bfa1cd7c8a84057f666ac", "message": "wip", "committedDate": "2020-05-15T03:11:10Z", "type": "commit"}, {"oid": "300fddbd9f22bc1761eb8f069e24a456baaf3962", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/300fddbd9f22bc1761eb8f069e24a456baaf3962", "message": "Fix the javadocs", "committedDate": "2020-05-15T04:02:44Z", "type": "commit"}, {"oid": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "message": "wip", "committedDate": "2020-05-15T04:53:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r425828957", "bodyText": "I could be wrong, but I suspect there may be multiple issues with this assertion, some of it functional, some of it due to incompleteness.  All of the following should be double checked with Ryan, Lenny, and Anthony:\n\n\nSeems to assume a single cluster and no non-clustered servers. Consequently, this test seems to assume that only one server can go down a time.  This is incorrect when there are multiple clusters, unmanaged servers, a replica count change, or a deleted cluster.\n\n\nSeems to dynamically obtain a list of servers when checking if only one server is 'down'.  IMO, it'd be better to get the list of servers at the beginning of a test before any changes are made to initiate the roll (otherwise, it won't catch if two servers in the cluster 'disappear' at the same time).  This 'original list' should be then compared to what's expected by the domain resource in terms of replicas, restartVersions, and image in order to determine the expected behavior for the roll.\n\n\nNote that this may get a little tricky when 'replicas' changes at the same time as everything else.  When replicas increases, the number of 'not ready' can be higher than 1 since the replicas are allowed to start in parallel.   When replicas decreases I assume (but am not sure) the roll is expected to defer terminating the servers until after it's completed the roll of the previous servers, and then only terminate them one at a time.   Similar issues may be seen when a cluster is deleted (the roll doesn't apply in that case I assume) or a new cluster is added (multiple servers can start at once).\n\n\nSeems to use 'Terminating' as a criteria when checking if a single server is down. For any particular domain it should check the admin server is ready - if not, then the admin server should be the only cycling server.  Then it should check that all other servers are 'ready' except one for their particular cluster as compared to the list of pods obtained at the beginning of the test (except in the case of varying replicas).\n\n\nDoes not seem to verify that admin server always is 'ahead' of other servers (first to roll and reach target state, and only one that should be down until this occurs)?\n\n\nDoes not verify that rolls are expected to occur 'in order' within a given cluster.\n\n\nAt the conclusion of the test, does not check if all servers have (a) reached their target domain/cluster/server restartVersion and (b) reached their target image.  (This should be done in addition to checking for  'ready' state.)", "author": "tbarnes-us", "createdAt": "2020-05-15T14:11:08Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, domainUid, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating.\n+   *\n+   * @param podName name of pod to check for termination status\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which the pod is running\n+   * @return true if given pod is terminating otherwise false\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  private static Callable<Boolean> onlyGivenPodTerminating(String podName, String domainUid, String namespace)\n+      throws Exception {\n+    return () -> {\n+      String labelSelectors = String.format(\"weblogic.serverName\", domainUid);\n+      V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+      if (listPods.getItems().isEmpty()) {", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTI4OQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427611289", "bodyText": "Removed getting pods dynamically and instead the pod names are passed to the assertion method as a list. The assertion method will simply go through the list and verify its restarted in the sequence it is added in the list, at the same time verifies no other pods are restarted at the same time. verifying the restart version after rolling should be done in the test IMO.", "author": "sankarpn", "createdAt": "2020-05-19T21:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4ODE5Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428788193", "bodyText": "verifying the restart version after rolling should be done in the test IMO.", "author": "tbarnes-us", "createdAt": "2020-05-21T17:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4OTI4Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428789283", "bodyText": "Why? A \"proper\" restart version and image are required for every single roll.  They're essential for correct behavior.  So why not centrally ensure they match the domain resource's values for every roll?", "author": "tbarnes-us", "createdAt": "2020-05-21T17:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTQzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428815434", "bodyText": "The requirement is to assert pods replacement doesn't exceed maxUnavailable at a time. We can create another assertion to ensure the integrity of the restartVersion and image.", "author": "sankarpn", "createdAt": "2020-05-21T17:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTI3OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428829278", "bodyText": "the 'spirit' of the requirement IMO, is to check that roll is working as designed from a customer perspective, this includes restart-version and image", "author": "tbarnes-us", "createdAt": "2020-05-21T18:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTgyODk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211333", "bodyText": "up to ten minutes", "author": "markxnelson", "createdAt": "2020-05-17T02:56:12Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQyNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211426", "bodyText": "but your logic below seems to wait longer than ten minutes", "author": "markxnelson", "createdAt": "2020-05-17T02:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDQzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114435", "bodyText": "changed javadoc", "author": "sankarpn", "createdAt": "2020-05-20T15:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDc2OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114768", "bodyText": "but your logic below seems to wait longer than ten minutes\n\nremoved old wait code", "author": "sankarpn", "createdAt": "2020-05-20T15:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTM2NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211365", "bodyText": "method name seems wrong, something like verifyRollingRestartOccurred maybe?", "author": "markxnelson", "createdAt": "2020-05-17T02:57:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDkzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428114936", "bodyText": "changed", "author": "sankarpn", "createdAt": "2020-05-20T15:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ2NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211464", "bodyText": "something seems wrong here - what it you call this too late?\nseems like this needs to be some kind of \"watcher\" than can be started before you initiate the roll, and collect a future/promise/whatever from it afterwards/later", "author": "markxnelson", "createdAt": "2020-05-17T02:59:22Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNjcxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428116713", "bodyText": "now the assertion method takes the list of pods to check for rolling restart from test and there is a requirement for using this assertion , it should be called right after the patching was done.", "author": "sankarpn", "createdAt": "2020-05-20T15:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211473", "bodyText": "how do you know you found all of the expected pods? again, there is a timing issue here", "author": "markxnelson", "createdAt": "2020-05-17T02:59:46Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNjkzMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428116932", "bodyText": "see above comment", "author": "sankarpn", "createdAt": "2020-05-20T15:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTUyOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211529", "bodyText": "check that all of the pods are in termination status in a set of concurrent threads", "author": "markxnelson", "createdAt": "2020-05-17T03:00:18Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTAzOQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119039", "bodyText": "checking the pod termination status is now sequential according to the order of pods in the list. Also while checking for termination status of a  given pod , the method will check no other pods are terminating along with it.", "author": "sankarpn", "createdAt": "2020-05-20T15:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211547", "bodyText": "again, not sure this is a good idea when you are running under maven/failsafe plugin", "author": "markxnelson", "createdAt": "2020-05-17T03:00:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU5NA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211594", "bodyText": "you could just use the kubernetes get pods api and set watch = true .....", "author": "markxnelson", "createdAt": "2020-05-17T03:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTQ0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119443", "bodyText": "no concurrent checking now, its sequential", "author": "sankarpn", "createdAt": "2020-05-20T15:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYxMA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211610", "bodyText": "do you need to wait for them to be ready, or just running?", "author": "markxnelson", "createdAt": "2020-05-17T03:02:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDE2Nw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428120167", "bodyText": "The refactored code will check the termination status and then the ready status", "author": "sankarpn", "createdAt": "2020-05-20T15:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYzNQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r426211635", "bodyText": "this will wait another ten minutes right?", "author": "markxnelson", "createdAt": "2020-05-17T03:02:41Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodList;\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  // reusable condition factory\n+  private static ConditionFactory retry\n+      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+\n+  /**\n+   * Check the pods in the given namespace are restarted in a rolling fashion.\n+   * Waits until all pods are restarted, for upto 10 minutes.\n+   *\n+   * @param domainUid UID of the WebLogic domain\n+   * @param namespace name of the namespace in which to check for the pods restart sequence\n+   * @return true if pods in the namespace are restarted in a rolling fashion otherwise false\n+   * @throws ApiException when Kubernetes cluster query fails\n+   * @throws InterruptedException when pod status check threads are interrupted\n+   * @throws ExecutionException when pod status checks times out\n+   * @throws TimeoutException when waiting for the threads times out\n+   */\n+  public static boolean isARollingRestart(String domainUid, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException {\n+\n+    // query cluster and get pods from the namespace\n+    String labelSelectors = \"weblogic.serverName\";\n+    V1PodList listPods = Kubernetes.listPods(namespace, labelSelectors);\n+    ArrayList<String> podNames = new ArrayList<>();\n+\n+    //return if no pods are found\n+    if (listPods.getItems().isEmpty()) {\n+      logger.severe(\"No pods found in namespace {0}\", namespace);\n+      return false;\n+    } else {\n+      logger.info(\"WebLogic pods found in namespace {0}\", namespace);\n+      for (V1Pod item : listPods.getItems()) {\n+        logger.info(item.getMetadata().getName());\n+        podNames.add(item.getMetadata().getName());\n+      }\n+    }\n+\n+    // check the pods termination status in concurrent thread\n+    ExecutorService executorService = Executors.newFixedThreadPool(podNames.size());\n+    ArrayList<Future<Boolean>> threads = new ArrayList<Future<Boolean>>();\n+    for (var podName : podNames) {\n+      // check for pod termination status and return true if pod is terminating\n+      threads.add(executorService.submit(() -> {\n+        retry\n+            .conditionEvaluationListener(\n+                condition -> logger.info(\"Waiting for pod {0} in namespace {1} to terminate\"\n+                    + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                    podName,\n+                    namespace,\n+                    condition.getElapsedTimeInMS(),\n+                    condition.getRemainingTimeInMS()))\n+            .until(onlyGivenPodTerminating(podName, domainUid, namespace));\n+        return true;\n+      }));\n+      // wait for the callable to finish running and check if all pods were terminating\n+      for (var future : threads) {\n+        if (!future.get(10, MINUTES)) {\n+          return false;\n+        }\n+      }\n+    }\n+    executorService.shutdownNow();\n+\n+    // wait for pods to become ready\n+    for (var podName : podNames) {\n+      logger.info(\"Wait for pod {0} to be ready in namespace {1}\", podName, namespace);\n+      retry", "originalCommit": "e1d8e9ba121a1bb14a2b0066e4e3ecc563ba5b0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDY2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428120663", "bodyText": "now its a standard  wait time of 5 minutes/pod", "author": "sankarpn", "createdAt": "2020-05-20T15:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex a1b861554b..30a02c0a37 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -24,9 +24,47 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n \n public class Pod {\n \n-  // reusable condition factory\n-  private static ConditionFactory retry\n-      = with().pollInterval(5, SECONDS).atMost(10, MINUTES).await();\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace)\n+      throws ApiException, InterruptedException, ExecutionException, TimeoutException, Exception {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    for (var podName : pods) {\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be terminating in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, podName, namespace),\n+              String.format(\n+                  \"pod %s didn't terminate in namespace %s\", podName, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(\n+              condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+                  + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+                  podName,\n+                  namespace,\n+                  condition.getElapsedTimeInMS(),\n+                  condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, podName),\n+              String.format(\n+                  \"pod %s is not ready in namespace %s\", podName, namespace)));\n+    }\n+\n+    return true;\n+  }\n \n   /**\n    * Check the pods in the given namespace are restarted in a rolling fashion.\n"}}, {"oid": "29ddbf8fe8e094b921c2699adf43ea4f9653cf03", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/29ddbf8fe8e094b921c2699adf43ea4f9653cf03", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart", "committedDate": "2020-05-18T19:26:54Z", "type": "commit"}, {"oid": "cc3e0cd84e6deff648b908aff24921a2700dbfbb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/cc3e0cd84e6deff648b908aff24921a2700dbfbb", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart", "committedDate": "2020-05-18T20:06:53Z", "type": "commit"}, {"oid": "c355db5e3e0088c61265dae28af332647459c63c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c355db5e3e0088c61265dae28af332647459c63c", "message": "wip", "committedDate": "2020-05-18T20:56:38Z", "type": "commit"}, {"oid": "044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/044ce2a9b3d9d4a2299b14699fb1744609ca25ee", "message": "changed the logic", "committedDate": "2020-05-18T21:36:20Z", "type": "commit"}, {"oid": "8f6ded5a2e0781c3477b7151b3f52660d9a473cb", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8f6ded5a2e0781c3477b7151b3f52660d9a473cb", "message": "p# Please enter the commit message for your changes. Lines starting", "committedDate": "2020-05-18T22:06:32Z", "type": "commit"}, {"oid": "e7ca17a9333e96d196fbaf17e16130c0cbb349c6", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/e7ca17a9333e96d196fbaf17e16130c0cbb349c6", "message": "wip", "committedDate": "2020-05-18T22:32:37Z", "type": "commit"}, {"oid": "611b96cc93b5568fbfd6f7116e5a07a51b6e769d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/611b96cc93b5568fbfd6f7116e5a07a51b6e769d", "message": "wip", "committedDate": "2020-05-18T23:25:57Z", "type": "commit"}, {"oid": "5290039fc17219398c90156cf94f9b5447d4335c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/5290039fc17219398c90156cf94f9b5447d4335c", "message": "wip", "committedDate": "2020-05-19T15:41:11Z", "type": "commit"}, {"oid": "804cec5f35f49820b867c1e84e298114c7ce0669", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/804cec5f35f49820b867c1e84e298114c7ce0669", "message": "refactor", "committedDate": "2020-05-19T15:52:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427452563", "bodyText": "You assume the pods will be terminated in a specific order. This needs to match how operator does the termination.", "author": "xiancao", "createdAt": "2020-05-19T16:52:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),", "originalCommit": "804cec5f35f49820b867c1e84e298114c7ce0669", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTIzOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428121238", "bodyText": "It is up to the test provide the list of pods in a order for rolling restart", "author": "sankarpn", "createdAt": "2020-05-20T15:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDE3Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428130176", "bodyText": "The operator does roll the servers in sorted order.", "author": "rjeberhard", "createdAt": "2020-05-20T16:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MjU2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex 77ace25e7c..6250aefce2 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -67,7 +67,7 @@ public class Pod {\n    * @param pods names of the pods in a list\n    * @param podName name of pod to check for termination status\n    * @param namespace name of the namespace in which the pod terminating status to be checked\n-   * @return true if given pod is terminating\n+   * @return true if given pod is the only pod terminating\n    * @throws Exception when more than one pod is terminating or cluster query fails\n    */\n   public static Callable<Boolean> onlyGivenPodTerminating(ArrayList<String> pods, String podName, String namespace)\n"}}, {"oid": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/971efd49234fbbbb4a935d8fe3f479fd23865e49", "message": "wip", "committedDate": "2020-05-19T19:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NDA3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427584075", "bodyText": "print the pod names that are terminating", "author": "vanajamukkara", "createdAt": "2020-05-19T20:36:39Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.\n+    for (var pod : pods) {\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be \"\n+          + \"terminating in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> onlyGivenPodTerminating(pods, pod, namespace),\n+              String.format(\"pod %s didn't terminate in namespace %s\", pod, namespace)));\n+\n+      retry\n+          .conditionEvaluationListener(condition -> logger.info(\"Waiting for pod {0} to be ready in namespace {1} \"\n+          + \"(elapsed time {2}ms, remaining time {3}ms)\",\n+          pod,\n+          namespace,\n+          condition.getElapsedTimeInMS(),\n+          condition.getRemainingTimeInMS()))\n+          .until(assertDoesNotThrow(() -> podReady(namespace, null, pod),\n+              String.format(\"pod %s is not ready in namespace %s\", pod, namespace)));\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the given pod is the only one terminating from the list of pods.\n+   *\n+   * @param pods names of the pods in a list\n+   * @param podName name of pod to check for termination status\n+   * @param namespace name of the namespace in which the pod terminating status to be checked\n+   * @return true if given pod is the only pod terminating\n+   * @throws Exception when more than one pod is terminating or cluster query fails\n+   */\n+  public static Callable<Boolean> onlyGivenPodTerminating(ArrayList<String> pods, String podName, String namespace)\n+      throws Exception {\n+    return () -> {\n+      int terminatingPods = 0;\n+      boolean givenPodTerminating = false;\n+      for (var pod : pods) {\n+        if (Kubernetes.isPodTerminating(namespace, null, pod)) {\n+          terminatingPods++;", "originalCommit": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTg0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427601848", "bodyText": "Its printed inside the Kubernetes.isPodTerminating method", "author": "sankarpn", "createdAt": "2020-05-19T21:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NDA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex 6250aefce2..ed6fd9007d 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -17,7 +17,9 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n public class Pod {\n \n   /**\n-   * Check pods are restarted in the same order as in the pods list.\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n    * @param pods names of the pods in a list\n    * @param namespace name of the namespace in which to check for pods rolling restart\n    * @return true if pods are restarted in rolling fashion\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427586931", "bodyText": "get the pods list before patching domain", "author": "vanajamukkara", "createdAt": "2020-05-19T20:41:56Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java", "diffHunk": "@@ -372,6 +374,16 @@ public void testCreateMiiConfigMapDomain() {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n+    ArrayList<String> pods = new ArrayList<>();", "originalCommit": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMjc2Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427602766", "bodyText": "moved it before patching", "author": "sankarpn", "createdAt": "2020-05-19T21:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTQ1MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428121450", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-05-20T15:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4NjkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java\nindex 1e88423c1a..a63472fb86 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/ItMiiConfigMapOverride.java\n\n@@ -374,11 +380,6 @@ class ItMiiConfigMapOverride implements LoggedTest {\n         \"patchDomainCustomResource(restartVersion)  failed \");\n     assertTrue(rvPatched, \"patchDomainCustomResource(restartVersion) failed\");\n \n-    ArrayList<String> pods = new ArrayList<>();\n-    pods.add(adminServerPodName);\n-    for (int i = 1; i <= replicaCount; i++) {\n-      pods.add(managedServerPrefix + i);\n-    }\n     assertTrue(assertDoesNotThrow(\n         () -> (verifyRollingRestartOccurred(pods, domainNamespace)),\n          \"More than one pod was restarted at same time\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDc5Ng==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427590796", "bodyText": "Check only one pod is restarted at a time in the same order as in the pods list ...", "author": "vanajamukkara", "createdAt": "2020-05-19T20:49:03Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check pods are restarted in the same order as in the pods list.", "originalCommit": "971efd49234fbbbb4a935d8fe3f479fd23865e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMzE3Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r427603173", "bodyText": "fixed", "author": "sankarpn", "createdAt": "2020-05-19T21:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5MDc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex 6250aefce2..ed6fd9007d 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -17,7 +17,9 @@ import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n public class Pod {\n \n   /**\n-   * Check pods are restarted in the same order as in the pods list.\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n    * @param pods names of the pods in a list\n    * @param namespace name of the namespace in which to check for pods rolling restart\n    * @return true if pods are restarted in rolling fashion\n"}}, {"oid": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "message": "Address review comments", "committedDate": "2020-05-19T21:14:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428119243", "bodyText": "I have a use case where I want to verify there I want to see the rolling restart should shutdown 2 servers simultaneously where the maxUnavailable attribute is set to 2.  In this case what will be my pod list?  Say I have 1 admin and 3 managed servers ( ms1,ms2, and ms3 ) Here  I should see ms1 and ms2 can both go to terminating state simultaneously while ms3 will be re-stated after both ms1 and ms2 are up", "author": "anpanigr", "createdAt": "2020-05-20T15:47:50Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "originalCommit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNTA3NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428125075", "bodyText": "According to the JIRA only one server can restart at a time.\nhttps://jira.****/jira/browse/OWLS-81478\nIf 2 servers can go down at the same time then how can it be a rolling restart?", "author": "sankarpn", "createdAt": "2020-05-20T15:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTQ4MA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428129480", "bodyText": "We have a field that controls how many servers can be down at the same time -- it's maxUnavailable. The default value is 1.", "author": "rjeberhard", "createdAt": "2020-05-20T16:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyOTgwNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428129807", "bodyText": "This was added for customers with larger clusters who want to improve the time to roll the entire cluster.", "author": "rjeberhard", "createdAt": "2020-05-20T16:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDAxMw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428130013", "bodyText": "Yes, still, it is a rolling re-start as long as the cluster service is available. The maxUnavailable attribute is designed for this purpose. It can be any non-zero value less than the replica.  See the reference page\nhttps://github.com/oracle/weblogic-kubernetes-operator/blob/master/docs/domains/Domain.md", "author": "anpanigr", "createdAt": "2020-05-20T16:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxOTg0OA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428319848", "bodyText": "now checking the max number of pods that can restart concurrently to be not more than maxUnavailable.", "author": "sankarpn", "createdAt": "2020-05-20T21:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTI0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex ed6fd9007d..d763456cb8 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -3,10 +3,12 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.ArrayList;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n \n+import io.kubernetes.client.openapi.models.V1Pod;\n import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n \n import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzExMg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428127112", "bodyText": "Type of argument can just be List", "author": "rjeberhard", "createdAt": "2020-05-20T15:58:57Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java", "diffHunk": "@@ -157,9 +160,20 @@\n    * @return true if the pod is terminating otherwise false\n    */\n   public static Callable<Boolean> podTerminating(String podName, String domainUid, String namespace) {\n-    return () -> Kubernetes.isPodTerminating(namespace, domainUid, podName);\n+    return Pod.podTerminating(namespace, domainUid, podName);\n   }\n \n+  /**\n+   * Check pods are restarted in the same order as in the pods list.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {", "originalCommit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMDMzNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428320334", "bodyText": "Now the argument is a Map with podnames and its creation time stamps.\nThe test will create a LinkedHashMap and add all the pods with its creation time stamps.", "author": "sankarpn", "createdAt": "2020-05-20T21:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzExMg=="}], "type": "inlineReview", "revised_code": {"commit": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java\nindex 24a9b0df54..aee7d66049 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/TestAssertions.java\n\n@@ -164,13 +163,14 @@ public class TestAssertions {\n   }\n \n   /**\n-   * Check pods are restarted in the same order as in the pods list.\n-   * @param pods names of the pods in a list\n-   * @param namespace name of the namespace in which to check for pods rolling restart\n-   * @return true if pods are restarted in rolling fashion\n+   * Verify pods are restarted in a rolling fashion with not more than maxUnavailable pods restarted concurrently.\n+   * @param pods map of pod names with its creation time stamps\n+   * @param maxUnavailable number of pods can concurrently restart at the same time\n+   * @param namespace name of the namespace in which the pod restart status to be checked\n+   * @return true if pods are restarted in a rolling fashion\n    */\n-  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n-    return Pod.verifyRollingRestartOccurred(pods, namespace);\n+  public static boolean verifyRollingRestartOccurred(Map<String, String> pods, int maxUnavailable, String namespace) {\n+    return Pod.verifyRollingRestartOccurred(pods, maxUnavailable, namespace);\n   }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODcxOA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428128718", "bodyText": "As an alternative, you can check that the pod's metadata.deletionTimestamp is set. If this field has a value, then the pod has been marked for deletion. It will either then be in it's terminating phase or soon will be.", "author": "rjeberhard", "createdAt": "2020-05-20T16:01:11Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Kubernetes.java", "diffHunk": "@@ -154,27 +153,30 @@ public static boolean isPodReady(String namespace, String domainUid, String podN\n   }\n \n   /**\n-   * Checks if a pod exists in a given namespace and in Terminating state.\n+   * Check if a pod exists in a given namespace and is terminating.\n    * @param namespace in which to check for the pod\n    * @param domainUid the label the pod is decorated with\n    * @param podName name of the pod to check for\n-   * @return true if pod is in Terminating state otherwise false\n+   * @return true if pod is terminating otherwise false\n    * @throws ApiException when there is error in querying the cluster\n    */\n-  public static boolean isPodTerminating(String namespace, String domainUid, String podName) throws ApiException {", "originalCommit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMDYxNA==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428320614", "bodyText": "Yes, the new implementation uses pod deletion timestamp.", "author": "sankarpn", "createdAt": "2020-05-20T21:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODcxOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428132231", "bodyText": "On this statement: \"This assertion method needs to be called right after the domain is patched to ensure it doesn't miss any of the pods restart.\"...  This seems likely to intermittently fail. I think it would be better to collect the current V1PodList in advance of starting the roll and using that as the input.", "author": "rjeberhard", "createdAt": "2020-05-20T16:06:16Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.", "originalCommit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzOTE1NQ==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428139155", "bodyText": "+1 to that", "author": "tbarnes-us", "createdAt": "2020-05-20T16:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMTM3Mg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428321372", "bodyText": "The test supplies the list of pods with its creation timestamps(created before the patching).", "author": "sankarpn", "createdAt": "2020-05-20T21:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMjIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex ed6fd9007d..d763456cb8 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -3,10 +3,12 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.ArrayList;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n \n+import io.kubernetes.client.openapi.models.V1Pod;\n import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n \n import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMzYzNg==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428133636", "bodyText": "Not sure if I've read this correctly, but even though WebLogic terminates and restarts slowly, I'd like the code to be defensive to the condition that you missed detecting the termination. It would be enough to find that the \"new\" Pod has a creation timestamp later than when the roll started.", "author": "rjeberhard", "createdAt": "2020-05-20T16:08:24Z", "path": "new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2020, Oracle Corporation and/or its affiliates.\n+// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.\n+\n+package oracle.weblogic.kubernetes.assertions.impl;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+\n+import org.awaitility.core.ConditionFactory;\n+\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static oracle.weblogic.kubernetes.extensions.LoggedTest.logger;\n+import static org.awaitility.Awaitility.with;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+public class Pod {\n+\n+  /**\n+   * Check only one pod is restarted at a time in the same order as in the pods list.\n+   * This assertion method needs to be called right after the domain is patched to ensure\n+   * it doesn't miss any of the pods restart.\n+   * @param pods names of the pods in a list\n+   * @param namespace name of the namespace in which to check for pods rolling restart\n+   * @return true if pods are restarted in rolling fashion\n+   */\n+  public static boolean verifyRollingRestartOccurred(ArrayList<String> pods, String namespace) {\n+\n+    // check the pods list is not empty\n+    if (pods.isEmpty()) {\n+      logger.severe(\"The pods list is empty\");\n+      return false;\n+    }\n+\n+    // reusable condition factory\n+    ConditionFactory retry\n+        = with().pollInterval(5, SECONDS).atMost(5, MINUTES).await();\n+\n+    // check pods are terminated and started.", "originalCommit": "d68257ecf2ab4b2cb87ba0f0b53eb25bd18c06a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2NjAxNw==", "url": "https://github.com/oracle/weblogic-kubernetes-operator/pull/1651#discussion_r428366017", "bodyText": "The new implementation will compare creation time stamps to determine the pods replacement status.", "author": "sankarpn", "createdAt": "2020-05-20T23:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMzYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "chunk": "diff --git a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\nindex ed6fd9007d..d763456cb8 100644\n--- a/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n+++ b/new-integration-tests/src/test/java/oracle/weblogic/kubernetes/assertions/impl/Pod.java\n\n@@ -3,10 +3,12 @@\n \n package oracle.weblogic.kubernetes.assertions.impl;\n \n-import java.util.ArrayList;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n \n+import io.kubernetes.client.openapi.models.V1Pod;\n import org.awaitility.core.ConditionFactory;\n+import org.joda.time.DateTime;\n \n import static java.util.concurrent.TimeUnit.MINUTES;\n import static java.util.concurrent.TimeUnit.SECONDS;\n"}}, {"oid": "8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/8c6726ea3c42a88bb4cb8357eb3a51fe53e6e540", "message": "Addressing review comments", "committedDate": "2020-05-20T20:18:18Z", "type": "commit"}, {"oid": "d00dccaad2ef0eb830ca163da9026de51085e8f3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/d00dccaad2ef0eb830ca163da9026de51085e8f3", "message": "Merge branch 'develop' of https://github.com/oracle/weblogic-kubernetes-operator into assertrollingrestart", "committedDate": "2020-05-20T20:19:05Z", "type": "commit"}, {"oid": "014a7cf057a2098e8f09a0db73efaac79dcdaaa9", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/014a7cf057a2098e8f09a0db73efaac79dcdaaa9", "message": "wip", "committedDate": "2020-05-20T21:04:08Z", "type": "commit"}, {"oid": "9eb968d8047674f1a4e7618b7b011825a59d8cf2", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/9eb968d8047674f1a4e7618b7b011825a59d8cf2", "message": "wip", "committedDate": "2020-05-20T21:09:54Z", "type": "commit"}, {"oid": "62f0f87c96c2a950ff7c4675bc194527baf8e76d", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/62f0f87c96c2a950ff7c4675bc194527baf8e76d", "message": "wip", "committedDate": "2020-05-20T21:18:59Z", "type": "commit"}, {"oid": "ccd405d6eebb15da9e87d1fdada88192a31eca3e", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/ccd405d6eebb15da9e87d1fdada88192a31eca3e", "message": "wip", "committedDate": "2020-05-20T21:24:02Z", "type": "commit"}, {"oid": "c63f887ad26cdff57bb45a2cfde4b853f3127fc3", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/c63f887ad26cdff57bb45a2cfde4b853f3127fc3", "message": "wip", "committedDate": "2020-05-20T21:40:50Z", "type": "commit"}, {"oid": "214e8f1555af22802e5b15b8ce6a8c82d8fb917a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/214e8f1555af22802e5b15b8ce6a8c82d8fb917a", "message": "null check", "committedDate": "2020-05-20T22:15:02Z", "type": "commit"}, {"oid": "44ca6bf7fdd5f41763cad0e72ee7f031f6fc724c", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/44ca6bf7fdd5f41763cad0e72ee7f031f6fc724c", "message": "wip", "committedDate": "2020-05-20T22:37:47Z", "type": "commit"}, {"oid": "b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a", "url": "https://github.com/oracle/weblogic-kubernetes-operator/commit/b2a5c593daa9995cacff6410c44cf4b6a5a5aa4a", "message": "Merge branch 'develop' into assertrollingrestart", "committedDate": "2020-05-21T16:03:38Z", "type": "commit"}]}