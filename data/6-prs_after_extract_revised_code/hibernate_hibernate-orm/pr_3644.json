{"pr_number": 3644, "pr_title": "HHH-14318 Work on @JoinFormula and @JoinColumnOrFormula support", "pr_createdAt": "2020-11-12T22:54:34Z", "pr_url": "https://github.com/hibernate/hibernate-orm/pull/3644", "timeline": [{"oid": "8649534f34d1918723cd399e0717dcf6b4530957", "url": "https://github.com/hibernate/hibernate-orm/commit/8649534f34d1918723cd399e0717dcf6b4530957", "message": "HHH-14318 Work on @JoinFormula and @JoinColumnOrFormula support", "committedDate": "2020-11-13T11:08:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522944032", "bodyText": "Why this change? MutableInteger was added to explicitly replace such uses of AtomicInteger", "author": "sebersole", "createdAt": "2020-11-13T13:18:13Z", "path": "hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java", "diffHunk": "@@ -50,7 +51,7 @@\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TypeDefinition implements Serializable {\n-\tpublic static final MutableInteger NAME_COUNTER = new MutableInteger();\n+\tpublic static final AtomicInteger NAME_COUNTER = new AtomicInteger();", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3MjEzMw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523072133", "bodyText": "Since this is static and thus accessible by multiple threads, this must use a thread safe data structure like AtomicInteger.", "author": "beikov", "createdAt": "2020-11-13T16:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE2MzgwMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523163802", "bodyText": "Ah, missed the static.. carry on.", "author": "sebersole", "createdAt": "2020-11-13T19:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "884e2c59d7c3ec147ea6db703d606b3016a15524", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java\nindex 2b41046107..b8e7d32671 100644\n--- a/hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java\n+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java\n\n@@ -51,7 +50,7 @@ import org.hibernate.usertype.UserType;\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TypeDefinition implements Serializable {\n-\tpublic static final AtomicInteger NAME_COUNTER = new AtomicInteger();\n+\tpublic static final MutableInteger NAME_COUNTER = new MutableInteger();\n \n \tprivate final String name;\n \tprivate final Class typeImplementorClass;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NTM4Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522945383", "bodyText": "Could we stick with the standard code style for multi-line statements?  Or at least one of the 2 prevalent ones?", "author": "sebersole", "createdAt": "2020-11-13T13:20:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java", "diffHunk": "@@ -78,6 +79,21 @@ default void visitJdbcTypes(\n \t\tthrow new NotYetImplementedFor6Exception( getClass() );\n \t}\n \n+\tdefault void visitJdbcTypes(\n+\t\t\tClause clause,\n+\t\t\tTypeConfiguration typeConfiguration,\n+\t\t\tIndexedConsumer<JdbcMapping> action) {\n+\t\tvisitJdbcTypes( new Consumer<JdbcMapping>() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNzY3Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523027672", "bodyText": "Also, why not just switch everything to use this method rather than the form accepting a Consumer?", "author": "sebersole", "createdAt": "2020-11-13T15:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NTM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java\nindex 35b9f8861d..afb0e3353a 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java\n\n@@ -83,15 +83,19 @@ public interface Bindable {\n \t\t\tClause clause,\n \t\t\tTypeConfiguration typeConfiguration,\n \t\t\tIndexedConsumer<JdbcMapping> action) {\n-\t\tvisitJdbcTypes( new Consumer<JdbcMapping>() {\n-\t\t\tprivate int index;\n+\t\tvisitJdbcTypes(\n+\t\t\t\tnew Consumer<JdbcMapping>() {\n+\t\t\t\t\tprivate int index;\n \n-\t\t\t@Override\n-\t\t\tpublic void accept(JdbcMapping jdbcMapping) {\n-\t\t\t\taction.accept( index, jdbcMapping );\n-\t\t\t\tindex++;\n-\t\t\t}\n-\t\t}, clause, typeConfiguration );\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic void accept(JdbcMapping jdbcMapping) {\n+\t\t\t\t\t\taction.accept( index, jdbcMapping );\n+\t\t\t\t\t\tindex++;\n+\t\t\t\t\t}\n+\t\t\t\t},\n+\t\t\t\tclause,\n+\t\t\t\ttypeConfiguration\n+\t\t);\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NjQwNQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522946405", "bodyText": "I think both table and JdbcMapping make sense as well.  Would also allow us to clean up some of the functional interfaces around column handling", "author": "sebersole", "createdAt": "2020-11-13T13:22:40Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+/**\n+ * A column mapping.\n+ *\n+ * @author Christian Beikov\n+ */\n+public interface ColumnMapping {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java\nindex d456c08808..e8a669f35e 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java\n\n@@ -12,9 +12,9 @@ package org.hibernate.metamodel.mapping;\n  * @author Christian Beikov\n  */\n public interface ColumnMapping {\n-\t// todo: table expression? jdbc mapping?\n \tString getMappedColumnExpression();\n \tString getCustomReadExpression();\n \tString getCustomWriteExpression();\n \tboolean isMappedColumnExpressionFormula();\n+\tJdbcMapping getJdbcMapping();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0ODEyOQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522948129", "bodyText": "I'd rather leave table expression off here...  While today embeddable values need to map to a single table, so far I have been working in 6 under the assumption that we want to start allowing compositions across tables.  We cannot fully make that transition until we can pull \"writing\" under this new mapping model, but as much as possible let's design the mapping model with this in mind.\nAnd of course the is no notion of a JdbcMapping for multiple columns, unless we start considering complex SQL types (arrays, etc)", "author": "sebersole", "createdAt": "2020-11-13T13:25:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.hibernate.mapping.IndexedConsumer;\n+\n+/**\n+ * A container for multiple column mappings.\n+ *\n+ * @author Christian Beikov\n+ */\n+public interface ColumnMappings {\n+\t// todo: table expression? jdbc mapping?", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java\nindex c83e7716db..f9b3b671eb 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java\n\n@@ -6,34 +6,32 @@\n  */\n package org.hibernate.metamodel.mapping;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n-import org.hibernate.mapping.IndexedConsumer;\n-\n /**\n  * A container for multiple column mappings.\n  *\n  * @author Christian Beikov\n  */\n public interface ColumnMappings {\n-\t// todo: table expression? jdbc mapping?\n \tString getMappedColumnExpression(int columnIndex);\n \tString getCustomReadExpression(int columnIndex);\n \tString getCustomWriteExpression(int columnIndex);\n \tboolean isMappedColumnExpressionFormula(int columnIndex);\n+\tJdbcMapping getJdbcMapping(int columnIndex);\n \n \tint getColumnSpan();\n \n \tvoid forEachColumn(\n \t\t\tfinal String containingTableExpression,\n-\t\t\tfinal List<JdbcMapping> jdbcMappings,\n+\t\t\tfinal int columnIndexOffset,\n \t\t\tfinal ColumnConsumer consumer);\n \n-\tvoid forEachColumn(\n+\tdefault void forEachColumn(\n \t\t\tfinal String containingTableExpression,\n-\t\t\tfinal List<JdbcMapping> jdbcMappings,\n-\t\t\tfinal IndexedColumnConsumer consumer);\n+\t\t\tfinal ColumnConsumer consumer) {\n+\t\tforEachColumn( containingTableExpression, 0, consumer );\n+\t}\n \n-\tList<String> getMappedColumnExpressions();\n+\tList<JdbcMapping> getJdbcMappings();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0OTM1Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522949353", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T13:28:09Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java", "diffHunk": "@@ -311,17 +310,13 @@ public CascadeStyle getCascadeStyle() {\n \t\t\t}\n \t\t\telse if ( subtype instanceof CompositeType ) {\n \t\t\t\tfinal CompositeType subCompositeType = (CompositeType) subtype;\n-\t\t\t\tfinal int columnSpan = subCompositeType.getColumnSpan( sessionFactory );\n-\n-\t\t\t\tfinal List<String> customReadExpressions = new ArrayList<>( columnSpan );\n-\t\t\t\tfinal List<String> customWriteExpressions = new ArrayList<>( columnSpan );\n-\n-\t\t\t\tfinal Iterator<Selectable> columnIterator = bootDescriptor.getColumnIterator();\n-\t\t\t\twhile ( columnIterator.hasNext() ) {\n-\t\t\t\t\tfinal Selectable selectable = columnIterator.next();\n-\t\t\t\t\tcustomReadExpressions.add( selectable.getCustomReadExpression() );\n-\t\t\t\t\tcustomWriteExpressions.add( selectable.getCustomWriteExpression() );\n-\t\t\t\t}\n+\t\t\t\tfinal ColumnMappings subMappings = ColumnMappingsImpl.from(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java\nindex c2bff51d1e..bc4103b2c2 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java\n\n@@ -291,71 +287,68 @@ public class EmbeddableMappingType implements ManagedMappingType {\n \t\t\t\t\t}\n \t\t\t\t};\n \n-\t\t\t\tattributeMappings.put(\n-\t\t\t\t\t\tbootPropertyDescriptor.getName(),\n-\t\t\t\t\t\tnew DiscriminatedAssociationAttributeMapping(\n-\t\t\t\t\t\t\t\tvalueMapping.getNavigableRole().append( bootPropertyDescriptor.getName() ),\n-\t\t\t\t\t\t\t\ttypeConfiguration.getJavaTypeDescriptorRegistry().getDescriptor( Object.class ),\n-\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\tattributeIndex,\n-\t\t\t\t\t\t\t\tattributeMetadataAccess,\n-\t\t\t\t\t\t\t\tbootPropertyDescriptor.isLazy() ? FetchTiming.DELAYED : FetchTiming.IMMEDIATE,\n-\t\t\t\t\t\t\t\tpropertyAccess,\n-\t\t\t\t\t\t\t\tbootPropertyDescriptor,\n-\t\t\t\t\t\t\t\tanyType,\n-\t\t\t\t\t\t\t\tbootValueMapping,\n-\t\t\t\t\t\t\t\tcreationProcess\n-\t\t\t\t\t\t)\n+\t\t\t\tDiscriminatedAssociationAttributeMapping attributeMapping = new DiscriminatedAssociationAttributeMapping(\n+\t\t\t\t\t\tvalueMapping.getNavigableRole().append( bootPropertyDescriptor.getName() ),\n+\t\t\t\t\t\ttypeConfiguration.getJavaTypeDescriptorRegistry().getDescriptor( Object.class ),\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tattributeIndex,\n+\t\t\t\t\t\tattributeMetadataAccess,\n+\t\t\t\t\t\tbootPropertyDescriptor.isLazy() ? FetchTiming.DELAYED : FetchTiming.IMMEDIATE,\n+\t\t\t\t\t\tpropertyAccess,\n+\t\t\t\t\t\tbootPropertyDescriptor,\n+\t\t\t\t\t\tanyType,\n+\t\t\t\t\t\tbootValueMapping,\n+\t\t\t\t\t\tcreationProcess\n \t\t\t\t);\n+\t\t\t\taddAttribute( attributeMapping );\n+\t\t\t\tcolumnPosition += columnSpan;\n \t\t\t}\n \t\t\telse if ( subtype instanceof CompositeType ) {\n \t\t\t\tfinal CompositeType subCompositeType = (CompositeType) subtype;\n-\t\t\t\tfinal ColumnMappings subMappings = ColumnMappingsImpl.from(\n-\t\t\t\t\t\t(Component) bootPropertyDescriptor.getValue(),\n-\t\t\t\t\t\tcreationProcess.getCreationContext()\n-\t\t\t\t\t\t\t\t.getSessionFactory()\n-\t\t\t\t\t\t\t\t.getDialect(),\n-\t\t\t\t\t\tcreationProcess.getSqmFunctionRegistry()\n-\t\t\t\t);\n+\t\t\t\tfinal int columnSpan = subCompositeType.getColumnSpan( sessionFactory );\n+\t\t\t\tfinal String[] subRootTableKeyColumnNames;\n+\t\t\t\tif ( rootTableKeyColumnNames == null ) {\n+\t\t\t\t\tsubRootTableKeyColumnNames = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tsubRootTableKeyColumnNames = new String[columnSpan];\n+\t\t\t\t\tSystem.arraycopy( rootTableKeyColumnNames, columnPosition, subRootTableKeyColumnNames, 0, columnSpan );\n+\t\t\t\t}\n \n-\t\t\t\tattributeMappings.put(\n+\t\t\t\tEmbeddedAttributeMapping attributeMapping = MappingModelCreationHelper.buildEmbeddedAttributeMapping(\n \t\t\t\t\t\tbootPropertyDescriptor.getName(),\n-\t\t\t\t\t\tMappingModelCreationHelper.buildEmbeddedAttributeMapping(\n-\t\t\t\t\t\t\t\tbootPropertyDescriptor.getName(),\n-\t\t\t\t\t\t\t\tattributeIndex,\n-\t\t\t\t\t\t\t\tbootPropertyDescriptor,\n-\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\tsubCompositeType,\n-\t\t\t\t\t\t\t\tcontainingTableExpression,\n-\t\t\t\t\t\t\t\tsubMappings,\n-\t\t\t\t\t\t\t\trepresentationStrategy.resolvePropertyAccess( bootPropertyDescriptor ),\n-\t\t\t\t\t\t\t\tcompositeType.getCascadeStyle( attributeIndex ),\n-\t\t\t\t\t\t\t\tcreationProcess\n-\t\t\t\t\t\t)\n+\t\t\t\t\t\tattributeIndex,\n+\t\t\t\t\t\tbootPropertyDescriptor,\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tsubCompositeType,\n+\t\t\t\t\t\tcontainingTableExpression,\n+\t\t\t\t\t\tsubRootTableKeyColumnNames,\n+\t\t\t\t\t\trepresentationStrategy.resolvePropertyAccess( bootPropertyDescriptor ),\n+\t\t\t\t\t\tcompositeType.getCascadeStyle( attributeIndex ),\n+\t\t\t\t\t\tcreationProcess\n \t\t\t\t);\n-\n-\t\t\t\tcolumnPosition += subMappings.getColumnSpan();\n+\t\t\t\taddAttribute( attributeMapping );\n+\t\t\t\tcolumnPosition += columnSpan;\n \t\t\t}\n \t\t\telse {\n \t\t\t\tfinal EntityPersister entityPersister = creationProcess\n \t\t\t\t\t\t.getEntityPersister( bootDescriptor.getOwner().getEntityName() );\n \t\t\t\tif ( subtype instanceof CollectionType ) {\n-\t\t\t\t\tattributeMappings.put(\n+\t\t\t\t\tPluralAttributeMapping attributeMapping = MappingModelCreationHelper.buildPluralAttributeMapping(\n \t\t\t\t\t\t\tbootPropertyDescriptor.getName(),\n-\t\t\t\t\t\t\tMappingModelCreationHelper.buildPluralAttributeMapping(\n-\t\t\t\t\t\t\t\t\tbootPropertyDescriptor.getName(),\n-\t\t\t\t\t\t\t\t\tattributeIndex,\n-\t\t\t\t\t\t\t\t\tbootPropertyDescriptor,\n-\t\t\t\t\t\t\t\t\tentityPersister,\n-\t\t\t\t\t\t\t\t\trepresentationStrategy.resolvePropertyAccess( bootPropertyDescriptor ),\n-\t\t\t\t\t\t\t\t\tcompositeType.getCascadeStyle( attributeIndex),\n-\t\t\t\t\t\t\t\t\tcompositeType.getFetchMode( attributeIndex ),\n-\t\t\t\t\t\t\t\t\tcreationProcess\n-\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\tattributeIndex,\n+\t\t\t\t\t\t\tbootPropertyDescriptor,\n+\t\t\t\t\t\t\tentityPersister,\n+\t\t\t\t\t\t\trepresentationStrategy.resolvePropertyAccess( bootPropertyDescriptor ),\n+\t\t\t\t\t\t\tcompositeType.getCascadeStyle( attributeIndex ),\n+\t\t\t\t\t\t\tcompositeType.getFetchMode( attributeIndex ),\n+\t\t\t\t\t\t\tcreationProcess\n \t\t\t\t\t);\n+\t\t\t\t\taddAttribute( attributeMapping );\n \t\t\t\t}\n \t\t\t\telse if ( subtype instanceof EntityType ) {\n-\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = MappingModelCreationHelper.buildSingularAssociationAttributeMapping(\n+\t\t\t\t\tfinal int columnSpan = subtype.getColumnSpan( sessionFactory );\n+\t\t\t\t\tfinal ToOneAttributeMapping attributeMapping = MappingModelCreationHelper.buildSingularAssociationAttributeMapping(\n \t\t\t\t\t\t\tbootPropertyDescriptor.getName(),\n \t\t\t\t\t\t\tvalueMapping.getNavigableRole().append( bootPropertyDescriptor.getName() ),\n \t\t\t\t\t\t\tattributeIndex,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0OTgxMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522949812", "bodyText": "Again with the code style here and below", "author": "sebersole", "createdAt": "2020-11-13T13:29:06Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java", "diffHunk": "@@ -61,7 +61,59 @@ default void visitColumns(ColumnConsumer consumer) {\n \n \tvoid visitReferringColumns(ColumnConsumer consumer);\n \n+\tdefault void visitReferringColumns(IndexedColumnConsumer consumer) {\n+\t\tvisitReferringColumns( new ColumnConsumer() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java\nindex 56702d551f..b1298504c2 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java\n\n@@ -55,64 +55,20 @@ public interface ForeignKeyDescriptor extends VirtualModelPart {\n \t * Visits the FK \"referring\" columns\n \t */\n \t@Override\n-\tdefault void visitColumns(ColumnConsumer consumer) {\n-\t\tvisitReferringColumns( consumer );\n+\tdefault void visitColumns(int columnIndexOffset, ColumnConsumer consumer) {\n+\t\tvisitReferringColumns( columnIndexOffset, consumer );\n \t}\n \n-\tvoid visitReferringColumns(ColumnConsumer consumer);\n+\tvoid visitReferringColumns(int columnIndexOffset, ColumnConsumer consumer);\n \n-\tdefault void visitReferringColumns(IndexedColumnConsumer consumer) {\n-\t\tvisitReferringColumns( new ColumnConsumer() {\n-\t\t\tprivate int index;\n+\tvoid visitTargetColumns(int columnIndexOffset, ColumnConsumer consumer);\n \n-\t\t\t@Override\n-\t\t\tpublic void accept(\n-\t\t\t\t\tString containingTableExpression,\n-\t\t\t\t\tString columnExpression,\n-\t\t\t\t\tboolean isFormula,\n-\t\t\t\t\tString customReadExpression,\n-\t\t\t\t\tString customWriteExpression,\n-\t\t\t\t\tJdbcMapping jdbcMapping) {\n-\t\t\t\tconsumer.accept(\n-\t\t\t\t\t\tindex,\n-\t\t\t\t\t\tcontainingTableExpression,\n-\t\t\t\t\t\tcolumnExpression,\n-\t\t\t\t\t\tisFormula,\n-\t\t\t\t\t\tcustomReadExpression,\n-\t\t\t\t\t\tcustomWriteExpression,\n-\t\t\t\t\t\tjdbcMapping\n-\t\t\t\t);\n-\t\t\t\tindex++;\n-\t\t\t}\n-\t\t} );\n+\tdefault void visitReferringColumns(ColumnConsumer consumer)  {\n+\t\tvisitReferringColumns( 0, consumer );\n \t}\n \n-\tvoid visitTargetColumns(ColumnConsumer consumer);\n-\n-\tdefault void visitTargetColumns(IndexedColumnConsumer consumer) {\n-\t\tvisitTargetColumns( new ColumnConsumer() {\n-\t\t\tprivate int index;\n-\n-\t\t\t@Override\n-\t\t\tpublic void accept(\n-\t\t\t\t\tString containingTableExpression,\n-\t\t\t\t\tString columnExpression,\n-\t\t\t\t\tboolean isFormula,\n-\t\t\t\t\tString customReadExpression,\n-\t\t\t\t\tString customWriteExpression,\n-\t\t\t\t\tJdbcMapping jdbcMapping) {\n-\t\t\t\tconsumer.accept(\n-\t\t\t\t\t\tindex,\n-\t\t\t\t\t\tcontainingTableExpression,\n-\t\t\t\t\t\tcolumnExpression,\n-\t\t\t\t\t\tisFormula,\n-\t\t\t\t\t\tcustomReadExpression,\n-\t\t\t\t\t\tcustomWriteExpression,\n-\t\t\t\t\t\tjdbcMapping\n-\t\t\t\t);\n-\t\t\t\tindex++;\n-\t\t\t}\n-\t\t} );\n+\tdefault void visitTargetColumns(ColumnConsumer consumer) {\n+\t\tvisitTargetColumns( 0, consumer );\n \t}\n \n \tAssociationKey getAssociationKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk1MDMyMQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522950321", "bodyText": "Perhaps both this and a IndexedColumnMappingConsumer make sense?  If the target already has ColumnMappings, imo it makes sense to allow a consumer to access the aggregation.", "author": "sebersole", "createdAt": "2020-11-13T13:30:04Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/IndexedColumnConsumer.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+/**\n+ * Consumer used to visit columns for a given model part\n+ *\n+ * @author Steve Ebersole\n+ */\n+@FunctionalInterface\n+public interface IndexedColumnConsumer {\n+\tvoid accept(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/IndexedColumnConsumer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappingConsumer.java\nsimilarity index 64%\nrename from hibernate-core/src/main/java/org/hibernate/metamodel/mapping/IndexedColumnConsumer.java\nrename to hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappingConsumer.java\nindex 952c364872..3437dd587a 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/IndexedColumnConsumer.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappingConsumer.java\n\n@@ -9,16 +9,12 @@ package org.hibernate.metamodel.mapping;\n /**\n  * Consumer used to visit columns for a given model part\n  *\n- * @author Steve Ebersole\n+ * @author Christian Beikov\n  */\n @FunctionalInterface\n-public interface IndexedColumnConsumer {\n+public interface ColumnMappingConsumer {\n \tvoid accept(\n-\t\t\tint index,\n+\t\t\tint columnIndex,\n \t\t\tString containingTableExpression,\n-\t\t\tString columnExpression,\n-\t\t\tboolean isFormula,\n-\t\t\tString customReadExpression,\n-\t\t\tString customWriteExpression,\n-\t\t\tJdbcMapping jdbcMapping);\n+\t\t\tColumnMapping columnMapping);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk1MjI1Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522952252", "bodyText": "Similar question regarding ColumnConsumer and IndexedColumnConsumer... why not just pass the ColumnMapping rather than each of its aggregated values individually?", "author": "sebersole", "createdAt": "2020-11-13T13:33:48Z", "path": "hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java", "diffHunk": "@@ -917,9 +917,8 @@ private QuerySpec generateSubSelect(\n \n \t\tfinal SqlExpressionResolver sqlExpressionResolver = creationState.getSqlExpressionResolver();\n \n-\t\tfinal MutableInteger count = new MutableInteger();\n \t\tfkDescriptor.visitTargetColumns(\n-\t\t\t\t(table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {\n+\t\t\t\t(valuesPosition, table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "884e2c59d7c3ec147ea6db703d606b3016a15524", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java b/hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java\nindex ad85e32bcd..751580b073 100644\n--- a/hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java\n+++ b/hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java\n\n@@ -917,8 +918,9 @@ public class LoaderSelectBuilder {\n \n \t\tfinal SqlExpressionResolver sqlExpressionResolver = creationState.getSqlExpressionResolver();\n \n+\t\tfinal MutableInteger count = new MutableInteger();\n \t\tfkDescriptor.visitTargetColumns(\n-\t\t\t\t(valuesPosition, table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {\n+\t\t\t\t(table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {\n \t\t\t\t\t// for each column, resolve a SqlSelection and add it to the sub-query select-clause\n \t\t\t\t\tfinal TableReference tableReference = ownerTableGroup.resolveTableReference( table );\n \t\t\t\t\tfinal Expression expression = sqlExpressionResolver.resolveSqlExpression(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTgwMw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523031803", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T15:41:22Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java", "diffHunk": "@@ -38,14 +36,7 @@\n \t */\n \tString getContainingTableExpression();\n \n-\t/**\n-\t * The column expressions (column name or formula) to which this embedded value\n-\t * is mapped\n-\t */\n-\tList<String> getMappedColumnExpressions();\n-\n-\tList<String> getCustomReadExpressions();\n-\tList<String> getCustomWriteExpressions();\n+\tColumnMappings getColumnMappings();", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java\nindex e5770865ab..9471f63199 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java\n\n@@ -36,8 +37,6 @@ public interface EmbeddableValuedModelPart extends ModelPart, Fetchable, Fetchab\n \t */\n \tString getContainingTableExpression();\n \n-\tColumnMappings getColumnMappings();\n-\n \t/**\n \t * @see org.hibernate.annotations.Parent\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzI4NA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523037284", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T15:49:50Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java", "diffHunk": "@@ -33,10 +33,7 @@ public static Expression buildColumnReferenceExpression(\n \t\t\tif ( sqlExpressionResolver == null ) {\n \t\t\t\treturn new ColumnReference(\n \t\t\t\t\t\tbasicPart.getContainingTableExpression(),\n-\t\t\t\t\t\tbasicPart.getMappedColumnExpression(),\n-\t\t\t\t\t\tbasicPart.isMappedColumnExpressionFormula(),\n-\t\t\t\t\t\tbasicPart.getCustomReadExpression(),\n-\t\t\t\t\t\tbasicPart.getCustomWriteExpression(),\n+\t\t\t\t\t\tbasicPart,", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java\nindex 55b304bcac..8b31eda7ff 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java\n\n@@ -27,33 +27,10 @@ public class MappingModelHelper {\n \t\t\tSessionFactoryImplementor sessionFactory) {\n \t\tfinal int jdbcTypeCount = modelPart.getJdbcTypeCount( sessionFactory.getTypeConfiguration() );\n \n-\t\tif ( jdbcTypeCount == 1 ) {\n-\t\t\tassert modelPart instanceof BasicValuedModelPart;\n-\t\t\tfinal BasicValuedModelPart basicPart = (BasicValuedModelPart) modelPart;\n-\t\t\tif ( sqlExpressionResolver == null ) {\n-\t\t\t\treturn new ColumnReference(\n-\t\t\t\t\t\tbasicPart.getContainingTableExpression(),\n-\t\t\t\t\t\tbasicPart,\n-\t\t\t\t\t\tbasicPart.getJdbcMapping(),\n-\t\t\t\t\t\tsessionFactory\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\treturn sqlExpressionResolver.resolveSqlExpression(\n-\t\t\t\t\t\tcreateColumnReferenceKey( basicPart.getContainingTableExpression(), basicPart.getMappedColumnExpression() ),\n-\t\t\t\t\t\tsqlAstProcessingState -> new ColumnReference(\n-\t\t\t\t\t\t\t\tbasicPart.getContainingTableExpression(),\n-\t\t\t\t\t\t\t\tbasicPart,\n-\t\t\t\t\t\t\t\tbasicPart.getJdbcMapping(),\n-\t\t\t\t\t\t\t\tsessionFactory\n-\t\t\t\t\t\t)\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n-\t\telse {\n+\t\tif ( modelPart instanceof EmbeddableValuedModelPart ) {\n \t\t\tfinal List<ColumnReference> columnReferences = new ArrayList<>( jdbcTypeCount );\n \t\t\tmodelPart.visitColumns(\n-\t\t\t\t\t(table, column, isFormula, readFragment, writeFragment, jdbcMapping) -> {\n+\t\t\t\t\t(columnIndex, table, column, isFormula, readFragment, writeFragment, jdbcMapping) -> {\n \t\t\t\t\t\tfinal ColumnReference colRef;\n \t\t\t\t\t\tif ( sqlExpressionResolver == null ) {\n \t\t\t\t\t\t\tcolRef = new ColumnReference(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzYxMA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523037610", "bodyText": "Multi-line code style", "author": "sebersole", "createdAt": "2020-11-13T15:50:19Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java", "diffHunk": "@@ -98,5 +98,31 @@ default void visitColumns(ColumnConsumer consumer) {\n \n \t}\n \n+\tdefault void visitColumns(IndexedColumnConsumer consumer) {\n+\t\tvisitColumns( new ColumnConsumer() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java\nindex a5873f35ea..eea83c8742 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java\n\n@@ -95,33 +95,11 @@ public interface ModelPart extends MappingModelExpressable {\n \t}\n \n \tdefault void visitColumns(ColumnConsumer consumer) {\n-\n+\t\tvisitColumns( 0, consumer );\n \t}\n \n-\tdefault void visitColumns(IndexedColumnConsumer consumer) {\n-\t\tvisitColumns( new ColumnConsumer() {\n-\t\t\tprivate int index;\n+\tdefault void visitColumns(int columnIndexOffset, ColumnConsumer consumer) {\n \n-\t\t\t@Override\n-\t\t\tpublic void accept(\n-\t\t\t\t\tString containingTableExpression,\n-\t\t\t\t\tString columnExpression,\n-\t\t\t\t\tboolean isFormula,\n-\t\t\t\t\tString customReadExpression,\n-\t\t\t\t\tString customWriteExpression,\n-\t\t\t\t\tJdbcMapping jdbcMapping) {\n-\t\t\t\tconsumer.accept(\n-\t\t\t\t\t\tindex,\n-\t\t\t\t\t\tcontainingTableExpression,\n-\t\t\t\t\t\tcolumnExpression,\n-\t\t\t\t\t\tisFormula,\n-\t\t\t\t\t\tcustomReadExpression,\n-\t\t\t\t\t\tcustomWriteExpression,\n-\t\t\t\t\t\tjdbcMapping\n-\t\t\t\t);\n-\t\t\t\tindex++;\n-\t\t\t}\n-\t\t} );\n \t}\n \n \tEntityMappingType findContainingEntityMapping();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzODQ0Ng==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523038446", "bodyText": "Multi-line code style", "author": "sebersole", "createdAt": "2020-11-13T15:51:40Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping.internal;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import org.hibernate.dialect.Dialect;\n+import org.hibernate.internal.util.collections.ArrayHelper;\n+import org.hibernate.internal.util.collections.CollectionHelper;\n+import org.hibernate.mapping.Component;\n+import org.hibernate.mapping.IndexedConsumer;\n+import org.hibernate.mapping.Selectable;\n+import org.hibernate.mapping.Value;\n+import org.hibernate.metamodel.mapping.ColumnConsumer;\n+import org.hibernate.metamodel.mapping.ColumnMappings;\n+import org.hibernate.metamodel.mapping.IndexedColumnConsumer;\n+import org.hibernate.metamodel.mapping.JdbcMapping;\n+import org.hibernate.query.sqm.function.SqmFunctionRegistry;\n+\n+/**\n+ * @author Christian Beikov\n+ */\n+public class ColumnMappingsImpl implements ColumnMappings {\n+\n+\tprivate final String[] columnExpressions;\n+\tprivate final String[] customReadExpressions;\n+\tprivate final String[] customWriteExpressions;\n+\tprivate final boolean[] mappedColumnExpressionFormula;\n+\n+\tpublic ColumnMappingsImpl(\n+\t\t\tString[] columnExpressions,\n+\t\t\tString[] customReadExpressions,\n+\t\t\tString[] customWriteExpressions,\n+\t\t\tboolean[] mappedColumnExpressionFormula) {\n+\t\tthis.columnExpressions = columnExpressions;\n+\t\tthis.customReadExpressions = customReadExpressions;\n+\t\tthis.customWriteExpressions = customWriteExpressions;\n+\t\tthis.mappedColumnExpressionFormula = mappedColumnExpressionFormula;\n+\t}\n+\n+\tpublic static ColumnMappings from(Component component, Dialect dialect, SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\treturn from( component::forEachColumn, component.getPropertySpan(), dialect, sqmFunctionRegistry );\n+\t}\n+\n+\tpublic static ColumnMappings from(Value value, Dialect dialect, SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\tif ( value instanceof Component ) {\n+\t\t\treturn from( (Component) value, dialect, sqmFunctionRegistry );\n+\t\t}\n+\t\treturn from( consumer -> {\n+\t\t\tIterator<Selectable> columnIterator = value.getColumnIterator();\n+\t\t\tint columnIndex = 0;\n+\t\t\twhile ( columnIterator.hasNext() ) {\n+\t\t\t\tconsumer.accept( columnIndex, columnIterator.next() );\n+\t\t\t\tcolumnIndex++;\n+\t\t\t}\n+\t\t}, value.getColumnSpan(), dialect, sqmFunctionRegistry );\n+\t}\n+\n+\tprivate static ColumnMappings from(\n+\t\t\tfinal Consumer<IndexedConsumer<Selectable>> consumer,\n+\t\t\tfinal int propertySpan,\n+\t\t\tfinal Dialect dialect,\n+\t\t\tfinal SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\tfinal List<String> columnExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<String> customReadExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<String> customWriteExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<Boolean> isFormulas = CollectionHelper.arrayList( propertySpan );\n+\n+\t\tconsumer.accept( (index, selectable) -> {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java\nindex dd9b8671b9..772270108e 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java\n\n@@ -6,23 +6,25 @@\n  */\n package org.hibernate.metamodel.mapping.internal;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.function.Consumer;\n \n import org.hibernate.dialect.Dialect;\n+import org.hibernate.engine.spi.Mapping;\n import org.hibernate.internal.util.collections.ArrayHelper;\n import org.hibernate.internal.util.collections.CollectionHelper;\n-import org.hibernate.mapping.Component;\n-import org.hibernate.mapping.IndexedConsumer;\n import org.hibernate.mapping.Selectable;\n import org.hibernate.mapping.Value;\n import org.hibernate.metamodel.mapping.ColumnConsumer;\n import org.hibernate.metamodel.mapping.ColumnMappings;\n-import org.hibernate.metamodel.mapping.IndexedColumnConsumer;\n+import org.hibernate.metamodel.mapping.EmbeddableMappingType;\n import org.hibernate.metamodel.mapping.JdbcMapping;\n import org.hibernate.query.sqm.function.SqmFunctionRegistry;\n+import org.hibernate.type.CompositeType;\n+import org.hibernate.type.EntityType;\n+import org.hibernate.type.Type;\n \n /**\n  * @author Christian Beikov\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NTYyNQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523045625", "bodyText": "I'm tempted to say that ColumnReference should accept the ColumnMapping rather than the individual pieces.  I understand you probably chose that because it matches the existing contracts.\nBut this is point I brought up in regards to model parts accepting a ColumnConsumer, but that really a ColumnMappingConsumer makes sense as well.  There is never a time when a model part wont have the  ColumnMapping reference(s) already, so concerns about instantiations isn't really a hinderance there.\nI'm not sure there is ever a time when we would not want a ColumnMapping on the ColumnReference for some reason (\"PK tables\", e.g.), but if so we could e.g. add a ModelColumnReference also that takes the ColumnMapping.\nI just think we added this ColumnMapping contract because it cleaned up a lot of code.  It would be a shame to not use it in other places where we could be using it.", "author": "sebersole", "createdAt": "2020-11-13T16:02:49Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -181,11 +186,11 @@ public DomainResult createDomainResult(\n \t\t\t\t\t\t\t),\n \t\t\t\t\t\t\ts ->\n \t\t\t\t\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\t\t\t\t\tidentificationVariable,", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\nindex 182874cf64..5ec291c567 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n\n@@ -176,34 +156,34 @@ public class EmbeddedForeignKeyDescriptor implements ForeignKeyDescriptor, Model\n \t\tList<SqlSelection> sqlSelections = new ArrayList<>( keyColumnMappings.getColumnSpan() );\n \t\tkeyColumnMappings.forEachColumn(\n \t\t\t\tidentificationVariable,\n-\t\t\t\tjdbcMappings,\n-\t\t\t\t(containingTableExpression, columnExpression, isFormula, customReadExpression, customWriteExpression, jdbcMapping) -> {\n-\t\t\tfinal SqlSelection sqlSelection = sqlExpressionResolver.resolveSqlSelection(\n-\t\t\t\t\tsqlExpressionResolver.resolveSqlExpression(\n-\t\t\t\t\t\t\tSqlExpressionResolver.createColumnReferenceKey(\n-\t\t\t\t\t\t\t\t\ttableReference,\n-\t\t\t\t\t\t\t\t\tcolumnExpression\n+\t\t\t\t(columnIndex, containingTableExpression, columnExpression, isFormula, customReadExpression, customWriteExpression, jdbcMapping) -> {\n+\t\t\t\t\tfinal SqlSelection sqlSelection = sqlExpressionResolver.resolveSqlSelection(\n+\t\t\t\t\t\t\tsqlExpressionResolver.resolveSqlExpression(\n+\t\t\t\t\t\t\t\t\tSqlExpressionResolver.createColumnReferenceKey(\n+\t\t\t\t\t\t\t\t\t\t\ttableReference,\n+\t\t\t\t\t\t\t\t\t\t\tcolumnExpression\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\ts ->\n+\t\t\t\t\t\t\t\t\t\t\tnew ColumnReference(\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcontainingTableExpression,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcolumnExpression,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tisFormula,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcustomReadExpression,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcustomWriteExpression,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tjdbcMapping,\n+\t\t\t\t\t\t\t\t\t\t\t\t\tcreationState.getSqlAstCreationState()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getCreationContext()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getSessionFactory()\n+\t\t\t\t\t\t\t\t\t\t\t)\n \t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\ts ->\n-\t\t\t\t\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\t\t\t\t\tcontainingTableExpression,\n-\t\t\t\t\t\t\t\t\t\t\tcolumnExpression,\n-\t\t\t\t\t\t\t\t\t\t\tisFormula,\n-\t\t\t\t\t\t\t\t\t\t\tcustomReadExpression,\n-\t\t\t\t\t\t\t\t\t\t\tcustomWriteExpression,\n-\t\t\t\t\t\t\t\t\t\t\tjdbcMapping,\n-\t\t\t\t\t\t\t\t\t\t\tcreationState.getSqlAstCreationState()\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.getCreationContext()\n-\t\t\t\t\t\t\t\t\t\t\t\t\t.getSessionFactory()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t),\n-\t\t\t\t\tjdbcMapping.getJavaTypeDescriptor(),\n-\t\t\t\t\tsqlAstCreationState.getCreationContext().getDomainModel().getTypeConfiguration()\n-\t\t\t);\n-\t\t\tsqlSelections.add( sqlSelection );\n-\t\t} );\n+\t\t\t\t\t\t\tjdbcMapping.getJavaTypeDescriptor(),\n+\t\t\t\t\t\t\tsqlAstCreationState.getCreationContext().getDomainModel().getTypeConfiguration()\n+\t\t\t\t\t);\n+\t\t\t\t\tsqlSelections.add( sqlSelection );\n+\t\t\t\t}\n+\t\t);\n \n-\t\treturn new EmbeddableForeignKeyResultImpl(\n+\t\treturn new EmbeddableForeignKeyResultImpl<>(\n \t\t\t\tsqlSelections,\n \t\t\t\tcollectionPath,\n \t\t\t\tmappingType,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0OTI5MA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523049290", "bodyText": "The more I see it the more I really like your naming pattern here better - #forEachColumn as opposed to #visitColumns.  It better matches with the Java naming.\nI'm actually thinking of a general refactoring to make that change.  What do y'all think?", "author": "sebersole", "createdAt": "2020-11-13T16:08:50Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -255,46 +260,49 @@ public Predicate generateJoinPredicate(\n \t\tfinal String lhsTableExpression = lhs.getTableExpression();\n \t\tif ( lhsTableExpression.equals( keyColumnContainingTable ) ) {\n \t\t\tassert rhsTableExpression.equals( targetColumnContainingTable );\n-\t\t\treturn getPredicate( lhs, rhs, creationContext, keyColumnExpressions, targetColumnExpressions );\n+\t\t\treturn getPredicate( lhs, rhs, creationContext, keyColumnMappings, targetColumnMappings );\n \t\t}\n \t\telse {\n \t\t\tassert rhsTableExpression.equals( keyColumnContainingTable );\n-\t\t\treturn getPredicate( lhs, rhs, creationContext, targetColumnExpressions, keyColumnExpressions );\n+\t\t\treturn getPredicate( lhs, rhs, creationContext, targetColumnMappings, keyColumnMappings );\n \t\t}\n \t}\n \n \tprivate Predicate getPredicate(\n \t\t\tTableReference lhs,\n \t\t\tTableReference rhs,\n \t\t\tSqlAstCreationContext creationContext,\n-\t\t\tList<String> lhsExpressions,\n-\t\t\tList<String> rhsColumnExpressions) {\n+\t\t\tColumnMappings lhsMappings,\n+\t\t\tColumnMappings rhsMappings) {\n \t\tfinal Junction predicate = new Junction( Junction.Nature.CONJUNCTION );\n-\t\tfor ( int i = 0; i < lhsExpressions.size(); i++ ) {\n-\t\t\tfinal JdbcMapping jdbcMapping = jdbcMappings.get( i );\n-\t\t\tfinal ComparisonPredicate comparisonPredicate = new ComparisonPredicate(\n-\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\tlhs,\n-\t\t\t\t\t\t\tlhsExpressions.get( i ),\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tjdbcMapping,\n-\t\t\t\t\t\t\tcreationContext.getSessionFactory()\n-\t\t\t\t\t),\n-\t\t\t\t\tComparisonOperator.EQUAL,\n-\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\trhs,\n-\t\t\t\t\t\t\trhsColumnExpressions.get( i ),\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tjdbcMapping,\n-\t\t\t\t\t\t\tcreationContext.getSessionFactory()\n-\t\t\t\t\t)\n-\t\t\t);\n-\t\t\tpredicate.add( comparisonPredicate );\n-\t\t}\n+\t\tlhsMappings.forEachColumn(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\nindex 182874cf64..5ec291c567 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n\n@@ -277,7 +257,6 @@ public class EmbeddedForeignKeyDescriptor implements ForeignKeyDescriptor, Model\n \t\tfinal Junction predicate = new Junction( Junction.Nature.CONJUNCTION );\n \t\tlhsMappings.forEachColumn(\n \t\t\t\tlhs.getIdentificationVariable(),\n-\t\t\t\tjdbcMappings,\n \t\t\t\t(i, containingTableExpression, columnExpression, isFormula, customReadExpression, customWriteExpression, jdbcMapping) -> {\n \t\t\t\t\tfinal ComparisonPredicate comparisonPredicate = new ComparisonPredicate(\n \t\t\t\t\t\t\tnew ColumnReference(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MTA4Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523051083", "bodyText": "Another case where this code would be a lot cleaner passing along the ColumnMapping", "author": "sebersole", "createdAt": "2020-11-13T16:11:48Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -115,35 +116,39 @@ public DomainResult createCollectionFetchDomainResult(\n \t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( keyColumnContainingTable );\n \t\t\tfinal String identificationVariable = tableReference.getIdentificationVariable();\n \n-\t\t\tList<SqlSelection> sqlSelections = new ArrayList<>();\n-\t\t\tfor ( int i = 0; i < keyColumnExpressions.size(); i++ ) {\n-\t\t\t\tfinal JdbcMapping jdbcMapping = jdbcMappings.get( i );\n-\t\t\t\tfinal String columnExpression = targetColumnExpressions.get( i );\n-\t\t\t\tfinal SqlSelection sqlSelection = sqlExpressionResolver.resolveSqlSelection(\n-\t\t\t\t\t\tsqlExpressionResolver.resolveSqlExpression(\n-\t\t\t\t\t\t\t\tSqlExpressionResolver.createColumnReferenceKey(\n-\t\t\t\t\t\t\t\t\t\ttableReference,\n-\t\t\t\t\t\t\t\t\t\tcolumnExpression\n+\t\t\tList<SqlSelection> sqlSelections = new ArrayList<>( targetColumnMappings.getColumnSpan() );\n+\t\t\ttargetColumnMappings.forEachColumn(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c63b686e9eb49b46a39c1a08463600aad18524d4", "chunk": "diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\nindex 182874cf64..5ec291c567 100644\n--- a/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java\n\n@@ -119,8 +100,7 @@ public class EmbeddedForeignKeyDescriptor implements ForeignKeyDescriptor, Model\n \t\t\tList<SqlSelection> sqlSelections = new ArrayList<>( targetColumnMappings.getColumnSpan() );\n \t\t\ttargetColumnMappings.forEachColumn(\n \t\t\t\t\tidentificationVariable,\n-\t\t\t\t\tjdbcMappings,\n-\t\t\t\t\t(containingTableExpression, columnExpression, isFormula, customReadExpression, customWriteExpression, jdbcMapping) -> {\n+\t\t\t\t\t(columnIndex, containingTableExpression, columnExpression, isFormula, customReadExpression, customWriteExpression, jdbcMapping) -> {\n \t\t\t\t\t\tfinal SqlSelection sqlSelection = sqlExpressionResolver.resolveSqlSelection(\n \t\t\t\t\t\t\t\tsqlExpressionResolver.resolveSqlExpression(\n \t\t\t\t\t\t\t\t\t\tSqlExpressionResolver.createColumnReferenceKey(\n"}}, {"oid": "c63b686e9eb49b46a39c1a08463600aad18524d4", "url": "https://github.com/hibernate/hibernate-orm/commit/c63b686e9eb49b46a39c1a08463600aad18524d4", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T10:56:13Z", "type": "forcePushed"}, {"oid": "ca5520e21e4c7547632fc505fb0a51a931bfe0fa", "url": "https://github.com/hibernate/hibernate-orm/commit/ca5520e21e4c7547632fc505fb0a51a931bfe0fa", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T15:29:14Z", "type": "forcePushed"}, {"oid": "a03a0d04dac8cfa2f17b851e1e4fda9e3630c814", "url": "https://github.com/hibernate/hibernate-orm/commit/a03a0d04dac8cfa2f17b851e1e4fda9e3630c814", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T17:20:49Z", "type": "forcePushed"}, {"oid": "5aed3fbcac4cfee28fd3066255d420ded8fa37e5", "url": "https://github.com/hibernate/hibernate-orm/commit/5aed3fbcac4cfee28fd3066255d420ded8fa37e5", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T23:23:09Z", "type": "forcePushed"}, {"oid": "884e2c59d7c3ec147ea6db703d606b3016a15524", "url": "https://github.com/hibernate/hibernate-orm/commit/884e2c59d7c3ec147ea6db703d606b3016a15524", "message": "Use new parent PostgreSQLDialect for @RequiresDialect rather than subclass", "committedDate": "2020-12-11T10:58:05Z", "type": "commit"}, {"oid": "1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "url": "https://github.com/hibernate/hibernate-orm/commit/1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-14T12:52:42Z", "type": "commit"}, {"oid": "1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "url": "https://github.com/hibernate/hibernate-orm/commit/1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-14T12:52:42Z", "type": "forcePushed"}]}