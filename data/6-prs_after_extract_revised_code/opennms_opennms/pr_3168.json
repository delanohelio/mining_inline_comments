{"pr_number": 3168, "pr_title": "NMS-12692: Hostname resolution for flow queries", "pr_createdAt": "2020-09-23T13:51:40Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3168", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1MDAwMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3168#discussion_r493650001", "bodyText": "Conversations need to be mapped as well.", "author": "j-white", "createdAt": "2020-09-23T14:42:03Z", "path": "features/flows/elastic/src/main/java/org/opennms/netmgt/flows/elastic/agg/AggregatedFlowQueryService.java", "diffHunk": "@@ -84,22 +89,30 @@ public AggregatedFlowQueryService(JestClient client, IndexSelector indexSelector\n \n     @Override\n     public CompletableFuture<List<TrafficSummary<Conversation>>> getTopNConversationSummaries(int N, boolean includeOther, List<Filter> filters) {\n-        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, Types.CONVERSATION );\n+        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, Types.CONVERSATION);", "originalCommit": "d2e35fe8a1b0c78de9cf28f3f53aa4477144c9e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a744677cf214bac2d60859928ab4ac78b72eae88", "chunk": "diff --git a/features/flows/elastic/src/main/java/org/opennms/netmgt/flows/elastic/agg/AggregatedFlowQueryService.java b/features/flows/elastic/src/main/java/org/opennms/netmgt/flows/elastic/agg/AggregatedFlowQueryService.java\nindex b4d15f59210..39cc2e7ce69 100644\n--- a/features/flows/elastic/src/main/java/org/opennms/netmgt/flows/elastic/agg/AggregatedFlowQueryService.java\n+++ b/features/flows/elastic/src/main/java/org/opennms/netmgt/flows/elastic/agg/AggregatedFlowQueryService.java\n\n@@ -77,29 +80,87 @@ public class AggregatedFlowQueryService extends ElasticFlowQueryService {\n         super(client, indexSelector);\n     }\n \n+    /**\n+     * use the convert the results of the proportional_sum aggregation (provided by our ES plugin) to a table\n+     */\n+    private static void toTableFromBuckets(ImmutableTable.Builder<Directional<String>, Long, Double> builder, SearchResult res,\n+                                           final Function<TermsAggregation.Entry, String> transform) {\n+        final MetricAggregation aggs = res.getAggregations();\n+        if (aggs == null) {\n+            // No results\n+            return;\n+        }\n+        final TermsAggregation byKeyAgg = aggs.getTermsAggregation(\"by_key\");\n+        if (byKeyAgg == null) {\n+            // No results\n+            return;\n+        }\n+        for (TermsAggregation.Entry bucket : byKeyAgg.getBuckets()) {\n+            final ProportionalSumAggregation bytesInAgg = bucket.getAggregation(\"bytes_in\", ProportionalSumAggregation.class);\n+            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesInAgg.getBuckets()) {\n+                builder.put(new Directional<>(transform.apply(bucket), true), dateHistogram.getTime(), dateHistogram.getValue());\n+            }\n+            final ProportionalSumAggregation bytesOutAgg = bucket.getAggregation(\"bytes_out\", ProportionalSumAggregation.class);\n+            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesOutAgg.getBuckets()) {\n+                builder.put(new Directional<>(transform.apply(bucket), false), dateHistogram.getTime(), dateHistogram.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * use the convert the results of the proportional_sum aggregation (provided by our ES plugin) to a table\n+     */\n+    private static <T> void toTableFromTotals(ImmutableTable.Builder<Directional<String>, Long, Double> builder, SearchResult res) {\n+        final MetricAggregation aggs = res.getAggregations();\n+        if (aggs == null) {\n+            // No results\n+            return;\n+        }\n+        final ProportionalSumAggregation bytesInAgg = aggs.getAggregation(\"bytes_in\", ProportionalSumAggregation.class);\n+        if (bytesInAgg != null) {\n+            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesInAgg.getBuckets()) {\n+                builder.put(new Directional<>(OTHER_NAME, true), dateHistogram.getTime(), dateHistogram.getValue());\n+            }\n+        }\n+        final ProportionalSumAggregation bytesOutAgg = aggs.getAggregation(\"bytes_out\", ProportionalSumAggregation.class);\n+        if (bytesOutAgg != null) {\n+            for (ProportionalSumAggregation.DateHistogram dateHistogram : bytesOutAgg.getBuckets()) {\n+                builder.put(new Directional<>(OTHER_NAME, false), dateHistogram.getTime(), dateHistogram.getValue());\n+            }\n+        }\n+    }\n+\n     @Override\n     public CompletableFuture<List<TrafficSummary<String>>> getTopNApplicationSummaries(int N, boolean includeOther, List<Filter> filters) {\n-        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_APPLICATION, Types.APPLICATION);\n+        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_APPLICATION, \"application\", AggregatedFlowQueryService::mapApplication);\n     }\n \n     @Override\n     public CompletableFuture<Table<Directional<String>, Long, Double>> getTopNApplicationSeries(int N, long step, boolean includeOther, List<Filter> filters) {\n-        return getTopNSeries(N, step, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_APPLICATION, Types.APPLICATION);\n+        return getTopNSeries(N, step, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_APPLICATION, \"application\", AggregatedFlowQueryService::mapApplication);\n     }\n \n     @Override\n     public CompletableFuture<List<TrafficSummary<Conversation>>> getTopNConversationSummaries(int N, boolean includeOther, List<Filter> filters) {\n-        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, Types.CONVERSATION);\n+        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, \"conversation_key\", TermsAggregation.Entry::getKeyAsString)\n+                .thenCompose((summaries) -> transpose(summaries.stream()\n+                                                               .map(summary -> this.resolveHostnameForConversation(summary.getEntity(), filters)\n+                                                                                   .thenApply(host -> TrafficSummary.from(host)\n+                                                                                                                    .withBytesFrom(summary)\n+                                                                                                                    .build()))\n+                                                               .collect(Collectors.toList()),\n+                                                      Collectors.toList()));\n     }\n \n     @Override\n     public CompletableFuture<Table<Directional<Conversation>, Long, Double>> getTopNConversationSeries(int N, long step, boolean includeOther, List<Filter> filters) {\n-        return getTopNSeries(N, step, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, Types.CONVERSATION);\n+        return getTopNSeries(N, step, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_CONVERSATION, \"conversation_key\", TermsAggregation.Entry::getKeyAsString)\n+                .thenCompose((res) -> mapTable(res, host -> this.resolveHostnameForConversation(host, filters)));\n     }\n \n     @Override\n     public CompletableFuture<List<TrafficSummary<Host>>> getTopNHostSummaries(int N, boolean includeOther, List<Filter> filters) {\n-        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_HOST, Types.HOST)\n+        return getTopNSummary(N, includeOther, filters, GroupedBy.EXPORTER_INTERFACE_HOST, \"host_address\", TermsAggregation.Entry::getKeyAsString)\n                 .thenCompose((summaries) -> transpose(summaries.stream()\n                                                                .map(summary -> this.resolveHostnameForHost(summary.getEntity(), filters)\n                                                                                    .thenApply(host -> TrafficSummary.from(host)\n"}}, {"oid": "a744677cf214bac2d60859928ab4ac78b72eae88", "url": "https://github.com/OpenNMS/opennms/commit/a744677cf214bac2d60859928ab4ac78b72eae88", "message": "NMS-12692: Hostname resolution for flow queries\n\nThis implements hostname querying for aggregated flows processed by nephron\nand fixes hostname querying for row flows.", "committedDate": "2020-09-24T09:42:18Z", "type": "forcePushed"}, {"oid": "6fc86c7a976fac8a14045777c9235e71dff2e7e6", "url": "https://github.com/OpenNMS/opennms/commit/6fc86c7a976fac8a14045777c9235e71dff2e7e6", "message": "NMS-12692: Hostname resolution for flow queries\n\nThis implements hostname querying for aggregated flows processed by nephron\nand fixes hostname querying for row flows.", "committedDate": "2020-09-29T09:33:05Z", "type": "commit"}, {"oid": "6fc86c7a976fac8a14045777c9235e71dff2e7e6", "url": "https://github.com/OpenNMS/opennms/commit/6fc86c7a976fac8a14045777c9235e71dff2e7e6", "message": "NMS-12692: Hostname resolution for flow queries\n\nThis implements hostname querying for aggregated flows processed by nephron\nand fixes hostname querying for row flows.", "committedDate": "2020-09-29T09:33:05Z", "type": "forcePushed"}]}