{"pr_number": 1779, "pr_title": "Counter battery fire", "pr_createdAt": "2020-03-20T03:49:34Z", "pr_url": "https://github.com/MegaMek/megamek/pull/1779", "timeline": [{"oid": "aadb751e8b0a0d71dcdbbc1eaffd46c224b09a8c", "url": "https://github.com/MegaMek/megamek/commit/aadb751e8b0a0d71dcdbbc1eaffd46c224b09a8c", "message": "work in progress", "committedDate": "2020-03-14T01:14:56Z", "type": "commit"}, {"oid": "305b0017d8a1887f44d60f5db8691b816d035c3a", "url": "https://github.com/MegaMek/megamek/commit/305b0017d8a1887f44d60f5db8691b816d035c3a", "message": "work on handling counter-battery attacks", "committedDate": "2020-03-16T18:26:20Z", "type": "commit"}, {"oid": "17b00b2374f85896d3175325a6389ca760183cbc", "url": "https://github.com/MegaMek/megamek/commit/17b00b2374f85896d3175325a6389ca760183cbc", "message": "full round trip", "committedDate": "2020-03-18T04:46:49Z", "type": "commit"}, {"oid": "86cbb80ce2856430447578ca65c40ed06067fe18", "url": "https://github.com/MegaMek/megamek/commit/86cbb80ce2856430447578ca65c40ed06067fe18", "message": "finishing touches", "committedDate": "2020-03-20T03:12:59Z", "type": "commit"}, {"oid": "220bee0ed76e6ff08c603e793112742b107aa718", "url": "https://github.com/MegaMek/megamek/commit/220bee0ed76e6ff08c603e793112742b107aa718", "message": "bot action", "committedDate": "2020-03-20T03:44:26Z", "type": "commit"}, {"oid": "80213f6902440800b51d32a6f38c3927817cf910", "url": "https://github.com/MegaMek/megamek/commit/80213f6902440800b51d32a6f38c3927817cf910", "message": "Merge branch 'master' into counter_battery_fire", "committedDate": "2020-03-20T03:53:03Z", "type": "commit"}, {"oid": "78480d3298cbe9c33208f969f965c58d1aec0b73", "url": "https://github.com/MegaMek/megamek/commit/78480d3298cbe9c33208f969f965c58d1aec0b73", "message": "Delete CounterBatteryHelper.java", "committedDate": "2020-03-20T03:53:42Z", "type": "commit"}, {"oid": "5182d015ed8d146ce5c2dcada210eaa7044a3593", "url": "https://github.com/MegaMek/megamek/commit/5182d015ed8d146ce5c2dcada210eaa7044a3593", "message": "don't vastly over-value counter-battery attacks", "committedDate": "2020-03-20T04:04:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0OTMzNQ==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r395449335", "bodyText": "Is this just mof = Math.max(mof + 2, 0) ?", "author": "sixlettervariables", "createdAt": "2020-03-20T05:54:32Z", "path": "megamek/src/megamek/common/weapons/ArtilleryWeaponIndirectFireHandler.java", "diffHunk": "@@ -455,6 +415,143 @@ else if ((null != bestSpotter) && !(this instanceof ArtilleryWeaponDirectFireHan\n         return false;\n     }\n     \n+    /**\n+     * Worker function that handles \"artillery round landed here\" reports,\n+     * and direct artillery scatter. \n+     * @return Whether or not we should continue attack resolution afterwards\n+     */\n+    private Coords handleReportsAndDirectScatter(boolean isFlak, Coords targetPos, Vector<Report> vPhaseReport, ArtilleryAttackAction aaa) {\n+        Coords originalTargetPos = targetPos;\n+        \n+        Report r;\n+        // special report for off-board target\n+        if (target.isOffBoard()) {\n+            r = new Report(9994);\n+            r.subject = subjectId;\n+            vPhaseReport.addElement(r);\n+        }\n+        \n+        if (!bMissed) {\n+            // off-board targets can just report direct hit and move on\n+            if (target.isOffBoard()) {\n+                r = new Report(9996);\n+                r.subject = subjectId;\n+                r.indent();\n+                vPhaseReport.addElement(r);\n+                return targetPos;\n+            } \n+            \n+            if (!isFlak) {\n+                r = new Report(3190);\n+            } else {\n+                r = new Report(3191);\n+            }\n+            r.subject = subjectId;\n+            r.add(targetPos.getBoardNum());\n+            vPhaseReport.addElement(r);\n+\n+            String artyMsg = \"Artillery hit here on round \" + game.getRoundCount() \n+                    + \", fired by \" + game.getPlayer(aaa.getPlayerId()).getName()\n+                    + \" (this hex is now an auto-hit)\";\n+            game.getBoard().addSpecialHexDisplay(\n+                    targetPos,\n+                    new SpecialHexDisplay(SpecialHexDisplay.Type.ARTILLERY_HIT,\n+                            game.getRoundCount(), game.getPlayer(aaa\n+                                    .getPlayerId()), artyMsg));\n+\n+        } else {\n+            // direct fire artillery only scatters by one d6\n+            // we do this here to avoid duplicating handle()\n+            // in the ArtilleryWeaponDirectFireHandler\n+            Coords origPos = targetPos;\n+            int moF = toHit.getMoS();\n+            if (ae.hasAbility(\"oblique_artillery\")) {\n+                // getMoS returns a negative MoF\n+                // simple math is better so lets make it positive\n+                if ((-moF -2) < 1) {\n+                    moF = 0;\n+                } else {\n+                    moF = moF +2;", "originalCommit": "5182d015ed8d146ce5c2dcada210eaa7044a3593", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1NTQ5Ng==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r395655496", "bodyText": "I honestly have no idea, I just copy and pasted it from where it originally was.", "author": "NickAragua", "createdAt": "2020-03-20T14:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0OTMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8757348ef4e409fd3760166bc763ba5fb111c0a8", "chunk": "diff --git a/megamek/src/megamek/common/weapons/ArtilleryWeaponIndirectFireHandler.java b/megamek/src/megamek/common/weapons/ArtilleryWeaponIndirectFireHandler.java\nindex 0d219d71dc..70c8d2e27e 100644\n--- a/megamek/src/megamek/common/weapons/ArtilleryWeaponIndirectFireHandler.java\n+++ b/megamek/src/megamek/common/weapons/ArtilleryWeaponIndirectFireHandler.java\n\n@@ -468,11 +468,7 @@ public class ArtilleryWeaponIndirectFireHandler extends AmmoWeaponHandler {\n             if (ae.hasAbility(\"oblique_artillery\")) {\n                 // getMoS returns a negative MoF\n                 // simple math is better so lets make it positive\n-                if ((-moF -2) < 1) {\n-                    moF = 0;\n-                } else {\n-                    moF = moF +2;\n-                }\n+                moF = Math.max(moF + 2, 0);\n             }\n             targetPos = Compute.scatterDirectArty(targetPos, moF);\n             if (game.getBoard().contains(targetPos)) {\n"}}, {"oid": "7c47f3a0b815aa709e73f09356c8f64053a69222", "url": "https://github.com/MegaMek/megamek/commit/7c47f3a0b815aa709e73f09356c8f64053a69222", "message": "draw off board image; minor optimization", "committedDate": "2020-03-21T02:50:13Z", "type": "commit"}, {"oid": "8757348ef4e409fd3760166bc763ba5fb111c0a8", "url": "https://github.com/MegaMek/megamek/commit/8757348ef4e409fd3760166bc763ba5fb111c0a8", "message": "use built-in function", "committedDate": "2020-03-21T02:59:10Z", "type": "commit"}, {"oid": "c3e7ad24224dcaa1cf32cb632e41c39b80e5b262", "url": "https://github.com/MegaMek/megamek/commit/c3e7ad24224dcaa1cf32cb632e41c39b80e5b262", "message": "offboard nukes part I", "committedDate": "2020-03-24T16:12:13Z", "type": "commit"}, {"oid": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "url": "https://github.com/MegaMek/megamek/commit/bb3689b088120e2d2cae6ff13826b7cc481e4455", "message": "handle off-board nuclear fire", "committedDate": "2020-03-26T02:18:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDU4Mw==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604583", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(selectedArtilleryWeapon == null ) {\n          \n          \n            \n                    if(selectedArtilleryWeapon == null) {", "author": "sixlettervariables", "createdAt": "2020-03-28T01:52:31Z", "path": "megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*  \n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \n+*  \n+* This program is free software; you can redistribute it and/or modify it under  \n+* the terms of the GNU General Public License as published by the Free Software  \n+* Foundation; either version 2 of the License, or (at your option) any later  \n+* version.  \n+*  \n+* This program is distributed in the hope that it will be useful, but WITHOUT  \n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \n+* details.  \n+*/  \n+\n+package megamek.client.ui.swing;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.swing.JOptionPane;\n+\n+import megamek.client.ui.IDisplayable;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.SharedUtility;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.common.AmmoType;\n+import megamek.common.Compute;\n+import megamek.common.Configuration;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.HexTarget;\n+import megamek.common.IGame;\n+import megamek.common.actions.ArtilleryAttackAction;\n+import megamek.common.actions.WeaponAttackAction;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.MegaMekFile;\n+import megamek.common.IPlayer;\n+import megamek.common.Mounted;\n+import megamek.common.OffBoardDirection;\n+import megamek.common.Targetable;\n+\n+/**\n+ * This class handles the display and logic for the off board targeting overlay.\n+ *\n+ */\n+public class OffBoardTargetOverlay implements IDisplayable {\n+    private static final int EDGE_OFFSET = 5;\n+    private static final int WIDE_EDGE_SIZE = 60;\n+    private static final int NARROW_EDGE_SIZE = 40;\n+    private static final String FILENAME_OFFBOARD_TARGET_IMAGE = \"OffBoardTarget.png\";\n+    \n+    private boolean isHit = false;\n+    private ClientGUI clientgui;\n+    private Map<OffBoardDirection, Rectangle> buttons = new HashMap<>();\n+    private TargetingPhaseDisplay targetingPhaseDisplay;\n+    private Image offBoardTargetImage;\n+    \n+    private IGame getCurrentGame() {\n+        return clientgui.getClient().getGame();\n+    }\n+    \n+    private IPlayer getCurrentPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    /**\n+     * Sets a reference to a TargetingPhaseDisplay. Used to communicate a generated attack to it.\n+     */\n+    public void setTargetingPhaseDisplay(TargetingPhaseDisplay tpd) {\n+        targetingPhaseDisplay = tpd;\n+    }    \n+    \n+    public OffBoardTargetOverlay(ClientGUI clientgui) {\n+        this.clientgui = clientgui;\n+        \n+        offBoardTargetImage = ImageUtil.loadImageFromFile(\n+                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_OFFBOARD_TARGET_IMAGE)\n+                        .toString());\n+        \n+        //Maybe TODO: display dimmed version of off-board icon during movement phase OR targeting phase when weapon is ineligible to fire \n+        //Maybe TODO: maybe tooltips?\n+    }\n+    \n+    /**\n+     * Logic that determines if this overlay should be visible.\n+     */\n+    private boolean shouldBeVisible() {\n+        // only relevant if it's our turn in the targeting phase\n+        boolean visible = clientgui.getClient().isMyTurn() &&\n+                (getCurrentGame().getPhase() == IGame.Phase.PHASE_TARGETING);\n+        \n+        if(!visible) {\n+            return false;\n+        }\n+        \n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // only relevant if we've got an artillery weapon selected for one of our own units\n+        if(selectedArtilleryWeapon == null ) {", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "chunk": "diff --git a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\nindex b10a052dee..56b2e7af4c 100644\n--- a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n+++ b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n\n@@ -104,7 +104,7 @@ public class OffBoardTargetOverlay implements IDisplayable {\n         Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n         \n         // only relevant if we've got an artillery weapon selected for one of our own units\n-        if(selectedArtilleryWeapon == null ) {\n+        if(selectedArtilleryWeapon == null) {\n             return false;\n         }\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDYzMg==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604632", "bodyText": "Do we have constants/statics for these modes?", "author": "sixlettervariables", "createdAt": "2020-03-28T01:52:56Z", "path": "megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*  \n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \n+*  \n+* This program is free software; you can redistribute it and/or modify it under  \n+* the terms of the GNU General Public License as published by the Free Software  \n+* Foundation; either version 2 of the License, or (at your option) any later  \n+* version.  \n+*  \n+* This program is distributed in the hope that it will be useful, but WITHOUT  \n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \n+* details.  \n+*/  \n+\n+package megamek.client.ui.swing;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.swing.JOptionPane;\n+\n+import megamek.client.ui.IDisplayable;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.SharedUtility;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.common.AmmoType;\n+import megamek.common.Compute;\n+import megamek.common.Configuration;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.HexTarget;\n+import megamek.common.IGame;\n+import megamek.common.actions.ArtilleryAttackAction;\n+import megamek.common.actions.WeaponAttackAction;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.MegaMekFile;\n+import megamek.common.IPlayer;\n+import megamek.common.Mounted;\n+import megamek.common.OffBoardDirection;\n+import megamek.common.Targetable;\n+\n+/**\n+ * This class handles the display and logic for the off board targeting overlay.\n+ *\n+ */\n+public class OffBoardTargetOverlay implements IDisplayable {\n+    private static final int EDGE_OFFSET = 5;\n+    private static final int WIDE_EDGE_SIZE = 60;\n+    private static final int NARROW_EDGE_SIZE = 40;\n+    private static final String FILENAME_OFFBOARD_TARGET_IMAGE = \"OffBoardTarget.png\";\n+    \n+    private boolean isHit = false;\n+    private ClientGUI clientgui;\n+    private Map<OffBoardDirection, Rectangle> buttons = new HashMap<>();\n+    private TargetingPhaseDisplay targetingPhaseDisplay;\n+    private Image offBoardTargetImage;\n+    \n+    private IGame getCurrentGame() {\n+        return clientgui.getClient().getGame();\n+    }\n+    \n+    private IPlayer getCurrentPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    /**\n+     * Sets a reference to a TargetingPhaseDisplay. Used to communicate a generated attack to it.\n+     */\n+    public void setTargetingPhaseDisplay(TargetingPhaseDisplay tpd) {\n+        targetingPhaseDisplay = tpd;\n+    }    \n+    \n+    public OffBoardTargetOverlay(ClientGUI clientgui) {\n+        this.clientgui = clientgui;\n+        \n+        offBoardTargetImage = ImageUtil.loadImageFromFile(\n+                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_OFFBOARD_TARGET_IMAGE)\n+                        .toString());\n+        \n+        //Maybe TODO: display dimmed version of off-board icon during movement phase OR targeting phase when weapon is ineligible to fire \n+        //Maybe TODO: maybe tooltips?\n+    }\n+    \n+    /**\n+     * Logic that determines if this overlay should be visible.\n+     */\n+    private boolean shouldBeVisible() {\n+        // only relevant if it's our turn in the targeting phase\n+        boolean visible = clientgui.getClient().isMyTurn() &&\n+                (getCurrentGame().getPhase() == IGame.Phase.PHASE_TARGETING);\n+        \n+        if(!visible) {\n+            return false;\n+        }\n+        \n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // only relevant if we've got an artillery weapon selected for one of our own units\n+        if(selectedArtilleryWeapon == null ) {\n+            return false;\n+        }\n+        \n+        // the artillery weapon needs to be using non-homing ammo\n+        Mounted ammo = selectedArtilleryWeapon.getLinked();\n+        AmmoType ammoType = (AmmoType) ammo.getType();\n+        if((ammoType.getMunitionType() == AmmoType.M_HOMING) \n+                && ammo.curMode().equals(\"Homing\")) {", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNTAxMA==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399615010", "bodyText": "Not at this time. There are quite a few places where this comparison is made, so I think I'm going to hold off on it for this PR, for the sake of minimizing its impact.", "author": "NickAragua", "createdAt": "2020-03-28T03:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDYzMg=="}], "type": "inlineReview", "revised_code": {"commit": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "chunk": "diff --git a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\nindex b10a052dee..56b2e7af4c 100644\n--- a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n+++ b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n\n@@ -104,7 +104,7 @@ public class OffBoardTargetOverlay implements IDisplayable {\n         Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n         \n         // only relevant if we've got an artillery weapon selected for one of our own units\n-        if(selectedArtilleryWeapon == null ) {\n+        if(selectedArtilleryWeapon == null) {\n             return false;\n         }\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDcyMA==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604720", "bodyText": "If buttons will never contain OffBoardDirection.None you can probably omit this if test.", "author": "sixlettervariables", "createdAt": "2020-03-28T01:53:46Z", "path": "megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*  \n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \n+*  \n+* This program is free software; you can redistribute it and/or modify it under  \n+* the terms of the GNU General Public License as published by the Free Software  \n+* Foundation; either version 2 of the License, or (at your option) any later  \n+* version.  \n+*  \n+* This program is distributed in the hope that it will be useful, but WITHOUT  \n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \n+* details.  \n+*/  \n+\n+package megamek.client.ui.swing;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.swing.JOptionPane;\n+\n+import megamek.client.ui.IDisplayable;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.SharedUtility;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.common.AmmoType;\n+import megamek.common.Compute;\n+import megamek.common.Configuration;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.HexTarget;\n+import megamek.common.IGame;\n+import megamek.common.actions.ArtilleryAttackAction;\n+import megamek.common.actions.WeaponAttackAction;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.MegaMekFile;\n+import megamek.common.IPlayer;\n+import megamek.common.Mounted;\n+import megamek.common.OffBoardDirection;\n+import megamek.common.Targetable;\n+\n+/**\n+ * This class handles the display and logic for the off board targeting overlay.\n+ *\n+ */\n+public class OffBoardTargetOverlay implements IDisplayable {\n+    private static final int EDGE_OFFSET = 5;\n+    private static final int WIDE_EDGE_SIZE = 60;\n+    private static final int NARROW_EDGE_SIZE = 40;\n+    private static final String FILENAME_OFFBOARD_TARGET_IMAGE = \"OffBoardTarget.png\";\n+    \n+    private boolean isHit = false;\n+    private ClientGUI clientgui;\n+    private Map<OffBoardDirection, Rectangle> buttons = new HashMap<>();\n+    private TargetingPhaseDisplay targetingPhaseDisplay;\n+    private Image offBoardTargetImage;\n+    \n+    private IGame getCurrentGame() {\n+        return clientgui.getClient().getGame();\n+    }\n+    \n+    private IPlayer getCurrentPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    /**\n+     * Sets a reference to a TargetingPhaseDisplay. Used to communicate a generated attack to it.\n+     */\n+    public void setTargetingPhaseDisplay(TargetingPhaseDisplay tpd) {\n+        targetingPhaseDisplay = tpd;\n+    }    \n+    \n+    public OffBoardTargetOverlay(ClientGUI clientgui) {\n+        this.clientgui = clientgui;\n+        \n+        offBoardTargetImage = ImageUtil.loadImageFromFile(\n+                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_OFFBOARD_TARGET_IMAGE)\n+                        .toString());\n+        \n+        //Maybe TODO: display dimmed version of off-board icon during movement phase OR targeting phase when weapon is ineligible to fire \n+        //Maybe TODO: maybe tooltips?\n+    }\n+    \n+    /**\n+     * Logic that determines if this overlay should be visible.\n+     */\n+    private boolean shouldBeVisible() {\n+        // only relevant if it's our turn in the targeting phase\n+        boolean visible = clientgui.getClient().isMyTurn() &&\n+                (getCurrentGame().getPhase() == IGame.Phase.PHASE_TARGETING);\n+        \n+        if(!visible) {\n+            return false;\n+        }\n+        \n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // only relevant if we've got an artillery weapon selected for one of our own units\n+        if(selectedArtilleryWeapon == null ) {\n+            return false;\n+        }\n+        \n+        // the artillery weapon needs to be using non-homing ammo\n+        Mounted ammo = selectedArtilleryWeapon.getLinked();\n+        AmmoType ammoType = (AmmoType) ammo.getType();\n+        if((ammoType.getMunitionType() == AmmoType.M_HOMING) \n+                && ammo.curMode().equals(\"Homing\")) {\n+            return false;\n+        }\n+        \n+        // only show these if there are any actual enemy units eligible for off board targeting\n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE && showDirectionalElement(direction, selectedArtilleryWeapon)) {\n+                return true; \n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Logic that determines whether to show a specific directional indicator\n+     */\n+    private boolean showDirectionalElement(OffBoardDirection direction, Mounted selectedArtilleryWeapon) {\n+        for(Entity entity : getCurrentGame().getAllOffboardEnemyEntities(getCurrentPlayer())) {\n+            if(entity.isOffBoardObserved(getCurrentPlayer().getTeam()) && \n+                    (entity.getOffBoardDirection() == direction) &&\n+                        (targetingPhaseDisplay.ce().isOffBoard() ||\n+                        weaponFacingInDirection(selectedArtilleryWeapon, direction))) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Worker function that determines if the given weapon is facing in the correct off-board direction.\n+     */\n+    private boolean weaponFacingInDirection(Mounted artilleryWeapon, OffBoardDirection direction) {\n+        Coords checkCoords = artilleryWeapon.getEntity().getPosition();\n+        int translationDistance;\n+        \n+        // little hack: we project a point 10 hexes off board to the north/south/east/west and declare a hex target with it\n+        // then use Compute.isInArc, as that takes into account all the logic including torso/turret twists.\n+        switch(direction) {\n+        case NORTH:\n+            checkCoords = checkCoords.translated(0, checkCoords.getY() + 10);\n+            break;\n+        case SOUTH:\n+            checkCoords = checkCoords.translated(3, getCurrentGame().getBoard().getHeight() - checkCoords.getY() + 10);\n+            break;\n+        case EAST:\n+            translationDistance = ((getCurrentGame().getBoard().getWidth() - checkCoords.getX()) / 2) + 5;\n+            checkCoords = checkCoords.translated(1, translationDistance).translated(2, translationDistance);\n+            break;\n+        case WEST:\n+            translationDistance = checkCoords.getX() + 5;\n+            checkCoords = checkCoords.translated(4, translationDistance).translated(5, translationDistance);\n+            break;\n+        default:\n+            return false;\n+        }\n+        \n+        Targetable checkTarget = new HexTarget(checkCoords, Targetable.TYPE_HEX_ARTILLERY);\n+        \n+        return Compute.isInArc(getCurrentGame(), artilleryWeapon.getEntity().getId(), \n+                artilleryWeapon.getEntity().getEquipmentNum(artilleryWeapon), checkTarget);\n+    }\n+    \n+    @Override\n+    public boolean isBeingDragged() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDragged(Point point, Dimension backSize) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isHit(Point point, Dimension size) {\n+        Point actualPoint = point;\n+        actualPoint.x = (int) (point.getX() + clientgui.getBoardView().getDisplayablesRect().getX());\n+        actualPoint.y = (int) (point.getY() + clientgui.getBoardView().getDisplayablesRect().getY());\n+        \n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE) {", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "chunk": "diff --git a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\nindex b10a052dee..56b2e7af4c 100644\n--- a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n+++ b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n\n@@ -104,7 +104,7 @@ public class OffBoardTargetOverlay implements IDisplayable {\n         Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n         \n         // only relevant if we've got an artillery weapon selected for one of our own units\n-        if(selectedArtilleryWeapon == null ) {\n+        if(selectedArtilleryWeapon == null) {\n             return false;\n         }\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDg0Mg==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604842", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /// east rectangle is narrower than wider, and at the right of the board view, but to the left of the unit overview panel\n          \n          \n            \n                    // east rectangle is narrower than wider, and at the right of the board view, but to the left of the unit overview panel", "author": "sixlettervariables", "createdAt": "2020-03-28T01:54:49Z", "path": "megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*  \n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \n+*  \n+* This program is free software; you can redistribute it and/or modify it under  \n+* the terms of the GNU General Public License as published by the Free Software  \n+* Foundation; either version 2 of the License, or (at your option) any later  \n+* version.  \n+*  \n+* This program is distributed in the hope that it will be useful, but WITHOUT  \n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \n+* details.  \n+*/  \n+\n+package megamek.client.ui.swing;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.swing.JOptionPane;\n+\n+import megamek.client.ui.IDisplayable;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.SharedUtility;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.common.AmmoType;\n+import megamek.common.Compute;\n+import megamek.common.Configuration;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.HexTarget;\n+import megamek.common.IGame;\n+import megamek.common.actions.ArtilleryAttackAction;\n+import megamek.common.actions.WeaponAttackAction;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.MegaMekFile;\n+import megamek.common.IPlayer;\n+import megamek.common.Mounted;\n+import megamek.common.OffBoardDirection;\n+import megamek.common.Targetable;\n+\n+/**\n+ * This class handles the display and logic for the off board targeting overlay.\n+ *\n+ */\n+public class OffBoardTargetOverlay implements IDisplayable {\n+    private static final int EDGE_OFFSET = 5;\n+    private static final int WIDE_EDGE_SIZE = 60;\n+    private static final int NARROW_EDGE_SIZE = 40;\n+    private static final String FILENAME_OFFBOARD_TARGET_IMAGE = \"OffBoardTarget.png\";\n+    \n+    private boolean isHit = false;\n+    private ClientGUI clientgui;\n+    private Map<OffBoardDirection, Rectangle> buttons = new HashMap<>();\n+    private TargetingPhaseDisplay targetingPhaseDisplay;\n+    private Image offBoardTargetImage;\n+    \n+    private IGame getCurrentGame() {\n+        return clientgui.getClient().getGame();\n+    }\n+    \n+    private IPlayer getCurrentPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    /**\n+     * Sets a reference to a TargetingPhaseDisplay. Used to communicate a generated attack to it.\n+     */\n+    public void setTargetingPhaseDisplay(TargetingPhaseDisplay tpd) {\n+        targetingPhaseDisplay = tpd;\n+    }    \n+    \n+    public OffBoardTargetOverlay(ClientGUI clientgui) {\n+        this.clientgui = clientgui;\n+        \n+        offBoardTargetImage = ImageUtil.loadImageFromFile(\n+                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_OFFBOARD_TARGET_IMAGE)\n+                        .toString());\n+        \n+        //Maybe TODO: display dimmed version of off-board icon during movement phase OR targeting phase when weapon is ineligible to fire \n+        //Maybe TODO: maybe tooltips?\n+    }\n+    \n+    /**\n+     * Logic that determines if this overlay should be visible.\n+     */\n+    private boolean shouldBeVisible() {\n+        // only relevant if it's our turn in the targeting phase\n+        boolean visible = clientgui.getClient().isMyTurn() &&\n+                (getCurrentGame().getPhase() == IGame.Phase.PHASE_TARGETING);\n+        \n+        if(!visible) {\n+            return false;\n+        }\n+        \n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // only relevant if we've got an artillery weapon selected for one of our own units\n+        if(selectedArtilleryWeapon == null ) {\n+            return false;\n+        }\n+        \n+        // the artillery weapon needs to be using non-homing ammo\n+        Mounted ammo = selectedArtilleryWeapon.getLinked();\n+        AmmoType ammoType = (AmmoType) ammo.getType();\n+        if((ammoType.getMunitionType() == AmmoType.M_HOMING) \n+                && ammo.curMode().equals(\"Homing\")) {\n+            return false;\n+        }\n+        \n+        // only show these if there are any actual enemy units eligible for off board targeting\n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE && showDirectionalElement(direction, selectedArtilleryWeapon)) {\n+                return true; \n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Logic that determines whether to show a specific directional indicator\n+     */\n+    private boolean showDirectionalElement(OffBoardDirection direction, Mounted selectedArtilleryWeapon) {\n+        for(Entity entity : getCurrentGame().getAllOffboardEnemyEntities(getCurrentPlayer())) {\n+            if(entity.isOffBoardObserved(getCurrentPlayer().getTeam()) && \n+                    (entity.getOffBoardDirection() == direction) &&\n+                        (targetingPhaseDisplay.ce().isOffBoard() ||\n+                        weaponFacingInDirection(selectedArtilleryWeapon, direction))) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Worker function that determines if the given weapon is facing in the correct off-board direction.\n+     */\n+    private boolean weaponFacingInDirection(Mounted artilleryWeapon, OffBoardDirection direction) {\n+        Coords checkCoords = artilleryWeapon.getEntity().getPosition();\n+        int translationDistance;\n+        \n+        // little hack: we project a point 10 hexes off board to the north/south/east/west and declare a hex target with it\n+        // then use Compute.isInArc, as that takes into account all the logic including torso/turret twists.\n+        switch(direction) {\n+        case NORTH:\n+            checkCoords = checkCoords.translated(0, checkCoords.getY() + 10);\n+            break;\n+        case SOUTH:\n+            checkCoords = checkCoords.translated(3, getCurrentGame().getBoard().getHeight() - checkCoords.getY() + 10);\n+            break;\n+        case EAST:\n+            translationDistance = ((getCurrentGame().getBoard().getWidth() - checkCoords.getX()) / 2) + 5;\n+            checkCoords = checkCoords.translated(1, translationDistance).translated(2, translationDistance);\n+            break;\n+        case WEST:\n+            translationDistance = checkCoords.getX() + 5;\n+            checkCoords = checkCoords.translated(4, translationDistance).translated(5, translationDistance);\n+            break;\n+        default:\n+            return false;\n+        }\n+        \n+        Targetable checkTarget = new HexTarget(checkCoords, Targetable.TYPE_HEX_ARTILLERY);\n+        \n+        return Compute.isInArc(getCurrentGame(), artilleryWeapon.getEntity().getId(), \n+                artilleryWeapon.getEntity().getEquipmentNum(artilleryWeapon), checkTarget);\n+    }\n+    \n+    @Override\n+    public boolean isBeingDragged() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDragged(Point point, Dimension backSize) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isHit(Point point, Dimension size) {\n+        Point actualPoint = point;\n+        actualPoint.x = (int) (point.getX() + clientgui.getBoardView().getDisplayablesRect().getX());\n+        actualPoint.y = (int) (point.getY() + clientgui.getBoardView().getDisplayablesRect().getY());\n+        \n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE) {\n+                if(buttons.containsKey(direction) &&\n+                        buttons.get(direction).contains(point)) {\n+                    isHit = true;\n+                    handleButtonClick(direction);\n+                    return true;\n+                }\n+            }\n+        }\n+                \n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isMouseOver(Point point, Dimension backSize) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        if (!shouldBeVisible()) {\n+            return false;\n+        }\n+\n+        if (isHit) {\n+            isHit = false;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void draw(Graphics graph, Rectangle rect) {\n+        if(!shouldBeVisible()) {\n+            return;\n+        }\n+        \n+        Rectangle button;\n+        buttons.clear();\n+        \n+        Color push = graph.getColor();\n+        graph.setColor(GUIPreferences.getInstance().getColor(GUIPreferences.ADVANCED_UNITOVERVIEW_VALID_COLOR));\n+        \n+        // each of these draws the relevant icon and stores the coordinates for retrieval when checking hit box\n+        // pre-store the selected artillery weapon as it carries out a bunch of computations\n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // draw top icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.NORTH, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.NORTH, rect);\n+            buttons.put(OffBoardDirection.NORTH, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw left icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.WEST, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.WEST, rect);\n+            buttons.put(OffBoardDirection.WEST, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw bottom icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.SOUTH, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.SOUTH, rect);\n+            buttons.put(OffBoardDirection.SOUTH, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw right icon, if necessary. This one is hairy because of the unit overview pane\n+        if(showDirectionalElement(OffBoardDirection.EAST, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.EAST, rect);\n+            buttons.put(OffBoardDirection.EAST, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // be nice, leave the color as we found it\n+        graph.setColor(push);\n+    }\n+    \n+    /**\n+     * Worker function that generates a rectangle that can be drawn on screen\n+     * or evaluated for hit detection.\n+     */\n+    private Rectangle generateRectangle(OffBoardDirection direction, Rectangle boundingRectangle) {\n+        int xPosition;\n+        int yPosition;        \n+        \n+        switch(direction) {\n+        // north rectangle is wider than narrower, and at the top of the board view\n+        case NORTH:\n+            xPosition = boundingRectangle.x + (int) (boundingRectangle.width / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            yPosition = boundingRectangle.y + EDGE_OFFSET;\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE);\n+        // west rectangle is narrower than wider, and at the left of the board view\n+        case WEST:\n+            xPosition = boundingRectangle.x + EDGE_OFFSET;\n+            yPosition = boundingRectangle.y + (int) (boundingRectangle.height / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE); // used to be NARROW_EDGE_SIZE, WIDE_EDGE_SIZE);\n+        // south rectangle is wider than narrower, and at the bottom of the board view\n+        case SOUTH:\n+            xPosition = boundingRectangle.x + (int) (boundingRectangle.width / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            yPosition = boundingRectangle.y + boundingRectangle.height - EDGE_OFFSET - NARROW_EDGE_SIZE;\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE);\n+        /// east rectangle is narrower than wider, and at the right of the board view, but to the left of the unit overview panel", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "chunk": "diff --git a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\nindex b10a052dee..56b2e7af4c 100644\n--- a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n+++ b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n\n@@ -104,7 +104,7 @@ public class OffBoardTargetOverlay implements IDisplayable {\n         Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n         \n         // only relevant if we've got an artillery weapon selected for one of our own units\n-        if(selectedArtilleryWeapon == null ) {\n+        if(selectedArtilleryWeapon == null) {\n             return false;\n         }\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDg3MQ==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604871", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Possible shows a target selection popup\n          \n          \n            \n                 * Possibly shows a target selection popup", "author": "sixlettervariables", "createdAt": "2020-03-28T01:55:09Z", "path": "megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*  \n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \n+*  \n+* This program is free software; you can redistribute it and/or modify it under  \n+* the terms of the GNU General Public License as published by the Free Software  \n+* Foundation; either version 2 of the License, or (at your option) any later  \n+* version.  \n+*  \n+* This program is distributed in the hope that it will be useful, but WITHOUT  \n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \n+* details.  \n+*/  \n+\n+package megamek.client.ui.swing;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.swing.JOptionPane;\n+\n+import megamek.client.ui.IDisplayable;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.SharedUtility;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.common.AmmoType;\n+import megamek.common.Compute;\n+import megamek.common.Configuration;\n+import megamek.common.Coords;\n+import megamek.common.Entity;\n+import megamek.common.HexTarget;\n+import megamek.common.IGame;\n+import megamek.common.actions.ArtilleryAttackAction;\n+import megamek.common.actions.WeaponAttackAction;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.MegaMekFile;\n+import megamek.common.IPlayer;\n+import megamek.common.Mounted;\n+import megamek.common.OffBoardDirection;\n+import megamek.common.Targetable;\n+\n+/**\n+ * This class handles the display and logic for the off board targeting overlay.\n+ *\n+ */\n+public class OffBoardTargetOverlay implements IDisplayable {\n+    private static final int EDGE_OFFSET = 5;\n+    private static final int WIDE_EDGE_SIZE = 60;\n+    private static final int NARROW_EDGE_SIZE = 40;\n+    private static final String FILENAME_OFFBOARD_TARGET_IMAGE = \"OffBoardTarget.png\";\n+    \n+    private boolean isHit = false;\n+    private ClientGUI clientgui;\n+    private Map<OffBoardDirection, Rectangle> buttons = new HashMap<>();\n+    private TargetingPhaseDisplay targetingPhaseDisplay;\n+    private Image offBoardTargetImage;\n+    \n+    private IGame getCurrentGame() {\n+        return clientgui.getClient().getGame();\n+    }\n+    \n+    private IPlayer getCurrentPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    /**\n+     * Sets a reference to a TargetingPhaseDisplay. Used to communicate a generated attack to it.\n+     */\n+    public void setTargetingPhaseDisplay(TargetingPhaseDisplay tpd) {\n+        targetingPhaseDisplay = tpd;\n+    }    \n+    \n+    public OffBoardTargetOverlay(ClientGUI clientgui) {\n+        this.clientgui = clientgui;\n+        \n+        offBoardTargetImage = ImageUtil.loadImageFromFile(\n+                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_OFFBOARD_TARGET_IMAGE)\n+                        .toString());\n+        \n+        //Maybe TODO: display dimmed version of off-board icon during movement phase OR targeting phase when weapon is ineligible to fire \n+        //Maybe TODO: maybe tooltips?\n+    }\n+    \n+    /**\n+     * Logic that determines if this overlay should be visible.\n+     */\n+    private boolean shouldBeVisible() {\n+        // only relevant if it's our turn in the targeting phase\n+        boolean visible = clientgui.getClient().isMyTurn() &&\n+                (getCurrentGame().getPhase() == IGame.Phase.PHASE_TARGETING);\n+        \n+        if(!visible) {\n+            return false;\n+        }\n+        \n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // only relevant if we've got an artillery weapon selected for one of our own units\n+        if(selectedArtilleryWeapon == null ) {\n+            return false;\n+        }\n+        \n+        // the artillery weapon needs to be using non-homing ammo\n+        Mounted ammo = selectedArtilleryWeapon.getLinked();\n+        AmmoType ammoType = (AmmoType) ammo.getType();\n+        if((ammoType.getMunitionType() == AmmoType.M_HOMING) \n+                && ammo.curMode().equals(\"Homing\")) {\n+            return false;\n+        }\n+        \n+        // only show these if there are any actual enemy units eligible for off board targeting\n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE && showDirectionalElement(direction, selectedArtilleryWeapon)) {\n+                return true; \n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Logic that determines whether to show a specific directional indicator\n+     */\n+    private boolean showDirectionalElement(OffBoardDirection direction, Mounted selectedArtilleryWeapon) {\n+        for(Entity entity : getCurrentGame().getAllOffboardEnemyEntities(getCurrentPlayer())) {\n+            if(entity.isOffBoardObserved(getCurrentPlayer().getTeam()) && \n+                    (entity.getOffBoardDirection() == direction) &&\n+                        (targetingPhaseDisplay.ce().isOffBoard() ||\n+                        weaponFacingInDirection(selectedArtilleryWeapon, direction))) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Worker function that determines if the given weapon is facing in the correct off-board direction.\n+     */\n+    private boolean weaponFacingInDirection(Mounted artilleryWeapon, OffBoardDirection direction) {\n+        Coords checkCoords = artilleryWeapon.getEntity().getPosition();\n+        int translationDistance;\n+        \n+        // little hack: we project a point 10 hexes off board to the north/south/east/west and declare a hex target with it\n+        // then use Compute.isInArc, as that takes into account all the logic including torso/turret twists.\n+        switch(direction) {\n+        case NORTH:\n+            checkCoords = checkCoords.translated(0, checkCoords.getY() + 10);\n+            break;\n+        case SOUTH:\n+            checkCoords = checkCoords.translated(3, getCurrentGame().getBoard().getHeight() - checkCoords.getY() + 10);\n+            break;\n+        case EAST:\n+            translationDistance = ((getCurrentGame().getBoard().getWidth() - checkCoords.getX()) / 2) + 5;\n+            checkCoords = checkCoords.translated(1, translationDistance).translated(2, translationDistance);\n+            break;\n+        case WEST:\n+            translationDistance = checkCoords.getX() + 5;\n+            checkCoords = checkCoords.translated(4, translationDistance).translated(5, translationDistance);\n+            break;\n+        default:\n+            return false;\n+        }\n+        \n+        Targetable checkTarget = new HexTarget(checkCoords, Targetable.TYPE_HEX_ARTILLERY);\n+        \n+        return Compute.isInArc(getCurrentGame(), artilleryWeapon.getEntity().getId(), \n+                artilleryWeapon.getEntity().getEquipmentNum(artilleryWeapon), checkTarget);\n+    }\n+    \n+    @Override\n+    public boolean isBeingDragged() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDragged(Point point, Dimension backSize) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isHit(Point point, Dimension size) {\n+        Point actualPoint = point;\n+        actualPoint.x = (int) (point.getX() + clientgui.getBoardView().getDisplayablesRect().getX());\n+        actualPoint.y = (int) (point.getY() + clientgui.getBoardView().getDisplayablesRect().getY());\n+        \n+        for(OffBoardDirection direction : OffBoardDirection.values()) {\n+            if(direction != OffBoardDirection.NONE) {\n+                if(buttons.containsKey(direction) &&\n+                        buttons.get(direction).contains(point)) {\n+                    isHit = true;\n+                    handleButtonClick(direction);\n+                    return true;\n+                }\n+            }\n+        }\n+                \n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isMouseOver(Point point, Dimension backSize) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isReleased() {\n+        if (!shouldBeVisible()) {\n+            return false;\n+        }\n+\n+        if (isHit) {\n+            isHit = false;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void draw(Graphics graph, Rectangle rect) {\n+        if(!shouldBeVisible()) {\n+            return;\n+        }\n+        \n+        Rectangle button;\n+        buttons.clear();\n+        \n+        Color push = graph.getColor();\n+        graph.setColor(GUIPreferences.getInstance().getColor(GUIPreferences.ADVANCED_UNITOVERVIEW_VALID_COLOR));\n+        \n+        // each of these draws the relevant icon and stores the coordinates for retrieval when checking hit box\n+        // pre-store the selected artillery weapon as it carries out a bunch of computations\n+        Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n+        \n+        // draw top icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.NORTH, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.NORTH, rect);\n+            buttons.put(OffBoardDirection.NORTH, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw left icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.WEST, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.WEST, rect);\n+            buttons.put(OffBoardDirection.WEST, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw bottom icon, if necessary\n+        if(showDirectionalElement(OffBoardDirection.SOUTH, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.SOUTH, rect);\n+            buttons.put(OffBoardDirection.SOUTH, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // draw right icon, if necessary. This one is hairy because of the unit overview pane\n+        if(showDirectionalElement(OffBoardDirection.EAST, selectedArtilleryWeapon)) {\n+            button = generateRectangle(OffBoardDirection.EAST, rect);\n+            buttons.put(OffBoardDirection.EAST, button);\n+            graph.drawImage(offBoardTargetImage, button.x, button.y, button.width, button.height, (BoardView1) clientgui.getBoardView());\n+        }\n+        \n+        // be nice, leave the color as we found it\n+        graph.setColor(push);\n+    }\n+    \n+    /**\n+     * Worker function that generates a rectangle that can be drawn on screen\n+     * or evaluated for hit detection.\n+     */\n+    private Rectangle generateRectangle(OffBoardDirection direction, Rectangle boundingRectangle) {\n+        int xPosition;\n+        int yPosition;        \n+        \n+        switch(direction) {\n+        // north rectangle is wider than narrower, and at the top of the board view\n+        case NORTH:\n+            xPosition = boundingRectangle.x + (int) (boundingRectangle.width / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            yPosition = boundingRectangle.y + EDGE_OFFSET;\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE);\n+        // west rectangle is narrower than wider, and at the left of the board view\n+        case WEST:\n+            xPosition = boundingRectangle.x + EDGE_OFFSET;\n+            yPosition = boundingRectangle.y + (int) (boundingRectangle.height / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE); // used to be NARROW_EDGE_SIZE, WIDE_EDGE_SIZE);\n+        // south rectangle is wider than narrower, and at the bottom of the board view\n+        case SOUTH:\n+            xPosition = boundingRectangle.x + (int) (boundingRectangle.width / 2) - (int) (WIDE_EDGE_SIZE / 2);\n+            yPosition = boundingRectangle.y + boundingRectangle.height - EDGE_OFFSET - NARROW_EDGE_SIZE;\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE);\n+        /// east rectangle is narrower than wider, and at the right of the board view, but to the left of the unit overview panel\n+        case EAST:\n+            int extraXOffset = GUIPreferences.getInstance().getShowUnitOverview() ? UnitOverview.getUIWidth() : 0;\n+            xPosition = boundingRectangle.x + boundingRectangle.width - WIDE_EDGE_SIZE - EDGE_OFFSET - extraXOffset;\n+            yPosition = boundingRectangle.y + (int) (boundingRectangle.height / 2) - (int) (NARROW_EDGE_SIZE / 2);\n+            return new Rectangle(xPosition, yPosition, WIDE_EDGE_SIZE, NARROW_EDGE_SIZE); // used to be NARROW_EDGE_SIZE, WIDE_EDGE_SIZE);\n+        default:\n+            return null;\n+                \n+        }\n+    }\n+\n+    @Override\n+    public boolean isSliding() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setIdleTime(long l, boolean b) {\n+    }\n+\n+    @Override\n+    public boolean slide() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Worker function that handles a click on a 'counterbattery fire' overlay button.\n+     * Possible shows a target selection popup", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "chunk": "diff --git a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\nindex b10a052dee..56b2e7af4c 100644\n--- a/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n+++ b/megamek/src/megamek/client/ui/swing/OffBoardTargetOverlay.java\n\n@@ -104,7 +104,7 @@ public class OffBoardTargetOverlay implements IDisplayable {\n         Mounted selectedArtilleryWeapon = clientgui.getBoardView().getSelectedArtilleryWeapon();\n         \n         // only relevant if we've got an artillery weapon selected for one of our own units\n-        if(selectedArtilleryWeapon == null ) {\n+        if(selectedArtilleryWeapon == null) {\n             return false;\n         }\n         \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwNDk2OA==", "url": "https://github.com/MegaMek/megamek/pull/1779#discussion_r399604968", "bodyText": "Probably worth a comment explaining how this nukeStats map works.", "author": "sixlettervariables", "createdAt": "2020-03-28T01:56:28Z", "path": "megamek/src/megamek/common/weapons/AreaEffectHelper.java", "diffHunk": "@@ -67,6 +81,46 @@ private static void initializeFuelAirBlastRadiusIndexData() {\n         addFuelAirBlastRadiusIndex(AmmoType.T_LONG_TOM, 3);\n     }\n     \n+    /**\n+     * Worker function that initializes data for NUCLEAR WEAPONS\n+     */\n+    private static void initializeNukeStats() {\n+        nukeStats = new HashMap<>();\n+        \n+        NukeStats nukeEntry = new NukeStats();\n+        nukeEntry.baseDamage = 100;\n+        nukeEntry.degradation = 5;\n+        nukeEntry.secondaryRadius = 40;\n+        nukeEntry.craterDepth = 0;\n+        \n+        nukeStats.put(0, nukeEntry);", "originalCommit": "bb3689b088120e2d2cae6ff13826b7cc481e4455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "url": "https://github.com/MegaMek/megamek/commit/dcf4d0a69d9d1bcb884bd214406241b6031c65bb", "message": "code review changes", "committedDate": "2020-03-28T03:40:55Z", "type": "commit"}, {"oid": "80f6ac4860bb44d90f40bb08a8381fb87b2ed7c8", "url": "https://github.com/MegaMek/megamek/commit/80f6ac4860bb44d90f40bb08a8381fb87b2ed7c8", "message": "homing logic consolidation; reporting bug fix", "committedDate": "2020-03-28T04:46:17Z", "type": "commit"}, {"oid": "395cc8a5cff9c9620ea19cd39613f2b2eaf879c9", "url": "https://github.com/MegaMek/megamek/commit/395cc8a5cff9c9620ea19cd39613f2b2eaf879c9", "message": "don't observe on-board entities", "committedDate": "2020-03-28T04:48:01Z", "type": "commit"}]}