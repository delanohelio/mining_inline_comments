{"pr_number": 2148, "pr_title": "make bot turn calculations more tolerant of threading-related errors fixable by kicking and replacing the bot", "pr_createdAt": "2020-08-14T04:37:06Z", "pr_url": "https://github.com/MegaMek/megamek/pull/2148", "timeline": [{"oid": "b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "url": "https://github.com/MegaMek/megamek/commit/b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "message": "make mode list thread safe", "committedDate": "2020-08-14T04:23:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNzgzMg==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470407832", "bodyText": "Collections.synchronizedList protects the given methods on List from concurrent access, however, they do not protect iteration. So you'd need to use synchronized. Oh and you have to use threadSafeModes everywhere you want to use modes.\nExcept, threadSafeModes isn't being used for all of your mutable uses of modes (add, remove). As it stands, you'd likely be better served by simply wrapping every usage of modes in a synchronized block on modes itself.", "author": "sixlettervariables", "createdAt": "2020-08-14T04:46:56Z", "path": "megamek/src/megamek/common/EquipmentType.java", "diffHunk": "@@ -553,10 +555,16 @@ public boolean hasModeType(String modeType) {\n     \t\treturn false;\n     \t}\n     \t\n-    \tfor(EquipmentMode mode : modes) {\n-    \t\tif(mode.getName().equals(modeType)) {\n-    \t\t\treturn true;\n-    \t\t}\n+    \t// sometimes, the list of modes may be modified while we're looping through it\n+    \t// so let's do this in a thread-safe way\n+    \tList<EquipmentMode> threadSafeModes = Collections.synchronizedList(modes);", "originalCommit": "b97fc285ad53ef51858a889e22c2e5f5eff29ea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQxMDcyMA==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470410720", "bodyText": "Also it looks like modes is a Vector, which already has the same behavior as a synchronizedList. So basically, either addMode or removeMode was called while this was going on. My guess is a network delay or GC pause gave it enough timing to fail.", "author": "sixlettervariables", "createdAt": "2020-08-14T04:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNzgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "a1c78c3ec4d8a2d4314975d1b05b469a600bb26c", "chunk": "diff --git a/megamek/src/megamek/common/EquipmentType.java b/megamek/src/megamek/common/EquipmentType.java\nindex 9f5f0b0f6f..141ebd67e1 100644\n--- a/megamek/src/megamek/common/EquipmentType.java\n+++ b/megamek/src/megamek/common/EquipmentType.java\n\n@@ -555,16 +555,10 @@ public class EquipmentType implements ITechnology {\n     \t\treturn false;\n     \t}\n     \t\n-    \t// sometimes, the list of modes may be modified while we're looping through it\n-    \t// so let's do this in a thread-safe way\n-    \tList<EquipmentMode> threadSafeModes = Collections.synchronizedList(modes);\n-    \t\n-    \tsynchronized(threadSafeModes) {\n-\t    \tfor(EquipmentMode mode : threadSafeModes) {\n-\t    \t\tif(mode.getName().equals(modeType)) {\n-\t    \t\t\treturn true;\n-\t    \t\t}\n-\t    \t}\n+    \tfor(EquipmentMode mode : modes) {\n+    \t\tif(mode.getName().equals(modeType)) {\n+    \t\t\treturn true;\n+    \t\t}\n     \t}\n     \t\n     \treturn false;\n"}}, {"oid": "a1c78c3ec4d8a2d4314975d1b05b469a600bb26c", "url": "https://github.com/MegaMek/megamek/commit/a1c78c3ec4d8a2d4314975d1b05b469a600bb26c", "message": "more general solution to the problem; spheroid dropship movement fix", "committedDate": "2020-08-15T02:32:01Z", "type": "commit"}, {"oid": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "url": "https://github.com/MegaMek/megamek/commit/cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "message": "cleanup", "committedDate": "2020-08-15T02:39:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyODk4OA==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470928988", "bodyText": "Can we refactor the inner try contents into its own method? That would separate the concerns here nicely.", "author": "sixlettervariables", "createdAt": "2020-08-15T02:55:50Z", "path": "megamek/src/megamek/client/bot/BotClient.java", "diffHunk": "@@ -507,57 +510,71 @@ private synchronized void calculateMyTurn() {\n         currentTurnEnemyEntities = null;\n         currentTurnFriendlyEntities = null;\n         \n-        try {\n-            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {\n-                MovePath mp;\n-                if (game.getTurn() instanceof GameTurn.SpecificEntityTurn) {\n-                    GameTurn.SpecificEntityTurn turn = (GameTurn.SpecificEntityTurn) game\n-                            .getTurn();\n-                    Entity mustMove = game.getEntity(turn.getEntityNum());\n-                    mp = continueMovementFor(mustMove);\n-                } else {\n-                    if (config.isForcedIndividual()) {\n-                        Entity mustMove = getRandomUnmovedEntity();\n-                        mp = continueMovementFor(mustMove);\n-                    } else {\n-                        mp = calculateMoveTurn();\n-                    }\n-                }\n-                moveEntity(mp.getEntity().getId(), mp);\n-            } else if (game.getPhase() == IGame.Phase.PHASE_FIRING) {\n-                // TODO: consider that if you're hidden you should hold fire\n-                calculateFiringTurn();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_PHYSICAL) {\n-                PhysicalOption po = calculatePhysicalTurn();\n-                // Bug #1072137: don't crash if the bot can't find a physical.\n-                if (null != po) {\n-                    sendAttackData(po.attacker.getId(), po.getVector());\n-                } else {\n-                    // Send a \"no attack\" to clear the game turn, if any.\n-                    sendAttackData(game.getFirstEntityNum(getMyTurn()),\n-                                   new Vector<>(0));\n-                }\n-            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {\n-                calculateDeployment();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {\n-                Vector<Minefield> mines = calculateMinefieldDeployment();\n-                for (Minefield mine : mines) {\n-                    game.addMinefield(mine);\n-                }\n-                sendDeployMinefields(mines);\n-                sendPlayerInfo();\n-            } else if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {\n-                // For now, declare no autohit hexes.\n-                Vector<Coords> autoHitHexes = calculateArtyAutoHitHexes();\n-                sendArtyAutoHitHexes(autoHitHexes);\n-            } else if ((game.getPhase() == IGame.Phase.PHASE_TARGETING)\n-                       || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)) {\n-                // Send a \"no attack\" to clear the game turn, if any.\n-                // TODO: Fix for real arty stuff\n-                calculateTargetingOffBoardTurn();\n-            }\n-        } catch (Throwable t) {\n-            t.printStackTrace();\n+        int retryCount = 0;\n+        boolean success = false;\n+        \n+        while((retryCount < BOT_TURN_RETRY_COUNT) && !success) {\n+\t        try {\n+\t            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {", "originalCommit": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "chunk": "diff --git a/megamek/src/megamek/client/bot/BotClient.java b/megamek/src/megamek/client/bot/BotClient.java\nindex 49fc106cd0..a7bc3f2f6a 100644\n--- a/megamek/src/megamek/client/bot/BotClient.java\n+++ b/megamek/src/megamek/client/bot/BotClient.java\n\n@@ -504,80 +504,97 @@ public abstract class BotClient extends Client {\n         }\n         return unMoved.get(Compute.randomInt(unMoved.size()));\n     }\n-\n+    \n+    /**\n+     * Calculate what to do on my turn.\n+     * Has a retry mechanism for when the turn calculation fails due to concurrency issues\n+     */\n     private synchronized void calculateMyTurn() {\n-        // clear out transient data\n-        currentTurnEnemyEntities = null;\n-        currentTurnFriendlyEntities = null;\n-        \n-        int retryCount = 0;\n+    \tint retryCount = 0;\n         boolean success = false;\n         \n         while((retryCount < BOT_TURN_RETRY_COUNT) && !success) {\n-\t        try {\n-\t            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {\n-\t                MovePath mp;\n-\t                if (game.getTurn() instanceof GameTurn.SpecificEntityTurn) {\n-\t                    GameTurn.SpecificEntityTurn turn = (GameTurn.SpecificEntityTurn) game\n-\t                            .getTurn();\n-\t                    Entity mustMove = game.getEntity(turn.getEntityNum());\n-\t                    mp = continueMovementFor(mustMove);\n-\t                } else {\n-\t                    if (config.isForcedIndividual()) {\n-\t                        Entity mustMove = getRandomUnmovedEntity();\n-\t                        mp = continueMovementFor(mustMove);\n-\t                    } else {\n-\t                        mp = calculateMoveTurn();\n-\t                    }\n-\t                }\n-\t                moveEntity(mp.getEntity().getId(), mp);\n-\t            } else if (game.getPhase() == IGame.Phase.PHASE_FIRING) {\n-\t                calculateFiringTurn();\n-\t            } else if (game.getPhase() == IGame.Phase.PHASE_PHYSICAL) {\n-\t                PhysicalOption po = calculatePhysicalTurn();\n-\t                // Bug #1072137: don't crash if the bot can't find a physical.\n-\t                if (null != po) {\n-\t                    sendAttackData(po.attacker.getId(), po.getVector());\n-\t                } else {\n-\t                    // Send a \"no attack\" to clear the game turn, if any.\n-\t                    sendAttackData(game.getFirstEntityNum(getMyTurn()),\n-\t                                   new Vector<>(0));\n-\t                }\n-\t            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {\n-\t                calculateDeployment();\n-\t            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {\n-\t                Vector<Minefield> mines = calculateMinefieldDeployment();\n-\t                for (Minefield mine : mines) {\n-\t                    game.addMinefield(mine);\n-\t                }\n-\t                sendDeployMinefields(mines);\n-\t                sendPlayerInfo();\n-\t            } else if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {\n-\t                // For now, declare no autohit hexes.\n-\t                Vector<Coords> autoHitHexes = calculateArtyAutoHitHexes();\n-\t                sendArtyAutoHitHexes(autoHitHexes);\n-\t            } else if ((game.getPhase() == IGame.Phase.PHASE_TARGETING)\n-\t                       || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)) {\n-\t                // Princess implements arty targeting; no plans to do so for testbod\n-\t                calculateTargetingOffBoardTurn();\n-\t            }\n-\t            \n-\t            success = true;\n-\t        } catch (Throwable t) {\n-\t            MegaMek.getLogger().error(this, t.toString());\n-\t            \n-\t            // if we fail, take a nap for 500-1500 milliseconds, then try again\n+        \tsuccess = calculateMyTurnWorker();\n+        \t\n+        \tif(!success) {\n+\t        \t// if we fail, take a nap for 500-1500 milliseconds, then try again\n \t            // as it may be due to some kind of thread-related issue\n+        \t\t// limit number of retries so we're not endlessly spinning\n+        \t\t// if we can't recover from the error\n \t            retryCount++;\n \t            try {\n \t\t\t\t\tThread.sleep(Compute.randomInt(1000) + 500);\n \t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\tMegaMek.getLogger().error(this, t.toString());\n+\t\t\t\t\tMegaMek.getLogger().error(this, e.toString());\n \t\t\t\t}\n \t        }\n         }\n     }\n \n+    /**\n+     * Worker function for a single attempt to calculate the bot's turn.\n+     */\n+    private synchronized boolean calculateMyTurnWorker() {\n+        // clear out transient data\n+        currentTurnEnemyEntities = null;\n+        currentTurnFriendlyEntities = null;\n+        \n+        try {\n+            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {\n+                MovePath mp;\n+                if (game.getTurn() instanceof GameTurn.SpecificEntityTurn) {\n+                    GameTurn.SpecificEntityTurn turn = (GameTurn.SpecificEntityTurn) game\n+                            .getTurn();\n+                    Entity mustMove = game.getEntity(turn.getEntityNum());\n+                    mp = continueMovementFor(mustMove);\n+                } else {\n+                    if (config.isForcedIndividual()) {\n+                        Entity mustMove = getRandomUnmovedEntity();\n+                        mp = continueMovementFor(mustMove);\n+                    } else {\n+                        mp = calculateMoveTurn();\n+                    }\n+                }\n+                moveEntity(mp.getEntity().getId(), mp);\n+            } else if (game.getPhase() == IGame.Phase.PHASE_FIRING) {\n+                calculateFiringTurn();\n+            } else if (game.getPhase() == IGame.Phase.PHASE_PHYSICAL) {\n+                PhysicalOption po = calculatePhysicalTurn();\n+                // Bug #1072137: don't crash if the bot can't find a physical.\n+                if (null != po) {\n+                    sendAttackData(po.attacker.getId(), po.getVector());\n+                } else {\n+                    // Send a \"no attack\" to clear the game turn, if any.\n+                    sendAttackData(game.getFirstEntityNum(getMyTurn()),\n+                                   new Vector<>(0));\n+                }\n+            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOYMENT) {\n+                calculateDeployment();\n+            } else if (game.getPhase() == IGame.Phase.PHASE_DEPLOY_MINEFIELDS) {\n+                Vector<Minefield> mines = calculateMinefieldDeployment();\n+                for (Minefield mine : mines) {\n+                    game.addMinefield(mine);\n+                }\n+                sendDeployMinefields(mines);\n+                sendPlayerInfo();\n+            } else if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {\n+                // For now, declare no autohit hexes.\n+                Vector<Coords> autoHitHexes = calculateArtyAutoHitHexes();\n+                sendArtyAutoHitHexes(autoHitHexes);\n+            } else if ((game.getPhase() == IGame.Phase.PHASE_TARGETING)\n+                       || (game.getPhase() == IGame.Phase.PHASE_OFFBOARD)) {\n+                // Princess implements arty targeting; no plans to do so for testbod\n+                calculateTargetingOffBoardTurn();\n+            }\n+            \n+            return true;\n+        } catch (Throwable t) {\n+            MegaMek.getLogger().error(this, t.toString());\n+            \n+            return false;\n+        }\n+    }\n+\n     public double getMassOfAllInBuilding(final IGame game, final Coords coords) {\n         double mass = 0;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyOTM0Mw==", "url": "https://github.com/MegaMek/megamek/pull/2148#discussion_r470929343", "bodyText": "Same as above.", "author": "sixlettervariables", "createdAt": "2020-08-15T03:00:16Z", "path": "megamek/src/megamek/client/bot/princess/PathEnumerator.java", "diffHunk": "@@ -168,166 +170,173 @@ void updateUnitLocations(Entity entity, List<MovePath> paths) {\n     public void recalculateMovesFor(final Entity mover) {\n         final String METHOD_NAME = \"recalculateMovesFor(IGame, Entity)\";\n         getOwner().methodBegin(getClass(), METHOD_NAME);\n-        try {\n-\n-            // Record it's current position.\n-            getLastKnownLocations().put(\n-                    mover.getId(),\n-                    CoordFacingCombo.createCoordFacingCombo(\n-                            mover.getPosition(), mover.getFacing()));\n-\n-            // Clear out any already calculated paths.\n-            getUnitPaths().remove(mover.getId());\n-            getLongRangePaths().remove(mover.getId());\n-            \n-            // if the entity does not exist in the game for any reason, let's cut out safely\n-            // otherwise, we'll run into problems calculating paths\n-            if (getGame().getEntity(mover.getId()) == null) {\n-                // clean up orphaned entries in local storage\n-                getUnitMovableAreas().remove(mover.getId());\n-                getUnitPotentialLocations().remove(mover.getId());\n-                getLastKnownLocations().remove(mover.getId());\n-                return;\n-            }\n-\n-            // Start constructing the new list of paths.\n-            List<MovePath> paths = new ArrayList<>();\n-            \n-            // Aero movement on atmospheric ground maps\n-            // currently only applies to a) conventional aircraft, b) aerotech units, c) lams in air mode\n-            if(mover.isAirborneAeroOnGroundMap() && !((IAero) mover).isSpheroid()) {\n-                AeroGroundPathFinder apf = AeroGroundPathFinder.getInstance(getGame());\n-                MovePath startPath = new MovePath(getGame(), mover);\n-                apf.run(startPath);\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-                \n-                // Remove illegal paths.\n-                Filter<MovePath> filter = new Filter<MovePath>() {\n-                    @Override\n-                    public boolean shouldStay(MovePath movePath) {\n-                        return isLegalAeroMove(movePath);\n-                    }\n-                };\n-                \n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Unfiltered paths: \" + paths.size());\n-                paths = new ArrayList<>(filter.doFilter(paths));\n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out illegal paths: \" + paths.size());\n-                AeroGroundOffBoardFilter offBoardFilter = new AeroGroundOffBoardFilter();\n-                paths = new ArrayList<>(offBoardFilter.doFilter(paths));\n-                \n-                MovePath offBoardPath = offBoardFilter.getShortestPath();\n-                if(offBoardPath != null) {\n-                    paths.add(offBoardFilter.getShortestPath());\n-                }\n-                \n-                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out offboard paths: \" + paths.size());\n-                \n-                // This is code useful for debugging, but puts out a lot of log entries, which slows things down. \n-                HashMap<Integer, Integer> pathLengths = new HashMap<Integer, Integer>();\n-                for(MovePath path : paths) {\n-                    if(!pathLengths.containsKey(path.length())) {\n-                        pathLengths.put(path.length(), 0);\n-                    }\n-                    Integer lengthCount = pathLengths.get(path.length());\n-                    pathLengths.put(path.length(), lengthCount + 1);\n-                    \n-                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n-                }\n-                \n-                for(Integer length : pathLengths.keySet()) {\n-                    this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Paths of length \" + length + \": \" + pathLengths.get(length));\n-                }\n-            // this handles the case of the mover being an aerospace unit and \"advances space flight\" rules being on\n-            } else if(mover.isAero() && game.useVectorMove()) {\n-                NewtonianAerospacePathFinder npf = NewtonianAerospacePathFinder.getInstance(getGame());\n-                npf.run(new MovePath(game, mover));\n-                paths.addAll(npf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being an aerospace unit on a space map\n-            } else if(mover.isAero() && game.getBoard().inSpace()) {\n-                AeroSpacePathFinder apf = AeroSpacePathFinder.getInstance(getGame());\n-                apf.run(new MovePath(game, mover));\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being a winged aerospace unit on a low-atmo map\n-            } else if(mover.isAero() && game.getBoard().inAtmosphere() && !Compute.useSpheroidAtmosphere(game, mover)) {\n-                AeroLowAltitudePathFinder apf = AeroLowAltitudePathFinder.getInstance(getGame());\n-                apf.run(new MovePath(game, mover));\n-                paths.addAll(apf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover acting like a spheroid aerospace unit in an atmosphere\n-            } else if(Compute.useSpheroidAtmosphere(game, mover)) {\n-                SpheroidPathFinder spf = SpheroidPathFinder.getInstance(game);\n-                spf.run(new MovePath(game, mover));\n-                paths.addAll(spf.getAllComputedPathsUncategorized());\n-            // this handles the case of the mover being an infantry unit of some kind, that's not airborne.\n-            } else if (mover.hasETypeFlag(Entity.ETYPE_INFANTRY) && !mover.isAirborne()) {\n-                InfantryPathFinder ipf = InfantryPathFinder.getInstance(getGame());\n-                ipf.run(new MovePath(game, mover));\n-                paths.addAll(ipf.getAllComputedPathsUncategorized());\n-                \n-                // generate long-range paths appropriate to the bot's current state\n-                updateLongRangePaths(mover);\n-            // this handles situations where a unit is high up in the air, but is not an aircraft\n-            // such as an ejected pilot or a unit hot dropping from a dropship, as these cannot move\n-            } else if (!mover.isAero() && mover.isAirborne()) {\n-                paths.add(new MovePath(game, mover));\n-            } else { // Non-Aero movement\n-                // TODO: Will this cause Princess to never use MASC?\n-                LongestPathFinder lpf = LongestPathFinder\n-                        .newInstanceOfLongestPath(mover.getRunMPwithoutMASC(),\n-                                MoveStepType.FORWARDS, getGame());\n-                lpf.run(new MovePath(game, mover));\n-                paths.addAll(lpf.getLongestComputedPaths());\n-\n-                //add walking moves\n-                lpf = LongestPathFinder.newInstanceOfLongestPath(\n-                        mover.getWalkMP(), MoveStepType.BACKWARDS, getGame());\n-                lpf.run(new MovePath(getGame(), mover));\n-                paths.addAll(lpf.getLongestComputedPaths());\n-\n-                //add jumping moves\n-                if (mover.getJumpMP() > 0) {\n-                    ShortestPathFinder spf = ShortestPathFinder\n-                            .newInstanceOfOneToAll(mover.getJumpMP(),\n-                                    MoveStepType.FORWARDS, getGame());\n-                    spf.run((new MovePath(game, mover))\n-                            .addStep(MoveStepType.START_JUMP));\n-                    paths.addAll(spf.getAllComputedPathsUncategorized());\n-                }\n-\n-                for(MovePath path : paths) {\n-                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n-                }\n-                \n-                // Try climbing over obstacles and onto bridges\n-                adjustPathsForBridges(paths);\n-\n-                //filter those paths that end in illegal state\n-                Filter<MovePath> filter = new Filter<MovePath>() {\n-                    @Override\n-                    public boolean shouldStay(MovePath movePath) {\n-                        boolean isLegal = movePath.isMoveLegal();\n-                        return isLegal\n-                                && (Compute.stackingViolation(getGame(),\n-                                        mover.getId(),\n-                                        movePath.getFinalCoords()) == null);\n-                    }\n-                };\n-                paths = new ArrayList<>(filter.doFilter(paths));\n-                \n-                // generate long-range paths appropriate to the bot's current state\n-                updateLongRangePaths(mover);\n-            }\n-\n-            // Update our locations and add the computed paths.\n-            updateUnitLocations(mover, paths);\n-            getUnitPaths().put(mover.getId(), paths);\n-\n-            // calculate bounding area for move\n-            ConvexBoardArea myArea = new ConvexBoardArea(owner);\n-            myArea.addCoordFacingCombos(getUnitPotentialLocations().get(\n-                    mover.getId()).iterator());\n-            getUnitMovableAreas().put(mover.getId(), myArea);\n-        } finally {\n-            getOwner().methodEnd(getClass(), METHOD_NAME);\n+        \n+        int retryCount = 0;\n+        boolean success = false;\n+        \n+        while ((retryCount < BotClient.BOT_TURN_RETRY_COUNT) && !success) {\n+\t        try {\n+\t\n+\t            // Record it's current position.\n+\t            getLastKnownLocations().put(", "originalCommit": "cc93a650850c40c7b179dfbf6c583fd09fcdafc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "chunk": "diff --git a/megamek/src/megamek/client/bot/princess/PathEnumerator.java b/megamek/src/megamek/client/bot/princess/PathEnumerator.java\nindex a024c7d32d..2a7f5eac6c 100644\n--- a/megamek/src/megamek/client/bot/princess/PathEnumerator.java\n+++ b/megamek/src/megamek/client/bot/princess/PathEnumerator.java\n\n@@ -165,181 +165,194 @@ public class PathEnumerator {\n     }\n \n     /**\n-     * calculates all moves for a given unit, keeping the shortest path to each hex/facing pair\n+     * Calculate what to do on my turn.\n+     * Has a retry mechanism for when the turn calculation fails due to concurrency issues\n      */\n-    public void recalculateMovesFor(final Entity mover) {\n-        final String METHOD_NAME = \"recalculateMovesFor(IGame, Entity)\";\n-        getOwner().methodBegin(getClass(), METHOD_NAME);\n-        \n-        int retryCount = 0;\n+    public synchronized void recalculateMovesFor(final Entity mover) {\n+    \tint retryCount = 0;\n         boolean success = false;\n         \n-        while ((retryCount < BotClient.BOT_TURN_RETRY_COUNT) && !success) {\n-\t        try {\n-\t\n-\t            // Record it's current position.\n-\t            getLastKnownLocations().put(\n-\t                    mover.getId(),\n-\t                    CoordFacingCombo.createCoordFacingCombo(\n-\t                            mover.getPosition(), mover.getFacing()));\n-\t\n-\t            // Clear out any already calculated paths.\n-\t            getUnitPaths().remove(mover.getId());\n-\t            getLongRangePaths().remove(mover.getId());\n-\t            \n-\t            // if the entity does not exist in the game for any reason, let's cut out safely\n-\t            // otherwise, we'll run into problems calculating paths\n-\t            if (getGame().getEntity(mover.getId()) == null) {\n-\t                // clean up orphaned entries in local storage\n-\t                getUnitMovableAreas().remove(mover.getId());\n-\t                getUnitPotentialLocations().remove(mover.getId());\n-\t                getLastKnownLocations().remove(mover.getId());\n-\t                return;\n-\t            }\n-\t\n-\t            // Start constructing the new list of paths.\n-\t            List<MovePath> paths = new ArrayList<>();\n-\t            \n-\t            // Aero movement on atmospheric ground maps\n-\t            // currently only applies to a) conventional aircraft, b) aerotech units, c) lams in air mode\n-\t            if(mover.isAirborneAeroOnGroundMap() && !((IAero) mover).isSpheroid()) {\n-\t                AeroGroundPathFinder apf = AeroGroundPathFinder.getInstance(getGame());\n-\t                MovePath startPath = new MovePath(getGame(), mover);\n-\t                apf.run(startPath);\n-\t                paths.addAll(apf.getAllComputedPathsUncategorized());\n-\t                \n-\t                // Remove illegal paths.\n-\t                Filter<MovePath> filter = new Filter<MovePath>() {\n-\t                    @Override\n-\t                    public boolean shouldStay(MovePath movePath) {\n-\t                        return isLegalAeroMove(movePath);\n-\t                    }\n-\t                };\n-\t                \n-\t                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Unfiltered paths: \" + paths.size());\n-\t                paths = new ArrayList<>(filter.doFilter(paths));\n-\t                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out illegal paths: \" + paths.size());\n-\t                AeroGroundOffBoardFilter offBoardFilter = new AeroGroundOffBoardFilter();\n-\t                paths = new ArrayList<>(offBoardFilter.doFilter(paths));\n-\t                \n-\t                MovePath offBoardPath = offBoardFilter.getShortestPath();\n-\t                if(offBoardPath != null) {\n-\t                    paths.add(offBoardFilter.getShortestPath());\n-\t                }\n-\t                \n-\t                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out offboard paths: \" + paths.size());\n-\t                \n-\t                // This is code useful for debugging, but puts out a lot of log entries, which slows things down. \n-\t                // disabled\n-\t                // logAllPaths(paths);\n-\t            // this handles the case of the mover being an aerospace unit and \"advances space flight\" rules being on\n-\t            } else if(mover.isAero() && game.useVectorMove()) {\n-\t                NewtonianAerospacePathFinder npf = NewtonianAerospacePathFinder.getInstance(getGame());\n-\t                npf.run(new MovePath(game, mover));\n-\t                paths.addAll(npf.getAllComputedPathsUncategorized());\n-\t            // this handles the case of the mover being an aerospace unit on a space map\n-\t            } else if(mover.isAero() && game.getBoard().inSpace()) {\n-\t                AeroSpacePathFinder apf = AeroSpacePathFinder.getInstance(getGame());\n-\t                apf.run(new MovePath(game, mover));\n-\t                paths.addAll(apf.getAllComputedPathsUncategorized());\n-\t            // this handles the case of the mover being a winged aerospace unit on a low-atmo map\n-\t            } else if(mover.isAero() && game.getBoard().inAtmosphere() && !Compute.useSpheroidAtmosphere(game, mover)) {\n-\t                AeroLowAltitudePathFinder apf = AeroLowAltitudePathFinder.getInstance(getGame());\n-\t                apf.run(new MovePath(game, mover));\n-\t                paths.addAll(apf.getAllComputedPathsUncategorized());\n-\t            // this handles the case of the mover acting like a spheroid aerospace unit in an atmosphere\n-\t            } else if(Compute.useSpheroidAtmosphere(game, mover)) {\n-\t                SpheroidPathFinder spf = SpheroidPathFinder.getInstance(game);\n-\t                spf.run(new MovePath(game, mover));\n-\t                paths.addAll(spf.getAllComputedPathsUncategorized());\n-\t            // this handles the case of the mover being an infantry unit of some kind, that's not airborne.\n-\t            } else if (mover.hasETypeFlag(Entity.ETYPE_INFANTRY) && !mover.isAirborne()) {\n-\t                InfantryPathFinder ipf = InfantryPathFinder.getInstance(getGame());\n-\t                ipf.run(new MovePath(game, mover));\n-\t                paths.addAll(ipf.getAllComputedPathsUncategorized());\n-\t                \n-\t                // generate long-range paths appropriate to the bot's current state\n-\t                updateLongRangePaths(mover);\n-\t            // this handles situations where a unit is high up in the air, but is not an aircraft\n-\t            // such as an ejected pilot or a unit hot dropping from a dropship, as these cannot move\n-\t            } else if (!mover.isAero() && mover.isAirborne()) {\n-\t                paths.add(new MovePath(game, mover));\n-\t            } else { // Non-Aero movement\n-\t                // TODO: Will this cause Princess to never use MASC?\n-\t                LongestPathFinder lpf = LongestPathFinder\n-\t                        .newInstanceOfLongestPath(mover.getRunMPwithoutMASC(),\n-\t                                MoveStepType.FORWARDS, getGame());\n-\t                lpf.run(new MovePath(game, mover));\n-\t                paths.addAll(lpf.getLongestComputedPaths());\n-\t\n-\t                //add walking moves\n-\t                lpf = LongestPathFinder.newInstanceOfLongestPath(\n-\t                        mover.getWalkMP(), MoveStepType.BACKWARDS, getGame());\n-\t                lpf.run(new MovePath(getGame(), mover));\n-\t                paths.addAll(lpf.getLongestComputedPaths());\n-\t\n-\t                //add jumping moves\n-\t                if (mover.getJumpMP() > 0) {\n-\t                    ShortestPathFinder spf = ShortestPathFinder\n-\t                            .newInstanceOfOneToAll(mover.getJumpMP(),\n-\t                                    MoveStepType.FORWARDS, getGame());\n-\t                    spf.run((new MovePath(game, mover))\n-\t                            .addStep(MoveStepType.START_JUMP));\n-\t                    paths.addAll(spf.getAllComputedPathsUncategorized());\n-\t                }\n-\t\n-\t                for(MovePath path : paths) {\n-\t                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n-\t                }\n-\t                \n-\t                // Try climbing over obstacles and onto bridges\n-\t                adjustPathsForBridges(paths);\n-\t\n-\t                //filter those paths that end in illegal state\n-\t                Filter<MovePath> filter = new Filter<MovePath>() {\n-\t                    @Override\n-\t                    public boolean shouldStay(MovePath movePath) {\n-\t                        boolean isLegal = movePath.isMoveLegal();\n-\t                        return isLegal\n-\t                                && (Compute.stackingViolation(getGame(),\n-\t                                        mover.getId(),\n-\t                                        movePath.getFinalCoords()) == null);\n-\t                    }\n-\t                };\n-\t                paths = new ArrayList<>(filter.doFilter(paths));\n-\t                \n-\t                // generate long-range paths appropriate to the bot's current state\n-\t                updateLongRangePaths(mover);\n-\t            }\n-\t\n-\t            // Update our locations and add the computed paths.\n-\t            updateUnitLocations(mover, paths);\n-\t            getUnitPaths().put(mover.getId(), paths);\n-\t\n-\t            // calculate bounding area for move\n-\t            ConvexBoardArea myArea = new ConvexBoardArea(owner);\n-\t            myArea.addCoordFacingCombos(getUnitPotentialLocations().get(\n-\t                    mover.getId()).iterator());\n-\t            getUnitMovableAreas().put(mover.getId(), myArea);\n-\t            \n-\t            success = true;\n-\t        } catch(Exception e) {\n-\t        \tMegaMek.getLogger().error(this, e.toString());\n-\t            \n-\t            // if we fail, take a nap for 500-1500 milliseconds, then try again\n+        while((retryCount < BotClient.BOT_TURN_RETRY_COUNT) && !success) {\n+        \tsuccess = recalculateMovesForWorker(mover);\n+        \t\n+        \tif(!success) {\n+\t        \t// if we fail, take a nap for 500-1500 milliseconds, then try again\n \t            // as it may be due to some kind of thread-related issue\n+        \t\t// limit number of retries so we're not endlessly spinning\n+        \t\t// if we can't recover from the error\n \t            retryCount++;\n \t            try {\n \t\t\t\t\tThread.sleep(Compute.randomInt(1000) + 500);\n-\t\t\t\t} catch (InterruptedException t) {\n-\t\t\t\t\tMegaMek.getLogger().error(this, t.toString());\n+\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t\tMegaMek.getLogger().error(this, e.toString());\n \t\t\t\t}\n-\t        } finally {\n-\t            getOwner().methodEnd(getClass(), METHOD_NAME);\n \t        }\n         }\n     }\n     \n+    /**\n+     * calculates all moves for a given unit, keeping the shortest (or longest, depending) path to each facing/pair\n+     */\n+    private boolean recalculateMovesForWorker(final Entity mover) {\n+        final String METHOD_NAME = \"recalculateMovesFor(IGame, Entity)\";\n+        getOwner().methodBegin(getClass(), METHOD_NAME);\n+\n+        try {\n+\t\n+            // Record it's current position.\n+            getLastKnownLocations().put(\n+                    mover.getId(),\n+                    CoordFacingCombo.createCoordFacingCombo(\n+                            mover.getPosition(), mover.getFacing()));\n+\n+            // Clear out any already calculated paths.\n+            getUnitPaths().remove(mover.getId());\n+            getLongRangePaths().remove(mover.getId());\n+            \n+            // if the entity does not exist in the game for any reason, let's cut out safely\n+            // otherwise, we'll run into problems calculating paths\n+            if (getGame().getEntity(mover.getId()) == null) {\n+                // clean up orphaned entries in local storage\n+                getUnitMovableAreas().remove(mover.getId());\n+                getUnitPotentialLocations().remove(mover.getId());\n+                getLastKnownLocations().remove(mover.getId());\n+                return true;\n+            }\n+\n+            // Start constructing the new list of paths.\n+            List<MovePath> paths = new ArrayList<>();\n+            \n+            // Aero movement on atmospheric ground maps\n+            // currently only applies to a) conventional aircraft, b) aerotech units, c) lams in air mode\n+            if(mover.isAirborneAeroOnGroundMap() && !((IAero) mover).isSpheroid()) {\n+                AeroGroundPathFinder apf = AeroGroundPathFinder.getInstance(getGame());\n+                MovePath startPath = new MovePath(getGame(), mover);\n+                apf.run(startPath);\n+                paths.addAll(apf.getAllComputedPathsUncategorized());\n+                \n+                // Remove illegal paths.\n+                Filter<MovePath> filter = new Filter<MovePath>() {\n+                    @Override\n+                    public boolean shouldStay(MovePath movePath) {\n+                        return isLegalAeroMove(movePath);\n+                    }\n+                };\n+                \n+                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Unfiltered paths: \" + paths.size());\n+                paths = new ArrayList<>(filter.doFilter(paths));\n+                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out illegal paths: \" + paths.size());\n+                AeroGroundOffBoardFilter offBoardFilter = new AeroGroundOffBoardFilter();\n+                paths = new ArrayList<>(offBoardFilter.doFilter(paths));\n+                \n+                MovePath offBoardPath = offBoardFilter.getShortestPath();\n+                if(offBoardPath != null) {\n+                    paths.add(offBoardFilter.getShortestPath());\n+                }\n+                \n+                this.owner.log(this.getClass(), METHOD_NAME, LogLevel.DEBUG, \"Filtered out offboard paths: \" + paths.size());\n+                \n+                // This is code useful for debugging, but puts out a lot of log entries, which slows things down. \n+                // disabled\n+                // logAllPaths(paths);\n+            // this handles the case of the mover being an aerospace unit and \"advances space flight\" rules being on\n+            } else if(mover.isAero() && game.useVectorMove()) {\n+                NewtonianAerospacePathFinder npf = NewtonianAerospacePathFinder.getInstance(getGame());\n+                npf.run(new MovePath(game, mover));\n+                paths.addAll(npf.getAllComputedPathsUncategorized());\n+            // this handles the case of the mover being an aerospace unit on a space map\n+            } else if(mover.isAero() && game.getBoard().inSpace()) {\n+                AeroSpacePathFinder apf = AeroSpacePathFinder.getInstance(getGame());\n+                apf.run(new MovePath(game, mover));\n+                paths.addAll(apf.getAllComputedPathsUncategorized());\n+            // this handles the case of the mover being a winged aerospace unit on a low-atmo map\n+            } else if(mover.isAero() && game.getBoard().inAtmosphere() && !Compute.useSpheroidAtmosphere(game, mover)) {\n+                AeroLowAltitudePathFinder apf = AeroLowAltitudePathFinder.getInstance(getGame());\n+                apf.run(new MovePath(game, mover));\n+                paths.addAll(apf.getAllComputedPathsUncategorized());\n+            // this handles the case of the mover acting like a spheroid aerospace unit in an atmosphere\n+            } else if(Compute.useSpheroidAtmosphere(game, mover)) {\n+                SpheroidPathFinder spf = SpheroidPathFinder.getInstance(game);\n+                spf.run(new MovePath(game, mover));\n+                paths.addAll(spf.getAllComputedPathsUncategorized());\n+            // this handles the case of the mover being an infantry unit of some kind, that's not airborne.\n+            } else if (mover.hasETypeFlag(Entity.ETYPE_INFANTRY) && !mover.isAirborne()) {\n+                InfantryPathFinder ipf = InfantryPathFinder.getInstance(getGame());\n+                ipf.run(new MovePath(game, mover));\n+                paths.addAll(ipf.getAllComputedPathsUncategorized());\n+                \n+                // generate long-range paths appropriate to the bot's current state\n+                updateLongRangePaths(mover);\n+            // this handles situations where a unit is high up in the air, but is not an aircraft\n+            // such as an ejected pilot or a unit hot dropping from a dropship, as these cannot move\n+            } else if (!mover.isAero() && mover.isAirborne()) {\n+                paths.add(new MovePath(game, mover));\n+            } else { // Non-Aero movement\n+                // TODO: Will this cause Princess to never use MASC?\n+                LongestPathFinder lpf = LongestPathFinder\n+                        .newInstanceOfLongestPath(mover.getRunMPwithoutMASC(),\n+                                MoveStepType.FORWARDS, getGame());\n+                lpf.run(new MovePath(game, mover));\n+                paths.addAll(lpf.getLongestComputedPaths());\n+\n+                //add walking moves\n+                lpf = LongestPathFinder.newInstanceOfLongestPath(\n+                        mover.getWalkMP(), MoveStepType.BACKWARDS, getGame());\n+                lpf.run(new MovePath(getGame(), mover));\n+                paths.addAll(lpf.getLongestComputedPaths());\n+\n+                //add jumping moves\n+                if (mover.getJumpMP() > 0) {\n+                    ShortestPathFinder spf = ShortestPathFinder\n+                            .newInstanceOfOneToAll(mover.getJumpMP(),\n+                                    MoveStepType.FORWARDS, getGame());\n+                    spf.run((new MovePath(game, mover))\n+                            .addStep(MoveStepType.START_JUMP));\n+                    paths.addAll(spf.getAllComputedPathsUncategorized());\n+                }\n+\n+                for(MovePath path : paths) {\n+                    this.owner.log(this.getClass(), \"Path \", LogLevel.DEBUG, path.toString());\n+                }\n+                \n+                // Try climbing over obstacles and onto bridges\n+                adjustPathsForBridges(paths);\n+\n+                //filter those paths that end in illegal state\n+                Filter<MovePath> filter = new Filter<MovePath>() {\n+                    @Override\n+                    public boolean shouldStay(MovePath movePath) {\n+                        boolean isLegal = movePath.isMoveLegal();\n+                        return isLegal\n+                                && (Compute.stackingViolation(getGame(),\n+                                        mover.getId(),\n+                                        movePath.getFinalCoords()) == null);\n+                    }\n+                };\n+                paths = new ArrayList<>(filter.doFilter(paths));\n+                \n+                // generate long-range paths appropriate to the bot's current state\n+                updateLongRangePaths(mover);\n+            }\n+\n+            // Update our locations and add the computed paths.\n+            updateUnitLocations(mover, paths);\n+            getUnitPaths().put(mover.getId(), paths);\n+\n+            // calculate bounding area for move\n+            ConvexBoardArea myArea = new ConvexBoardArea(owner);\n+            myArea.addCoordFacingCombos(getUnitPotentialLocations().get(\n+                    mover.getId()).iterator());\n+            getUnitMovableAreas().put(mover.getId(), myArea);\n+            \n+            return true;\n+        } catch(Exception e) {\n+        \tMegaMek.getLogger().error(this, e.toString());\n+        \treturn false;\n+        } finally {\n+            getOwner().methodEnd(getClass(), METHOD_NAME);\n+        }\n+    }\n+    \n     /**\n      * Worker function that updates the long-range path collection for a particular entity\n      */\n"}}, {"oid": "381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "url": "https://github.com/MegaMek/megamek/commit/381a80ebe02dcf2165f12f1bf18bfb314ab1c80b", "message": "separate retry and worker functionality", "committedDate": "2020-08-15T04:22:24Z", "type": "commit"}]}