{"pr_number": 11454, "pr_title": "[BEAM-8871] Support trySplit for ByteKeyRangeTracker", "pr_createdAt": "2020-04-17T21:19:53Z", "pr_url": "https://github.com/apache/beam/pull/11454", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NjAxOA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410476018", "bodyText": "This is taken from https://github.com/apache/beam/blob/master/sdks/java/core/src/test/java/org/apache/beam/sdk/io/range/ByteKeyRangeTest.java#L365-L382", "author": "boyuanzz", "createdAt": "2020-04-17T21:21:30Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java", "diffHunk": "@@ -287,4 +318,30 @@ public void testBacklogPartiallyCompleted() {\n     tracker.tryClaim(ByteKey.of(0xa0));\n     assertThat(tracker.getSize(), allOf(greaterThan(0.), lessThan(1.)));\n   }\n+\n+  /** Asserts the two ByteKey are equal except trailing zeros. */\n+  private static void assertByteKeyEqualExceptPadding(ByteKey expected, ByteKey key) {", "originalCommit": "ab5444cdb8606ae98fc9bef52ccfa03de943743f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5NDA1Ng==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410594056", "bodyText": "Make that method public and call it from this test since they are both in the same module.", "author": "lukecwik", "createdAt": "2020-04-18T03:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NjAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\nindex c334d78ac2..b23b2dc56d 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n\n@@ -291,57 +329,49 @@ public class ByteKeyRangeTrackerTest {\n   @Test\n   public void testBacklogUnstarted() {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n-    assertEquals(1., tracker.getSize(), 0.001);\n+    Progress progress = tracker.getProgress();\n+    assertEquals(0, progress.getWorkCompleted(), 0.001);\n+    assertEquals(1, progress.getWorkRemaining(), 0.001);\n \n     tracker = ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)));\n-    assertEquals(1., tracker.getSize(), 0.001);\n+    progress = tracker.getProgress();\n+    assertEquals(0, progress.getWorkCompleted(), 0.001);\n+    assertEquals(1, progress.getWorkRemaining(), 0.001);\n   }\n \n   @Test\n   public void testBacklogFinished() {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n     tracker.tryClaim(ByteKey.EMPTY);\n-    assertEquals(0., tracker.getSize(), 0.001);\n+    Progress progress = tracker.getProgress();\n+    assertEquals(1, progress.getWorkCompleted(), 0.001);\n+    assertEquals(0, progress.getWorkRemaining(), 0.001);\n \n     tracker = ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)));\n     tracker.tryClaim(ByteKey.of(0xd0));\n-    assertEquals(0., tracker.getSize(), 0.001);\n+    progress = tracker.getProgress();\n+    assertEquals(1, progress.getWorkCompleted(), 0.001);\n+    assertEquals(0, progress.getWorkRemaining(), 0.001);\n   }\n \n   @Test\n   public void testBacklogPartiallyCompleted() {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n     tracker.tryClaim(ByteKey.of(0xa0));\n-    assertThat(tracker.getSize(), allOf(greaterThan(0.), lessThan(1.)));\n+    Progress progress = tracker.getProgress();\n+    assertEquals(0.625, progress.getWorkCompleted(), 0.001);\n+    assertEquals(0.375, progress.getWorkRemaining(), 0.001);\n \n-    tracker = ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)));\n+    tracker = ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0xc0)));\n     tracker.tryClaim(ByteKey.of(0xa0));\n-    assertThat(tracker.getSize(), allOf(greaterThan(0.), lessThan(1.)));\n-  }\n-\n-  /** Asserts the two ByteKey are equal except trailing zeros. */\n-  private static void assertByteKeyEqualExceptPadding(ByteKey expected, ByteKey key) {\n-    ByteBuffer shortKey = expected.getValue();\n-    ByteBuffer longKey = key.getValue();\n-    if (shortKey.remaining() > longKey.remaining()) {\n-      shortKey = key.getValue();\n-      longKey = expected.getValue();\n-    }\n-    for (int i = 0; i < shortKey.remaining(); ++i) {\n-      if (shortKey.get(i) != longKey.get(i)) {\n-        fail(String.format(\"Expected %s (up to trailing zeros), got %s\", expected, key));\n-      }\n-    }\n-    for (int j = shortKey.remaining(); j < longKey.remaining(); ++j) {\n-      if (longKey.get(j) != 0) {\n-        fail(String.format(\"Expected %s (up to trailing zeros), got %s\", expected, key));\n-      }\n-    }\n+    progress = tracker.getProgress();\n+    assertEquals(0.75, progress.getWorkCompleted(), 0.001);\n+    assertEquals(0.25, progress.getWorkRemaining(), 0.001);\n   }\n \n   /** Asserts the two ByteKeyRange are equal except trailing zeros. */\n-  private static void assertEqualExceptPadding(ByteKeyRange expected, ByteKeyRange key) {\n-    assertByteKeyEqualExceptPadding(expected.getStartKey(), key.getStartKey());\n-    assertByteKeyEqualExceptPadding(expected.getEndKey(), key.getEndKey());\n+  private static void assertKeyRangeEqualExceptPadding(ByteKeyRange expected, ByteKeyRange key) {\n+    assertEqualExceptPadding(expected.getStartKey(), key.getStartKey());\n+    assertEqualExceptPadding(expected.getEndKey(), key.getEndKey());\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410479854", "bodyText": "Should this method then be @Nullable  and/or in the parent class?", "author": "iemejia", "createdAt": "2020-04-17T21:31:41Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,38 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n-\n-    // If we haven't done any work, we should return the original range we were processing\n-    // as the checkpoint.\n-    if (lastAttemptedKey == null) {\n-      ByteKeyRange rval = range;\n-      // We update our current range to an interval that contains no elements.\n-      range = NO_KEYS;\n-      return SplitResult.of(range, rval);\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {\n+      return null;", "originalCommit": "ab5444cdb8606ae98fc9bef52ccfa03de943743f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NzI4Mw==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410487283", "bodyText": "It should be in the parent class.\n@robertwb was going to take a look at fixing up the docs and method signatures to ensure that null, None, nil were allowed and what they meant under certain scenarios.", "author": "lukecwik", "createdAt": "2020-04-17T21:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5MzA3MA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410493070", "bodyText": "I can update  java RestrictionTracker within this PR if that's preferable.", "author": "boyuanzz", "createdAt": "2020-04-17T22:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5NDMxMw==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410594313", "bodyText": "That works for me.", "author": "lukecwik", "createdAt": "2020-04-18T03:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY2Mjg2Mw==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410662863", "bodyText": "I am ok with null but couldn't we have modelled this with something Option type friendly like UnsplittableResult maybe with a isSplittable() method to resolve the case difference?", "author": "iemejia", "createdAt": "2020-04-18T07:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwOTQzMA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r411509430", "bodyText": "Since restriction trackers return RestrictionT, we could only do this if we updated the trySplit method to return SplitResult<RestrictionT> where SplitResult would be something like Optional.\nThat could be useful if we wanted to plumb the failure reason for the split back to the runner.", "author": "lukecwik", "createdAt": "2020-04-20T16:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzODExMg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r411538112", "bodyText": "The trySplit has returned SplitResult<RestrictionT> as result. If we want the runner understand the failure reason, we also need to create a set of well known literals. If just for logging purpose, we can also log the msg at SDK level.", "author": "boyuanzz", "createdAt": "2020-04-20T16:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMjg5OA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r413412898", "bodyText": "Semantically, what we want to return here is the empty split. It is important that the infrastructure be able to recognize and empty split (of type RestrictionT) so that it won't try to further split/reschedule it. One could create a new SplitResult type for Java, but I'm unconvinced it's worth its weight. (Certainly None/nil feel more appropriate for Python and Go respectively.)", "author": "robertwb", "createdAt": "2020-04-22T23:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "a4aa88616399273d0b0e9d6d59be79ad256208ce", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex f17562bbe9..692d96d904 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -72,29 +72,47 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n     if (lastAttemptedKey != null && lastAttemptedKey.isEmpty()) {\n       return null;\n     }\n+\n     ByteKey startKey = (lastAttemptedKey == null) ? range.getStartKey() : next(lastAttemptedKey);\n     ByteKey endKey = range.getEndKey();\n     // There is no more space for split.\n     if (!endKey.isEmpty() && startKey.compareTo(endKey) >= 0) {\n       return null;\n     }\n+\n+    // Treat checkpoint specially because {@link ByteKeyRange#interpolateKey} computes a key with\n+    // trailing zeros when fraction is 0.\n+    if (fractionOfRemainder == 0.0) {\n+      // If we haven't done any work, we should return the original range we were processing\n+      // as the checkpoint.\n+      if (lastAttemptedKey == null) {\n+        // We update our current range to an interval that contains no elements.\n+        ByteKeyRange rval = range;\n+        range = NO_KEYS;\n+        return SplitResult.of(range, rval);\n+      } else {\n+        range = ByteKeyRange.of(range.getStartKey(), startKey);\n+        return SplitResult.of(range, ByteKeyRange.of(startKey, endKey));\n+      }\n+    }\n+\n     ByteKeyRange unprocessedRange = ByteKeyRange.of(startKey, range.getEndKey());\n     ByteKey splitPos;\n     try {\n+      // The interpolateKey shouldn't return empty key. Please refer to {@link\n+      // ByteKeyRange#interpolateKey}.\n       splitPos = unprocessedRange.interpolateKey(fractionOfRemainder);\n+      checkState(!splitPos.isEmpty());\n     } catch (Exception e) {\n+      // There is no way to interpolate a key based on provided fraction.\n       return null;\n     }\n     // Computed splitPos is out of current tracking restriction.\n     if (!range.getEndKey().isEmpty() && splitPos.equals(range.getEndKey())) {\n       return null;\n     }\n-    if (range.getStartKey().compareTo(splitPos) == 0) {\n-      // Set current restriction to empty range when checkpointing at the first key.\n-      range = NO_KEYS;\n-    } else {\n-      range = ByteKeyRange.of(range.getStartKey(), splitPos);\n-    }\n+\n+    range = ByteKeyRange.of(range.getStartKey(), splitPos);\n     return SplitResult.of(range, ByteKeyRange.of(splitPos, endKey));\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MDgzNA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410480834", "bodyText": "s/starKey/startKey", "author": "iemejia", "createdAt": "2020-04-17T21:34:21Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/range/ByteKeyRange.java", "diffHunk": "@@ -218,6 +218,10 @@ public double estimateFractionForKey(ByteKey key) {\n   public ByteKey interpolateKey(double fraction) {\n     checkArgument(\n         fraction >= 0.0 && fraction < 1.0, \"Fraction %s must be in the range [0, 1)\", fraction);\n+    // Return starKey when fraction is 0 in order to avoid adding trailing zeros during computation.", "originalCommit": "ab5444cdb8606ae98fc9bef52ccfa03de943743f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a4aa88616399273d0b0e9d6d59be79ad256208ce", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/range/ByteKeyRange.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/range/ByteKeyRange.java\nindex 22b23f3fa0..42b8040e3b 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/io/range/ByteKeyRange.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/io/range/ByteKeyRange.java\n\n@@ -218,10 +218,6 @@ public final class ByteKeyRange\n   public ByteKey interpolateKey(double fraction) {\n     checkArgument(\n         fraction >= 0.0 && fraction < 1.0, \"Fraction %s must be in the range [0, 1)\", fraction);\n-    // Return starKey when fraction is 0 in order to avoid adding trailing zeros during computation.\n-    if (fraction == 0.0) {\n-      return ByteKey.copyFrom(startKey.getValue());\n-    }\n     byte[] startBytes = startKey.getBytes();\n     byte[] endBytes = endKey.getBytes();\n     // If the endKey is unspecified, add a leading 1 byte to it and a leading 0 byte to all other\n"}}, {"oid": "a4aa88616399273d0b0e9d6d59be79ad256208ce", "url": "https://github.com/apache/beam/commit/a4aa88616399273d0b0e9d6d59be79ad256208ce", "message": "Update trySplit logic to treat checkpoint specially.", "committedDate": "2020-04-17T22:54:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MjAzOQ==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410592039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * position. Each claimed position should be a valid split point.\n          \n          \n            \n               * position. Each claimed position MUST be a valid split point.", "author": "lukecwik", "createdAt": "2020-04-18T03:36:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java", "diffHunk": "@@ -29,7 +30,7 @@\n public abstract class RestrictionTracker<RestrictionT, PositionT> {\n   /**\n    * Attempts to claim the block of work in the current restriction identified by the given\n-   * position.\n+   * position. Each claimed position should be a valid split point.", "originalCommit": "13cfe2eec07bf133ba3cd53636bbca5e3b9b4295", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\nindex e8200e8bb9..d0e02cae35 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n\n@@ -25,12 +26,16 @@ import org.apache.beam.sdk.transforms.DoFn;\n /**\n  * Manages access to the restriction and keeps track of its claimed part for a <a\n  * href=\"https://s.apache.org/splittable-do-fn\">splittable</a> {@link DoFn}.\n+ *\n+ * <p>{@link RestrictionTracker}s should implement {@link HasProgress} otherwise poor auto-scaling\n+ * of workers and/or splitting may result if the progress is an inaccurate representation of the\n+ * known amount of completed and remaining work.\n  */\n @Experimental(Kind.SPLITTABLE_DO_FN)\n public abstract class RestrictionTracker<RestrictionT, PositionT> {\n   /**\n    * Attempts to claim the block of work in the current restriction identified by the given\n-   * position. Each claimed position should be a valid split point.\n+   * position. Each claimed position MUST be a valid split point.\n    *\n    * <p>If this succeeds, the DoFn MUST execute the entire block of work. If this fails:\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MzU2Ng==", "url": "https://github.com/apache/beam/pull/11454#discussion_r410593566", "bodyText": "We should make it clear that a checkpoint must return a valid split result or null where null represents that there is no residual.", "author": "lukecwik", "createdAt": "2020-04-18T03:40:22Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java", "diffHunk": "@@ -80,6 +81,7 @@\n    *     represent based upon the current known remaining amount of work.\n    * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}.", "originalCommit": "13cfe2eec07bf133ba3cd53636bbca5e3b9b4295", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\nindex e8200e8bb9..d0e02cae35 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n\n@@ -79,7 +84,9 @@ public abstract class RestrictionTracker<RestrictionT, PositionT> {\n    *\n    * @param fractionOfRemainder A hint as to the fraction of work the primary restriction should\n    *     represent based upon the current known remaining amount of work.\n-   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}.\n+   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. If the\n+   *     {@code fractionOfRemainder == 0}, a {@code null} result MUST imply that the restriction\n+   *     tracker is done and there is no more work left to do.\n    */\n   @Nullable\n   public abstract SplitResult<RestrictionT> trySplit(double fractionOfRemainder);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyMzE4Ng==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414023186", "bodyText": "or startKey == endKey", "author": "lukecwik", "createdAt": "2020-04-23T18:22:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,56 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NDMzMw==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414074333", "bodyText": "I think the major question is about startKey == endKey or NO_KEYS. There are 2 options in my mind:\n\nUse startKey == endKey and NO_KEYS to represent an empty key range.\nOnly use NO_KEYS as a notion of empty key range. In order to do this, we need to change the current range to NO_KEYS after checkpointing if necessary.\nI chose option 2 as my current implementation, that's why I only exam NO_KEYS in tryClaim and checkDone.\n\nWhat do you think?", "author": "boyuanzz", "createdAt": "2020-04-23T19:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyMzE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA4MTYzMg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414081632", "bodyText": "A user can still create a restriction where startkey == endkey, have no tryClaim calls and be checkpointed which is why we need to support both cases.", "author": "lukecwik", "createdAt": "2020-04-23T19:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyMzE4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex 692d96d904..ddbe9bd42e 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -65,7 +66,8 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n     // No split on an empty range.\n-    if (NO_KEYS.equals(range)) {\n+    if (NO_KEYS.equals(range)\n+        || (!range.getEndKey().isEmpty() && range.getStartKey().equals(range.getEndKey()))) {\n       return null;\n     }\n     // There is no more remaining work after the entire range has been claimed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzNDg5MQ==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414034891", "bodyText": "We should return [startKey, startKey) as the primary unless startKey is \"\" and then we should return NO_KEYS", "author": "lukecwik", "createdAt": "2020-04-23T18:40:17Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,56 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {\n+      return null;\n+    }\n+    // There is no more remaining work after the entire range has been claimed.\n+    if (lastAttemptedKey != null && lastAttemptedKey.isEmpty()) {\n+      return null;\n+    }\n \n-    // If we haven't done any work, we should return the original range we were processing\n-    // as the checkpoint.\n-    if (lastAttemptedKey == null) {\n-      ByteKeyRange rval = range;\n-      // We update our current range to an interval that contains no elements.\n-      range = NO_KEYS;\n-      return SplitResult.of(range, rval);\n+    ByteKey startKey = (lastAttemptedKey == null) ? range.getStartKey() : next(lastAttemptedKey);\n+    ByteKey endKey = range.getEndKey();\n+    // There is no more space for split.\n+    if (!endKey.isEmpty() && startKey.compareTo(endKey) >= 0) {\n+      return null;\n     }\n \n-    // Return an empty range if the current range is done.\n-    if (lastAttemptedKey.isEmpty()\n-        || !(range.getEndKey().isEmpty() || range.getEndKey().compareTo(lastAttemptedKey) > 0)) {\n-      return SplitResult.of(range, NO_KEYS);\n+    // Treat checkpoint specially because {@link ByteKeyRange#interpolateKey} computes a key with\n+    // trailing zeros when fraction is 0.\n+    if (fractionOfRemainder == 0.0) {\n+      // If we haven't done any work, we should return the original range we were processing\n+      // as the checkpoint.\n+      if (lastAttemptedKey == null) {\n+        // We update our current range to an interval that contains no elements.\n+        ByteKeyRange rval = range;\n+        range = NO_KEYS;", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex 692d96d904..ddbe9bd42e 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -65,7 +66,8 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n     // No split on an empty range.\n-    if (NO_KEYS.equals(range)) {\n+    if (NO_KEYS.equals(range)\n+        || (!range.getEndKey().isEmpty() && range.getStartKey().equals(range.getEndKey()))) {\n       return null;\n     }\n     // There is no more remaining work after the entire range has been claimed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODEyMA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414038120", "bodyText": "I would get rid of this local variable since its not being computed and is always range.getEndKey(). We can see that it doesn't add value since you use range.getEndKey() and not endKey below.", "author": "lukecwik", "createdAt": "2020-04-23T18:45:22Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,56 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {\n+      return null;\n+    }\n+    // There is no more remaining work after the entire range has been claimed.\n+    if (lastAttemptedKey != null && lastAttemptedKey.isEmpty()) {\n+      return null;\n+    }\n \n-    // If we haven't done any work, we should return the original range we were processing\n-    // as the checkpoint.\n-    if (lastAttemptedKey == null) {\n-      ByteKeyRange rval = range;\n-      // We update our current range to an interval that contains no elements.\n-      range = NO_KEYS;\n-      return SplitResult.of(range, rval);\n+    ByteKey startKey = (lastAttemptedKey == null) ? range.getStartKey() : next(lastAttemptedKey);\n+    ByteKey endKey = range.getEndKey();", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5ODQ4OQ==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414098489", "bodyText": "When there is a split, the range is updated first before constructing residual. Thus stashing endKey is needed unless we create another local var to stash residual.", "author": "boyuanzz", "createdAt": "2020-04-23T20:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMTcyMg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414101722", "bodyText": "I see. Thanks", "author": "lukecwik", "createdAt": "2020-04-23T20:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex 692d96d904..ddbe9bd42e 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -65,7 +66,8 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n     // No split on an empty range.\n-    if (NO_KEYS.equals(range)) {\n+    if (NO_KEYS.equals(range)\n+        || (!range.getEndKey().isEmpty() && range.getStartKey().equals(range.getEndKey()))) {\n       return null;\n     }\n     // There is no more remaining work after the entire range has been claimed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODI3Ng==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414038276", "bodyText": "startKey -> unprocessedRangeStartKey", "author": "lukecwik", "createdAt": "2020-04-23T18:45:36Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,56 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {\n+      return null;\n+    }\n+    // There is no more remaining work after the entire range has been claimed.\n+    if (lastAttemptedKey != null && lastAttemptedKey.isEmpty()) {\n+      return null;\n+    }\n \n-    // If we haven't done any work, we should return the original range we were processing\n-    // as the checkpoint.\n-    if (lastAttemptedKey == null) {\n-      ByteKeyRange rval = range;\n-      // We update our current range to an interval that contains no elements.\n-      range = NO_KEYS;\n-      return SplitResult.of(range, rval);\n+    ByteKey startKey = (lastAttemptedKey == null) ? range.getStartKey() : next(lastAttemptedKey);", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex 692d96d904..ddbe9bd42e 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -65,7 +66,8 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n     // No split on an empty range.\n-    if (NO_KEYS.equals(range)) {\n+    if (NO_KEYS.equals(range)\n+        || (!range.getEndKey().isEmpty() && range.getStartKey().equals(range.getEndKey()))) {\n       return null;\n     }\n     // There is no more remaining work after the entire range has been claimed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzOTQ3MA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414039470", "bodyText": "compare whether splitPos >= range.getEndKey()", "author": "lukecwik", "createdAt": "2020-04-23T18:47:30Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -64,31 +64,56 @@ public ByteKeyRange currentRestriction() {\n \n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n-    // TODO(BEAM-8871): Add support for splitting off a fixed amount of work for this restriction\n-    // instead of only supporting checkpointing.\n+    // No split on an empty range.\n+    if (NO_KEYS.equals(range)) {\n+      return null;\n+    }\n+    // There is no more remaining work after the entire range has been claimed.\n+    if (lastAttemptedKey != null && lastAttemptedKey.isEmpty()) {\n+      return null;\n+    }\n \n-    // If we haven't done any work, we should return the original range we were processing\n-    // as the checkpoint.\n-    if (lastAttemptedKey == null) {\n-      ByteKeyRange rval = range;\n-      // We update our current range to an interval that contains no elements.\n-      range = NO_KEYS;\n-      return SplitResult.of(range, rval);\n+    ByteKey startKey = (lastAttemptedKey == null) ? range.getStartKey() : next(lastAttemptedKey);\n+    ByteKey endKey = range.getEndKey();\n+    // There is no more space for split.\n+    if (!endKey.isEmpty() && startKey.compareTo(endKey) >= 0) {\n+      return null;\n     }\n \n-    // Return an empty range if the current range is done.\n-    if (lastAttemptedKey.isEmpty()\n-        || !(range.getEndKey().isEmpty() || range.getEndKey().compareTo(lastAttemptedKey) > 0)) {\n-      return SplitResult.of(range, NO_KEYS);\n+    // Treat checkpoint specially because {@link ByteKeyRange#interpolateKey} computes a key with\n+    // trailing zeros when fraction is 0.\n+    if (fractionOfRemainder == 0.0) {\n+      // If we haven't done any work, we should return the original range we were processing\n+      // as the checkpoint.\n+      if (lastAttemptedKey == null) {\n+        // We update our current range to an interval that contains no elements.\n+        ByteKeyRange rval = range;\n+        range = NO_KEYS;\n+        return SplitResult.of(range, rval);\n+      } else {\n+        range = ByteKeyRange.of(range.getStartKey(), startKey);\n+        return SplitResult.of(range, ByteKeyRange.of(startKey, endKey));\n+      }\n     }\n \n-    // Otherwise we compute the \"remainder\" of the range from the last key.\n-    assert lastAttemptedKey.equals(lastClaimedKey)\n-        : \"Expect both keys to be equal since the last key attempted was a valid key in the range.\";\n-    ByteKey nextKey = next(lastAttemptedKey);\n-    ByteKeyRange res = ByteKeyRange.of(nextKey, range.getEndKey());\n-    this.range = ByteKeyRange.of(range.getStartKey(), nextKey);\n-    return SplitResult.of(range, res);\n+    ByteKeyRange unprocessedRange = ByteKeyRange.of(startKey, range.getEndKey());\n+    ByteKey splitPos;\n+    try {\n+      // The interpolateKey shouldn't return empty key. Please refer to {@link\n+      // ByteKeyRange#interpolateKey}.\n+      splitPos = unprocessedRange.interpolateKey(fractionOfRemainder);\n+      checkState(!splitPos.isEmpty());\n+    } catch (Exception e) {\n+      // There is no way to interpolate a key based on provided fraction.\n+      return null;\n+    }\n+    // Computed splitPos is out of current tracking restriction.\n+    if (!range.getEndKey().isEmpty() && splitPos.equals(range.getEndKey())) {", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\nindex 692d96d904..ddbe9bd42e 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java\n\n@@ -65,7 +66,8 @@ public class ByteKeyRangeTracker extends RestrictionTracker<ByteKeyRange, ByteKe\n   @Override\n   public SplitResult<ByteKeyRange> trySplit(double fractionOfRemainder) {\n     // No split on an empty range.\n-    if (NO_KEYS.equals(range)) {\n+    if (NO_KEYS.equals(range)\n+        || (!range.getEndKey().isEmpty() && range.getStartKey().equals(range.getEndKey()))) {\n       return null;\n     }\n     // There is no more remaining work after the entire range has been claimed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzOTczMg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414039732", "bodyText": "We should cover the case where start == end at the NO_KEYS check at the top since it would be valid to be done and not have attempted anything because of how checkpoint is implemented.", "author": "lukecwik", "createdAt": "2020-04-23T18:47:55Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTracker.java", "diffHunk": "@@ -156,6 +181,11 @@ public void checkDone() throws IllegalStateException {\n       return;", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0Mjc1OQ==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414042759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. A\n          \n          \n            \n               *     checkpoint(fractionOfRemainder == 0) must either return a valid split result or null which\n          \n          \n            \n               *     means there is no more left work.\n          \n          \n            \n               * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. If the {@code fractionOfRemainder == 0}, a {@code null} result MUST imply that the restriction tracker is done and there is no more work left to do.", "author": "lukecwik", "createdAt": "2020-04-23T18:52:26Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java", "diffHunk": "@@ -78,8 +79,11 @@\n    *\n    * @param fractionOfRemainder A hint as to the fraction of work the primary restriction should\n    *     represent based upon the current known remaining amount of work.\n-   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}.\n+   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. A\n+   *     checkpoint(fractionOfRemainder == 0) must either return a valid split result or null which\n+   *     means there is no more left work.", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\nindex 47c614acd3..d0e02cae35 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/RestrictionTracker.java\n\n@@ -79,9 +84,9 @@ public abstract class RestrictionTracker<RestrictionT, PositionT> {\n    *\n    * @param fractionOfRemainder A hint as to the fraction of work the primary restriction should\n    *     represent based upon the current known remaining amount of work.\n-   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. A\n-   *     checkpoint(fractionOfRemainder == 0) must either return a valid split result or null which\n-   *     means there is no more left work.\n+   * @return a {@link SplitResult} if a split was possible, otherwise returns {@code null}. If the\n+   *     {@code fractionOfRemainder == 0}, a {@code null} result MUST imply that the restriction\n+   *     tracker is done and there is no more work left to do.\n    */\n   @Nullable\n   public abstract SplitResult<RestrictionT> trySplit(double fractionOfRemainder);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0NDAxNg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414044016", "bodyText": "Add a tryClaim test for empty ranges covering NO_KEYS and when startKey == endKey", "author": "lukecwik", "createdAt": "2020-04-23T18:54:27Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java", "diffHunk": "@@ -50,6 +52,7 @@ public void testTryClaim() throws Exception {\n     assertTrue(tracker.tryClaim(ByteKey.of(0x50)));\n     assertTrue(tracker.tryClaim(ByteKey.of(0x99)));\n     assertFalse(tracker.tryClaim(ByteKey.of(0xc0)));\n+    tracker.checkDone();\n   }\n ", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0ODAzMg==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414048032", "bodyText": "Why is the primary here 0x00 for the start key and not ByteKey.EMPTY?", "author": "lukecwik", "createdAt": "2020-04-23T19:00:38Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java", "diffHunk": "@@ -152,9 +158,35 @@ public void testCheckpointAfterLastUsingEmptyKey() throws Exception {\n     assertTrue(tracker.tryClaim(ByteKey.of(0x90)));\n     assertTrue(tracker.tryClaim(ByteKey.of(0xa0)));\n     assertFalse(tracker.tryClaim(ByteKey.EMPTY));\n-    ByteKeyRange checkpoint = tracker.trySplit(0).getResidual();\n+    assertNull(tracker.trySplit(0));\n     assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)), tracker.currentRestriction());\n-    assertEquals(ByteKeyRangeTracker.NO_KEYS, checkpoint);\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testTrySplit() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));\n+    SplitResult<ByteKeyRange> res = tracker.trySplit(0.5);\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n+    tracker.tryClaim(ByteKey.of(0x00));\n+    res = tracker.trySplit(0.5);\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.of(0x00), ByteKey.of(0x20)), res.getPrimary());", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExNjA2MA==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414116060", "bodyText": "It should be EMPTY. Thanks for catching this!", "author": "boyuanzz", "createdAt": "2020-04-23T20:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0ODAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\nindex d3c7b59c27..b23b2dc56d 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n\n@@ -165,30 +194,38 @@ public class ByteKeyRangeTrackerTest {\n \n   @Test\n   public void testTrySplit() throws Exception {\n-    ByteKeyRangeTracker tracker =\n-        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));\n+    ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n     SplitResult<ByteKeyRange> res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x80), ByteKey.EMPTY), res.getResidual());\n     tracker.tryClaim(ByteKey.of(0x00));\n     res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x00), ByteKey.of(0x20)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x20), ByteKey.of(0x40)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n     assertNull(tracker.trySplit(1));\n   }\n \n   @Test\n-  public void testTrySplitAtEmptyRange() throws Exception {\n+  public void testTrySplitAtNoKeysRange() throws Exception {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRangeTracker.NO_KEYS);\n     assertNull(tracker.trySplit(0));\n     assertNull(tracker.trySplit(1));\n     tracker.checkDone();\n   }\n \n+  @Test\n+  public void testTrySplitAtEmptyRange() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)));\n+    assertNull(tracker.trySplit(0.5));\n+    assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)), tracker.currentRestriction());\n+    tracker.checkDone();\n+  }\n+\n   @Test\n   public void testNonMonotonicClaim() throws Exception {\n     ByteKeyRangeTracker tracker =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0ODIyNQ==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414048225", "bodyText": "Start with the ALL_KEYS range.", "author": "lukecwik", "createdAt": "2020-04-23T19:00:57Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java", "diffHunk": "@@ -152,9 +158,35 @@ public void testCheckpointAfterLastUsingEmptyKey() throws Exception {\n     assertTrue(tracker.tryClaim(ByteKey.of(0x90)));\n     assertTrue(tracker.tryClaim(ByteKey.of(0xa0)));\n     assertFalse(tracker.tryClaim(ByteKey.EMPTY));\n-    ByteKeyRange checkpoint = tracker.trySplit(0).getResidual();\n+    assertNull(tracker.trySplit(0));\n     assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)), tracker.currentRestriction());\n-    assertEquals(ByteKeyRangeTracker.NO_KEYS, checkpoint);\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testTrySplit() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\nindex d3c7b59c27..b23b2dc56d 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n\n@@ -165,30 +194,38 @@ public class ByteKeyRangeTrackerTest {\n \n   @Test\n   public void testTrySplit() throws Exception {\n-    ByteKeyRangeTracker tracker =\n-        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));\n+    ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n     SplitResult<ByteKeyRange> res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x80), ByteKey.EMPTY), res.getResidual());\n     tracker.tryClaim(ByteKey.of(0x00));\n     res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x00), ByteKey.of(0x20)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x20), ByteKey.of(0x40)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n     assertNull(tracker.trySplit(1));\n   }\n \n   @Test\n-  public void testTrySplitAtEmptyRange() throws Exception {\n+  public void testTrySplitAtNoKeysRange() throws Exception {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRangeTracker.NO_KEYS);\n     assertNull(tracker.trySplit(0));\n     assertNull(tracker.trySplit(1));\n     tracker.checkDone();\n   }\n \n+  @Test\n+  public void testTrySplitAtEmptyRange() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)));\n+    assertNull(tracker.trySplit(0.5));\n+    assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)), tracker.currentRestriction());\n+    tracker.checkDone();\n+  }\n+\n   @Test\n   public void testNonMonotonicClaim() throws Exception {\n     ByteKeyRangeTracker tracker =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0ODk1Ng==", "url": "https://github.com/apache/beam/pull/11454#discussion_r414048956", "bodyText": "Cover the case where startKey == endKey and also add a call for trySplit at 0.5", "author": "lukecwik", "createdAt": "2020-04-23T19:02:00Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java", "diffHunk": "@@ -152,9 +158,35 @@ public void testCheckpointAfterLastUsingEmptyKey() throws Exception {\n     assertTrue(tracker.tryClaim(ByteKey.of(0x90)));\n     assertTrue(tracker.tryClaim(ByteKey.of(0xa0)));\n     assertFalse(tracker.tryClaim(ByteKey.EMPTY));\n-    ByteKeyRange checkpoint = tracker.trySplit(0).getResidual();\n+    assertNull(tracker.trySplit(0));\n     assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0xc0)), tracker.currentRestriction());\n-    assertEquals(ByteKeyRangeTracker.NO_KEYS, checkpoint);\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testTrySplit() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));\n+    SplitResult<ByteKeyRange> res = tracker.trySplit(0.5);\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n+    tracker.tryClaim(ByteKey.of(0x00));\n+    res = tracker.trySplit(0.5);\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.of(0x00), ByteKey.of(0x20)), res.getPrimary());\n+    assertKeyRangeEqualExceptPadding(\n+        ByteKeyRange.of(ByteKey.of(0x20), ByteKey.of(0x40)), res.getResidual());\n+    assertNull(tracker.trySplit(1));\n+  }\n+\n+  @Test\n+  public void testTrySplitAtEmptyRange() throws Exception {\n+    ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRangeTracker.NO_KEYS);", "originalCommit": "54cf62fb0bb060005ffaa196c543743b321e3279", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\nindex d3c7b59c27..b23b2dc56d 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/ByteKeyRangeTrackerTest.java\n\n@@ -165,30 +194,38 @@ public class ByteKeyRangeTrackerTest {\n \n   @Test\n   public void testTrySplit() throws Exception {\n-    ByteKeyRangeTracker tracker =\n-        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)));\n+    ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRange.ALL_KEYS);\n     SplitResult<ByteKeyRange> res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x80)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x80), ByteKey.EMPTY), res.getResidual());\n     tracker.tryClaim(ByteKey.of(0x00));\n     res = tracker.trySplit(0.5);\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x00), ByteKey.of(0x20)), res.getPrimary());\n+        ByteKeyRange.of(ByteKey.EMPTY, ByteKey.of(0x40)), res.getPrimary());\n     assertKeyRangeEqualExceptPadding(\n-        ByteKeyRange.of(ByteKey.of(0x20), ByteKey.of(0x40)), res.getResidual());\n+        ByteKeyRange.of(ByteKey.of(0x40), ByteKey.of(0x80)), res.getResidual());\n     assertNull(tracker.trySplit(1));\n   }\n \n   @Test\n-  public void testTrySplitAtEmptyRange() throws Exception {\n+  public void testTrySplitAtNoKeysRange() throws Exception {\n     ByteKeyRangeTracker tracker = ByteKeyRangeTracker.of(ByteKeyRangeTracker.NO_KEYS);\n     assertNull(tracker.trySplit(0));\n     assertNull(tracker.trySplit(1));\n     tracker.checkDone();\n   }\n \n+  @Test\n+  public void testTrySplitAtEmptyRange() throws Exception {\n+    ByteKeyRangeTracker tracker =\n+        ByteKeyRangeTracker.of(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)));\n+    assertNull(tracker.trySplit(0.5));\n+    assertEquals(ByteKeyRange.of(ByteKey.of(0x10), ByteKey.of(0x10)), tracker.currentRestriction());\n+    tracker.checkDone();\n+  }\n+\n   @Test\n   public void testNonMonotonicClaim() throws Exception {\n     ByteKeyRangeTracker tracker =\n"}}, {"oid": "6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "url": "https://github.com/apache/beam/commit/6e0bdbde1a177db22ea6081c11082cd3c9759fdc", "message": "[BEAM-8871] Support trySplit for ByteKeyRangeTracker", "committedDate": "2020-04-23T21:31:01Z", "type": "forcePushed"}, {"oid": "89958d8311b7225be51f3d86f03cb58581279372", "url": "https://github.com/apache/beam/commit/89958d8311b7225be51f3d86f03cb58581279372", "message": "[BEAM-8871] Support trySplit for ByteKeyRangeTracker", "committedDate": "2020-04-23T21:38:17Z", "type": "commit"}, {"oid": "89958d8311b7225be51f3d86f03cb58581279372", "url": "https://github.com/apache/beam/commit/89958d8311b7225be51f3d86f03cb58581279372", "message": "[BEAM-8871] Support trySplit for ByteKeyRangeTracker", "committedDate": "2020-04-23T21:38:17Z", "type": "forcePushed"}]}