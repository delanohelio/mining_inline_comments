{"pr_number": 13318, "pr_title": "[BEAM-11300] Improve Nexmark performance:", "pr_createdAt": "2020-11-12T14:12:43Z", "pr_url": "https://github.com/apache/beam/pull/13318", "timeline": [{"oid": "3d980846c1da07171fb1615432f7424cef521038", "url": "https://github.com/apache/beam/commit/3d980846c1da07171fb1615432f7424cef521038", "message": "Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-12T21:02:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODAwOQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525368009", "bodyText": "Simpler to do\n.apply(\"EventByAuctionSeller\", WithKeys.of(Auction::seller).withKeyType(TypeDescriptors.longs()))", "author": "reuvenlax", "createdAt": "2020-11-17T17:53:54Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -83,27 +75,29 @@ public Query3(NexmarkConfiguration configuration) {\n \n   @Override\n   public PCollection<NameCityStateId> expand(PCollection<Event> events) {\n-    int numEventsInPane = 30;\n-\n-    PCollection<Event> eventsWindowed =\n-        events.apply(\n-            Window.<Event>into(new GlobalWindows())\n-                .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(numEventsInPane)))\n-                .discardingFiredPanes()\n-                .withAllowedLateness(Duration.ZERO));\n-    PCollection<KV<Long, Auction>> auctionsBySellerId =\n-        eventsWindowed\n+    PCollection<KV<Long, Event>> auctionsBySellerId =\n+        events\n             // Only want the new auction events.\n             .apply(NexmarkQueryUtil.JUST_NEW_AUCTIONS)\n \n             // We only want auctions in category 10.\n             .apply(name + \".InCategory\", Filter.by(auction -> auction.category == 10))\n \n             // Key auctions by their seller id.\n-            .apply(\"AuctionBySeller\", NexmarkQueryUtil.AUCTION_BY_SELLER);\n-\n-    PCollection<KV<Long, Person>> personsById =\n-        eventsWindowed\n+            .apply(", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzU4NQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526017585", "bodyText": "this doesn't work because we also need to change to the union Event type.\nAlso Auction::seller has the error \"Objects is not a functional interface\".\nSo I kept as is, let me know if you'd rather WithKeys and then some auction->event with auction pardo. If you do, do you have suggestions on fixing the error?  My java is out of date so I'm not sure how to fix that off the top of my head.", "author": "scwhittle", "createdAt": "2020-11-18T11:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..2112bd4d5f 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -83,7 +83,7 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n             // We only want auctions in category 10.\n             .apply(name + \".InCategory\", Filter.by(auction -> auction.category == 10))\n \n-            // Key auctions by their seller id.\n+            // Key auctions by their seller id and move to union Event type.\n             .apply(\n                 \"EventByAuctionSeller\",\n                 ParDo.of(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODIwMg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525368202", "bodyText": "Ditto - simpler to use WithKeys", "author": "reuvenlax", "createdAt": "2020-11-17T17:54:09Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -115,19 +109,23 @@ public Query3(NexmarkConfiguration configuration) {\n                         \"OR\".equals(person.state)\n                             || \"ID\".equals(person.state)\n                             || \"CA\".equals(person.state)))\n+            .apply(", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzY0Ng==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526017646", "bodyText": "ditto", "author": "scwhittle", "createdAt": "2020-11-18T11:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..2112bd4d5f 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -109,6 +109,8 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n                         \"OR\".equals(person.state)\n                             || \"ID\".equals(person.state)\n                             || \"CA\".equals(person.state)))\n+\n+            // Key persons by their id and move to the union event type.\n             .apply(\n                 \"EventByPersonId\",\n                 ParDo.of(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQwNw==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525369407", "bodyText": "Instead of ProcessContext just inject @element and OutputReceiver parameters", "author": "reuvenlax", "createdAt": "2020-11-17T17:55:50Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNDI3Nw==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526014277", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..2112bd4d5f 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -194,7 +196,8 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n \n     @ProcessElement\n     public void processElement(\n-        ProcessContext c,\n+        @Element KV<Long, Event> element,\n+        OutputReceiver<KV<Auction, Person>> output,\n         @TimerId(STATE_EXPIRING) Timer timer,\n         @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n         @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDU1OA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525370558", "bodyText": "Comment - this is because Event is a union object, etc.", "author": "reuvenlax", "createdAt": "2020-11-17T17:57:29Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,\n-        @TimerId(PERSON_STATE_EXPIRING) Timer timer,\n-        @StateId(PERSON) ValueState<Person> personState,\n-        @StateId(AUCTIONS) ValueState<List<Auction>> auctionsState) {\n+        @TimerId(STATE_EXPIRING) Timer timer,\n+        @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n+        @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n       // We would *almost* implement this by  rewindowing into the global window and\n       // running a combiner over the result. The combiner's accumulator would be the\n       // state we use below. However, combiners cannot emit intermediate results, thus\n-      // we need to wait for the pending ReduceFn API.\n+      // we need to wait for the pending ReduceFn API\n \n       Person existingPerson = personState.read();\n-      if (existingPerson != null) {\n-        // We've already seen the new person event for this person id.\n-        // We can join with any new auctions on-the-fly without needing any\n-        // additional persistent state.\n-        for (Auction newAuction : c.element().getValue().getAll(NexmarkQueryUtil.AUCTION_TAG)) {\n-          newAuctionCounter.inc();\n-          newOldOutputCounter.inc();\n-          c.output(KV.of(newAuction, existingPerson));\n-        }\n-        return;\n-      }\n-\n-      Person theNewPerson = null;\n-      for (Person newPerson : c.element().getValue().getAll(NexmarkQueryUtil.PERSON_TAG)) {\n-        if (theNewPerson == null) {\n-          theNewPerson = newPerson;\n+      if (c.element().getValue().newPerson != null) {", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNTQ3MQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526015471", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..2112bd4d5f 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -194,7 +196,8 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n \n     @ProcessElement\n     public void processElement(\n-        ProcessContext c,\n+        @Element KV<Long, Event> element,\n+        OutputReceiver<KV<Auction, Person>> output,\n         @TimerId(STATE_EXPIRING) Timer timer,\n         @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n         @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTMzMg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525371332", "bodyText": "If this is not the first time this person has been seen, there's no point in even fetching auctionsState, right?", "author": "reuvenlax", "createdAt": "2020-11-17T17:58:43Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,\n-        @TimerId(PERSON_STATE_EXPIRING) Timer timer,\n-        @StateId(PERSON) ValueState<Person> personState,\n-        @StateId(AUCTIONS) ValueState<List<Auction>> auctionsState) {\n+        @TimerId(STATE_EXPIRING) Timer timer,\n+        @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n+        @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n       // We would *almost* implement this by  rewindowing into the global window and\n       // running a combiner over the result. The combiner's accumulator would be the\n       // state we use below. However, combiners cannot emit intermediate results, thus\n-      // we need to wait for the pending ReduceFn API.\n+      // we need to wait for the pending ReduceFn API\n \n       Person existingPerson = personState.read();\n-      if (existingPerson != null) {\n-        // We've already seen the new person event for this person id.\n-        // We can join with any new auctions on-the-fly without needing any\n-        // additional persistent state.\n-        for (Auction newAuction : c.element().getValue().getAll(NexmarkQueryUtil.AUCTION_TAG)) {\n-          newAuctionCounter.inc();\n-          newOldOutputCounter.inc();\n-          c.output(KV.of(newAuction, existingPerson));\n-        }\n-        return;\n-      }\n-\n-      Person theNewPerson = null;\n-      for (Person newPerson : c.element().getValue().getAll(NexmarkQueryUtil.PERSON_TAG)) {\n-        if (theNewPerson == null) {\n-          theNewPerson = newPerson;\n+      if (c.element().getValue().newPerson != null) {\n+        Person person = c.element().getValue().newPerson;\n+        if (existingPerson == null) {\n+          newPersonCounter.inc();\n+          personState.write(person);\n         } else {\n-          if (theNewPerson.equals(newPerson)) {\n-            LOG.error(\"Duplicate person {}\", theNewPerson);\n+          if (person.equals(existingPerson)) {\n+            LOG.error(\"Duplicate person {}\", person);\n           } else {\n-            LOG.error(\"Conflicting persons {} and {}\", theNewPerson, newPerson);\n+            LOG.error(\"Conflicting persons {} and {}\", existingPerson, person);\n           }\n           fatalCounter.inc();\n-          continue;\n         }\n-        newPersonCounter.inc();\n         // We've now seen the person for this person id so can flush any\n         // pending auctions for the same seller id (an auction is done by only one seller).", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNTUyMQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526015521", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..2112bd4d5f 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -194,7 +196,8 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n \n     @ProcessElement\n     public void processElement(\n-        ProcessContext c,\n+        @Element KV<Long, Event> element,\n+        OutputReceiver<KV<Auction, Person>> output,\n         @TimerId(STATE_EXPIRING) Timer timer,\n         @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n         @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525372949", "bodyText": "Why are you making the expiration timer a processing-time timer? Isn't event time more correct here?", "author": "reuvenlax", "createdAt": "2020-11-17T18:01:08Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -164,21 +165,19 @@ public void processElement(ProcessContext c) {\n     @StateId(PERSON)\n     private static final StateSpec<ValueState<Person>> personSpec = StateSpecs.value(Person.CODER);\n \n-    private static final String PERSON_STATE_EXPIRING = \"personStateExpiring\";\n+    private static final String STATE_EXPIRING = \"stateExpiring\";\n \n     @StateId(AUCTIONS)\n-    private final StateSpec<ValueState<List<Auction>>> auctionsSpec =\n-        StateSpecs.value(ListCoder.of(Auction.CODER));\n+    private final StateSpec<BagState<Auction>> auctionsSpec = StateSpecs.bag(Auction.CODER);\n \n-    @TimerId(PERSON_STATE_EXPIRING)\n-    private final TimerSpec timerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+    @TimerId(STATE_EXPIRING)", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxOTA5MA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526019090", "bodyText": "Processing time is more equivalent to flink background GC, which is why I changed.  The previous code was never gc'ing auctions without persons, which seemed incorrect.  If we want to use an event time timer, it seems that we would need to keep some additional state to keep track of the highest event time of buffered auctions or people, otherwise we could reset timer inappropriately for late events. What do you think?", "author": "scwhittle", "createdAt": "2020-11-18T11:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDExNTgwMA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r534115800", "bodyText": "Changed back to event time timer.", "author": "scwhittle", "createdAt": "2020-12-02T12:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "77d9d45ab2243c47059408e0252d5f9e8cb389c9", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\nindex 683a2c1bd5..11ca3d7aa7 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java\n\n@@ -171,7 +174,7 @@ public class Query3 extends NexmarkQueryTransform<NameCityStateId> {\n     private final StateSpec<BagState<Auction>> auctionsSpec = StateSpecs.bag(Auction.CODER);\n \n     @TimerId(STATE_EXPIRING)\n-    private final TimerSpec timerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+    private final TimerSpec timerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n \n     // Used to refer the metrics namespace\n     private final String name;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MzgzNg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525383836", "bodyText": "AvroCoder tends to be very inefficient. Either write a custom coder or use SchemaCoder. To use SchemaCoder return the following from getAccumulatorCoder (unfortunately it appears that combiners have not been integrated yet with the SchemaRegistry, as otherwise it would be much simpler - just annotating with @DefaultSchema)\nJavaFieldSchema provider = new JavaFieldSchema();\nTypeDescriptor typeDescriptor = new TypeDescriptor{}();\nreturn SchemaCoder.of(provider.schemaFor(typeDescriptor), provider.toRowFunction(typeDescriptor), provider.fromRowFunction(typeDescriptor));", "author": "reuvenlax", "createdAt": "2020-11-17T18:17:54Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java", "diffHunk": "@@ -53,6 +56,48 @@\n public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n   private final NexmarkConfiguration configuration;\n \n+  public static class TopCombineFn\n+      extends AccumulatingCombineFn<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n+    @Override\n+    public Accum createAccumulator() {\n+      return new Accum();\n+    }\n+\n+    @DefaultCoder(AvroCoder.class)", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA3MDI4OQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526070289", "bodyText": "done with tweaks", "author": "scwhittle", "createdAt": "2020-11-18T13:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MzgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\nindex 76e4365b6d..dc01134305 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\n\n@@ -63,7 +67,19 @@ public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n       return new Accum();\n     }\n \n-    @DefaultCoder(AvroCoder.class)\n+    @Override\n+    public Coder<Accum> getAccumulatorCoder(\n+        @NonNull CoderRegistry registry, @NonNull Coder<KV<Long, Long>> inputCoder) {\n+      JavaFieldSchema provider = new JavaFieldSchema();\n+      TypeDescriptor<Accum> typeDescriptor = new TypeDescriptor<Accum>() {};\n+      provider.schemaFor(typeDescriptor);\n+      return SchemaCoder.of(\n+          provider.schemaFor(typeDescriptor),\n+          typeDescriptor,\n+          provider.toRowFunction(typeDescriptor),\n+          provider.fromRowFunction(typeDescriptor));\n+    }\n+\n     public static class Accum\n         implements AccumulatingCombineFn.Accumulator<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n       private ArrayList<Long> auctions = new ArrayList<>();\n"}}, {"oid": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "url": "https://github.com/apache/beam/commit/69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-18T13:09:31Z", "type": "forcePushed"}, {"oid": "f9760400106ec5d06306d2f85b601f54b5545481", "url": "https://github.com/apache/beam/commit/f9760400106ec5d06306d2f85b601f54b5545481", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-19T11:59:01Z", "type": "forcePushed"}, {"oid": "77d9d45ab2243c47059408e0252d5f9e8cb389c9", "url": "https://github.com/apache/beam/commit/77d9d45ab2243c47059408e0252d5f9e8cb389c9", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-02T11:29:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQzMjA1Mg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r534432052", "bodyText": "why do you call schemaFor twice?", "author": "reuvenlax", "createdAt": "2020-12-02T19:38:29Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java", "diffHunk": "@@ -53,6 +63,79 @@\n public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n   private final NexmarkConfiguration configuration;\n \n+  public static class TopCombineFn\n+      extends AccumulatingCombineFn<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n+    @Override\n+    public Accum createAccumulator() {\n+      return new Accum();\n+    }\n+\n+    @Override\n+    public Coder<Accum> getAccumulatorCoder(\n+        @NonNull CoderRegistry registry, @NonNull Coder<KV<Long, Long>> inputCoder) {\n+      JavaFieldSchema provider = new JavaFieldSchema();\n+      TypeDescriptor<Accum> typeDescriptor = new TypeDescriptor<Accum>() {};\n+      provider.schemaFor(typeDescriptor);", "originalCommit": "77d9d45ab2243c47059408e0252d5f9e8cb389c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "chunk": "diff --git a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\nindex 441bea8219..77d64ab0b0 100644\n--- a/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\n+++ b/sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java\n\n@@ -63,6 +63,7 @@ import org.joda.time.Duration;\n public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n   private final NexmarkConfiguration configuration;\n \n+  /** CombineFn that takes bidders with counts and keeps all bidders with the top count. */\n   public static class TopCombineFn\n       extends AccumulatingCombineFn<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n     @Override\n"}}, {"oid": "7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "url": "https://github.com/apache/beam/commit/7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-03T12:10:20Z", "type": "commit"}, {"oid": "7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "url": "https://github.com/apache/beam/commit/7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-03T12:10:20Z", "type": "forcePushed"}]}