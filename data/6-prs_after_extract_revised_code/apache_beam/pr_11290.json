{"pr_number": 11290, "pr_title": "[BEAM-9670] Fix nullability widening in CoGroup key resolution", "pr_createdAt": "2020-04-02T07:09:53Z", "pr_url": "https://github.com/apache/beam/pull/11290", "timeline": [{"oid": "b2ceb00f1bc681250c46af64b20b46e589414ad4", "url": "https://github.com/apache/beam/commit/b2ceb00f1bc681250c46af64b20b46e589414ad4", "message": "fix nullable widening", "committedDate": "2020-04-02T07:04:41Z", "type": "commit"}, {"oid": "789664619f034a4cce70a2e1479f9704a13eed26", "url": "https://github.com/apache/beam/commit/789664619f034a4cce70a2e1479f9704a13eed26", "message": "fix dead stores", "committedDate": "2020-04-02T07:39:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402450787", "bodyText": "Shouldn't we still verify that the schemas have equivalent types without nullability?", "author": "TheNeuralBit", "createdAt": "2020-04-02T16:34:38Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -63,16 +62,6 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n-    Schema leftSchema = leftRows.getSchema();\n-    Schema rightSchema = rightRows.getSchema();\n-    if (!leftSchema.typesEqual(rightSchema)) {\n-      throw new IllegalArgumentException(\n-          \"Can't intersect two tables with different schemas.\"\n-              + \"lhsSchema: \"\n-              + leftSchema\n-              + \"  rhsSchema: \"\n-              + rightSchema);\n-    }", "originalCommit": "789664619f034a4cce70a2e1479f9704a13eed26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NzcyNg==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402457726", "bodyText": "The merge function itself now verifies this.", "author": "reuvenlax", "createdAt": "2020-04-02T16:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3MjAwMQ==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402472001", "bodyText": "Ah I see. If there aren't any tests verifying this already could you add one?", "author": "TheNeuralBit", "createdAt": "2020-04-02T17:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3MzMzMQ==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402473331", "bodyText": "There is a test in CoGroupTest.java that verifies this. Should I add an additional one here?", "author": "reuvenlax", "createdAt": "2020-04-02T17:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3Nzg0NQ==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402477845", "bodyText": "It could be nice to have something in ZetaSQLDialectSpecTest to verify the set operation just in case we break the logic there and not in CoGroup, but I guess it's fine either way", "author": "TheNeuralBit", "createdAt": "2020-04-02T17:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1MDc4Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NDcxOQ==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402454719", "bodyText": "Just a general comment: do you think we should add a visitor pattern for this sort of thing?", "author": "TheNeuralBit", "createdAt": "2020-04-02T16:40:31Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaUtils.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+\n+/** A set of utility functions for schemas. */\n+public class SchemaUtils {\n+  /**\n+   * Given two schema that have matching types, return a nullable-widened schema.\n+   *\n+   * <p>The schemas must have matching types, except for field names which can differ. The returned\n+   * schema will contain the field names in the first schema. All field types will be nullable if\n+   * the corresponding field type is nullable in either of the input schemas.\n+   */\n+  public static Schema mergeWideningNullable(Schema schema1, Schema schema2) {\n+    if (schema1.getFieldCount() != schema2.getFieldCount()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge schemas with different numbers of fields. \"\n+              + \"schema1: \"\n+              + schema1\n+              + \" schema2: \"\n+              + schema2);\n+    }\n+    Schema.Builder builder = Schema.builder();\n+    for (int i = 0; i < schema1.getFieldCount(); ++i) {\n+      String name = schema1.getField(i).getName();\n+      builder.addField(\n+          name, widenNullableTypes(schema1.getField(i).getType(), schema2.getField(i).getType()));\n+    }\n+    return builder.build();\n+  }\n+\n+  static FieldType widenNullableTypes(FieldType fieldType1, FieldType fieldType2) {\n+    if (fieldType1.getTypeName() != fieldType2.getTypeName()) {\n+      throw new IllegalArgumentException(\n+          \"Cannot merge two types: \"\n+              + fieldType1.getTypeName()\n+              + \" and \"\n+              + fieldType2.getTypeName());\n+    }\n+\n+    FieldType result;\n+    switch (fieldType1.getTypeName()) {\n+      case ROW:\n+        result =\n+            FieldType.row(\n+                mergeWideningNullable(fieldType1.getRowSchema(), fieldType2.getRowSchema()));\n+        break;\n+      case ARRAY:\n+        FieldType arrayElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.array(arrayElementType);\n+        break;\n+      case ITERABLE:\n+        FieldType iterableElementType =\n+            widenNullableTypes(\n+                fieldType1.getCollectionElementType(), fieldType2.getCollectionElementType());\n+        result = FieldType.iterable(iterableElementType);\n+        break;\n+      case MAP:\n+        FieldType keyType =\n+            widenNullableTypes(fieldType1.getMapKeyType(), fieldType2.getMapKeyType());\n+        FieldType valueType =\n+            widenNullableTypes(fieldType1.getMapValueType(), fieldType2.getMapValueType());\n+        result = FieldType.map(keyType, valueType);\n+        break;\n+      case LOGICAL_TYPE:\n+        if (!fieldType1\n+            .getLogicalType()\n+            .getIdentifier()\n+            .equals(fieldType2.getLogicalType().getIdentifier())) {\n+          throw new IllegalArgumentException(\n+              \"Logical types don't match and cannot be merged: \"\n+                  + fieldType1.getLogicalType().getIdentifier()\n+                  + \".v.s\"\n+                  + fieldType2.getLogicalType().getIdentifier());\n+        }\n+        // fall through\n+      default:\n+        result = fieldType1;\n+    }\n+    return result.withNullable(fieldType1.getNullable() || fieldType2.getNullable());", "originalCommit": "789664619f034a4cce70a2e1479f9704a13eed26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1Nzc1Mw==", "url": "https://github.com/apache/beam/pull/11290#discussion_r402457753", "bodyText": "Maybe? I'm not sure visitor per se, as we don't require double dispatch. However we might consider generalizing the recursive tree walk.", "author": "reuvenlax", "createdAt": "2020-04-02T16:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ1NDcxOQ=="}], "type": "inlineReview", "revised_code": null}]}