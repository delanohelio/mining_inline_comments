{"pr_number": 12551, "pr_title": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "pr_createdAt": "2020-08-12T18:24:34Z", "pr_url": "https://github.com/apache/beam/pull/12551", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2Nzg4NA==", "url": "https://github.com/apache/beam/pull/12551#discussion_r469767884", "bodyText": "This is very expensive in terms of memory.", "author": "mxm", "createdAt": "2020-08-13T07:59:52Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1230,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final SortedMap<Long, Set<String>> outputTimestamps = new TreeMap<>();", "originalCommit": "72c260af8fff12208308a4e124a35300ab250889", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3NDIyNQ==", "url": "https://github.com/apache/beam/pull/12551#discussion_r469774225", "bodyText": "Agree, that's why I don't generally like this solution and would like to come up with different one.", "author": "je-ik", "createdAt": "2020-08-13T08:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2Nzg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "fe75b7e01d55a0c24486b032330d26d66b57f9c2", "chunk": "diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\nindex 73d4a83284..161534be89 100644\n--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n\n@@ -1230,7 +1227,7 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final SortedMap<Long, Set<String>> outputTimestamps = new TreeMap<>();\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();\n \n     private FlinkTimerInternals() {\n       MapStateDescriptor<String, TimerData> pendingTimersByIdStateDescriptor =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ==", "url": "https://github.com/apache/beam/pull/12551#discussion_r469769025", "bodyText": "IMHO there is no need to store the timer id here.", "author": "mxm", "createdAt": "2020-08-13T08:01:57Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1277,7 +1280,13 @@ private void onNewEventTimer(TimerData newTimer) {\n           \"Timer with id %s is not an event time timer!\",\n           newTimer.getTimerId());\n       if (timerUsesOutputTimestamp(newTimer)) {\n-        outputTimestampQueue.add(newTimer.getOutputTimestamp().getMillis());\n+        outputTimestamps.compute(\n+            newTimer.getOutputTimestamp().getMillis(),\n+            (k, v) -> {\n+              Set<String> timerIds = v == null ? new HashSet<>() : v;\n+              timerIds.add(getContextTimerId(newTimer.getTimerId(), newTimer.getNamespace()));", "originalCommit": "72c260af8fff12208308a4e124a35300ab250889", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3NDczNQ==", "url": "https://github.com/apache/beam/pull/12551#discussion_r469774735", "bodyText": "It should not. But in some cases, a timer output timestamp seems to appear in the queue twice (for the same timer) and removed only once, which causes the pipeline to get stuck.", "author": "je-ik", "createdAt": "2020-08-13T08:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3Nzk2Mw==", "url": "https://github.com/apache/beam/pull/12551#discussion_r469777963", "bodyText": "Duplicates are ok. If we have multiple timers set with different ids or even for the same keys, duplicates are expected. We could use a TreeMap instead of a PriorityQueue like we do in FlinkTimerInterals for the WatermarkHoldState, but I don't see anything wrong with the implementation here.\nYou likely have a problem in your application code, i.e. you set a timer output timestamp which holds back the watermark but your fire timestamp has not been reached by the watermark yet. Please investigate that first. Also note #12531 which was a bug in the Python SDK.", "author": "mxm", "createdAt": "2020-08-13T08:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc2OTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8ea092afefe8e3602d73c591e92a7ff5250684f5", "chunk": "diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\nindex 73d4a83284..918c84b27e 100644\n--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n\n@@ -1284,7 +1284,9 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window\n             newTimer.getOutputTimestamp().getMillis(),\n             (k, v) -> {\n               Set<String> timerIds = v == null ? new HashSet<>() : v;\n-              timerIds.add(getContextTimerId(newTimer.getTimerId(), newTimer.getNamespace()));\n+              Preconditions.checkState(\n+                  timerIds.add(getContextTimerId(newTimer.getTimerId(),\n+                  newTimer.getNamespace())));\n               return timerIds;\n             });\n       }\n"}}, {"oid": "8ea092afefe8e3602d73c591e92a7ff5250684f5", "url": "https://github.com/apache/beam/commit/8ea092afefe8e3602d73c591e92a7ff5250684f5", "message": "[BEAM-10691] add failing precondition check", "committedDate": "2020-08-13T11:35:23Z", "type": "forcePushed"}, {"oid": "fe75b7e01d55a0c24486b032330d26d66b57f9c2", "url": "https://github.com/apache/beam/commit/fe75b7e01d55a0c24486b032330d26d66b57f9c2", "message": "[BEAM-10691] change PriorityQueue to TreeMultiset for keeping track of timer output timestamps", "committedDate": "2020-08-14T12:50:51Z", "type": "forcePushed"}, {"oid": "d00291a6949b2b5afdbc0e08e58f12f507c1f656", "url": "https://github.com/apache/beam/commit/d00291a6949b2b5afdbc0e08e58f12f507c1f656", "message": "[BEAM-10691] change PriorityQueue to TreeMultiset for keeping track of timer output timestamps", "committedDate": "2020-08-14T13:11:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470623744", "bodyText": "We could also consider making this even more efficient by using a TreeMap<Long, Integer> where the key is the output timestamp and the value the number of timers which have set it, similar to how it's done in FlinkStateInternals for the watermark holds.\nFurther, we could remove outputTimestamps entirely and simply use stateInternals.addWatermarkHoldUsage(output_timestamp) and stateInternals.removeWatermarkHoldUsage(output_timestamp).", "author": "mxm", "createdAt": "2020-08-14T13:29:24Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -1226,7 +1227,7 @@ public TimerInternals timerInternals() {\n      * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n      * timer data from the state backend which is expensive if done for each timer.\n      */\n-    private final PriorityQueue<Long> outputTimestampQueue;\n+    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();", "originalCommit": "d00291a6949b2b5afdbc0e08e58f12f507c1f656", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNzUzNw==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470627537", "bodyText": "I don't know the internal details of TreeMultiset, but I'd suppose it to be pretty much the same as Map<Long, Integer> in terms of performance. Removing the outputTimestamps entirely seems to be the best option. I'll try that and let you know.", "author": "je-ik", "createdAt": "2020-08-14T13:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyOTY2OA==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470629668", "bodyText": "Maybe we could replace the TreeMap<Long, Integer> with the TreeMultiset?", "author": "je-ik", "createdAt": "2020-08-14T13:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMzEyMQ==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470633121", "bodyText": "Why would we do this? TreeMap<Long, Integer> seems like the better data structure because it stores the data compacted.", "author": "mxm", "createdAt": "2020-08-14T13:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNjU2Nw==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470636567", "bodyText": "TreeMultiset does the same. And saves some code and performance, the value is stored as array of length 1 and thus adding an already existing item to the set is just get() and in-place increment, while the TreeMap must do get & replace. I think the biggest argument here is that the code is more readable, though. I'll update the PR in a sec, so that you can see.", "author": "je-ik", "createdAt": "2020-08-14T13:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzODQzMQ==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470638431", "bodyText": "Pushed", "author": "je-ik", "createdAt": "2020-08-14T13:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1MDUxNw==", "url": "https://github.com/apache/beam/pull/12551#discussion_r470650517", "bodyText": "Wasn't familiar with the internals of TreeMultiSet but if that's the case, it sounds excellent! :)", "author": "mxm", "createdAt": "2020-08-14T14:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "ec03667b087b27ba5be21e94a0b5e11ddfbac0c5", "chunk": "diff --git a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\nindex 5747336bb4..a69cd83afb 100644\n--- a/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n+++ b/runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java\n\n@@ -1222,13 +1219,6 @@ public class DoFnOperator<InputT, OutputT> extends AbstractStreamOperator<Window\n      */\n     @VisibleForTesting final MapState<String, TimerData> pendingTimersById;\n \n-    /**\n-     * Sorted cache of the output timestamps for timers which have an earlier output time than the\n-     * fire time of the timer. Used for calculating the output watermark hold. This avoids fetching\n-     * timer data from the state backend which is expensive if done for each timer.\n-     */\n-    private final TreeMultiset<Long> outputTimestamps = TreeMultiset.create();\n-\n     private FlinkTimerInternals() {\n       MapStateDescriptor<String, TimerData> pendingTimersByIdStateDescriptor =\n           new MapStateDescriptor<>(\n"}}, {"oid": "ec03667b087b27ba5be21e94a0b5e11ddfbac0c5", "url": "https://github.com/apache/beam/commit/ec03667b087b27ba5be21e94a0b5e11ddfbac0c5", "message": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "committedDate": "2020-08-14T13:57:10Z", "type": "forcePushed"}, {"oid": "b6d338852b46f9d34cbc202f3df59341f0474f00", "url": "https://github.com/apache/beam/commit/b6d338852b46f9d34cbc202f3df59341f0474f00", "message": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "committedDate": "2020-08-14T14:20:29Z", "type": "forcePushed"}, {"oid": "cbc3031a7c9293729f8487082ba15ca994c7f70e", "url": "https://github.com/apache/beam/commit/cbc3031a7c9293729f8487082ba15ca994c7f70e", "message": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "committedDate": "2020-08-14T15:53:15Z", "type": "forcePushed"}, {"oid": "55874cc74a17dda87de5b2ffdb1253c759de888b", "url": "https://github.com/apache/beam/commit/55874cc74a17dda87de5b2ffdb1253c759de888b", "message": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "committedDate": "2020-08-14T16:05:24Z", "type": "commit"}, {"oid": "55874cc74a17dda87de5b2ffdb1253c759de888b", "url": "https://github.com/apache/beam/commit/55874cc74a17dda87de5b2ffdb1253c759de888b", "message": "[BEAM-10691] Use FlinkStateInternals#addWatermarkHoldUsage for timer output timestamp", "committedDate": "2020-08-14T16:05:24Z", "type": "forcePushed"}]}