{"pr_number": 11065, "pr_title": "[BEAM-2939, BEAM-9458] Add deduplication transform", "pr_createdAt": "2020-03-06T22:05:28Z", "pr_url": "https://github.com/apache/beam/pull/11065", "timeline": [{"oid": "8af39e6ef55cc18d459d8c9e7f543d05dc2d1e0f", "url": "https://github.com/apache/beam/commit/8af39e6ef55cc18d459d8c9e7f543d05dc2d1e0f", "message": "[BEAM-2939, BEAM-9458] Add deduplication transform for SplittableDoFns\n\nThis enables migrating the remaining UnboundedSources to use the UnboundedSoure SDF wrapper.", "committedDate": "2020-03-06T22:01:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTgzOQ==", "url": "https://github.com/apache/beam/pull/11065#discussion_r389191839", "bodyText": "You aren't actually using the value, could you use Void instead?\nhttps://github.com/apache/beam/blob/279a05604b83a54e8e5a79e13d8761f94841f326/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/VoidCoder.java", "author": "apilloud", "createdAt": "2020-03-06T23:27:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Deduplicate.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.state.StateSpec;\n+import org.apache.beam.sdk.state.StateSpecs;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.state.Timer;\n+import org.apache.beam.sdk.state.TimerSpec;\n+import org.apache.beam.sdk.state.TimerSpecs;\n+import org.apache.beam.sdk.state.ValueState;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.joda.time.Duration;\n+\n+/**\n+ * A set of {@link PTransform}s which deduplicate input records over a time domain and threshold.\n+ * Values in different windows will not be considered duplicates of each other. Deduplication is\n+ * best effort.\n+ *\n+ * <p>Two values of type {@code T} are compared for equality <b>not</b> by regular Java {@link\n+ * Object#equals}, but instead by first encoding each of the elements using the {@code\n+ * PCollection}'s {@code Coder}, and then comparing the encoded bytes. This admits efficient\n+ * parallel evaluation.\n+ *\n+ * <p>These PTransforms are different then {@link Distinct} since {@link Distinct} guarantees\n+ * uniqueness of values within a {@link PCollection} but may support a narrower set of {@link\n+ * org.apache.beam.sdk.values.WindowingStrategy windowing strategies} or may delay when output is\n+ * produced.\n+ *\n+ * <p>The durations specified may impose memory and/or storage requirements within a runner and care\n+ * might need to be used to ensure that the deduplication time limit is long enough to remove\n+ * duplicates but short enough to not cause performance problems within a runner. Each runner may\n+ * provide an optimized implementation of their choice using the deduplication time domain and\n+ * threshold specified.\n+ *\n+ * <p>Does not preserve any order the input PCollection might have had.\n+ *\n+ * <p>Example of use:\n+ *\n+ * <pre>{@code\n+ * PCollection<String> words = ...;\n+ * PCollection<String> deduplicatedWords =\n+ *     words.apply(Deduplicate.<String>values());\n+ * }</pre>\n+ */\n+public final class Deduplicate {\n+  /** The default is the {@link TimeDomain#PROCESSING_TIME processing time domain}. */\n+  public static final TimeDomain DEFAULT_TIME_DOMAIN = TimeDomain.PROCESSING_TIME;\n+  /** The default duration is 10 mins. */\n+  public static final Duration DEFAULT_DURATION = Duration.standardMinutes(10);\n+\n+  /**\n+   * Deduplicates values over a specified time domain and threshold. Construct via {@link\n+   * Deduplicate#values()}.\n+   */\n+  public static final class Values<T> extends PTransform<PCollection<T>, PCollection<T>> {\n+    private final TimeDomain timeDomain;\n+    private final Duration duration;\n+\n+    private Values(TimeDomain timeDomain, Duration duration) {\n+      this.timeDomain = timeDomain;\n+      this.duration = duration;\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<T> input) {\n+      return input\n+          .apply(\n+              \"KeyByElement\",\n+              MapElements.via(\n+                  new SimpleFunction<T, KV<T, Void>>() {\n+                    @Override\n+                    public KV<T, Void> apply(T element) {\n+                      return KV.of(element, (Void) null);\n+                    }\n+                  }))\n+          .apply(new KeyedValues<>(timeDomain, duration))\n+          .apply(Keys.create());\n+    }\n+\n+    /**\n+     * Returns a {@code Values} {@link PTransform} like this one but with the specified time domain.\n+     */\n+    public Values<T> withTimeDomain(TimeDomain timeDomain) {\n+      return new Values<T>(timeDomain, duration);\n+    }\n+\n+    /**\n+     * Returns a {@code Values} {@link PTransform} like this one but with the specified duration.\n+     */\n+    public Values<T> withDuration(Duration duration) {\n+      return new Values<T>(timeDomain, duration);\n+    }\n+  }\n+\n+  /**\n+   * A {@link PTransform} that uses a {@link SerializableFunction} to obtain a representative value\n+   * for each input element used for deduplication.\n+   *\n+   * <p>Construct via {@link Deduplicate#withRepresentativeValueFn}.\n+   *\n+   * @param <T> the type of input and output element\n+   * @param <IdT> the type of representative values used to dedup\n+   */\n+  public static final class WithRepresentativeValues<T, IdT>\n+      extends PTransform<PCollection<T>, PCollection<T>> {\n+    private final SerializableFunction<T, IdT> fn;\n+    @Nullable private final TypeDescriptor<IdT> type;\n+    @Nullable private final Coder<IdT> coder;\n+    private final TimeDomain timeDomain;\n+    private final Duration duration;\n+\n+    private WithRepresentativeValues(\n+        TimeDomain timeDomain,\n+        Duration duration,\n+        SerializableFunction<T, IdT> fn,\n+        @Nullable TypeDescriptor<IdT> type,\n+        @Nullable Coder<IdT> coder) {\n+      this.timeDomain = timeDomain;\n+      this.duration = duration;\n+      this.fn = fn;\n+      this.type = type;\n+      this.coder = coder;\n+    }\n+\n+    /**\n+     * Return a {@code WithRepresentativeValues} {@link PTransform} that is like this one, but with\n+     * the specified id type descriptor.\n+     *\n+     * <p>Either {@link #withRepresentativeCoder} or this method must be invoked if using {@link\n+     * Deduplicate#withRepresentativeValueFn} in Java 8 with a lambda as the fn.\n+     *\n+     * @param type a {@link TypeDescriptor} describing the representative type of this {@code\n+     *     WithRepresentativeValues}\n+     * @return A {@code WithRepresentativeValues} {@link PTransform} that is like this one, but with\n+     *     the specified representative value type descriptor. Any previously set representative\n+     *     value coder will be cleared.\n+     */\n+    public WithRepresentativeValues<T, IdT> withRepresentativeType(TypeDescriptor<IdT> type) {\n+      return new WithRepresentativeValues<>(timeDomain, duration, fn, type, null);\n+    }\n+\n+    /**\n+     * Return a {@code WithRepresentativeValues} {@link PTransform} that is like this one, but with\n+     * the specified id type coder.\n+     *\n+     * <p>Required for use of {@link Deduplicate#withRepresentativeValueFn} in Java 8 with a lambda\n+     * as the fn.\n+     *\n+     * @param coder a {@link Coder} capable of encoding the representative type of this {@code\n+     *     WithRepresentativeValues}\n+     * @return A {@code WithRepresentativeValues} {@link PTransform} that is like this one, but with\n+     *     the specified representative value coder. Any previously set representative value type\n+     *     descriptor will be cleared.\n+     */\n+    public WithRepresentativeValues<T, IdT> withRepresentativeCoder(Coder<IdT> coder) {\n+      return new WithRepresentativeValues<>(timeDomain, duration, fn, null, coder);\n+    }\n+\n+    /**\n+     * Returns a {@code WithRepresentativeValues} {@link PTransform} like this one but with the\n+     * specified time domain.\n+     */\n+    public WithRepresentativeValues<T, IdT> withTimeDomain(TimeDomain timeDomain) {\n+      return new WithRepresentativeValues<>(timeDomain, duration, fn, type, coder);\n+    }\n+\n+    /**\n+     * Return a {@code WithRepresentativeValues} {@link PTransform} that is like this one, but with\n+     * the specified deduplication duration.\n+     */\n+    public WithRepresentativeValues<T, IdT> withDuration(Duration duration) {\n+      return new WithRepresentativeValues<>(timeDomain, duration, fn, type, coder);\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<T> input) {\n+      WithKeys<IdT, T> withKeys = WithKeys.of(fn);\n+      if (type != null) {\n+        withKeys = withKeys.withKeyType(type);\n+      }\n+      PCollection<KV<IdT, T>> inputWithKey = input.apply(withKeys);\n+      if (coder != null) {\n+        inputWithKey.setCoder(KvCoder.of(coder, input.getCoder()));\n+      }\n+      return inputWithKey\n+          .apply(new KeyedValues<>(timeDomain, duration))\n+          .apply(org.apache.beam.sdk.transforms.Values.create());\n+    }\n+  }\n+\n+  /**\n+   * Deduplicates keyed values using the key over a specified time domain and threshold. Construct\n+   * via {@link Deduplicate#keyedValues()} ()}.\n+   */\n+  public static final class KeyedValues<K, V>\n+      extends PTransform<PCollection<KV<K, V>>, PCollection<KV<K, V>>> {\n+    private final TimeDomain timeDomain;\n+    private final Duration duration;\n+\n+    private KeyedValues(TimeDomain timeDomain, Duration duration) {\n+      this.timeDomain = timeDomain;\n+      this.duration = duration;\n+    }\n+\n+    @Override\n+    public PCollection<KV<K, V>> expand(PCollection<KV<K, V>> input) {\n+      return input.apply(ParDo.of(new DeduplicateFn<>(timeDomain, duration)));\n+    }\n+\n+    /**\n+     * Returns a {@code KeyedValues} {@link PTransform} like this one but with the specified time\n+     * domain.\n+     */\n+    public KeyedValues<K, V> withTimeDomain(TimeDomain timeDomain) {\n+      return new KeyedValues<>(timeDomain, duration);\n+    }\n+\n+    /**\n+     * Returns a {@code KeyedValues} {@link PTransform} like this one but with the specified\n+     * duration.\n+     */\n+    public KeyedValues<K, V> withDuration(Duration duration) {\n+      return new KeyedValues<>(timeDomain, duration);\n+    }\n+  }\n+\n+  /**\n+   * Returns a deduplication transform that deduplicates values for up to 10 mins within the {@link\n+   * TimeDomain#PROCESSING_TIME processing time domain}.\n+   */\n+  public static <T> Deduplicate.Values<T> values() {\n+    return new Deduplicate.Values<>(DEFAULT_TIME_DOMAIN, DEFAULT_DURATION);\n+  }\n+\n+  /**\n+   * Returns a deduplication transform that deduplicates keyed values using the key for up to 10\n+   * mins within the {@link TimeDomain#PROCESSING_TIME processing time domain}.\n+   */\n+  public static <K, V> Deduplicate.KeyedValues<K, V> keyedValues() {\n+    return new Deduplicate.KeyedValues<>(DEFAULT_TIME_DOMAIN, DEFAULT_DURATION);\n+  }\n+\n+  /**\n+   * Returns a deduplication transform that deduplicates values using the supplied representative\n+   * value for up to 10 mins within the {@link TimeDomain#PROCESSING_TIME processing time domain}.\n+   */\n+  public static <T, IdT> Deduplicate.WithRepresentativeValues<T, IdT> withRepresentativeValueFn(\n+      SerializableFunction<T, IdT> representativeValueFn) {\n+    return new Deduplicate.WithRepresentativeValues<T, IdT>(\n+        DEFAULT_TIME_DOMAIN, DEFAULT_DURATION, representativeValueFn, null, null);\n+  }\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  // prevent instantiation\n+  private Deduplicate() {}\n+\n+  /**\n+   * A stateful {@link DoFn} that uses a {@link ValueState} to capture whether the value has ever\n+   * been seen.\n+   *\n+   * @param <K>\n+   * @param <V>\n+   */\n+  private static class DeduplicateFn<K, V> extends DoFn<KV<K, V>, KV<K, V>> {\n+    private static final String EXPIRY_TIMER = \"expiryTimer\";\n+    private static final String SEEN_STATE = \"seen\";\n+\n+    @TimerId(EXPIRY_TIMER)\n+    private final TimerSpec expiryTimerSpec;\n+\n+    @StateId(SEEN_STATE)\n+    private final StateSpec<ValueState<Boolean>> seenState = StateSpecs.value(BooleanCoder.of());\n+\n+    private final Duration duration;\n+\n+    private DeduplicateFn(TimeDomain timeDomain, Duration duration) {\n+      this.expiryTimerSpec = TimerSpecs.timer(timeDomain);\n+      this.duration = duration;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<K, V> element,\n+        OutputReceiver<KV<K, V>> receiver,\n+        @StateId(SEEN_STATE) ValueState<Boolean> seenState,\n+        @TimerId(EXPIRY_TIMER) Timer expiryTimer) {\n+      Boolean seen = seenState.read();\n+      // Seen state is either set or not set so if it has been set then it must be true.", "originalCommit": "8af39e6ef55cc18d459d8c9e7f543d05dc2d1e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NTM3NQ==", "url": "https://github.com/apache/beam/pull/11065#discussion_r389195375", "bodyText": "ValueState doesn't support telling you whether the value is set and returns null if it isn't set, so using a VoidCoder would also return null if it was set.", "author": "lukecwik", "createdAt": "2020-03-06T23:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NjMzNw==", "url": "https://github.com/apache/beam/pull/11065#discussion_r389196337", "bodyText": "To my knowledge there is some existing complication about the encoding format that prevents isSet to be added to ValueSet since we can't tell whether its 0 bytes and exists vs 0 bytes and doesn't exist.", "author": "lukecwik", "createdAt": "2020-03-06T23:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTgzOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQwNzcyOA==", "url": "https://github.com/apache/beam/pull/11065#discussion_r389407728", "bodyText": "@lukecwik Maybe we should mark this one as @Experimental for the moment specially since it is coming directly to core.", "author": "iemejia", "createdAt": "2020-03-08T21:39:34Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Deduplicate.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.state.StateSpec;\n+import org.apache.beam.sdk.state.StateSpecs;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.state.Timer;\n+import org.apache.beam.sdk.state.TimerSpec;\n+import org.apache.beam.sdk.state.TimerSpecs;\n+import org.apache.beam.sdk.state.ValueState;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.joda.time.Duration;\n+\n+/**\n+ * A set of {@link PTransform}s which deduplicate input records over a time domain and threshold.\n+ * Values in different windows will not be considered duplicates of each other. Deduplication is\n+ * best effort.\n+ *\n+ * <p>Two values of type {@code T} are compared for equality <b>not</b> by regular Java {@link\n+ * Object#equals}, but instead by first encoding each of the elements using the {@code\n+ * PCollection}'s {@code Coder}, and then comparing the encoded bytes. This admits efficient\n+ * parallel evaluation.\n+ *\n+ * <p>These PTransforms are different then {@link Distinct} since {@link Distinct} guarantees\n+ * uniqueness of values within a {@link PCollection} but may support a narrower set of {@link\n+ * org.apache.beam.sdk.values.WindowingStrategy windowing strategies} or may delay when output is\n+ * produced.\n+ *\n+ * <p>The durations specified may impose memory and/or storage requirements within a runner and care\n+ * might need to be used to ensure that the deduplication time limit is long enough to remove\n+ * duplicates but short enough to not cause performance problems within a runner. Each runner may\n+ * provide an optimized implementation of their choice using the deduplication time domain and\n+ * threshold specified.\n+ *\n+ * <p>Does not preserve any order the input PCollection might have had.\n+ *\n+ * <p>Example of use:\n+ *\n+ * <pre>{@code\n+ * PCollection<String> words = ...;\n+ * PCollection<String> deduplicatedWords =\n+ *     words.apply(Deduplicate.<String>values());\n+ * }</pre>\n+ */\n+public final class Deduplicate {", "originalCommit": "8af39e6ef55cc18d459d8c9e7f543d05dc2d1e0f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}