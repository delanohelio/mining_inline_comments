{"pr_number": 13395, "pr_title": "[BEAM-11426] Add FHIR Search to io/gcp/healthcare/FhirIO", "pr_createdAt": "2020-11-20T17:27:57Z", "pr_url": "https://github.com/apache/beam/pull/13395", "timeline": [{"oid": "37f1134ae5c96016036442062ed0ec5a7e6edcb4", "url": "https://github.com/apache/beam/commit/37f1134ae5c96016036442062ed0ec5a7e6edcb4", "message": "Add Search to FHIRIO", "committedDate": "2020-11-20T05:31:51Z", "type": "commit"}, {"oid": "c7ce0ed246618a594596248882259594c332eb0c", "url": "https://github.com/apache/beam/commit/c7ce0ed246618a594596248882259594c332eb0c", "message": "Add Search to FHIRIO", "committedDate": "2020-11-20T17:14:59Z", "type": "commit"}, {"oid": "cba4b260ba9d370e6034ee754242f913074138ab", "url": "https://github.com/apache/beam/commit/cba4b260ba9d370e6034ee754242f913074138ab", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-11-20T17:17:38Z", "type": "commit"}, {"oid": "7015ba7b4c520c2c2ae78ede16fa0aa1ee27ca61", "url": "https://github.com/apache/beam/commit/7015ba7b4c520c2c2ae78ede16fa0aa1ee27ca61", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-11-20T17:23:17Z", "type": "commit"}, {"oid": "1cedaed15134216b919b1ae5c42ba487b8faf421", "url": "https://github.com/apache/beam/commit/1cedaed15134216b919b1ae5c42ba487b8faf421", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-11-20T17:24:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1MzI5NA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r527953294", "bodyText": "Should we pass the queries in as well, or is it part of fhirStore?", "author": "lastomato", "createdAt": "2020-11-20T20:28:22Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -215,6 +215,16 @@ public static Read readResources() {\n     return new Read();\n   }\n \n+  /**\n+   * Search resources from a PCollection\n+   *\n+   * @return the search\n+   * @see Search\n+   */\n+  public static Search searchResources(String fhirStore) {", "originalCommit": "1cedaed15134216b919b1ae5c42ba487b8faf421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MTQyNg==", "url": "https://github.com/apache/beam/pull/13395#discussion_r527961426", "bodyText": "I just realized that your case is totally different from what I thought, I expect a single query is used to generate the input to the pipeline, while it looks like we are doing something in reverse here, the search parameters are from the input. Can you confirm this is indeed the use case you have in mind? Please feel free to reach out to me offline.", "author": "lastomato", "createdAt": "2020-11-20T20:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1MzI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcyNzc2Mg==", "url": "https://github.com/apache/beam/pull/13395#discussion_r528727762", "bodyText": "I'll reply in an email offline.", "author": "janeliulwq", "createdAt": "2020-11-23T14:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1MzI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 3c1a1d7f4e..257d9f4a5c 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -196,1408 +205,1485 @@ import org.slf4j.LoggerFactory;\n  * DeidentifyConfig deidConfig = new DeidentifyConfig(); // use default DeidentifyConfig\n  * pipeline.apply(FhirIO.deidentify(fhirStoreName, destinationFhirStoreName, deidConfig));\n  *\n+ * // Search FHIR resources.\n+ * PCollection<KV<String, Map<String, Object>>> searchQueries = ...;\n+ * FhirIO.Search.Result searchResult =\n+ *      searchQueries.apply(FhirIO.searchResources(options.getFhirStore()));\n+ *\n  * }***\n  * </pre>\n  */\n @SuppressWarnings({\n-  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+        \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n })\n public class FhirIO {\n \n-  /**\n-   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n-   * notifications)\n-   *\n-   * @return the read\n-   * @see Read\n-   */\n-  public static Read readResources() {\n-    return new Read();\n-  }\n-\n-  /**\n-   * Search resources from a PCollection\n-   *\n-   * @return the search\n-   * @see Search\n-   */\n-  public static Search searchResources(String fhirStore) {\n-    return new Search(fhirStore);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      String fhirStore,\n-      String tempDir,\n-      String deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      ValueProvider<String> fhirStore,\n-      ValueProvider<String> tempDir,\n-      ValueProvider<String> deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n-    return new Export(\n-        StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(\n-      ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-    return new Export(fhirStore, exportGcsUriPrefix);\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n-    return new Deidentify(\n-        StaticValueProvider.of(sourceFhirStore),\n-        StaticValueProvider.of(destinationFhirStore),\n-        StaticValueProvider.of(deidConfig));\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      ValueProvider<String> sourceFhirStore,\n-      ValueProvider<String> destinationFhirStore,\n-      ValueProvider<DeidentifyConfig> deidConfig) {\n-    return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n-  }\n-\n-  /** The type Read. */\n-  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n-\n-    /** Instantiates a new Read. */\n-    public Read() {}\n-\n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedReads;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the read result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-            .keySet()\n-            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Read.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n-                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n-        }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedReads =\n-            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed reads.\n-       *\n-       * @return the failed reads\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedReads() {\n-        return failedReads;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n-\n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-\n-    @Override\n-    public FhirIO.Read.Result expand(PCollection<String> input) {\n-      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n-    }\n-\n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n+     * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+     * notifications)\n      *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * @return the read\n+     * @see Read\n      */\n-    static class FetchResourceJsonString\n-        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-\n-      /** Instantiates a new Fetch Fhir message DoFn. */\n-      public FetchResourceJsonString() {}\n-\n-      @Override\n-      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n-        return new FhirIO.Read.Result(\n-            resourceIds.apply(\n-                ParDo.of(new ReadResourceFn())\n-                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for fetching messages from the Fhir store with error handling. */\n-      static class ReadResourceFn extends DoFn<String, String> {\n-\n-        private Counter failedMessageGets =\n-            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n-        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n-        private final Counter successfulStringGets =\n-            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n-\n-        /** Instantiates a new Hl 7 v 2 message get fn. */\n-        ReadResourceFn() {}\n-\n-        /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n-         */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n-        }\n-\n-        /**\n-         * Process element.\n-         *\n-         * @param context the context\n-         */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          String resourceId = context.element();\n-          try {\n-            context.output(fetchResource(this.client, resourceId));\n-          } catch (Exception e) {\n-            failedMessageGets.inc();\n-            LOG.warn(\n-                String.format(\n-                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n-                        + \"Queue. Cause: %s Stack Trace: %s\",\n-                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n-          }\n-        }\n-\n-        private String fetchResource(HealthcareApiClient client, String resourceId)\n-            throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpBody resource = client.readFhirResource(resourceId);\n-\n-          if (resource == null) {\n-            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n-          }\n-          this.successfulStringGets.inc();\n-          return mapper.writeValueAsString(resource);\n-        }\n-      }\n-    }\n-  }\n-\n-  /** The type Write. */\n-  @AutoValue\n-  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n-\n-    /** The tag for the failed writes to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for the files that failed to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for temp files for import to FHIR store`. */\n-    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n-\n-    /** The enum Write method. */\n-    public enum WriteMethod {\n-      /**\n-       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n-       */\n-      EXECUTE_BUNDLE,\n-      /**\n-       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n-       * FHIR stores. <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n-       */\n-      IMPORT\n-    }\n-\n-    /** The type Result. */\n-    public static class Result implements POutput {\n-      private final Pipeline pipeline;\n-      private final PCollection<HealthcareIOError<String>> failedBodies;\n-      private final PCollection<HealthcareIOError<String>> failedFiles;\n-\n-      /**\n-       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n-       * pipeline\n-       *\n-       * @param failedBodies the failed inserts\n-       * @return the result\n-       */\n-      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n-        return new Result(pipeline, failedBodies, null);\n-      }\n-\n-      static Result in(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          PCollection<HealthcareIOError<String>> failedFiles) {\n-        return new Result(pipeline, failedBodies, failedFiles);\n-      }\n-\n-      /**\n-       * Gets failed bodies with err.\n-       *\n-       * @return the failed inserts with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n-        return this.failedBodies;\n-      }\n-\n-      /**\n-       * Gets failed file imports with err.\n-       *\n-       * @return the failed GCS uri with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n-        return this.failedFiles;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pipeline;\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-\n-      private Result(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n-        this.pipeline = pipeline;\n-        this.failedBodies = failedBodies;\n-        if (failedFiles == null) {\n-          failedFiles =\n-              (PCollection<HealthcareIOError<String>>)\n-                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-        }\n-        this.failedFiles = failedFiles;\n-      }\n+    public static Read readResources() {\n+        return new Read();\n     }\n \n     /**\n-     * Gets Fhir store.\n+     * Search resources from a Fhir store.\n      *\n-     * @return the Fhir store\n+     * @return the search\n+     * @see Search\n      */\n-    abstract ValueProvider<String> getFhirStore();\n+    public static Search searchResources(String fhirStore) {\n+        return new Search(fhirStore);\n+    }\n \n     /**\n-     * Gets write method.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the write method\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract WriteMethod getWriteMethod();\n+    public static Import importResources(\n+            String fhirStore,\n+            String tempDir,\n+            String deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets content structure.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the content structure\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+    public static Import importResources(\n+            ValueProvider<String> fhirStore,\n+            ValueProvider<String> tempDir,\n+            ValueProvider<String> deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets import gcs temp path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs temp path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n+    public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n+        return new Export(\n+                StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n+    }\n \n     /**\n-     * Gets import gcs dead letter path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs dead letter path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n-\n-    /** The type Builder. */\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-\n-      /**\n-       * Sets Fhir store.\n-       *\n-       * @param fhirStore the Fhir store\n-       * @return the Fhir store\n-       */\n-      abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n-\n-      /**\n-       * Sets write method.\n-       *\n-       * @param writeMethod the write method\n-       * @return the write method\n-       */\n-      abstract Builder setWriteMethod(WriteMethod writeMethod);\n-\n-      /**\n-       * Sets content structure.\n-       *\n-       * @param contentStructure the content structure\n-       * @return the content structure\n-       */\n-      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n-\n-      /**\n-       * Sets import gcs temp path.\n-       *\n-       * @param gcsTempPath the gcs temp path\n-       * @return the import gcs temp path\n-       */\n-      abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n-\n-      /**\n-       * Sets import gcs dead letter path.\n-       *\n-       * @param gcsDeadLetterPath the gcs dead letter path\n-       * @return the import gcs dead letter path\n-       */\n-      abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n-\n-      /**\n-       * Build write.\n-       *\n-       * @return the write\n-       */\n-      abstract Write build();\n-    }\n-\n-    private static Write.Builder write(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n+    public static Export exportResourcesToGcs(\n+            ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+        return new Export(fhirStore, exportGcsUriPrefix);\n     }\n \n     /**\n-     * Create Method creates a single FHIR resource. @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @param gcsTempPath the gcs temp path\n-     * @param gcsDeadLetterPath the gcs dead letter path\n-     * @param contentStructure the content structure\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsTempPath,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> gcsTempPath,\n-        ValueProvider<String> gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(gcsTempPath)\n-          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n-          .build();\n+    public static Deidentify deidentify(\n+            String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n+        return new Deidentify(\n+                StaticValueProvider.of(sourceFhirStore),\n+                StaticValueProvider.of(destinationFhirStore),\n+                StaticValueProvider.of(deidConfig));\n     }\n \n     /**\n-     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write executeBundles(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n+    public static Deidentify deidentify(\n+            ValueProvider<String> sourceFhirStore,\n+            ValueProvider<String> destinationFhirStore,\n+            ValueProvider<DeidentifyConfig> deidConfig) {\n+        return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n     }\n \n     /**\n-     * Execute bundles write.\n-     *\n-     * @param fhirStore the fhir store\n-     * @return the write\n+     * The type Read.\n      */\n-    public static Write executeBundles(ValueProvider<String> fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n-    }\n+    public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n-\n-    @Override\n-    public Result expand(PCollection<String> input) {\n-      PCollection<HealthcareIOError<String>> failedBundles;\n-      PCollection<HealthcareIOError<String>> failedImports;\n-      switch (this.getWriteMethod()) {\n-        case IMPORT:\n-          LOG.warn(\n-              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n-                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n-          ValueProvider<String> deadPath =\n-              getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n-          FhirIO.Import.ContentStructure contentStructure =\n-              getContentStructure().orElseThrow(IllegalArgumentException::new);\n-          ValueProvider<String> tempPath =\n-              getImportGcsTempPath()\n-                  .orElse(\n-                      StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n-        case EXECUTE_BUNDLE:\n-        default:\n-          failedBundles =\n-              input\n-                  .apply(\n-                      \"Execute FHIR Bundles\",\n-                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n-                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-      return Result.in(input.getPipeline(), failedBundles);\n-    }\n-  }\n-\n-  /**\n-   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n-   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n-   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n-   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n-   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n-   */\n-  public static class Import extends Write {\n-\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> deadLetterGcsPath;\n-    private final ContentStructure contentStructure;\n-    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n-    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n-    private ValueProvider<String> tempGcsPath;\n-\n-    /*\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n-     */\n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> tempGcsPath,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = fhirStore;\n-      this.tempGcsPath = tempGcsPath;\n-      this.deadLetterGcsPath = deadLetterGcsPath;\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+        /**\n+         * Instantiates a new Read.\n+         */\n+        public Read() {\n+        }\n+\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedReads;\n+            /**\n+             * The Pct.\n+             */\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the read result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Read.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                                    + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedReads =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed reads.\n+             *\n+             * @return the failed reads\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedReads() {\n+                return failedReads;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n+\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Read.Result expand(PCollection<String> input) {\n+            return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+        }\n+\n+        /**\n+         * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+         * store, and fetches the actual {@link String} object based on the id in the notification and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class FetchResourceJsonString\n+                extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+            /**\n+             * Instantiates a new Fetch Fhir message DoFn.\n+             */\n+            public FetchResourceJsonString() {\n+            }\n+\n+            @Override\n+            public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+                return new FhirIO.Read.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new ReadResourceFn())\n+                                        .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for fetching messages from the Fhir store with error handling.\n+             */\n+            static class ReadResourceFn extends DoFn<String, String> {\n+\n+                private Counter failedMessageGets =\n+                        Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+                private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+                private final Counter successfulStringGets =\n+                        Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+                private HealthcareApiClient client;\n+                private ObjectMapper mapper;\n+\n+                /**\n+                 * Instantiates a new Hl 7 v 2 message get fn.\n+                 */\n+                ReadResourceFn() {\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                    this.mapper = new ObjectMapper();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    String resourceId = context.element();\n+                    try {\n+                        context.output(fetchResource(this.client, resourceId));\n+                    } catch (Exception e) {\n+                        failedMessageGets.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+                    }\n+                }\n \n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this(fhirStore, null, deadLetterGcsPath, contentStructure);\n+                private String fetchResource(HealthcareApiClient client, String resourceId)\n+                        throws IOException, IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpBody resource = client.readFhirResource(resourceId);\n+\n+                    if (resource == null) {\n+                        throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+                    }\n+                    this.successfulStringGets.inc();\n+                    return mapper.writeValueAsString(resource);\n+                }\n+            }\n+        }\n     }\n+\n     /**\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n+     * The type Write.\n      */\n-    Import(\n-        String fhirStore,\n-        String tempGcsPath,\n-        String deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-      this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-      this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+    @AutoValue\n+    public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n \n-    @Override\n-    ValueProvider<String> getFhirStore() {\n-      return fhirStore;\n-    }\n+        /**\n+         * The tag for the failed writes to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for the files that failed to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for temp files for import to FHIR store`.\n+         */\n+        public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {\n+        };\n \n-    @Override\n-    WriteMethod getWriteMethod() {\n-      return WriteMethod.IMPORT;\n-    }\n+        /**\n+         * The enum Write method.\n+         */\n+        public enum WriteMethod {\n+            /**\n+             * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+             */\n+            EXECUTE_BUNDLE,\n+            /**\n+             * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+             * FHIR stores. <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+             */\n+            IMPORT\n+        }\n \n-    @Override\n-    Optional<ContentStructure> getContentStructure() {\n-      return Optional.of(contentStructure);\n-    }\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput {\n+            private final Pipeline pipeline;\n+            private final PCollection<HealthcareIOError<String>> failedBodies;\n+            private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+            /**\n+             * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+             * pipeline\n+             *\n+             * @param failedBodies the failed inserts\n+             * @return the result\n+             */\n+            static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+                return new Result(pipeline, failedBodies, null);\n+            }\n+\n+            static Result in(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    PCollection<HealthcareIOError<String>> failedFiles) {\n+                return new Result(pipeline, failedBodies, failedFiles);\n+            }\n+\n+            /**\n+             * Gets failed bodies with err.\n+             *\n+             * @return the failed inserts with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+                return this.failedBodies;\n+            }\n+\n+            /**\n+             * Gets failed file imports with err.\n+             *\n+             * @return the failed GCS uri with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+                return this.failedFiles;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pipeline;\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+\n+            private Result(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+                this.pipeline = pipeline;\n+                this.failedBodies = failedBodies;\n+                if (failedFiles == null) {\n+                    failedFiles =\n+                            (PCollection<HealthcareIOError<String>>)\n+                                    pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+                }\n+                this.failedFiles = failedFiles;\n+            }\n+        }\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsTempPath() {\n-      return Optional.of(tempGcsPath);\n-    }\n+        /**\n+         * Gets Fhir store.\n+         *\n+         * @return the Fhir store\n+         */\n+        abstract ValueProvider<String> getFhirStore();\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n-      return Optional.of(deadLetterGcsPath);\n-    }\n+        /**\n+         * Gets write method.\n+         *\n+         * @return the write method\n+         */\n+        abstract WriteMethod getWriteMethod();\n \n-    @Override\n-    public Write.Result expand(PCollection<String> input) {\n-      checkState(\n-          input.isBounded() == IsBounded.BOUNDED,\n-          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n-              + \"intended for batch use only.\");\n-\n-      // fall back on pipeline's temp location.\n-      ValueProvider<String> tempPath =\n-          getImportGcsTempPath()\n-              .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-      // Write bundles of String to GCS\n-      PCollectionTuple writeTmpFileResults =\n-          input.apply(\n-              \"Write nd json to GCS\",\n-              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n-                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n-\n-      PCollection<HealthcareIOError<String>> failedBodies =\n-          writeTmpFileResults\n-              .get(Write.FAILED_BODY)\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      int numShards = 100;\n-      PCollection<HealthcareIOError<String>> failedFiles =\n-          writeTmpFileResults\n-              .get(Write.TEMP_FILES)\n-              .apply(\n-                  \"Shard files\", // to paralelize group into batches\n-                  WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n-              .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n-              .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n-              .setCoder(\n-                  KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n-              .apply(\n-                  \"Import Batches\",\n-                  ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-\n-      input\n-          .getPipeline()\n-          .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n-          .apply(\n-              \"Resolve SubDirs\",\n-              MapElements.into(TypeDescriptors.strings())\n-                  .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n-          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n-          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n-          .apply(\n-              \"Match tempGcsPath\",\n-              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n-          .apply(\n-              \"Delete tempGcsPath\",\n-              ParDo.of(\n-                  new DoFn<Metadata, Void>() {\n-                    @ProcessElement\n-                    public void delete(@Element Metadata path, ProcessContext context) {\n-                      // Wait til window closes for failedBodies and failedFiles to ensure we are\n-                      // done processing\n-                      // anything under tempGcsPath because it has been successfully imported to\n-                      // FHIR store or\n-                      // copies have been moved to the dead letter path.\n-                      // Clean up all of tempGcsPath. This will handle removing phantom temporary\n-                      // objects from\n-                      // failed / rescheduled ImportFn::importBatch.\n-                      try {\n-                        FileSystems.delete(\n-                            Collections.singleton(path.resourceId()),\n-                            StandardMoveOptions.IGNORE_MISSING_FILES);\n-                      } catch (IOException e) {\n-                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n-                      }\n-                    }\n-                  }))\n-          .setCoder(VoidCoder.of());\n+        /**\n+         * Gets content structure.\n+         *\n+         * @return the content structure\n+         */\n+        abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n \n-      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n-    }\n+        /**\n+         * Gets import gcs temp path.\n+         *\n+         * @return the import gcs temp path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n \n-    /** The Write bundles to new line delimited json files. */\n-    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n-\n-      private final ValueProvider<String> fhirStore;\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ObjectMapper mapper;\n-      private ResourceId resourceId;\n-      private WritableByteChannel ndJsonChannel;\n-      private BoundedWindow window;\n-\n-      private transient HealthcareApiClient client;\n-      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n-\n-      WriteBundlesToFilesFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-      }\n-\n-      /**\n-       * Instantiates a new Import fn.\n-       *\n-       * @param fhirStore the fhir store\n-       * @param tempGcsPath the temp gcs path\n-       * @param deadLetterGcsPath the dead letter gcs path\n-       */\n-      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n-        this.fhirStore = StaticValueProvider.of(fhirStore);\n-        this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-        this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      }\n-\n-      /**\n-       * Init client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Init batch.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @StartBundle\n-      public void initFile() throws IOException {\n-        // Write each bundle to newline delimited JSON file.\n-        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n-        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n-        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n-        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n-        if (mapper == null) {\n-          this.mapper = new ObjectMapper();\n-        }\n-      }\n-\n-      /**\n-       * Add to batch.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @ProcessElement\n-      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n-        this.window = window;\n-        String httpBody = context.element();\n-        try {\n-          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n-          Object data = this.mapper.readValue(httpBody, Object.class);\n-          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n-          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n-        } catch (JsonProcessingException e) {\n-          String resource =\n-              String.format(\n-                  \"Failed to parse payload: %s as json at: %s : %s.\"\n-                      + \"Dropping message from batch import.\",\n-                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n-          LOG.warn(resource);\n-          context.output(\n-              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        /**\n+         * Gets import gcs dead letter path.\n+         *\n+         * @return the import gcs dead letter path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n+\n+        /**\n+         * The type Builder.\n+         */\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+\n+            /**\n+             * Sets Fhir store.\n+             *\n+             * @param fhirStore the Fhir store\n+             * @return the Fhir store\n+             */\n+            abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n+\n+            /**\n+             * Sets write method.\n+             *\n+             * @param writeMethod the write method\n+             * @return the write method\n+             */\n+            abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+            /**\n+             * Sets content structure.\n+             *\n+             * @param contentStructure the content structure\n+             * @return the content structure\n+             */\n+            abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+            /**\n+             * Sets import gcs temp path.\n+             *\n+             * @param gcsTempPath the gcs temp path\n+             * @return the import gcs temp path\n+             */\n+            abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n+\n+            /**\n+             * Sets import gcs dead letter path.\n+             *\n+             * @param gcsDeadLetterPath the gcs dead letter path\n+             * @return the import gcs dead letter path\n+             */\n+            abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n+\n+            /**\n+             * Build write.\n+             *\n+             * @return the write\n+             */\n+            abstract Write build();\n         }\n-      }\n-\n-      /**\n-       * Close file.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @FinishBundle\n-      public void closeFile(FinishBundleContext context) throws IOException {\n-        // Write the file with all elements in this bundle to GCS.\n-        ndJsonChannel.close();\n-        context.output(resourceId, window.maxTimestamp(), window);\n-      }\n-    }\n \n-    /** Import batches of new line delimited json files to FHIR Store. */\n-    static class ImportFn\n-        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n-\n-      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ResourceId tempDir;\n-      private final ContentStructure contentStructure;\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> fhirStore;\n-\n-      ImportFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath,\n-          @Nullable ContentStructure contentStructure) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-        if (contentStructure == null) {\n-          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-        } else {\n-          this.contentStructure = contentStructure;\n+        private static Write.Builder write(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n         }\n-      }\n-\n-      @Setup\n-      public void init() throws IOException {\n-        tempDir =\n-            FileSystems.matchNewResource(tempGcsPath.get(), true)\n-                .resolve(\n-                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n-                    StandardResolveOptions.RESOLVE_DIRECTORY);\n-        client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n-       * GCS URI.\n-       */\n-      @ProcessElement\n-      public void importBatch(\n-          @Element KV<Integer, Iterable<ResourceId>> element,\n-          OutputReceiver<HealthcareIOError<String>> output)\n-          throws IOException {\n-        Iterable<ResourceId> batch = element.getValue();\n-        List<ResourceId> tempDestinations = new ArrayList<>();\n-        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n-        assert batch != null;\n-        for (ResourceId file : batch) {\n-          tempDestinations.add(\n-              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n-          deadLetterDestinations.add(\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n-                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+\n+        /**\n+         * Create Method creates a single FHIR resource. @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+         *\n+         * @param fhirStore         the hl 7 v 2 store\n+         * @param gcsTempPath       the gcs temp path\n+         * @param gcsDeadLetterPath the gcs dead letter path\n+         * @param contentStructure  the content structure\n+         * @return the write\n+         */\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsTempPath,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        // Ignore missing files since this might be a retry, which means files\n-        // should have been copied over.\n-        FileSystems.copy(\n-            ImmutableList.copyOf(batch),\n-            tempDestinations,\n-            StandardMoveOptions.IGNORE_MISSING_FILES);\n-        // Check whether any temporary files are not present.\n-        boolean hasMissingFile =\n-            FileSystems.matchResources(tempDestinations).stream()\n-                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n-        if (hasMissingFile) {\n-          throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n-        try {\n-          // Blocking fhirStores.import request.\n-          assert contentStructure != null;\n-          Operation operation =\n-              client.importFhirResource(\n-                  fhirStore.get(), importUri.toString(), contentStructure.name());\n-          client.pollOperation(operation, 500L);\n-          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n-          // needed.\n-          FileSystems.delete(tempDestinations);\n-        } catch (IOException | InterruptedException e) {\n-          ResourceId deadLetterResourceId =\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n-          LOG.warn(\n-              String.format(\n-                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n-                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n-          FileSystems.rename(tempDestinations, deadLetterDestinations);\n-          output.output(HealthcareIOError.of(importUri.toString(), e));\n-        } finally {\n-          // If we've reached this point files have either been successfully import to FHIR store\n-          // or moved to Dead Letter Queue.\n-          // Clean up original files for this batch on GCS.\n-          FileSystems.delete(ImmutableList.copyOf(batch));\n+\n+        public static Write fhirStoresImport(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> gcsTempPath,\n+                ValueProvider<String> gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(gcsTempPath)\n+                    .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+                    .build();\n         }\n-      }\n-    }\n \n-    /** The enum Content structure. */\n-    public enum ContentStructure {\n-      /** If the content structure is not specified, the default value BUNDLE will be used. */\n-      CONTENT_STRUCTURE_UNSPECIFIED,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a bundle, which contains one or more resources. Set the bundle type to history to import\n-       * resource versions.\n-       */\n-      BUNDLE,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a single resource.\n-       */\n-      RESOURCE,\n-      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n-      BUNDLE_PRETTY,\n-      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n-      RESOURCE_PRETTY\n-    }\n-  }\n+        /**\n+         * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+         *\n+         * @param fhirStore the hl 7 v 2 store\n+         * @return the write\n+         */\n+        public static Write executeBundles(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-  /** The type Execute bundles. */\n-  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Execute bundles write.\n+         *\n+         * @param fhirStore the fhir store\n+         * @return the write\n+         */\n+        public static Write executeBundles(ValueProvider<String> fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-    /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    ExecuteBundles(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+        @Override\n+        public Result expand(PCollection<String> input) {\n+            PCollection<HealthcareIOError<String>> failedBundles;\n+            PCollection<HealthcareIOError<String>> failedImports;\n+            switch (this.getWriteMethod()) {\n+                case IMPORT:\n+                    LOG.warn(\n+                            \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                                    + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+                    ValueProvider<String> deadPath =\n+                            getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+                    FhirIO.Import.ContentStructure contentStructure =\n+                            getContentStructure().orElseThrow(IllegalArgumentException::new);\n+                    ValueProvider<String> tempPath =\n+                            getImportGcsTempPath()\n+                                    .orElse(\n+                                            StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+                    return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+                case EXECUTE_BUNDLE:\n+                default:\n+                    failedBundles =\n+                            input\n+                                    .apply(\n+                                            \"Execute FHIR Bundles\",\n+                                            ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                                    .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+            return Result.in(input.getPipeline(), failedBundles);\n+        }\n     }\n \n     /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n+     * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+     * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+     * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+     * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+     * as transactions which is safer practice for a use on a \"live\" FHIR store.\n      */\n-    ExecuteBundles(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Import extends Write {\n \n-    @Override\n-    public FhirIO.Write.Result expand(PCollection<String> input) {\n-      return Write.Result.in(\n-          input.getPipeline(),\n-          input\n-              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-    }\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> deadLetterGcsPath;\n+        private final ContentStructure contentStructure;\n+        private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+        private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+        private ValueProvider<String> tempGcsPath;\n+\n+        /*\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore the fhir store\n+         * @param tempGcsPath the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure the content structure\n+         */\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> tempGcsPath,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = fhirStore;\n+            this.tempGcsPath = tempGcsPath;\n+            this.deadLetterGcsPath = deadLetterGcsPath;\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    /** The type Write Fhir fn. */\n-    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n-\n-      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n-      private transient HealthcareApiClient client;\n-      private final ObjectMapper mapper = new ObjectMapper();\n-      /** The Fhir store. */\n-      private final ValueProvider<String> fhirStore;\n-\n-      /**\n-       * Instantiates a new Write Fhir fn.\n-       *\n-       * @param fhirStore the Fhir store\n-       */\n-      ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      /**\n-       * Initialize healthcare client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Execute Bundles.\n-       *\n-       * @param context the context\n-       */\n-      @ProcessElement\n-      public void executeBundles(ProcessContext context) {\n-        String body = context.element();\n-        try {\n-          // Validate that data was set to valid JSON.\n-          mapper.readTree(body);\n-          client.executeFhirBundle(fhirStore.get(), body);\n-        } catch (IOException | HealthcareHttpException e) {\n-          failedBundles.inc();\n-          context.output(HealthcareIOError.of(body, e));\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this(fhirStore, null, deadLetterGcsPath, contentStructure);\n         }\n-      }\n-    }\n-  }\n \n-  /** Export FHIR resources from a FHIR store to new line delimited json files on GCS. */\n-  public static class Export extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> exportGcsUriPrefix;\n+        /**\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore         the fhir store\n+         * @param tempGcsPath       the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure  the content structure\n+         */\n+        Import(\n+                String fhirStore,\n+                String tempGcsPath,\n+                String deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+            this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+            this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-      this.fhirStore = fhirStore;\n-      this.exportGcsUriPrefix = exportGcsUriPrefix;\n-    }\n+        @Override\n+        ValueProvider<String> getFhirStore() {\n+            return fhirStore;\n+        }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleExportOperations\",\n-              ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n-          .apply(FileIO.matchAll())\n-          .apply(FileIO.readMatches())\n-          .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n-    }\n+        @Override\n+        WriteMethod getWriteMethod() {\n+            return WriteMethod.IMPORT;\n+        }\n \n-    /** A function that schedules an export operation and monitors the status. */\n-    public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> exportGcsUriPrefix;\n-\n-      public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n-        this.exportGcsUriPrefix = exportGcsUriPrefix;\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void exportResourcesToGcs(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String fhirStore = context.element();\n-        String gcsPrefix = this.exportGcsUriPrefix.get();\n-        Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new RuntimeException(\n-              String.format(\"Export operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ContentStructure> getContentStructure() {\n+            return Optional.of(contentStructure);\n         }\n-        context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n-      }\n-    }\n-  }\n-\n-  /** Deidentify FHIR resources from a FHIR store to a destination FHIR store. */\n-  public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> sourceFhirStore;\n-    private final ValueProvider<String> destinationFhirStore;\n-    private final ValueProvider<DeidentifyConfig> deidConfig;\n-\n-    public Deidentify(\n-        ValueProvider<String> sourceFhirStore,\n-        ValueProvider<String> destinationFhirStore,\n-        ValueProvider<DeidentifyConfig> deidConfig) {\n-      this.sourceFhirStore = sourceFhirStore;\n-      this.destinationFhirStore = destinationFhirStore;\n-      this.deidConfig = deidConfig;\n-    }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .getPipeline()\n-          .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleDeidentifyFhirStoreOperations\",\n-              ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n-    }\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsTempPath() {\n+            return Optional.of(tempGcsPath);\n+        }\n \n-    /** A function that schedules a deidentify operation and monitors the status. */\n-    public static class DeidentifyFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> destinationFhirStore;\n-      private static final Gson gson = new Gson();\n-      private final String deidConfigJson;\n-\n-      public DeidentifyFn(\n-          ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n-        this.destinationFhirStore = destinationFhirStore;\n-        this.deidConfigJson = gson.toJson(deidConfig.get());\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void deidentify(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String sourceFhirStore = context.element();\n-        String destinationFhirStore = this.destinationFhirStore.get();\n-        DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n-        Operation operation =\n-            client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new IOException(\n-              String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n+            return Optional.of(deadLetterGcsPath);\n         }\n-        context.output(destinationFhirStore);\n-      }\n-    }\n-  }\n \n-  /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, Object>>>, FhirIO.Search.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+        @Override\n+        public Write.Result expand(PCollection<String> input) {\n+            checkState(\n+                    input.isBounded() == IsBounded.BOUNDED,\n+                    \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+                            + \"intended for batch use only.\");\n+\n+            // fall back on pipeline's temp location.\n+            ValueProvider<String> tempPath =\n+                    getImportGcsTempPath()\n+                            .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+            // Write bundles of String to GCS\n+            PCollectionTuple writeTmpFileResults =\n+                    input.apply(\n+                            \"Write nd json to GCS\",\n+                            ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                                    .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+            PCollection<HealthcareIOError<String>> failedBodies =\n+                    writeTmpFileResults\n+                            .get(Write.FAILED_BODY)\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            int numShards = 100;\n+            PCollection<HealthcareIOError<String>> failedFiles =\n+                    writeTmpFileResults\n+                            .get(Write.TEMP_FILES)\n+                            .apply(\n+                                    \"Shard files\", // to paralelize group into batches\n+                                    WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n+                            .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n+                            .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+                            .setCoder(\n+                                    KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n+                            .apply(\n+                                    \"Import Batches\",\n+                                    ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+            input\n+                    .getPipeline()\n+                    .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"Resolve SubDirs\",\n+                            MapElements.into(TypeDescriptors.strings())\n+                                    .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n+                    .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+                    .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+                    .apply(\n+                            \"Match tempGcsPath\",\n+                            FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+                    .apply(\n+                            \"Delete tempGcsPath\",\n+                            ParDo.of(\n+                                    new DoFn<Metadata, Void>() {\n+                                        @ProcessElement\n+                                        public void delete(@Element Metadata path, ProcessContext context) {\n+                                            // Wait til window closes for failedBodies and failedFiles to ensure we are\n+                                            // done processing\n+                                            // anything under tempGcsPath because it has been successfully imported to\n+                                            // FHIR store or\n+                                            // copies have been moved to the dead letter path.\n+                                            // Clean up all of tempGcsPath. This will handle removing phantom temporary\n+                                            // objects from\n+                                            // failed / rescheduled ImportFn::importBatch.\n+                                            try {\n+                                                FileSystems.delete(\n+                                                        Collections.singleton(path.resourceId()),\n+                                                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                                            } catch (IOException e) {\n+                                                LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                                            }\n+                                        }\n+                                    }))\n+                    .setCoder(VoidCoder.of());\n+\n+            return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+        }\n+\n+        /**\n+         * The Write bundles to new line delimited json files.\n+         */\n+        static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+            private final ValueProvider<String> fhirStore;\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ObjectMapper mapper;\n+            private ResourceId resourceId;\n+            private WritableByteChannel ndJsonChannel;\n+            private BoundedWindow window;\n+\n+            private transient HealthcareApiClient client;\n+            private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+            WriteBundlesToFilesFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+            }\n+\n+            /**\n+             * Instantiates a new Import fn.\n+             *\n+             * @param fhirStore         the fhir store\n+             * @param tempGcsPath       the temp gcs path\n+             * @param deadLetterGcsPath the dead letter gcs path\n+             */\n+            WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+                this.fhirStore = StaticValueProvider.of(fhirStore);\n+                this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+                this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            }\n+\n+            /**\n+             * Init client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Init batch.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @StartBundle\n+            public void initFile() throws IOException {\n+                // Write each bundle to newline delimited JSON file.\n+                String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+                ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n+                this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+                this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+                if (mapper == null) {\n+                    this.mapper = new ObjectMapper();\n+                }\n+            }\n+\n+            /**\n+             * Add to batch.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @ProcessElement\n+            public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+                this.window = window;\n+                String httpBody = context.element();\n+                try {\n+                    // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+                    Object data = this.mapper.readValue(httpBody, Object.class);\n+                    String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+                    this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+                } catch (JsonProcessingException e) {\n+                    String resource =\n+                            String.format(\n+                                    \"Failed to parse payload: %s as json at: %s : %s.\"\n+                                            + \"Dropping message from batch import.\",\n+                                    httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+                    LOG.warn(resource);\n+                    context.output(\n+                            Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+                }\n+            }\n+\n+            /**\n+             * Close file.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @FinishBundle\n+            public void closeFile(FinishBundleContext context) throws IOException {\n+                // Write the file with all elements in this bundle to GCS.\n+                ndJsonChannel.close();\n+                context.output(resourceId, window.maxTimestamp(), window);\n+            }\n+        }\n \n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Import batches of new line delimited json files to FHIR Store.\n+         */\n+        static class ImportFn\n+                extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+            private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ResourceId tempDir;\n+            private final ContentStructure contentStructure;\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> fhirStore;\n+\n+            ImportFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath,\n+                    @Nullable ContentStructure contentStructure) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+                if (contentStructure == null) {\n+                    this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+                } else {\n+                    this.contentStructure = contentStructure;\n+                }\n+            }\n+\n+            @Setup\n+            public void init() throws IOException {\n+                tempDir =\n+                        FileSystems.matchNewResource(tempGcsPath.get(), true)\n+                                .resolve(\n+                                        String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                                        StandardResolveOptions.RESOLVE_DIRECTORY);\n+                client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+             * GCS URI.\n+             */\n+            @ProcessElement\n+            public void importBatch(\n+                    @Element KV<Integer, Iterable<ResourceId>> element,\n+                    OutputReceiver<HealthcareIOError<String>> output)\n+                    throws IOException {\n+                Iterable<ResourceId> batch = element.getValue();\n+                List<ResourceId> tempDestinations = new ArrayList<>();\n+                List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+                assert batch != null;\n+                for (ResourceId file : batch) {\n+                    tempDestinations.add(\n+                            tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                    deadLetterDestinations.add(\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n+                                    .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                }\n+                // Ignore missing files since this might be a retry, which means files\n+                // should have been copied over.\n+                FileSystems.copy(\n+                        ImmutableList.copyOf(batch),\n+                        tempDestinations,\n+                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                // Check whether any temporary files are not present.\n+                boolean hasMissingFile =\n+                        FileSystems.matchResources(tempDestinations).stream()\n+                                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n+                if (hasMissingFile) {\n+                    throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+                }\n+                ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+                try {\n+                    // Blocking fhirStores.import request.\n+                    assert contentStructure != null;\n+                    Operation operation =\n+                            client.importFhirResource(\n+                                    fhirStore.get(), importUri.toString(), contentStructure.name());\n+                    client.pollOperation(operation, 500L);\n+                    // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+                    // needed.\n+                    FileSystems.delete(tempDestinations);\n+                } catch (IOException | InterruptedException e) {\n+                    ResourceId deadLetterResourceId =\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n+                    LOG.warn(\n+                            String.format(\n+                                    \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                                    importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+                    FileSystems.rename(tempDestinations, deadLetterDestinations);\n+                    output.output(HealthcareIOError.of(importUri.toString(), e));\n+                } finally {\n+                    // If we've reached this point files have either been successfully import to FHIR store\n+                    // or moved to Dead Letter Queue.\n+                    // Clean up original files for this batch on GCS.\n+                    FileSystems.delete(ImmutableList.copyOf(batch));\n+                }\n+            }\n+        }\n \n-    /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    Search(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        /**\n+         * The enum Content structure.\n+         */\n+        public enum ContentStructure {\n+            /**\n+             * If the content structure is not specified, the default value BUNDLE will be used.\n+             */\n+            CONTENT_STRUCTURE_UNSPECIFIED,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a bundle, which contains one or more resources. Set the bundle type to history to import\n+             * resource versions.\n+             */\n+            BUNDLE,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a single resource.\n+             */\n+            RESOURCE,\n+            /**\n+             * The entire file is one JSON bundle. The JSON can span multiple lines.\n+             */\n+            BUNDLE_PRETTY,\n+            /**\n+             * The entire file is one JSON resource. The JSON can span multiple lines.\n+             */\n+            RESOURCE_PRETTY\n+        }\n     }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * The type Execute bundles.\n      */\n-    Search(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+        private final ValueProvider<String> fhirStore;\n \n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedSearches;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the search result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-                .keySet()\n-                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Search.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n-                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n         }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedSearches =\n-                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed searches.\n-       *\n-       * @return the failed searches\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n-        return failedSearches;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-              String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n \n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-            new TupleTag<HealthcareIOError<String>>() {};\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n \n-    @Override\n-    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, Object>>> input) {\n-      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        @Override\n+        public FhirIO.Write.Result expand(PCollection<String> input) {\n+            return Write.Result.in(\n+                    input.getPipeline(),\n+                    input\n+                            .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+\n+        /**\n+         * The type Write Fhir fn.\n+         */\n+        static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+            private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+            private transient HealthcareApiClient client;\n+            private final ObjectMapper mapper = new ObjectMapper();\n+            /**\n+             * The Fhir store.\n+             */\n+            private final ValueProvider<String> fhirStore;\n+\n+            /**\n+             * Instantiates a new Write Fhir fn.\n+             *\n+             * @param fhirStore the Fhir store\n+             */\n+            ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            /**\n+             * Initialize healthcare client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Execute Bundles.\n+             *\n+             * @param context the context\n+             */\n+            @ProcessElement\n+            public void executeBundles(ProcessContext context) {\n+                String body = context.element();\n+                try {\n+                    // Validate that data was set to valid JSON.\n+                    mapper.readTree(body);\n+                    client.executeFhirBundle(fhirStore.get(), body);\n+                } catch (IOException | HealthcareHttpException e) {\n+                    failedBundles.inc();\n+                    context.output(HealthcareIOError.of(body, e));\n+                }\n+            }\n+        }\n     }\n \n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n-     *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of failed searches from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * Export FHIR resources from a FHIR store to new line delimited json files on GCS.\n      */\n-    static class SearchResourcesJsonString\n-            extends PTransform<PCollection<KV<String, Map<String, Object>>>, FhirIO.Search.Result> {\n-\n-      private final ValueProvider<String> fhirStore;\n-\n-      /** Instantiates a new Search Fhir resources DoFn. */\n-      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      @Override\n-      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, Object>>> resourceIds) {\n-        return new FhirIO.Search.Result(\n-                resourceIds.apply(\n-                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n-                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for searching messages from the Fhir store with error handling. */\n-      static class SearchResourcesFn extends DoFn<KV<String, Map<String, Object>>, String> {\n-\n-        private Counter failedSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n-        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n-        private final Counter successfulSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n+    public static class Export extends PTransform<PBegin, PCollection<String>> {\n         private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> exportGcsUriPrefix;\n \n-        /** Instantiates a new Fhir resources search fn. */\n-        SearchResourcesFn(ValueProvider<String> fhirStore) {\n-          this.fhirStore = fhirStore;\n+        public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+            this.fhirStore = fhirStore;\n+            this.exportGcsUriPrefix = exportGcsUriPrefix;\n+        }\n+\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleExportOperations\",\n+                            ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n+                    .apply(FileIO.matchAll())\n+                    .apply(FileIO.readMatches())\n+                    .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n         }\n \n         /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n+         * A function that schedules an export operation and monitors the status.\n          */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n+        public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> exportGcsUriPrefix;\n+\n+            public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n+                this.exportGcsUriPrefix = exportGcsUriPrefix;\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void exportResourcesToGcs(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String fhirStore = context.element();\n+                String gcsPrefix = this.exportGcsUriPrefix.get();\n+                Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new RuntimeException(\n+                            String.format(\"Export operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deidentify FHIR resources from a FHIR store to a destination FHIR store.\n+     */\n+    public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> sourceFhirStore;\n+        private final ValueProvider<String> destinationFhirStore;\n+        private final ValueProvider<DeidentifyConfig> deidConfig;\n+\n+        public Deidentify(\n+                ValueProvider<String> sourceFhirStore,\n+                ValueProvider<String> destinationFhirStore,\n+                ValueProvider<DeidentifyConfig> deidConfig) {\n+            this.sourceFhirStore = sourceFhirStore;\n+            this.destinationFhirStore = destinationFhirStore;\n+            this.deidConfig = deidConfig;\n+        }\n+\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .getPipeline()\n+                    .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleDeidentifyFhirStoreOperations\",\n+                            ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n         }\n \n         /**\n-         * Process element.\n-         *\n-         * @param context the context\n+         * A function that schedules a deidentify operation and monitors the status.\n          */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          KV<String, Map<String, Object>> elementValues = context.element();\n-          try {\n-            context.output(searchResources(\n-                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n-          } catch (Exception e) {\n-            failedSearches.inc();\n-            LOG.warn(\n-                    String.format(\n-                            \"Error search FHIR messages writing to Dead Letter \"\n-                                    + \"Queue. Cause: %s Stack Trace: %s\",\n-                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n-          }\n+        public static class DeidentifyFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> destinationFhirStore;\n+            private static final Gson gson = new Gson();\n+            private final String deidConfigJson;\n+\n+            public DeidentifyFn(\n+                    ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n+                this.destinationFhirStore = destinationFhirStore;\n+                this.deidConfigJson = gson.toJson(deidConfig.get());\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void deidentify(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String sourceFhirStore = context.element();\n+                String destinationFhirStore = this.destinationFhirStore.get();\n+                DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n+                Operation operation =\n+                        client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new IOException(\n+                            String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(destinationFhirStore);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The type Search.\n+     */\n+    public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n+        private final ValueProvider<String> fhirStore;\n+\n+        Search(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        Search(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n         }\n \n-        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n-                                       @Nullable Map<String, Object> parameters)\n-                throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedSearches;\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the search result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Search.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                                    + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedSearches =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed searches.\n+             *\n+             * @return the failed searches\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+                return failedSearches;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n \n-          HttpBody resource = client.searchFhirResource(fhirStore, resourceType, parameters);\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+            return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        }\n \n-          this.successfulSearches.inc();\n-          return mapper.writeValueAsString(resource);\n+        /**\n+         * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+         * and search parameters, and fetches all matching resources based on the search criteria and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of failed searches from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class SearchResourcesJsonString\n+                extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+            private final ValueProvider<String> fhirStore;\n+\n+            public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            @Override\n+            public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+                return new FhirIO.Search.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                        .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for searching messages from the Fhir store with error handling.\n+             */\n+            static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+                private Counter failedSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+                private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+                private final Counter successfulSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+                private HealthcareApiClient client;\n+                private final ValueProvider<String> fhirStore;\n+\n+                /**\n+                 * Instantiates a new Fhir resources search fn.\n+                 */\n+                SearchResourcesFn(ValueProvider<String> fhirStore) {\n+                    this.fhirStore = fhirStore;\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    KV<String, Map<String, String>> elementValues = context.element();\n+                    try {\n+                        context.output(searchResources(\n+                                this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+                    } catch (Exception e) {\n+                        failedSearches.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error search FHIR messages writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+                    }\n+                }\n+\n+                private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                               @Nullable Map<String, String> parameters)\n+                        throws IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                            new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                                    client, fhirStore, resourceType, parameters);\n+                    JsonArray result = new JsonArray();\n+                    while (iter.hasNext()) {\n+                        result.addAll(iter.next());\n+                    }\n+                    this.successfulSearches.inc();\n+                    return result.toString();\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDg4Mw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r527954883", "bodyText": "nit: maybe remove this comment? Doesn't seem to be very informative.", "author": "lastomato", "createdAt": "2020-11-20T20:31:45Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -1388,4 +1398,206 @@ public void deidentify(ProcessContext context)\n       }\n     }\n   }\n+\n+  /** The type Search. */\n+  public static class Search extends PTransform<PCollection<KV<String, Map<String, Object>>>, FhirIO.Search.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n+    private final ValueProvider<String> fhirStore;\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(String fhirStore) {\n+      this.fhirStore = StaticValueProvider.of(fhirStore);\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedSearches;\n+      /** The Pct. */", "originalCommit": "1cedaed15134216b919b1ae5c42ba487b8faf421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcyNzUyNg==", "url": "https://github.com/apache/beam/pull/13395#discussion_r528727526", "bodyText": "Done.", "author": "janeliulwq", "createdAt": "2020-11-23T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NDg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "55a28e1aa754b417224afdfbfb781d5c4327bd9c", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 3c1a1d7f4e..f0d9a17224 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -1425,10 +1426,9 @@ public class FhirIO {\n \n     /** The type Result. */\n     public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n+      private PCollection<JsonArray> resources;\n \n       private PCollection<HealthcareIOError<String>> failedSearches;\n-      /** The Pct. */\n       PCollectionTuple pct;\n \n       /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTc3Ng==", "url": "https://github.com/apache/beam/pull/13395#discussion_r527959776", "bodyText": "You will need to handle pagination here, see how this is handled for ListMessages: https://github.com/apache/beam/blob/master/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java#L682.", "author": "lastomato", "createdAt": "2020-11-20T20:43:09Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java", "diffHunk": "@@ -545,6 +529,26 @@ public HttpBody readFhirResource(String resourceId) throws IOException {\n     return client.projects().locations().datasets().fhirStores().fhir().read(resourceId).execute();\n   }\n \n+  @Override\n+  public HttpBody searchFhirResource(\n+          String fhirStore,\n+          String resourceType,\n+          @Nullable Map<String, Object> parameters)\n+          throws IOException {\n+    SearchResourcesRequest request = new SearchResourcesRequest().setResourceType(resourceType);\n+    Search search = client\n+            .projects()\n+            .locations()\n+            .datasets()\n+            .fhirStores()\n+            .fhir()\n+            .search(fhirStore, request);", "originalCommit": "1cedaed15134216b919b1ae5c42ba487b8faf421", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcyNzU5MA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r528727590", "bodyText": "Done.", "author": "janeliulwq", "createdAt": "2020-11-23T14:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "55a28e1aa754b417224afdfbfb781d5c4327bd9c", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java\nindex 786cd44716..7e13935365 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/HttpHealthcareApiClient.java\n\n@@ -533,7 +542,8 @@ public class HttpHealthcareApiClient implements HealthcareApiClient, Serializabl\n   public HttpBody searchFhirResource(\n           String fhirStore,\n           String resourceType,\n-          @Nullable Map<String, Object> parameters)\n+          @Nullable Map<String, Object> parameters,\n+          String pageToken)\n           throws IOException {\n     SearchResourcesRequest request = new SearchResourcesRequest().setResourceType(resourceType);\n     Search search = client\n"}}, {"oid": "55a28e1aa754b417224afdfbfb781d5c4327bd9c", "url": "https://github.com/apache/beam/commit/55a28e1aa754b417224afdfbfb781d5c4327bd9c", "message": "Search iterator", "committedDate": "2020-11-23T04:46:32Z", "type": "commit"}, {"oid": "eef752e3f57c67367f4b3f61276da79beb837815", "url": "https://github.com/apache/beam/commit/eef752e3f57c67367f4b3f61276da79beb837815", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-11-23T04:51:13Z", "type": "commit"}, {"oid": "b0b91e9801279fd81701d541d8e4d46d5b8b5654", "url": "https://github.com/apache/beam/commit/b0b91e9801279fd81701d541d8e4d46d5b8b5654", "message": "Switch output type to String", "committedDate": "2020-11-23T05:04:57Z", "type": "commit"}, {"oid": "31b3b79c64b6b78b7c059cf35d19acf486756720", "url": "https://github.com/apache/beam/commit/31b3b79c64b6b78b7c059cf35d19acf486756720", "message": "Added documentation for search", "committedDate": "2020-11-23T17:04:56Z", "type": "commit"}, {"oid": "9144adc234fac396f45e0231f223734f7d7937e3", "url": "https://github.com/apache/beam/commit/9144adc234fac396f45e0231f223734f7d7937e3", "message": "Add FhirIOSearchIT", "committedDate": "2020-11-24T06:37:59Z", "type": "commit"}, {"oid": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "url": "https://github.com/apache/beam/commit/ba1ef19f6215ca496fae9003b17b55f027bf9e35", "message": "Add a timelimit to test to avoid OOM", "committedDate": "2020-11-24T18:44:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNjc5Nw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529806797", "bodyText": "nit: end with a period.", "author": "lastomato", "createdAt": "2020-11-24T18:55:13Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -215,6 +227,16 @@ public static Read readResources() {\n     return new Read();\n   }\n \n+  /**\n+   * Search resources from a PCollection", "originalCommit": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzNjQ0Mg==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529836442", "bodyText": "Done.", "author": "janeliulwq", "createdAt": "2020-11-24T19:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNjc5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 9c0d0e409d..257d9f4a5c 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -212,1406 +214,1476 @@ import org.slf4j.LoggerFactory;\n  * </pre>\n  */\n @SuppressWarnings({\n-  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+        \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n })\n public class FhirIO {\n \n-  /**\n-   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n-   * notifications)\n-   *\n-   * @return the read\n-   * @see Read\n-   */\n-  public static Read readResources() {\n-    return new Read();\n-  }\n-\n-  /**\n-   * Search resources from a PCollection\n-   *\n-   * @return the search\n-   * @see Search\n-   */\n-  public static Search searchResources(String fhirStore) {\n-    return new Search(fhirStore);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      String fhirStore,\n-      String tempDir,\n-      String deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      ValueProvider<String> fhirStore,\n-      ValueProvider<String> tempDir,\n-      ValueProvider<String> deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n-    return new Export(\n-        StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(\n-      ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-    return new Export(fhirStore, exportGcsUriPrefix);\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n-    return new Deidentify(\n-        StaticValueProvider.of(sourceFhirStore),\n-        StaticValueProvider.of(destinationFhirStore),\n-        StaticValueProvider.of(deidConfig));\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      ValueProvider<String> sourceFhirStore,\n-      ValueProvider<String> destinationFhirStore,\n-      ValueProvider<DeidentifyConfig> deidConfig) {\n-    return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n-  }\n-\n-  /** The type Read. */\n-  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n-\n-    /** Instantiates a new Read. */\n-    public Read() {}\n-\n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedReads;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the read result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-            .keySet()\n-            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Read.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n-                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n-        }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedReads =\n-            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed reads.\n-       *\n-       * @return the failed reads\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedReads() {\n-        return failedReads;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n-\n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-\n-    @Override\n-    public FhirIO.Read.Result expand(PCollection<String> input) {\n-      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n-    }\n-\n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n+     * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+     * notifications)\n      *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * @return the read\n+     * @see Read\n      */\n-    static class FetchResourceJsonString\n-        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-\n-      /** Instantiates a new Fetch Fhir message DoFn. */\n-      public FetchResourceJsonString() {}\n-\n-      @Override\n-      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n-        return new FhirIO.Read.Result(\n-            resourceIds.apply(\n-                ParDo.of(new ReadResourceFn())\n-                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for fetching messages from the Fhir store with error handling. */\n-      static class ReadResourceFn extends DoFn<String, String> {\n-\n-        private Counter failedMessageGets =\n-            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n-        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n-        private final Counter successfulStringGets =\n-            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n-\n-        /** Instantiates a new Hl 7 v 2 message get fn. */\n-        ReadResourceFn() {}\n-\n-        /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n-         */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n-        }\n-\n-        /**\n-         * Process element.\n-         *\n-         * @param context the context\n-         */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          String resourceId = context.element();\n-          try {\n-            context.output(fetchResource(this.client, resourceId));\n-          } catch (Exception e) {\n-            failedMessageGets.inc();\n-            LOG.warn(\n-                String.format(\n-                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n-                        + \"Queue. Cause: %s Stack Trace: %s\",\n-                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n-          }\n-        }\n-\n-        private String fetchResource(HealthcareApiClient client, String resourceId)\n-            throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpBody resource = client.readFhirResource(resourceId);\n-\n-          if (resource == null) {\n-            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n-          }\n-          this.successfulStringGets.inc();\n-          return mapper.writeValueAsString(resource);\n-        }\n-      }\n-    }\n-  }\n-\n-  /** The type Write. */\n-  @AutoValue\n-  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n-\n-    /** The tag for the failed writes to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for the files that failed to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for temp files for import to FHIR store`. */\n-    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n-\n-    /** The enum Write method. */\n-    public enum WriteMethod {\n-      /**\n-       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n-       */\n-      EXECUTE_BUNDLE,\n-      /**\n-       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n-       * FHIR stores. <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n-       */\n-      IMPORT\n-    }\n-\n-    /** The type Result. */\n-    public static class Result implements POutput {\n-      private final Pipeline pipeline;\n-      private final PCollection<HealthcareIOError<String>> failedBodies;\n-      private final PCollection<HealthcareIOError<String>> failedFiles;\n-\n-      /**\n-       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n-       * pipeline\n-       *\n-       * @param failedBodies the failed inserts\n-       * @return the result\n-       */\n-      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n-        return new Result(pipeline, failedBodies, null);\n-      }\n-\n-      static Result in(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          PCollection<HealthcareIOError<String>> failedFiles) {\n-        return new Result(pipeline, failedBodies, failedFiles);\n-      }\n-\n-      /**\n-       * Gets failed bodies with err.\n-       *\n-       * @return the failed inserts with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n-        return this.failedBodies;\n-      }\n-\n-      /**\n-       * Gets failed file imports with err.\n-       *\n-       * @return the failed GCS uri with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n-        return this.failedFiles;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pipeline;\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-\n-      private Result(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n-        this.pipeline = pipeline;\n-        this.failedBodies = failedBodies;\n-        if (failedFiles == null) {\n-          failedFiles =\n-              (PCollection<HealthcareIOError<String>>)\n-                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-        }\n-        this.failedFiles = failedFiles;\n-      }\n+    public static Read readResources() {\n+        return new Read();\n     }\n \n     /**\n-     * Gets Fhir store.\n+     * Search resources from a Fhir store.\n      *\n-     * @return the Fhir store\n+     * @return the search\n+     * @see Search\n      */\n-    abstract ValueProvider<String> getFhirStore();\n+    public static Search searchResources(String fhirStore) {\n+        return new Search(fhirStore);\n+    }\n \n     /**\n-     * Gets write method.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the write method\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract WriteMethod getWriteMethod();\n+    public static Import importResources(\n+            String fhirStore,\n+            String tempDir,\n+            String deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets content structure.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the content structure\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+    public static Import importResources(\n+            ValueProvider<String> fhirStore,\n+            ValueProvider<String> tempDir,\n+            ValueProvider<String> deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets import gcs temp path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs temp path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n+    public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n+        return new Export(\n+                StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n+    }\n \n     /**\n-     * Gets import gcs dead letter path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs dead letter path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n-\n-    /** The type Builder. */\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-\n-      /**\n-       * Sets Fhir store.\n-       *\n-       * @param fhirStore the Fhir store\n-       * @return the Fhir store\n-       */\n-      abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n-\n-      /**\n-       * Sets write method.\n-       *\n-       * @param writeMethod the write method\n-       * @return the write method\n-       */\n-      abstract Builder setWriteMethod(WriteMethod writeMethod);\n-\n-      /**\n-       * Sets content structure.\n-       *\n-       * @param contentStructure the content structure\n-       * @return the content structure\n-       */\n-      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n-\n-      /**\n-       * Sets import gcs temp path.\n-       *\n-       * @param gcsTempPath the gcs temp path\n-       * @return the import gcs temp path\n-       */\n-      abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n-\n-      /**\n-       * Sets import gcs dead letter path.\n-       *\n-       * @param gcsDeadLetterPath the gcs dead letter path\n-       * @return the import gcs dead letter path\n-       */\n-      abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n-\n-      /**\n-       * Build write.\n-       *\n-       * @return the write\n-       */\n-      abstract Write build();\n-    }\n-\n-    private static Write.Builder write(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n+    public static Export exportResourcesToGcs(\n+            ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+        return new Export(fhirStore, exportGcsUriPrefix);\n     }\n \n     /**\n-     * Create Method creates a single FHIR resource. @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @param gcsTempPath the gcs temp path\n-     * @param gcsDeadLetterPath the gcs dead letter path\n-     * @param contentStructure the content structure\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsTempPath,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> gcsTempPath,\n-        ValueProvider<String> gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(gcsTempPath)\n-          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n-          .build();\n+    public static Deidentify deidentify(\n+            String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n+        return new Deidentify(\n+                StaticValueProvider.of(sourceFhirStore),\n+                StaticValueProvider.of(destinationFhirStore),\n+                StaticValueProvider.of(deidConfig));\n     }\n \n     /**\n-     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write executeBundles(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n+    public static Deidentify deidentify(\n+            ValueProvider<String> sourceFhirStore,\n+            ValueProvider<String> destinationFhirStore,\n+            ValueProvider<DeidentifyConfig> deidConfig) {\n+        return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n     }\n \n     /**\n-     * Execute bundles write.\n-     *\n-     * @param fhirStore the fhir store\n-     * @return the write\n+     * The type Read.\n      */\n-    public static Write executeBundles(ValueProvider<String> fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n-    }\n+    public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n-\n-    @Override\n-    public Result expand(PCollection<String> input) {\n-      PCollection<HealthcareIOError<String>> failedBundles;\n-      PCollection<HealthcareIOError<String>> failedImports;\n-      switch (this.getWriteMethod()) {\n-        case IMPORT:\n-          LOG.warn(\n-              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n-                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n-          ValueProvider<String> deadPath =\n-              getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n-          FhirIO.Import.ContentStructure contentStructure =\n-              getContentStructure().orElseThrow(IllegalArgumentException::new);\n-          ValueProvider<String> tempPath =\n-              getImportGcsTempPath()\n-                  .orElse(\n-                      StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n-        case EXECUTE_BUNDLE:\n-        default:\n-          failedBundles =\n-              input\n-                  .apply(\n-                      \"Execute FHIR Bundles\",\n-                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n-                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-      return Result.in(input.getPipeline(), failedBundles);\n-    }\n-  }\n-\n-  /**\n-   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n-   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n-   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n-   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n-   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n-   */\n-  public static class Import extends Write {\n-\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> deadLetterGcsPath;\n-    private final ContentStructure contentStructure;\n-    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n-    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n-    private ValueProvider<String> tempGcsPath;\n-\n-    /*\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n-     */\n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> tempGcsPath,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = fhirStore;\n-      this.tempGcsPath = tempGcsPath;\n-      this.deadLetterGcsPath = deadLetterGcsPath;\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+        /**\n+         * Instantiates a new Read.\n+         */\n+        public Read() {\n+        }\n+\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedReads;\n+            /**\n+             * The Pct.\n+             */\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the read result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Read.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                                    + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedReads =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed reads.\n+             *\n+             * @return the failed reads\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedReads() {\n+                return failedReads;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n+\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Read.Result expand(PCollection<String> input) {\n+            return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+        }\n+\n+        /**\n+         * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+         * store, and fetches the actual {@link String} object based on the id in the notification and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class FetchResourceJsonString\n+                extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+            /**\n+             * Instantiates a new Fetch Fhir message DoFn.\n+             */\n+            public FetchResourceJsonString() {\n+            }\n+\n+            @Override\n+            public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+                return new FhirIO.Read.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new ReadResourceFn())\n+                                        .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for fetching messages from the Fhir store with error handling.\n+             */\n+            static class ReadResourceFn extends DoFn<String, String> {\n+\n+                private Counter failedMessageGets =\n+                        Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+                private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+                private final Counter successfulStringGets =\n+                        Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+                private HealthcareApiClient client;\n+                private ObjectMapper mapper;\n+\n+                /**\n+                 * Instantiates a new Hl 7 v 2 message get fn.\n+                 */\n+                ReadResourceFn() {\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                    this.mapper = new ObjectMapper();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    String resourceId = context.element();\n+                    try {\n+                        context.output(fetchResource(this.client, resourceId));\n+                    } catch (Exception e) {\n+                        failedMessageGets.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+                    }\n+                }\n+\n+                private String fetchResource(HealthcareApiClient client, String resourceId)\n+                        throws IOException, IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n \n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this(fhirStore, null, deadLetterGcsPath, contentStructure);\n+                    HttpBody resource = client.readFhirResource(resourceId);\n+\n+                    if (resource == null) {\n+                        throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+                    }\n+                    this.successfulStringGets.inc();\n+                    return mapper.writeValueAsString(resource);\n+                }\n+            }\n+        }\n     }\n+\n     /**\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n+     * The type Write.\n      */\n-    Import(\n-        String fhirStore,\n-        String tempGcsPath,\n-        String deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-      this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-      this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+    @AutoValue\n+    public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n \n-    @Override\n-    ValueProvider<String> getFhirStore() {\n-      return fhirStore;\n-    }\n+        /**\n+         * The tag for the failed writes to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for the files that failed to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for temp files for import to FHIR store`.\n+         */\n+        public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {\n+        };\n \n-    @Override\n-    WriteMethod getWriteMethod() {\n-      return WriteMethod.IMPORT;\n-    }\n+        /**\n+         * The enum Write method.\n+         */\n+        public enum WriteMethod {\n+            /**\n+             * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+             */\n+            EXECUTE_BUNDLE,\n+            /**\n+             * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+             * FHIR stores. <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+             */\n+            IMPORT\n+        }\n \n-    @Override\n-    Optional<ContentStructure> getContentStructure() {\n-      return Optional.of(contentStructure);\n-    }\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput {\n+            private final Pipeline pipeline;\n+            private final PCollection<HealthcareIOError<String>> failedBodies;\n+            private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+            /**\n+             * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+             * pipeline\n+             *\n+             * @param failedBodies the failed inserts\n+             * @return the result\n+             */\n+            static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+                return new Result(pipeline, failedBodies, null);\n+            }\n+\n+            static Result in(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    PCollection<HealthcareIOError<String>> failedFiles) {\n+                return new Result(pipeline, failedBodies, failedFiles);\n+            }\n+\n+            /**\n+             * Gets failed bodies with err.\n+             *\n+             * @return the failed inserts with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+                return this.failedBodies;\n+            }\n+\n+            /**\n+             * Gets failed file imports with err.\n+             *\n+             * @return the failed GCS uri with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+                return this.failedFiles;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pipeline;\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+\n+            private Result(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+                this.pipeline = pipeline;\n+                this.failedBodies = failedBodies;\n+                if (failedFiles == null) {\n+                    failedFiles =\n+                            (PCollection<HealthcareIOError<String>>)\n+                                    pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+                }\n+                this.failedFiles = failedFiles;\n+            }\n+        }\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsTempPath() {\n-      return Optional.of(tempGcsPath);\n-    }\n+        /**\n+         * Gets Fhir store.\n+         *\n+         * @return the Fhir store\n+         */\n+        abstract ValueProvider<String> getFhirStore();\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n-      return Optional.of(deadLetterGcsPath);\n-    }\n+        /**\n+         * Gets write method.\n+         *\n+         * @return the write method\n+         */\n+        abstract WriteMethod getWriteMethod();\n \n-    @Override\n-    public Write.Result expand(PCollection<String> input) {\n-      checkState(\n-          input.isBounded() == IsBounded.BOUNDED,\n-          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n-              + \"intended for batch use only.\");\n-\n-      // fall back on pipeline's temp location.\n-      ValueProvider<String> tempPath =\n-          getImportGcsTempPath()\n-              .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-      // Write bundles of String to GCS\n-      PCollectionTuple writeTmpFileResults =\n-          input.apply(\n-              \"Write nd json to GCS\",\n-              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n-                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n-\n-      PCollection<HealthcareIOError<String>> failedBodies =\n-          writeTmpFileResults\n-              .get(Write.FAILED_BODY)\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      int numShards = 100;\n-      PCollection<HealthcareIOError<String>> failedFiles =\n-          writeTmpFileResults\n-              .get(Write.TEMP_FILES)\n-              .apply(\n-                  \"Shard files\", // to paralelize group into batches\n-                  WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n-              .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n-              .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n-              .setCoder(\n-                  KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n-              .apply(\n-                  \"Import Batches\",\n-                  ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-\n-      input\n-          .getPipeline()\n-          .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n-          .apply(\n-              \"Resolve SubDirs\",\n-              MapElements.into(TypeDescriptors.strings())\n-                  .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n-          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n-          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n-          .apply(\n-              \"Match tempGcsPath\",\n-              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n-          .apply(\n-              \"Delete tempGcsPath\",\n-              ParDo.of(\n-                  new DoFn<Metadata, Void>() {\n-                    @ProcessElement\n-                    public void delete(@Element Metadata path, ProcessContext context) {\n-                      // Wait til window closes for failedBodies and failedFiles to ensure we are\n-                      // done processing\n-                      // anything under tempGcsPath because it has been successfully imported to\n-                      // FHIR store or\n-                      // copies have been moved to the dead letter path.\n-                      // Clean up all of tempGcsPath. This will handle removing phantom temporary\n-                      // objects from\n-                      // failed / rescheduled ImportFn::importBatch.\n-                      try {\n-                        FileSystems.delete(\n-                            Collections.singleton(path.resourceId()),\n-                            StandardMoveOptions.IGNORE_MISSING_FILES);\n-                      } catch (IOException e) {\n-                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n-                      }\n-                    }\n-                  }))\n-          .setCoder(VoidCoder.of());\n+        /**\n+         * Gets content structure.\n+         *\n+         * @return the content structure\n+         */\n+        abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n \n-      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n-    }\n+        /**\n+         * Gets import gcs temp path.\n+         *\n+         * @return the import gcs temp path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n \n-    /** The Write bundles to new line delimited json files. */\n-    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n-\n-      private final ValueProvider<String> fhirStore;\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ObjectMapper mapper;\n-      private ResourceId resourceId;\n-      private WritableByteChannel ndJsonChannel;\n-      private BoundedWindow window;\n-\n-      private transient HealthcareApiClient client;\n-      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n-\n-      WriteBundlesToFilesFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-      }\n-\n-      /**\n-       * Instantiates a new Import fn.\n-       *\n-       * @param fhirStore the fhir store\n-       * @param tempGcsPath the temp gcs path\n-       * @param deadLetterGcsPath the dead letter gcs path\n-       */\n-      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n-        this.fhirStore = StaticValueProvider.of(fhirStore);\n-        this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-        this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      }\n-\n-      /**\n-       * Init client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Init batch.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @StartBundle\n-      public void initFile() throws IOException {\n-        // Write each bundle to newline delimited JSON file.\n-        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n-        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n-        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n-        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n-        if (mapper == null) {\n-          this.mapper = new ObjectMapper();\n-        }\n-      }\n-\n-      /**\n-       * Add to batch.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @ProcessElement\n-      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n-        this.window = window;\n-        String httpBody = context.element();\n-        try {\n-          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n-          Object data = this.mapper.readValue(httpBody, Object.class);\n-          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n-          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n-        } catch (JsonProcessingException e) {\n-          String resource =\n-              String.format(\n-                  \"Failed to parse payload: %s as json at: %s : %s.\"\n-                      + \"Dropping message from batch import.\",\n-                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n-          LOG.warn(resource);\n-          context.output(\n-              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        /**\n+         * Gets import gcs dead letter path.\n+         *\n+         * @return the import gcs dead letter path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n+\n+        /**\n+         * The type Builder.\n+         */\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+\n+            /**\n+             * Sets Fhir store.\n+             *\n+             * @param fhirStore the Fhir store\n+             * @return the Fhir store\n+             */\n+            abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n+\n+            /**\n+             * Sets write method.\n+             *\n+             * @param writeMethod the write method\n+             * @return the write method\n+             */\n+            abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+            /**\n+             * Sets content structure.\n+             *\n+             * @param contentStructure the content structure\n+             * @return the content structure\n+             */\n+            abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+            /**\n+             * Sets import gcs temp path.\n+             *\n+             * @param gcsTempPath the gcs temp path\n+             * @return the import gcs temp path\n+             */\n+            abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n+\n+            /**\n+             * Sets import gcs dead letter path.\n+             *\n+             * @param gcsDeadLetterPath the gcs dead letter path\n+             * @return the import gcs dead letter path\n+             */\n+            abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n+\n+            /**\n+             * Build write.\n+             *\n+             * @return the write\n+             */\n+            abstract Write build();\n         }\n-      }\n-\n-      /**\n-       * Close file.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @FinishBundle\n-      public void closeFile(FinishBundleContext context) throws IOException {\n-        // Write the file with all elements in this bundle to GCS.\n-        ndJsonChannel.close();\n-        context.output(resourceId, window.maxTimestamp(), window);\n-      }\n-    }\n \n-    /** Import batches of new line delimited json files to FHIR Store. */\n-    static class ImportFn\n-        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n-\n-      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ResourceId tempDir;\n-      private final ContentStructure contentStructure;\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> fhirStore;\n-\n-      ImportFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath,\n-          @Nullable ContentStructure contentStructure) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-        if (contentStructure == null) {\n-          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-        } else {\n-          this.contentStructure = contentStructure;\n+        private static Write.Builder write(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n         }\n-      }\n-\n-      @Setup\n-      public void init() throws IOException {\n-        tempDir =\n-            FileSystems.matchNewResource(tempGcsPath.get(), true)\n-                .resolve(\n-                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n-                    StandardResolveOptions.RESOLVE_DIRECTORY);\n-        client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n-       * GCS URI.\n-       */\n-      @ProcessElement\n-      public void importBatch(\n-          @Element KV<Integer, Iterable<ResourceId>> element,\n-          OutputReceiver<HealthcareIOError<String>> output)\n-          throws IOException {\n-        Iterable<ResourceId> batch = element.getValue();\n-        List<ResourceId> tempDestinations = new ArrayList<>();\n-        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n-        assert batch != null;\n-        for (ResourceId file : batch) {\n-          tempDestinations.add(\n-              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n-          deadLetterDestinations.add(\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n-                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+\n+        /**\n+         * Create Method creates a single FHIR resource. @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+         *\n+         * @param fhirStore         the hl 7 v 2 store\n+         * @param gcsTempPath       the gcs temp path\n+         * @param gcsDeadLetterPath the gcs dead letter path\n+         * @param contentStructure  the content structure\n+         * @return the write\n+         */\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsTempPath,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        // Ignore missing files since this might be a retry, which means files\n-        // should have been copied over.\n-        FileSystems.copy(\n-            ImmutableList.copyOf(batch),\n-            tempDestinations,\n-            StandardMoveOptions.IGNORE_MISSING_FILES);\n-        // Check whether any temporary files are not present.\n-        boolean hasMissingFile =\n-            FileSystems.matchResources(tempDestinations).stream()\n-                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n-        if (hasMissingFile) {\n-          throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n-        try {\n-          // Blocking fhirStores.import request.\n-          assert contentStructure != null;\n-          Operation operation =\n-              client.importFhirResource(\n-                  fhirStore.get(), importUri.toString(), contentStructure.name());\n-          client.pollOperation(operation, 500L);\n-          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n-          // needed.\n-          FileSystems.delete(tempDestinations);\n-        } catch (IOException | InterruptedException e) {\n-          ResourceId deadLetterResourceId =\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n-          LOG.warn(\n-              String.format(\n-                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n-                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n-          FileSystems.rename(tempDestinations, deadLetterDestinations);\n-          output.output(HealthcareIOError.of(importUri.toString(), e));\n-        } finally {\n-          // If we've reached this point files have either been successfully import to FHIR store\n-          // or moved to Dead Letter Queue.\n-          // Clean up original files for this batch on GCS.\n-          FileSystems.delete(ImmutableList.copyOf(batch));\n+\n+        public static Write fhirStoresImport(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> gcsTempPath,\n+                ValueProvider<String> gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(gcsTempPath)\n+                    .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+                    .build();\n         }\n-      }\n-    }\n \n-    /** The enum Content structure. */\n-    public enum ContentStructure {\n-      /** If the content structure is not specified, the default value BUNDLE will be used. */\n-      CONTENT_STRUCTURE_UNSPECIFIED,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a bundle, which contains one or more resources. Set the bundle type to history to import\n-       * resource versions.\n-       */\n-      BUNDLE,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a single resource.\n-       */\n-      RESOURCE,\n-      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n-      BUNDLE_PRETTY,\n-      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n-      RESOURCE_PRETTY\n-    }\n-  }\n+        /**\n+         * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+         *\n+         * @param fhirStore the hl 7 v 2 store\n+         * @return the write\n+         */\n+        public static Write executeBundles(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-  /** The type Execute bundles. */\n-  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Execute bundles write.\n+         *\n+         * @param fhirStore the fhir store\n+         * @return the write\n+         */\n+        public static Write executeBundles(ValueProvider<String> fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-    /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    ExecuteBundles(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+        @Override\n+        public Result expand(PCollection<String> input) {\n+            PCollection<HealthcareIOError<String>> failedBundles;\n+            PCollection<HealthcareIOError<String>> failedImports;\n+            switch (this.getWriteMethod()) {\n+                case IMPORT:\n+                    LOG.warn(\n+                            \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                                    + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+                    ValueProvider<String> deadPath =\n+                            getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+                    FhirIO.Import.ContentStructure contentStructure =\n+                            getContentStructure().orElseThrow(IllegalArgumentException::new);\n+                    ValueProvider<String> tempPath =\n+                            getImportGcsTempPath()\n+                                    .orElse(\n+                                            StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+                    return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+                case EXECUTE_BUNDLE:\n+                default:\n+                    failedBundles =\n+                            input\n+                                    .apply(\n+                                            \"Execute FHIR Bundles\",\n+                                            ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                                    .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+            return Result.in(input.getPipeline(), failedBundles);\n+        }\n     }\n \n     /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n+     * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+     * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+     * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+     * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+     * as transactions which is safer practice for a use on a \"live\" FHIR store.\n      */\n-    ExecuteBundles(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Import extends Write {\n \n-    @Override\n-    public FhirIO.Write.Result expand(PCollection<String> input) {\n-      return Write.Result.in(\n-          input.getPipeline(),\n-          input\n-              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-    }\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> deadLetterGcsPath;\n+        private final ContentStructure contentStructure;\n+        private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+        private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+        private ValueProvider<String> tempGcsPath;\n+\n+        /*\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore the fhir store\n+         * @param tempGcsPath the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure the content structure\n+         */\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> tempGcsPath,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = fhirStore;\n+            this.tempGcsPath = tempGcsPath;\n+            this.deadLetterGcsPath = deadLetterGcsPath;\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    /** The type Write Fhir fn. */\n-    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n-\n-      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n-      private transient HealthcareApiClient client;\n-      private final ObjectMapper mapper = new ObjectMapper();\n-      /** The Fhir store. */\n-      private final ValueProvider<String> fhirStore;\n-\n-      /**\n-       * Instantiates a new Write Fhir fn.\n-       *\n-       * @param fhirStore the Fhir store\n-       */\n-      ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      /**\n-       * Initialize healthcare client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Execute Bundles.\n-       *\n-       * @param context the context\n-       */\n-      @ProcessElement\n-      public void executeBundles(ProcessContext context) {\n-        String body = context.element();\n-        try {\n-          // Validate that data was set to valid JSON.\n-          mapper.readTree(body);\n-          client.executeFhirBundle(fhirStore.get(), body);\n-        } catch (IOException | HealthcareHttpException e) {\n-          failedBundles.inc();\n-          context.output(HealthcareIOError.of(body, e));\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this(fhirStore, null, deadLetterGcsPath, contentStructure);\n         }\n-      }\n-    }\n-  }\n \n-  /** Export FHIR resources from a FHIR store to new line delimited json files on GCS. */\n-  public static class Export extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> exportGcsUriPrefix;\n+        /**\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore         the fhir store\n+         * @param tempGcsPath       the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure  the content structure\n+         */\n+        Import(\n+                String fhirStore,\n+                String tempGcsPath,\n+                String deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+            this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+            this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-      this.fhirStore = fhirStore;\n-      this.exportGcsUriPrefix = exportGcsUriPrefix;\n-    }\n+        @Override\n+        ValueProvider<String> getFhirStore() {\n+            return fhirStore;\n+        }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleExportOperations\",\n-              ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n-          .apply(FileIO.matchAll())\n-          .apply(FileIO.readMatches())\n-          .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n-    }\n+        @Override\n+        WriteMethod getWriteMethod() {\n+            return WriteMethod.IMPORT;\n+        }\n \n-    /** A function that schedules an export operation and monitors the status. */\n-    public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> exportGcsUriPrefix;\n-\n-      public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n-        this.exportGcsUriPrefix = exportGcsUriPrefix;\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void exportResourcesToGcs(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String fhirStore = context.element();\n-        String gcsPrefix = this.exportGcsUriPrefix.get();\n-        Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new RuntimeException(\n-              String.format(\"Export operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ContentStructure> getContentStructure() {\n+            return Optional.of(contentStructure);\n         }\n-        context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n-      }\n-    }\n-  }\n-\n-  /** Deidentify FHIR resources from a FHIR store to a destination FHIR store. */\n-  public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> sourceFhirStore;\n-    private final ValueProvider<String> destinationFhirStore;\n-    private final ValueProvider<DeidentifyConfig> deidConfig;\n-\n-    public Deidentify(\n-        ValueProvider<String> sourceFhirStore,\n-        ValueProvider<String> destinationFhirStore,\n-        ValueProvider<DeidentifyConfig> deidConfig) {\n-      this.sourceFhirStore = sourceFhirStore;\n-      this.destinationFhirStore = destinationFhirStore;\n-      this.deidConfig = deidConfig;\n-    }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .getPipeline()\n-          .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleDeidentifyFhirStoreOperations\",\n-              ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n-    }\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsTempPath() {\n+            return Optional.of(tempGcsPath);\n+        }\n \n-    /** A function that schedules a deidentify operation and monitors the status. */\n-    public static class DeidentifyFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> destinationFhirStore;\n-      private static final Gson gson = new Gson();\n-      private final String deidConfigJson;\n-\n-      public DeidentifyFn(\n-          ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n-        this.destinationFhirStore = destinationFhirStore;\n-        this.deidConfigJson = gson.toJson(deidConfig.get());\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void deidentify(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String sourceFhirStore = context.element();\n-        String destinationFhirStore = this.destinationFhirStore.get();\n-        DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n-        Operation operation =\n-            client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new IOException(\n-              String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n+            return Optional.of(deadLetterGcsPath);\n         }\n-        context.output(destinationFhirStore);\n-      }\n-    }\n-  }\n \n-  /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+        @Override\n+        public Write.Result expand(PCollection<String> input) {\n+            checkState(\n+                    input.isBounded() == IsBounded.BOUNDED,\n+                    \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+                            + \"intended for batch use only.\");\n+\n+            // fall back on pipeline's temp location.\n+            ValueProvider<String> tempPath =\n+                    getImportGcsTempPath()\n+                            .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+            // Write bundles of String to GCS\n+            PCollectionTuple writeTmpFileResults =\n+                    input.apply(\n+                            \"Write nd json to GCS\",\n+                            ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                                    .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+            PCollection<HealthcareIOError<String>> failedBodies =\n+                    writeTmpFileResults\n+                            .get(Write.FAILED_BODY)\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            int numShards = 100;\n+            PCollection<HealthcareIOError<String>> failedFiles =\n+                    writeTmpFileResults\n+                            .get(Write.TEMP_FILES)\n+                            .apply(\n+                                    \"Shard files\", // to paralelize group into batches\n+                                    WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n+                            .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n+                            .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+                            .setCoder(\n+                                    KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n+                            .apply(\n+                                    \"Import Batches\",\n+                                    ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+            input\n+                    .getPipeline()\n+                    .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"Resolve SubDirs\",\n+                            MapElements.into(TypeDescriptors.strings())\n+                                    .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n+                    .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+                    .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+                    .apply(\n+                            \"Match tempGcsPath\",\n+                            FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+                    .apply(\n+                            \"Delete tempGcsPath\",\n+                            ParDo.of(\n+                                    new DoFn<Metadata, Void>() {\n+                                        @ProcessElement\n+                                        public void delete(@Element Metadata path, ProcessContext context) {\n+                                            // Wait til window closes for failedBodies and failedFiles to ensure we are\n+                                            // done processing\n+                                            // anything under tempGcsPath because it has been successfully imported to\n+                                            // FHIR store or\n+                                            // copies have been moved to the dead letter path.\n+                                            // Clean up all of tempGcsPath. This will handle removing phantom temporary\n+                                            // objects from\n+                                            // failed / rescheduled ImportFn::importBatch.\n+                                            try {\n+                                                FileSystems.delete(\n+                                                        Collections.singleton(path.resourceId()),\n+                                                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                                            } catch (IOException e) {\n+                                                LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                                            }\n+                                        }\n+                                    }))\n+                    .setCoder(VoidCoder.of());\n+\n+            return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+        }\n+\n+        /**\n+         * The Write bundles to new line delimited json files.\n+         */\n+        static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+            private final ValueProvider<String> fhirStore;\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ObjectMapper mapper;\n+            private ResourceId resourceId;\n+            private WritableByteChannel ndJsonChannel;\n+            private BoundedWindow window;\n+\n+            private transient HealthcareApiClient client;\n+            private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+            WriteBundlesToFilesFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+            }\n+\n+            /**\n+             * Instantiates a new Import fn.\n+             *\n+             * @param fhirStore         the fhir store\n+             * @param tempGcsPath       the temp gcs path\n+             * @param deadLetterGcsPath the dead letter gcs path\n+             */\n+            WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+                this.fhirStore = StaticValueProvider.of(fhirStore);\n+                this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+                this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            }\n+\n+            /**\n+             * Init client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Init batch.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @StartBundle\n+            public void initFile() throws IOException {\n+                // Write each bundle to newline delimited JSON file.\n+                String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+                ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n+                this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+                this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+                if (mapper == null) {\n+                    this.mapper = new ObjectMapper();\n+                }\n+            }\n+\n+            /**\n+             * Add to batch.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @ProcessElement\n+            public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+                this.window = window;\n+                String httpBody = context.element();\n+                try {\n+                    // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+                    Object data = this.mapper.readValue(httpBody, Object.class);\n+                    String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+                    this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+                } catch (JsonProcessingException e) {\n+                    String resource =\n+                            String.format(\n+                                    \"Failed to parse payload: %s as json at: %s : %s.\"\n+                                            + \"Dropping message from batch import.\",\n+                                    httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+                    LOG.warn(resource);\n+                    context.output(\n+                            Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+                }\n+            }\n+\n+            /**\n+             * Close file.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @FinishBundle\n+            public void closeFile(FinishBundleContext context) throws IOException {\n+                // Write the file with all elements in this bundle to GCS.\n+                ndJsonChannel.close();\n+                context.output(resourceId, window.maxTimestamp(), window);\n+            }\n+        }\n \n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Import batches of new line delimited json files to FHIR Store.\n+         */\n+        static class ImportFn\n+                extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+            private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ResourceId tempDir;\n+            private final ContentStructure contentStructure;\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> fhirStore;\n+\n+            ImportFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath,\n+                    @Nullable ContentStructure contentStructure) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+                if (contentStructure == null) {\n+                    this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+                } else {\n+                    this.contentStructure = contentStructure;\n+                }\n+            }\n+\n+            @Setup\n+            public void init() throws IOException {\n+                tempDir =\n+                        FileSystems.matchNewResource(tempGcsPath.get(), true)\n+                                .resolve(\n+                                        String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                                        StandardResolveOptions.RESOLVE_DIRECTORY);\n+                client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+             * GCS URI.\n+             */\n+            @ProcessElement\n+            public void importBatch(\n+                    @Element KV<Integer, Iterable<ResourceId>> element,\n+                    OutputReceiver<HealthcareIOError<String>> output)\n+                    throws IOException {\n+                Iterable<ResourceId> batch = element.getValue();\n+                List<ResourceId> tempDestinations = new ArrayList<>();\n+                List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+                assert batch != null;\n+                for (ResourceId file : batch) {\n+                    tempDestinations.add(\n+                            tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                    deadLetterDestinations.add(\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n+                                    .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                }\n+                // Ignore missing files since this might be a retry, which means files\n+                // should have been copied over.\n+                FileSystems.copy(\n+                        ImmutableList.copyOf(batch),\n+                        tempDestinations,\n+                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                // Check whether any temporary files are not present.\n+                boolean hasMissingFile =\n+                        FileSystems.matchResources(tempDestinations).stream()\n+                                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n+                if (hasMissingFile) {\n+                    throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+                }\n+                ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+                try {\n+                    // Blocking fhirStores.import request.\n+                    assert contentStructure != null;\n+                    Operation operation =\n+                            client.importFhirResource(\n+                                    fhirStore.get(), importUri.toString(), contentStructure.name());\n+                    client.pollOperation(operation, 500L);\n+                    // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+                    // needed.\n+                    FileSystems.delete(tempDestinations);\n+                } catch (IOException | InterruptedException e) {\n+                    ResourceId deadLetterResourceId =\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n+                    LOG.warn(\n+                            String.format(\n+                                    \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                                    importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+                    FileSystems.rename(tempDestinations, deadLetterDestinations);\n+                    output.output(HealthcareIOError.of(importUri.toString(), e));\n+                } finally {\n+                    // If we've reached this point files have either been successfully import to FHIR store\n+                    // or moved to Dead Letter Queue.\n+                    // Clean up original files for this batch on GCS.\n+                    FileSystems.delete(ImmutableList.copyOf(batch));\n+                }\n+            }\n+        }\n+\n+        /**\n+         * The enum Content structure.\n+         */\n+        public enum ContentStructure {\n+            /**\n+             * If the content structure is not specified, the default value BUNDLE will be used.\n+             */\n+            CONTENT_STRUCTURE_UNSPECIFIED,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a bundle, which contains one or more resources. Set the bundle type to history to import\n+             * resource versions.\n+             */\n+            BUNDLE,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a single resource.\n+             */\n+            RESOURCE,\n+            /**\n+             * The entire file is one JSON bundle. The JSON can span multiple lines.\n+             */\n+            BUNDLE_PRETTY,\n+            /**\n+             * The entire file is one JSON resource. The JSON can span multiple lines.\n+             */\n+            RESOURCE_PRETTY\n+        }\n+    }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * The type Execute bundles.\n      */\n-    Search(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+    public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+        private final ValueProvider<String> fhirStore;\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        @Override\n+        public FhirIO.Write.Result expand(PCollection<String> input) {\n+            return Write.Result.in(\n+                    input.getPipeline(),\n+                    input\n+                            .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+\n+        /**\n+         * The type Write Fhir fn.\n+         */\n+        static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+            private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+            private transient HealthcareApiClient client;\n+            private final ObjectMapper mapper = new ObjectMapper();\n+            /**\n+             * The Fhir store.\n+             */\n+            private final ValueProvider<String> fhirStore;\n+\n+            /**\n+             * Instantiates a new Write Fhir fn.\n+             *\n+             * @param fhirStore the Fhir store\n+             */\n+            ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            /**\n+             * Initialize healthcare client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Execute Bundles.\n+             *\n+             * @param context the context\n+             */\n+            @ProcessElement\n+            public void executeBundles(ProcessContext context) {\n+                String body = context.element();\n+                try {\n+                    // Validate that data was set to valid JSON.\n+                    mapper.readTree(body);\n+                    client.executeFhirBundle(fhirStore.get(), body);\n+                } catch (IOException | HealthcareHttpException e) {\n+                    failedBundles.inc();\n+                    context.output(HealthcareIOError.of(body, e));\n+                }\n+            }\n+        }\n     }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * Export FHIR resources from a FHIR store to new line delimited json files on GCS.\n      */\n-    Search(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Export extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> exportGcsUriPrefix;\n+\n+        public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+            this.fhirStore = fhirStore;\n+            this.exportGcsUriPrefix = exportGcsUriPrefix;\n+        }\n \n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedSearches;\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the search result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-                .keySet()\n-                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Search.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n-                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleExportOperations\",\n+                            ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n+                    .apply(FileIO.matchAll())\n+                    .apply(FileIO.readMatches())\n+                    .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n+        }\n+\n+        /**\n+         * A function that schedules an export operation and monitors the status.\n+         */\n+        public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> exportGcsUriPrefix;\n+\n+            public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n+                this.exportGcsUriPrefix = exportGcsUriPrefix;\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void exportResourcesToGcs(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String fhirStore = context.element();\n+                String gcsPrefix = this.exportGcsUriPrefix.get();\n+                Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new RuntimeException(\n+                            String.format(\"Export operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n+            }\n         }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedSearches =\n-                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed searches.\n-       *\n-       * @return the failed searches\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n-        return failedSearches;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-              String transformName, PInput input, PTransform<?, ?> transform) {}\n     }\n \n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-            new TupleTag<HealthcareIOError<String>>() {};\n+    /**\n+     * Deidentify FHIR resources from a FHIR store to a destination FHIR store.\n+     */\n+    public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> sourceFhirStore;\n+        private final ValueProvider<String> destinationFhirStore;\n+        private final ValueProvider<DeidentifyConfig> deidConfig;\n+\n+        public Deidentify(\n+                ValueProvider<String> sourceFhirStore,\n+                ValueProvider<String> destinationFhirStore,\n+                ValueProvider<DeidentifyConfig> deidConfig) {\n+            this.sourceFhirStore = sourceFhirStore;\n+            this.destinationFhirStore = destinationFhirStore;\n+            this.deidConfig = deidConfig;\n+        }\n \n-    @Override\n-    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n-      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .getPipeline()\n+                    .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleDeidentifyFhirStoreOperations\",\n+                            ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n+        }\n+\n+        /**\n+         * A function that schedules a deidentify operation and monitors the status.\n+         */\n+        public static class DeidentifyFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> destinationFhirStore;\n+            private static final Gson gson = new Gson();\n+            private final String deidConfigJson;\n+\n+            public DeidentifyFn(\n+                    ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n+                this.destinationFhirStore = destinationFhirStore;\n+                this.deidConfigJson = gson.toJson(deidConfig.get());\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void deidentify(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String sourceFhirStore = context.element();\n+                String destinationFhirStore = this.destinationFhirStore.get();\n+                DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n+                Operation operation =\n+                        client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new IOException(\n+                            String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(destinationFhirStore);\n+            }\n+        }\n     }\n \n     /**\n-     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n-     * and search parameters, and fetches all matching resources based on the search criteria and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n-     *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of failed searches from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * The type Search.\n      */\n-    static class SearchResourcesJsonString\n-            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-\n-      private final ValueProvider<String> fhirStore;\n-\n-      /** Instantiates a new Search Fhir resources DoFn. */\n-      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      @Override\n-      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n-        return new FhirIO.Search.Result(\n-                resourceIds.apply(\n-                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n-                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for searching messages from the Fhir store with error handling. */\n-      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n-\n-        private Counter failedSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n-        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n-        private final Counter successfulSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n-        private HealthcareApiClient client;\n+    public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n         private final ValueProvider<String> fhirStore;\n \n-        /** Instantiates a new Fhir resources search fn. */\n-        SearchResourcesFn(ValueProvider<String> fhirStore) {\n-          this.fhirStore = fhirStore;\n+        Search(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        Search(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedSearches;\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the search result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Search.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                                    + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedSearches =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed searches.\n+             *\n+             * @return the failed searches\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+                return failedSearches;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n         }\n \n         /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n+         * The tag for the main output of Fhir Messages.\n          */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+            return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n         }\n \n         /**\n-         * Process element.\n+         * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n          *\n-         * @param context the context\n+         * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+         * and search parameters, and fetches all matching resources based on the search criteria and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of failed searches from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n          */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          KV<String, Map<String, String>> elementValues = context.element();\n-          try {\n-            context.output(searchResources(\n-                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n-          } catch (Exception e) {\n-            failedSearches.inc();\n-            LOG.warn(\n-                    String.format(\n-                            \"Error search FHIR messages writing to Dead Letter \"\n-                                    + \"Queue. Cause: %s Stack Trace: %s\",\n-                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n-          }\n-        }\n-\n-        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n-                                       @Nullable Map<String, String> parameters)\n-                throws IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n-                  new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n-                          client, fhirStore, resourceType, parameters);\n-          JsonArray result = new JsonArray();\n-          while (iter.hasNext()) {\n-            result.addAll(iter.next());\n-          }\n-          this.successfulSearches.inc();\n-          return result.toString();\n+        static class SearchResourcesJsonString\n+                extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+            private final ValueProvider<String> fhirStore;\n+\n+            public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            @Override\n+            public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+                return new FhirIO.Search.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                        .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for searching messages from the Fhir store with error handling.\n+             */\n+            static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+                private Counter failedSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+                private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+                private final Counter successfulSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+                private HealthcareApiClient client;\n+                private final ValueProvider<String> fhirStore;\n+\n+                /**\n+                 * Instantiates a new Fhir resources search fn.\n+                 */\n+                SearchResourcesFn(ValueProvider<String> fhirStore) {\n+                    this.fhirStore = fhirStore;\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    KV<String, Map<String, String>> elementValues = context.element();\n+                    try {\n+                        context.output(searchResources(\n+                                this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+                    } catch (Exception e) {\n+                        failedSearches.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error search FHIR messages writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+                    }\n+                }\n+\n+                private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                               @Nullable Map<String, String> parameters)\n+                        throws IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                            new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                                    client, fhirStore, resourceType, parameters);\n+                    JsonArray result = new JsonArray();\n+                    while (iter.hasNext()) {\n+                        result.addAll(iter.next());\n+                    }\n+                    this.successfulSearches.inc();\n+                    return result.toString();\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNzExMw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529807113", "bodyText": "nit: you can remove these if they are obvious. Same for other comments.", "author": "lastomato", "createdAt": "2020-11-24T18:55:43Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -215,6 +227,16 @@ public static Read readResources() {\n     return new Read();\n   }\n \n+  /**\n+   * Search resources from a PCollection\n+   *\n+   * @return the search", "originalCommit": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzNjUwNA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529836504", "bodyText": "Keeping this one for consistency with other methods, removed some other comments.", "author": "janeliulwq", "createdAt": "2020-11-24T19:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNzExMw=="}], "type": "inlineReview", "revised_code": {"commit": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 9c0d0e409d..257d9f4a5c 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -212,1406 +214,1476 @@ import org.slf4j.LoggerFactory;\n  * </pre>\n  */\n @SuppressWarnings({\n-  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+        \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n })\n public class FhirIO {\n \n-  /**\n-   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n-   * notifications)\n-   *\n-   * @return the read\n-   * @see Read\n-   */\n-  public static Read readResources() {\n-    return new Read();\n-  }\n-\n-  /**\n-   * Search resources from a PCollection\n-   *\n-   * @return the search\n-   * @see Search\n-   */\n-  public static Search searchResources(String fhirStore) {\n-    return new Search(fhirStore);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      String fhirStore,\n-      String tempDir,\n-      String deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      ValueProvider<String> fhirStore,\n-      ValueProvider<String> tempDir,\n-      ValueProvider<String> deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n-    return new Export(\n-        StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(\n-      ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-    return new Export(fhirStore, exportGcsUriPrefix);\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n-    return new Deidentify(\n-        StaticValueProvider.of(sourceFhirStore),\n-        StaticValueProvider.of(destinationFhirStore),\n-        StaticValueProvider.of(deidConfig));\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      ValueProvider<String> sourceFhirStore,\n-      ValueProvider<String> destinationFhirStore,\n-      ValueProvider<DeidentifyConfig> deidConfig) {\n-    return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n-  }\n-\n-  /** The type Read. */\n-  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n-\n-    /** Instantiates a new Read. */\n-    public Read() {}\n-\n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedReads;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the read result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-            .keySet()\n-            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Read.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n-                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n-        }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedReads =\n-            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed reads.\n-       *\n-       * @return the failed reads\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedReads() {\n-        return failedReads;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n-\n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-\n-    @Override\n-    public FhirIO.Read.Result expand(PCollection<String> input) {\n-      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n-    }\n-\n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n+     * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+     * notifications)\n      *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * @return the read\n+     * @see Read\n      */\n-    static class FetchResourceJsonString\n-        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-\n-      /** Instantiates a new Fetch Fhir message DoFn. */\n-      public FetchResourceJsonString() {}\n-\n-      @Override\n-      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n-        return new FhirIO.Read.Result(\n-            resourceIds.apply(\n-                ParDo.of(new ReadResourceFn())\n-                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for fetching messages from the Fhir store with error handling. */\n-      static class ReadResourceFn extends DoFn<String, String> {\n-\n-        private Counter failedMessageGets =\n-            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n-        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n-        private final Counter successfulStringGets =\n-            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n-\n-        /** Instantiates a new Hl 7 v 2 message get fn. */\n-        ReadResourceFn() {}\n-\n-        /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n-         */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n-        }\n-\n-        /**\n-         * Process element.\n-         *\n-         * @param context the context\n-         */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          String resourceId = context.element();\n-          try {\n-            context.output(fetchResource(this.client, resourceId));\n-          } catch (Exception e) {\n-            failedMessageGets.inc();\n-            LOG.warn(\n-                String.format(\n-                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n-                        + \"Queue. Cause: %s Stack Trace: %s\",\n-                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n-          }\n-        }\n-\n-        private String fetchResource(HealthcareApiClient client, String resourceId)\n-            throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpBody resource = client.readFhirResource(resourceId);\n-\n-          if (resource == null) {\n-            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n-          }\n-          this.successfulStringGets.inc();\n-          return mapper.writeValueAsString(resource);\n-        }\n-      }\n-    }\n-  }\n-\n-  /** The type Write. */\n-  @AutoValue\n-  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n-\n-    /** The tag for the failed writes to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for the files that failed to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for temp files for import to FHIR store`. */\n-    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n-\n-    /** The enum Write method. */\n-    public enum WriteMethod {\n-      /**\n-       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n-       */\n-      EXECUTE_BUNDLE,\n-      /**\n-       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n-       * FHIR stores. <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n-       */\n-      IMPORT\n-    }\n-\n-    /** The type Result. */\n-    public static class Result implements POutput {\n-      private final Pipeline pipeline;\n-      private final PCollection<HealthcareIOError<String>> failedBodies;\n-      private final PCollection<HealthcareIOError<String>> failedFiles;\n-\n-      /**\n-       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n-       * pipeline\n-       *\n-       * @param failedBodies the failed inserts\n-       * @return the result\n-       */\n-      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n-        return new Result(pipeline, failedBodies, null);\n-      }\n-\n-      static Result in(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          PCollection<HealthcareIOError<String>> failedFiles) {\n-        return new Result(pipeline, failedBodies, failedFiles);\n-      }\n-\n-      /**\n-       * Gets failed bodies with err.\n-       *\n-       * @return the failed inserts with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n-        return this.failedBodies;\n-      }\n-\n-      /**\n-       * Gets failed file imports with err.\n-       *\n-       * @return the failed GCS uri with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n-        return this.failedFiles;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pipeline;\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-\n-      private Result(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n-        this.pipeline = pipeline;\n-        this.failedBodies = failedBodies;\n-        if (failedFiles == null) {\n-          failedFiles =\n-              (PCollection<HealthcareIOError<String>>)\n-                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-        }\n-        this.failedFiles = failedFiles;\n-      }\n+    public static Read readResources() {\n+        return new Read();\n     }\n \n     /**\n-     * Gets Fhir store.\n+     * Search resources from a Fhir store.\n      *\n-     * @return the Fhir store\n+     * @return the search\n+     * @see Search\n      */\n-    abstract ValueProvider<String> getFhirStore();\n+    public static Search searchResources(String fhirStore) {\n+        return new Search(fhirStore);\n+    }\n \n     /**\n-     * Gets write method.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the write method\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract WriteMethod getWriteMethod();\n+    public static Import importResources(\n+            String fhirStore,\n+            String tempDir,\n+            String deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets content structure.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the content structure\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+    public static Import importResources(\n+            ValueProvider<String> fhirStore,\n+            ValueProvider<String> tempDir,\n+            ValueProvider<String> deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets import gcs temp path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs temp path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n+    public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n+        return new Export(\n+                StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n+    }\n \n     /**\n-     * Gets import gcs dead letter path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs dead letter path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n-\n-    /** The type Builder. */\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-\n-      /**\n-       * Sets Fhir store.\n-       *\n-       * @param fhirStore the Fhir store\n-       * @return the Fhir store\n-       */\n-      abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n-\n-      /**\n-       * Sets write method.\n-       *\n-       * @param writeMethod the write method\n-       * @return the write method\n-       */\n-      abstract Builder setWriteMethod(WriteMethod writeMethod);\n-\n-      /**\n-       * Sets content structure.\n-       *\n-       * @param contentStructure the content structure\n-       * @return the content structure\n-       */\n-      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n-\n-      /**\n-       * Sets import gcs temp path.\n-       *\n-       * @param gcsTempPath the gcs temp path\n-       * @return the import gcs temp path\n-       */\n-      abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n-\n-      /**\n-       * Sets import gcs dead letter path.\n-       *\n-       * @param gcsDeadLetterPath the gcs dead letter path\n-       * @return the import gcs dead letter path\n-       */\n-      abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n-\n-      /**\n-       * Build write.\n-       *\n-       * @return the write\n-       */\n-      abstract Write build();\n-    }\n-\n-    private static Write.Builder write(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n+    public static Export exportResourcesToGcs(\n+            ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+        return new Export(fhirStore, exportGcsUriPrefix);\n     }\n \n     /**\n-     * Create Method creates a single FHIR resource. @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @param gcsTempPath the gcs temp path\n-     * @param gcsDeadLetterPath the gcs dead letter path\n-     * @param contentStructure the content structure\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsTempPath,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> gcsTempPath,\n-        ValueProvider<String> gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(gcsTempPath)\n-          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n-          .build();\n+    public static Deidentify deidentify(\n+            String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n+        return new Deidentify(\n+                StaticValueProvider.of(sourceFhirStore),\n+                StaticValueProvider.of(destinationFhirStore),\n+                StaticValueProvider.of(deidConfig));\n     }\n \n     /**\n-     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write executeBundles(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n+    public static Deidentify deidentify(\n+            ValueProvider<String> sourceFhirStore,\n+            ValueProvider<String> destinationFhirStore,\n+            ValueProvider<DeidentifyConfig> deidConfig) {\n+        return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n     }\n \n     /**\n-     * Execute bundles write.\n-     *\n-     * @param fhirStore the fhir store\n-     * @return the write\n+     * The type Read.\n      */\n-    public static Write executeBundles(ValueProvider<String> fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n-    }\n+    public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n-\n-    @Override\n-    public Result expand(PCollection<String> input) {\n-      PCollection<HealthcareIOError<String>> failedBundles;\n-      PCollection<HealthcareIOError<String>> failedImports;\n-      switch (this.getWriteMethod()) {\n-        case IMPORT:\n-          LOG.warn(\n-              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n-                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n-          ValueProvider<String> deadPath =\n-              getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n-          FhirIO.Import.ContentStructure contentStructure =\n-              getContentStructure().orElseThrow(IllegalArgumentException::new);\n-          ValueProvider<String> tempPath =\n-              getImportGcsTempPath()\n-                  .orElse(\n-                      StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n-        case EXECUTE_BUNDLE:\n-        default:\n-          failedBundles =\n-              input\n-                  .apply(\n-                      \"Execute FHIR Bundles\",\n-                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n-                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-      return Result.in(input.getPipeline(), failedBundles);\n-    }\n-  }\n-\n-  /**\n-   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n-   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n-   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n-   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n-   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n-   */\n-  public static class Import extends Write {\n-\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> deadLetterGcsPath;\n-    private final ContentStructure contentStructure;\n-    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n-    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n-    private ValueProvider<String> tempGcsPath;\n-\n-    /*\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n-     */\n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> tempGcsPath,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = fhirStore;\n-      this.tempGcsPath = tempGcsPath;\n-      this.deadLetterGcsPath = deadLetterGcsPath;\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+        /**\n+         * Instantiates a new Read.\n+         */\n+        public Read() {\n+        }\n+\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedReads;\n+            /**\n+             * The Pct.\n+             */\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the read result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Read.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                                    + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedReads =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed reads.\n+             *\n+             * @return the failed reads\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedReads() {\n+                return failedReads;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n+\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Read.Result expand(PCollection<String> input) {\n+            return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+        }\n+\n+        /**\n+         * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+         * store, and fetches the actual {@link String} object based on the id in the notification and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class FetchResourceJsonString\n+                extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+            /**\n+             * Instantiates a new Fetch Fhir message DoFn.\n+             */\n+            public FetchResourceJsonString() {\n+            }\n+\n+            @Override\n+            public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+                return new FhirIO.Read.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new ReadResourceFn())\n+                                        .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for fetching messages from the Fhir store with error handling.\n+             */\n+            static class ReadResourceFn extends DoFn<String, String> {\n+\n+                private Counter failedMessageGets =\n+                        Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+                private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+                private final Counter successfulStringGets =\n+                        Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+                private HealthcareApiClient client;\n+                private ObjectMapper mapper;\n+\n+                /**\n+                 * Instantiates a new Hl 7 v 2 message get fn.\n+                 */\n+                ReadResourceFn() {\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                    this.mapper = new ObjectMapper();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    String resourceId = context.element();\n+                    try {\n+                        context.output(fetchResource(this.client, resourceId));\n+                    } catch (Exception e) {\n+                        failedMessageGets.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+                    }\n+                }\n+\n+                private String fetchResource(HealthcareApiClient client, String resourceId)\n+                        throws IOException, IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n \n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this(fhirStore, null, deadLetterGcsPath, contentStructure);\n+                    HttpBody resource = client.readFhirResource(resourceId);\n+\n+                    if (resource == null) {\n+                        throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+                    }\n+                    this.successfulStringGets.inc();\n+                    return mapper.writeValueAsString(resource);\n+                }\n+            }\n+        }\n     }\n+\n     /**\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n+     * The type Write.\n      */\n-    Import(\n-        String fhirStore,\n-        String tempGcsPath,\n-        String deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-      this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-      this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+    @AutoValue\n+    public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n \n-    @Override\n-    ValueProvider<String> getFhirStore() {\n-      return fhirStore;\n-    }\n+        /**\n+         * The tag for the failed writes to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for the files that failed to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for temp files for import to FHIR store`.\n+         */\n+        public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {\n+        };\n \n-    @Override\n-    WriteMethod getWriteMethod() {\n-      return WriteMethod.IMPORT;\n-    }\n+        /**\n+         * The enum Write method.\n+         */\n+        public enum WriteMethod {\n+            /**\n+             * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+             */\n+            EXECUTE_BUNDLE,\n+            /**\n+             * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+             * FHIR stores. <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+             */\n+            IMPORT\n+        }\n \n-    @Override\n-    Optional<ContentStructure> getContentStructure() {\n-      return Optional.of(contentStructure);\n-    }\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput {\n+            private final Pipeline pipeline;\n+            private final PCollection<HealthcareIOError<String>> failedBodies;\n+            private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+            /**\n+             * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+             * pipeline\n+             *\n+             * @param failedBodies the failed inserts\n+             * @return the result\n+             */\n+            static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+                return new Result(pipeline, failedBodies, null);\n+            }\n+\n+            static Result in(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    PCollection<HealthcareIOError<String>> failedFiles) {\n+                return new Result(pipeline, failedBodies, failedFiles);\n+            }\n+\n+            /**\n+             * Gets failed bodies with err.\n+             *\n+             * @return the failed inserts with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+                return this.failedBodies;\n+            }\n+\n+            /**\n+             * Gets failed file imports with err.\n+             *\n+             * @return the failed GCS uri with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+                return this.failedFiles;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pipeline;\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+\n+            private Result(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+                this.pipeline = pipeline;\n+                this.failedBodies = failedBodies;\n+                if (failedFiles == null) {\n+                    failedFiles =\n+                            (PCollection<HealthcareIOError<String>>)\n+                                    pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+                }\n+                this.failedFiles = failedFiles;\n+            }\n+        }\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsTempPath() {\n-      return Optional.of(tempGcsPath);\n-    }\n+        /**\n+         * Gets Fhir store.\n+         *\n+         * @return the Fhir store\n+         */\n+        abstract ValueProvider<String> getFhirStore();\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n-      return Optional.of(deadLetterGcsPath);\n-    }\n+        /**\n+         * Gets write method.\n+         *\n+         * @return the write method\n+         */\n+        abstract WriteMethod getWriteMethod();\n \n-    @Override\n-    public Write.Result expand(PCollection<String> input) {\n-      checkState(\n-          input.isBounded() == IsBounded.BOUNDED,\n-          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n-              + \"intended for batch use only.\");\n-\n-      // fall back on pipeline's temp location.\n-      ValueProvider<String> tempPath =\n-          getImportGcsTempPath()\n-              .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-      // Write bundles of String to GCS\n-      PCollectionTuple writeTmpFileResults =\n-          input.apply(\n-              \"Write nd json to GCS\",\n-              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n-                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n-\n-      PCollection<HealthcareIOError<String>> failedBodies =\n-          writeTmpFileResults\n-              .get(Write.FAILED_BODY)\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      int numShards = 100;\n-      PCollection<HealthcareIOError<String>> failedFiles =\n-          writeTmpFileResults\n-              .get(Write.TEMP_FILES)\n-              .apply(\n-                  \"Shard files\", // to paralelize group into batches\n-                  WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n-              .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n-              .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n-              .setCoder(\n-                  KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n-              .apply(\n-                  \"Import Batches\",\n-                  ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-\n-      input\n-          .getPipeline()\n-          .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n-          .apply(\n-              \"Resolve SubDirs\",\n-              MapElements.into(TypeDescriptors.strings())\n-                  .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n-          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n-          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n-          .apply(\n-              \"Match tempGcsPath\",\n-              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n-          .apply(\n-              \"Delete tempGcsPath\",\n-              ParDo.of(\n-                  new DoFn<Metadata, Void>() {\n-                    @ProcessElement\n-                    public void delete(@Element Metadata path, ProcessContext context) {\n-                      // Wait til window closes for failedBodies and failedFiles to ensure we are\n-                      // done processing\n-                      // anything under tempGcsPath because it has been successfully imported to\n-                      // FHIR store or\n-                      // copies have been moved to the dead letter path.\n-                      // Clean up all of tempGcsPath. This will handle removing phantom temporary\n-                      // objects from\n-                      // failed / rescheduled ImportFn::importBatch.\n-                      try {\n-                        FileSystems.delete(\n-                            Collections.singleton(path.resourceId()),\n-                            StandardMoveOptions.IGNORE_MISSING_FILES);\n-                      } catch (IOException e) {\n-                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n-                      }\n-                    }\n-                  }))\n-          .setCoder(VoidCoder.of());\n+        /**\n+         * Gets content structure.\n+         *\n+         * @return the content structure\n+         */\n+        abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n \n-      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n-    }\n+        /**\n+         * Gets import gcs temp path.\n+         *\n+         * @return the import gcs temp path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n \n-    /** The Write bundles to new line delimited json files. */\n-    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n-\n-      private final ValueProvider<String> fhirStore;\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ObjectMapper mapper;\n-      private ResourceId resourceId;\n-      private WritableByteChannel ndJsonChannel;\n-      private BoundedWindow window;\n-\n-      private transient HealthcareApiClient client;\n-      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n-\n-      WriteBundlesToFilesFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-      }\n-\n-      /**\n-       * Instantiates a new Import fn.\n-       *\n-       * @param fhirStore the fhir store\n-       * @param tempGcsPath the temp gcs path\n-       * @param deadLetterGcsPath the dead letter gcs path\n-       */\n-      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n-        this.fhirStore = StaticValueProvider.of(fhirStore);\n-        this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-        this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      }\n-\n-      /**\n-       * Init client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Init batch.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @StartBundle\n-      public void initFile() throws IOException {\n-        // Write each bundle to newline delimited JSON file.\n-        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n-        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n-        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n-        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n-        if (mapper == null) {\n-          this.mapper = new ObjectMapper();\n-        }\n-      }\n-\n-      /**\n-       * Add to batch.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @ProcessElement\n-      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n-        this.window = window;\n-        String httpBody = context.element();\n-        try {\n-          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n-          Object data = this.mapper.readValue(httpBody, Object.class);\n-          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n-          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n-        } catch (JsonProcessingException e) {\n-          String resource =\n-              String.format(\n-                  \"Failed to parse payload: %s as json at: %s : %s.\"\n-                      + \"Dropping message from batch import.\",\n-                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n-          LOG.warn(resource);\n-          context.output(\n-              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        /**\n+         * Gets import gcs dead letter path.\n+         *\n+         * @return the import gcs dead letter path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n+\n+        /**\n+         * The type Builder.\n+         */\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+\n+            /**\n+             * Sets Fhir store.\n+             *\n+             * @param fhirStore the Fhir store\n+             * @return the Fhir store\n+             */\n+            abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n+\n+            /**\n+             * Sets write method.\n+             *\n+             * @param writeMethod the write method\n+             * @return the write method\n+             */\n+            abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+            /**\n+             * Sets content structure.\n+             *\n+             * @param contentStructure the content structure\n+             * @return the content structure\n+             */\n+            abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+            /**\n+             * Sets import gcs temp path.\n+             *\n+             * @param gcsTempPath the gcs temp path\n+             * @return the import gcs temp path\n+             */\n+            abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n+\n+            /**\n+             * Sets import gcs dead letter path.\n+             *\n+             * @param gcsDeadLetterPath the gcs dead letter path\n+             * @return the import gcs dead letter path\n+             */\n+            abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n+\n+            /**\n+             * Build write.\n+             *\n+             * @return the write\n+             */\n+            abstract Write build();\n         }\n-      }\n-\n-      /**\n-       * Close file.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @FinishBundle\n-      public void closeFile(FinishBundleContext context) throws IOException {\n-        // Write the file with all elements in this bundle to GCS.\n-        ndJsonChannel.close();\n-        context.output(resourceId, window.maxTimestamp(), window);\n-      }\n-    }\n \n-    /** Import batches of new line delimited json files to FHIR Store. */\n-    static class ImportFn\n-        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n-\n-      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ResourceId tempDir;\n-      private final ContentStructure contentStructure;\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> fhirStore;\n-\n-      ImportFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath,\n-          @Nullable ContentStructure contentStructure) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-        if (contentStructure == null) {\n-          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-        } else {\n-          this.contentStructure = contentStructure;\n+        private static Write.Builder write(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n         }\n-      }\n-\n-      @Setup\n-      public void init() throws IOException {\n-        tempDir =\n-            FileSystems.matchNewResource(tempGcsPath.get(), true)\n-                .resolve(\n-                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n-                    StandardResolveOptions.RESOLVE_DIRECTORY);\n-        client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n-       * GCS URI.\n-       */\n-      @ProcessElement\n-      public void importBatch(\n-          @Element KV<Integer, Iterable<ResourceId>> element,\n-          OutputReceiver<HealthcareIOError<String>> output)\n-          throws IOException {\n-        Iterable<ResourceId> batch = element.getValue();\n-        List<ResourceId> tempDestinations = new ArrayList<>();\n-        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n-        assert batch != null;\n-        for (ResourceId file : batch) {\n-          tempDestinations.add(\n-              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n-          deadLetterDestinations.add(\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n-                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+\n+        /**\n+         * Create Method creates a single FHIR resource. @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+         *\n+         * @param fhirStore         the hl 7 v 2 store\n+         * @param gcsTempPath       the gcs temp path\n+         * @param gcsDeadLetterPath the gcs dead letter path\n+         * @param contentStructure  the content structure\n+         * @return the write\n+         */\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsTempPath,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        // Ignore missing files since this might be a retry, which means files\n-        // should have been copied over.\n-        FileSystems.copy(\n-            ImmutableList.copyOf(batch),\n-            tempDestinations,\n-            StandardMoveOptions.IGNORE_MISSING_FILES);\n-        // Check whether any temporary files are not present.\n-        boolean hasMissingFile =\n-            FileSystems.matchResources(tempDestinations).stream()\n-                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n-        if (hasMissingFile) {\n-          throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n-        try {\n-          // Blocking fhirStores.import request.\n-          assert contentStructure != null;\n-          Operation operation =\n-              client.importFhirResource(\n-                  fhirStore.get(), importUri.toString(), contentStructure.name());\n-          client.pollOperation(operation, 500L);\n-          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n-          // needed.\n-          FileSystems.delete(tempDestinations);\n-        } catch (IOException | InterruptedException e) {\n-          ResourceId deadLetterResourceId =\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n-          LOG.warn(\n-              String.format(\n-                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n-                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n-          FileSystems.rename(tempDestinations, deadLetterDestinations);\n-          output.output(HealthcareIOError.of(importUri.toString(), e));\n-        } finally {\n-          // If we've reached this point files have either been successfully import to FHIR store\n-          // or moved to Dead Letter Queue.\n-          // Clean up original files for this batch on GCS.\n-          FileSystems.delete(ImmutableList.copyOf(batch));\n+\n+        public static Write fhirStoresImport(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> gcsTempPath,\n+                ValueProvider<String> gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(gcsTempPath)\n+                    .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+                    .build();\n         }\n-      }\n-    }\n \n-    /** The enum Content structure. */\n-    public enum ContentStructure {\n-      /** If the content structure is not specified, the default value BUNDLE will be used. */\n-      CONTENT_STRUCTURE_UNSPECIFIED,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a bundle, which contains one or more resources. Set the bundle type to history to import\n-       * resource versions.\n-       */\n-      BUNDLE,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a single resource.\n-       */\n-      RESOURCE,\n-      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n-      BUNDLE_PRETTY,\n-      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n-      RESOURCE_PRETTY\n-    }\n-  }\n+        /**\n+         * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+         *\n+         * @param fhirStore the hl 7 v 2 store\n+         * @return the write\n+         */\n+        public static Write executeBundles(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-  /** The type Execute bundles. */\n-  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Execute bundles write.\n+         *\n+         * @param fhirStore the fhir store\n+         * @return the write\n+         */\n+        public static Write executeBundles(ValueProvider<String> fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-    /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    ExecuteBundles(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+        @Override\n+        public Result expand(PCollection<String> input) {\n+            PCollection<HealthcareIOError<String>> failedBundles;\n+            PCollection<HealthcareIOError<String>> failedImports;\n+            switch (this.getWriteMethod()) {\n+                case IMPORT:\n+                    LOG.warn(\n+                            \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                                    + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+                    ValueProvider<String> deadPath =\n+                            getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+                    FhirIO.Import.ContentStructure contentStructure =\n+                            getContentStructure().orElseThrow(IllegalArgumentException::new);\n+                    ValueProvider<String> tempPath =\n+                            getImportGcsTempPath()\n+                                    .orElse(\n+                                            StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+                    return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+                case EXECUTE_BUNDLE:\n+                default:\n+                    failedBundles =\n+                            input\n+                                    .apply(\n+                                            \"Execute FHIR Bundles\",\n+                                            ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                                    .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+            return Result.in(input.getPipeline(), failedBundles);\n+        }\n     }\n \n     /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n+     * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+     * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+     * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+     * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+     * as transactions which is safer practice for a use on a \"live\" FHIR store.\n      */\n-    ExecuteBundles(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Import extends Write {\n \n-    @Override\n-    public FhirIO.Write.Result expand(PCollection<String> input) {\n-      return Write.Result.in(\n-          input.getPipeline(),\n-          input\n-              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-    }\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> deadLetterGcsPath;\n+        private final ContentStructure contentStructure;\n+        private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+        private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+        private ValueProvider<String> tempGcsPath;\n+\n+        /*\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore the fhir store\n+         * @param tempGcsPath the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure the content structure\n+         */\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> tempGcsPath,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = fhirStore;\n+            this.tempGcsPath = tempGcsPath;\n+            this.deadLetterGcsPath = deadLetterGcsPath;\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    /** The type Write Fhir fn. */\n-    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n-\n-      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n-      private transient HealthcareApiClient client;\n-      private final ObjectMapper mapper = new ObjectMapper();\n-      /** The Fhir store. */\n-      private final ValueProvider<String> fhirStore;\n-\n-      /**\n-       * Instantiates a new Write Fhir fn.\n-       *\n-       * @param fhirStore the Fhir store\n-       */\n-      ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      /**\n-       * Initialize healthcare client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Execute Bundles.\n-       *\n-       * @param context the context\n-       */\n-      @ProcessElement\n-      public void executeBundles(ProcessContext context) {\n-        String body = context.element();\n-        try {\n-          // Validate that data was set to valid JSON.\n-          mapper.readTree(body);\n-          client.executeFhirBundle(fhirStore.get(), body);\n-        } catch (IOException | HealthcareHttpException e) {\n-          failedBundles.inc();\n-          context.output(HealthcareIOError.of(body, e));\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this(fhirStore, null, deadLetterGcsPath, contentStructure);\n         }\n-      }\n-    }\n-  }\n \n-  /** Export FHIR resources from a FHIR store to new line delimited json files on GCS. */\n-  public static class Export extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> exportGcsUriPrefix;\n+        /**\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore         the fhir store\n+         * @param tempGcsPath       the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure  the content structure\n+         */\n+        Import(\n+                String fhirStore,\n+                String tempGcsPath,\n+                String deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+            this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+            this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-      this.fhirStore = fhirStore;\n-      this.exportGcsUriPrefix = exportGcsUriPrefix;\n-    }\n+        @Override\n+        ValueProvider<String> getFhirStore() {\n+            return fhirStore;\n+        }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleExportOperations\",\n-              ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n-          .apply(FileIO.matchAll())\n-          .apply(FileIO.readMatches())\n-          .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n-    }\n+        @Override\n+        WriteMethod getWriteMethod() {\n+            return WriteMethod.IMPORT;\n+        }\n \n-    /** A function that schedules an export operation and monitors the status. */\n-    public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> exportGcsUriPrefix;\n-\n-      public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n-        this.exportGcsUriPrefix = exportGcsUriPrefix;\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void exportResourcesToGcs(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String fhirStore = context.element();\n-        String gcsPrefix = this.exportGcsUriPrefix.get();\n-        Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new RuntimeException(\n-              String.format(\"Export operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ContentStructure> getContentStructure() {\n+            return Optional.of(contentStructure);\n         }\n-        context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n-      }\n-    }\n-  }\n-\n-  /** Deidentify FHIR resources from a FHIR store to a destination FHIR store. */\n-  public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> sourceFhirStore;\n-    private final ValueProvider<String> destinationFhirStore;\n-    private final ValueProvider<DeidentifyConfig> deidConfig;\n-\n-    public Deidentify(\n-        ValueProvider<String> sourceFhirStore,\n-        ValueProvider<String> destinationFhirStore,\n-        ValueProvider<DeidentifyConfig> deidConfig) {\n-      this.sourceFhirStore = sourceFhirStore;\n-      this.destinationFhirStore = destinationFhirStore;\n-      this.deidConfig = deidConfig;\n-    }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .getPipeline()\n-          .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleDeidentifyFhirStoreOperations\",\n-              ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n-    }\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsTempPath() {\n+            return Optional.of(tempGcsPath);\n+        }\n \n-    /** A function that schedules a deidentify operation and monitors the status. */\n-    public static class DeidentifyFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> destinationFhirStore;\n-      private static final Gson gson = new Gson();\n-      private final String deidConfigJson;\n-\n-      public DeidentifyFn(\n-          ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n-        this.destinationFhirStore = destinationFhirStore;\n-        this.deidConfigJson = gson.toJson(deidConfig.get());\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void deidentify(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String sourceFhirStore = context.element();\n-        String destinationFhirStore = this.destinationFhirStore.get();\n-        DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n-        Operation operation =\n-            client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new IOException(\n-              String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n+            return Optional.of(deadLetterGcsPath);\n         }\n-        context.output(destinationFhirStore);\n-      }\n-    }\n-  }\n \n-  /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+        @Override\n+        public Write.Result expand(PCollection<String> input) {\n+            checkState(\n+                    input.isBounded() == IsBounded.BOUNDED,\n+                    \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+                            + \"intended for batch use only.\");\n+\n+            // fall back on pipeline's temp location.\n+            ValueProvider<String> tempPath =\n+                    getImportGcsTempPath()\n+                            .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+            // Write bundles of String to GCS\n+            PCollectionTuple writeTmpFileResults =\n+                    input.apply(\n+                            \"Write nd json to GCS\",\n+                            ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                                    .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+            PCollection<HealthcareIOError<String>> failedBodies =\n+                    writeTmpFileResults\n+                            .get(Write.FAILED_BODY)\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            int numShards = 100;\n+            PCollection<HealthcareIOError<String>> failedFiles =\n+                    writeTmpFileResults\n+                            .get(Write.TEMP_FILES)\n+                            .apply(\n+                                    \"Shard files\", // to paralelize group into batches\n+                                    WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n+                            .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n+                            .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+                            .setCoder(\n+                                    KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n+                            .apply(\n+                                    \"Import Batches\",\n+                                    ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+            input\n+                    .getPipeline()\n+                    .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"Resolve SubDirs\",\n+                            MapElements.into(TypeDescriptors.strings())\n+                                    .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n+                    .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+                    .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+                    .apply(\n+                            \"Match tempGcsPath\",\n+                            FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+                    .apply(\n+                            \"Delete tempGcsPath\",\n+                            ParDo.of(\n+                                    new DoFn<Metadata, Void>() {\n+                                        @ProcessElement\n+                                        public void delete(@Element Metadata path, ProcessContext context) {\n+                                            // Wait til window closes for failedBodies and failedFiles to ensure we are\n+                                            // done processing\n+                                            // anything under tempGcsPath because it has been successfully imported to\n+                                            // FHIR store or\n+                                            // copies have been moved to the dead letter path.\n+                                            // Clean up all of tempGcsPath. This will handle removing phantom temporary\n+                                            // objects from\n+                                            // failed / rescheduled ImportFn::importBatch.\n+                                            try {\n+                                                FileSystems.delete(\n+                                                        Collections.singleton(path.resourceId()),\n+                                                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                                            } catch (IOException e) {\n+                                                LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                                            }\n+                                        }\n+                                    }))\n+                    .setCoder(VoidCoder.of());\n+\n+            return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+        }\n+\n+        /**\n+         * The Write bundles to new line delimited json files.\n+         */\n+        static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+            private final ValueProvider<String> fhirStore;\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ObjectMapper mapper;\n+            private ResourceId resourceId;\n+            private WritableByteChannel ndJsonChannel;\n+            private BoundedWindow window;\n+\n+            private transient HealthcareApiClient client;\n+            private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+            WriteBundlesToFilesFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+            }\n+\n+            /**\n+             * Instantiates a new Import fn.\n+             *\n+             * @param fhirStore         the fhir store\n+             * @param tempGcsPath       the temp gcs path\n+             * @param deadLetterGcsPath the dead letter gcs path\n+             */\n+            WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+                this.fhirStore = StaticValueProvider.of(fhirStore);\n+                this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+                this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            }\n+\n+            /**\n+             * Init client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Init batch.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @StartBundle\n+            public void initFile() throws IOException {\n+                // Write each bundle to newline delimited JSON file.\n+                String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+                ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n+                this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+                this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+                if (mapper == null) {\n+                    this.mapper = new ObjectMapper();\n+                }\n+            }\n+\n+            /**\n+             * Add to batch.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @ProcessElement\n+            public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+                this.window = window;\n+                String httpBody = context.element();\n+                try {\n+                    // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+                    Object data = this.mapper.readValue(httpBody, Object.class);\n+                    String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+                    this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+                } catch (JsonProcessingException e) {\n+                    String resource =\n+                            String.format(\n+                                    \"Failed to parse payload: %s as json at: %s : %s.\"\n+                                            + \"Dropping message from batch import.\",\n+                                    httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+                    LOG.warn(resource);\n+                    context.output(\n+                            Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+                }\n+            }\n+\n+            /**\n+             * Close file.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @FinishBundle\n+            public void closeFile(FinishBundleContext context) throws IOException {\n+                // Write the file with all elements in this bundle to GCS.\n+                ndJsonChannel.close();\n+                context.output(resourceId, window.maxTimestamp(), window);\n+            }\n+        }\n \n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Import batches of new line delimited json files to FHIR Store.\n+         */\n+        static class ImportFn\n+                extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+            private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ResourceId tempDir;\n+            private final ContentStructure contentStructure;\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> fhirStore;\n+\n+            ImportFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath,\n+                    @Nullable ContentStructure contentStructure) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+                if (contentStructure == null) {\n+                    this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+                } else {\n+                    this.contentStructure = contentStructure;\n+                }\n+            }\n+\n+            @Setup\n+            public void init() throws IOException {\n+                tempDir =\n+                        FileSystems.matchNewResource(tempGcsPath.get(), true)\n+                                .resolve(\n+                                        String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                                        StandardResolveOptions.RESOLVE_DIRECTORY);\n+                client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+             * GCS URI.\n+             */\n+            @ProcessElement\n+            public void importBatch(\n+                    @Element KV<Integer, Iterable<ResourceId>> element,\n+                    OutputReceiver<HealthcareIOError<String>> output)\n+                    throws IOException {\n+                Iterable<ResourceId> batch = element.getValue();\n+                List<ResourceId> tempDestinations = new ArrayList<>();\n+                List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+                assert batch != null;\n+                for (ResourceId file : batch) {\n+                    tempDestinations.add(\n+                            tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                    deadLetterDestinations.add(\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n+                                    .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                }\n+                // Ignore missing files since this might be a retry, which means files\n+                // should have been copied over.\n+                FileSystems.copy(\n+                        ImmutableList.copyOf(batch),\n+                        tempDestinations,\n+                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                // Check whether any temporary files are not present.\n+                boolean hasMissingFile =\n+                        FileSystems.matchResources(tempDestinations).stream()\n+                                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n+                if (hasMissingFile) {\n+                    throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+                }\n+                ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+                try {\n+                    // Blocking fhirStores.import request.\n+                    assert contentStructure != null;\n+                    Operation operation =\n+                            client.importFhirResource(\n+                                    fhirStore.get(), importUri.toString(), contentStructure.name());\n+                    client.pollOperation(operation, 500L);\n+                    // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+                    // needed.\n+                    FileSystems.delete(tempDestinations);\n+                } catch (IOException | InterruptedException e) {\n+                    ResourceId deadLetterResourceId =\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n+                    LOG.warn(\n+                            String.format(\n+                                    \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                                    importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+                    FileSystems.rename(tempDestinations, deadLetterDestinations);\n+                    output.output(HealthcareIOError.of(importUri.toString(), e));\n+                } finally {\n+                    // If we've reached this point files have either been successfully import to FHIR store\n+                    // or moved to Dead Letter Queue.\n+                    // Clean up original files for this batch on GCS.\n+                    FileSystems.delete(ImmutableList.copyOf(batch));\n+                }\n+            }\n+        }\n+\n+        /**\n+         * The enum Content structure.\n+         */\n+        public enum ContentStructure {\n+            /**\n+             * If the content structure is not specified, the default value BUNDLE will be used.\n+             */\n+            CONTENT_STRUCTURE_UNSPECIFIED,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a bundle, which contains one or more resources. Set the bundle type to history to import\n+             * resource versions.\n+             */\n+            BUNDLE,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a single resource.\n+             */\n+            RESOURCE,\n+            /**\n+             * The entire file is one JSON bundle. The JSON can span multiple lines.\n+             */\n+            BUNDLE_PRETTY,\n+            /**\n+             * The entire file is one JSON resource. The JSON can span multiple lines.\n+             */\n+            RESOURCE_PRETTY\n+        }\n+    }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * The type Execute bundles.\n      */\n-    Search(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+    public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+        private final ValueProvider<String> fhirStore;\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        @Override\n+        public FhirIO.Write.Result expand(PCollection<String> input) {\n+            return Write.Result.in(\n+                    input.getPipeline(),\n+                    input\n+                            .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+\n+        /**\n+         * The type Write Fhir fn.\n+         */\n+        static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+            private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+            private transient HealthcareApiClient client;\n+            private final ObjectMapper mapper = new ObjectMapper();\n+            /**\n+             * The Fhir store.\n+             */\n+            private final ValueProvider<String> fhirStore;\n+\n+            /**\n+             * Instantiates a new Write Fhir fn.\n+             *\n+             * @param fhirStore the Fhir store\n+             */\n+            ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            /**\n+             * Initialize healthcare client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Execute Bundles.\n+             *\n+             * @param context the context\n+             */\n+            @ProcessElement\n+            public void executeBundles(ProcessContext context) {\n+                String body = context.element();\n+                try {\n+                    // Validate that data was set to valid JSON.\n+                    mapper.readTree(body);\n+                    client.executeFhirBundle(fhirStore.get(), body);\n+                } catch (IOException | HealthcareHttpException e) {\n+                    failedBundles.inc();\n+                    context.output(HealthcareIOError.of(body, e));\n+                }\n+            }\n+        }\n     }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * Export FHIR resources from a FHIR store to new line delimited json files on GCS.\n      */\n-    Search(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Export extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> exportGcsUriPrefix;\n+\n+        public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+            this.fhirStore = fhirStore;\n+            this.exportGcsUriPrefix = exportGcsUriPrefix;\n+        }\n \n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedSearches;\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the search result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-                .keySet()\n-                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Search.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n-                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleExportOperations\",\n+                            ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n+                    .apply(FileIO.matchAll())\n+                    .apply(FileIO.readMatches())\n+                    .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n+        }\n+\n+        /**\n+         * A function that schedules an export operation and monitors the status.\n+         */\n+        public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> exportGcsUriPrefix;\n+\n+            public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n+                this.exportGcsUriPrefix = exportGcsUriPrefix;\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void exportResourcesToGcs(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String fhirStore = context.element();\n+                String gcsPrefix = this.exportGcsUriPrefix.get();\n+                Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new RuntimeException(\n+                            String.format(\"Export operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n+            }\n         }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedSearches =\n-                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed searches.\n-       *\n-       * @return the failed searches\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n-        return failedSearches;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-              String transformName, PInput input, PTransform<?, ?> transform) {}\n     }\n \n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-            new TupleTag<HealthcareIOError<String>>() {};\n+    /**\n+     * Deidentify FHIR resources from a FHIR store to a destination FHIR store.\n+     */\n+    public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> sourceFhirStore;\n+        private final ValueProvider<String> destinationFhirStore;\n+        private final ValueProvider<DeidentifyConfig> deidConfig;\n+\n+        public Deidentify(\n+                ValueProvider<String> sourceFhirStore,\n+                ValueProvider<String> destinationFhirStore,\n+                ValueProvider<DeidentifyConfig> deidConfig) {\n+            this.sourceFhirStore = sourceFhirStore;\n+            this.destinationFhirStore = destinationFhirStore;\n+            this.deidConfig = deidConfig;\n+        }\n \n-    @Override\n-    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n-      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .getPipeline()\n+                    .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleDeidentifyFhirStoreOperations\",\n+                            ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n+        }\n+\n+        /**\n+         * A function that schedules a deidentify operation and monitors the status.\n+         */\n+        public static class DeidentifyFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> destinationFhirStore;\n+            private static final Gson gson = new Gson();\n+            private final String deidConfigJson;\n+\n+            public DeidentifyFn(\n+                    ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n+                this.destinationFhirStore = destinationFhirStore;\n+                this.deidConfigJson = gson.toJson(deidConfig.get());\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void deidentify(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String sourceFhirStore = context.element();\n+                String destinationFhirStore = this.destinationFhirStore.get();\n+                DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n+                Operation operation =\n+                        client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new IOException(\n+                            String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(destinationFhirStore);\n+            }\n+        }\n     }\n \n     /**\n-     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n-     * and search parameters, and fetches all matching resources based on the search criteria and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n-     *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of failed searches from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * The type Search.\n      */\n-    static class SearchResourcesJsonString\n-            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-\n-      private final ValueProvider<String> fhirStore;\n-\n-      /** Instantiates a new Search Fhir resources DoFn. */\n-      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      @Override\n-      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n-        return new FhirIO.Search.Result(\n-                resourceIds.apply(\n-                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n-                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for searching messages from the Fhir store with error handling. */\n-      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n-\n-        private Counter failedSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n-        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n-        private final Counter successfulSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n-        private HealthcareApiClient client;\n+    public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n         private final ValueProvider<String> fhirStore;\n \n-        /** Instantiates a new Fhir resources search fn. */\n-        SearchResourcesFn(ValueProvider<String> fhirStore) {\n-          this.fhirStore = fhirStore;\n+        Search(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        Search(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedSearches;\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the search result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Search.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                                    + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedSearches =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed searches.\n+             *\n+             * @return the failed searches\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+                return failedSearches;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n         }\n \n         /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n+         * The tag for the main output of Fhir Messages.\n          */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+            return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n         }\n \n         /**\n-         * Process element.\n+         * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n          *\n-         * @param context the context\n+         * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+         * and search parameters, and fetches all matching resources based on the search criteria and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of failed searches from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n          */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          KV<String, Map<String, String>> elementValues = context.element();\n-          try {\n-            context.output(searchResources(\n-                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n-          } catch (Exception e) {\n-            failedSearches.inc();\n-            LOG.warn(\n-                    String.format(\n-                            \"Error search FHIR messages writing to Dead Letter \"\n-                                    + \"Queue. Cause: %s Stack Trace: %s\",\n-                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n-          }\n-        }\n-\n-        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n-                                       @Nullable Map<String, String> parameters)\n-                throws IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n-                  new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n-                          client, fhirStore, resourceType, parameters);\n-          JsonArray result = new JsonArray();\n-          while (iter.hasNext()) {\n-            result.addAll(iter.next());\n-          }\n-          this.successfulSearches.inc();\n-          return result.toString();\n+        static class SearchResourcesJsonString\n+                extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+            private final ValueProvider<String> fhirStore;\n+\n+            public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            @Override\n+            public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+                return new FhirIO.Search.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                        .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for searching messages from the Fhir store with error handling.\n+             */\n+            static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+                private Counter failedSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+                private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+                private final Counter successfulSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+                private HealthcareApiClient client;\n+                private final ValueProvider<String> fhirStore;\n+\n+                /**\n+                 * Instantiates a new Fhir resources search fn.\n+                 */\n+                SearchResourcesFn(ValueProvider<String> fhirStore) {\n+                    this.fhirStore = fhirStore;\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    KV<String, Map<String, String>> elementValues = context.element();\n+                    try {\n+                        context.output(searchResources(\n+                                this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+                    } catch (Exception e) {\n+                        failedSearches.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error search FHIR messages writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+                    }\n+                }\n+\n+                private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                               @Nullable Map<String, String> parameters)\n+                        throws IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                            new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                                    client, fhirStore, resourceType, parameters);\n+                    JsonArray result = new JsonArray();\n+                    while (iter.hasNext()) {\n+                        result.addAll(iter.next());\n+                    }\n+                    this.successfulSearches.inc();\n+                    return result.toString();\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODA5Mw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529808093", "bodyText": "nit: You can let IntelliJ format these long lines.", "author": "lastomato", "createdAt": "2020-11-24T18:57:20Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -1388,4 +1410,208 @@ public void deidentify(ProcessContext context)\n       }\n     }\n   }\n+\n+  /** The type Search. */\n+  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n+    private final ValueProvider<String> fhirStore;\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(String fhirStore) {\n+      this.fhirStore = StaticValueProvider.of(fhirStore);\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedSearches;\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the search result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+                .keySet()\n+                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Search.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedSearches =\n+                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));", "originalCommit": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzNjY5Mw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529836693", "bodyText": "I ran a reformat and it changed many lines other than the ones I'm touching, hope this is ok.", "author": "janeliulwq", "createdAt": "2020-11-24T19:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNjg5MA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r530526890", "bodyText": "It should be OK.", "author": "lastomato", "createdAt": "2020-11-25T17:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODA5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 9c0d0e409d..257d9f4a5c 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -212,1406 +214,1476 @@ import org.slf4j.LoggerFactory;\n  * </pre>\n  */\n @SuppressWarnings({\n-  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+        \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n })\n public class FhirIO {\n \n-  /**\n-   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n-   * notifications)\n-   *\n-   * @return the read\n-   * @see Read\n-   */\n-  public static Read readResources() {\n-    return new Read();\n-  }\n-\n-  /**\n-   * Search resources from a PCollection\n-   *\n-   * @return the search\n-   * @see Search\n-   */\n-  public static Search searchResources(String fhirStore) {\n-    return new Search(fhirStore);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      String fhirStore,\n-      String tempDir,\n-      String deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      ValueProvider<String> fhirStore,\n-      ValueProvider<String> tempDir,\n-      ValueProvider<String> deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n-    return new Export(\n-        StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(\n-      ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-    return new Export(fhirStore, exportGcsUriPrefix);\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n-    return new Deidentify(\n-        StaticValueProvider.of(sourceFhirStore),\n-        StaticValueProvider.of(destinationFhirStore),\n-        StaticValueProvider.of(deidConfig));\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      ValueProvider<String> sourceFhirStore,\n-      ValueProvider<String> destinationFhirStore,\n-      ValueProvider<DeidentifyConfig> deidConfig) {\n-    return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n-  }\n-\n-  /** The type Read. */\n-  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n-\n-    /** Instantiates a new Read. */\n-    public Read() {}\n-\n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedReads;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the read result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-            .keySet()\n-            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Read.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n-                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n-        }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedReads =\n-            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed reads.\n-       *\n-       * @return the failed reads\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedReads() {\n-        return failedReads;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n-\n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-\n-    @Override\n-    public FhirIO.Read.Result expand(PCollection<String> input) {\n-      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n-    }\n-\n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n+     * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+     * notifications)\n      *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * @return the read\n+     * @see Read\n      */\n-    static class FetchResourceJsonString\n-        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-\n-      /** Instantiates a new Fetch Fhir message DoFn. */\n-      public FetchResourceJsonString() {}\n-\n-      @Override\n-      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n-        return new FhirIO.Read.Result(\n-            resourceIds.apply(\n-                ParDo.of(new ReadResourceFn())\n-                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for fetching messages from the Fhir store with error handling. */\n-      static class ReadResourceFn extends DoFn<String, String> {\n-\n-        private Counter failedMessageGets =\n-            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n-        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n-        private final Counter successfulStringGets =\n-            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n-\n-        /** Instantiates a new Hl 7 v 2 message get fn. */\n-        ReadResourceFn() {}\n-\n-        /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n-         */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n-        }\n-\n-        /**\n-         * Process element.\n-         *\n-         * @param context the context\n-         */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          String resourceId = context.element();\n-          try {\n-            context.output(fetchResource(this.client, resourceId));\n-          } catch (Exception e) {\n-            failedMessageGets.inc();\n-            LOG.warn(\n-                String.format(\n-                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n-                        + \"Queue. Cause: %s Stack Trace: %s\",\n-                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n-          }\n-        }\n-\n-        private String fetchResource(HealthcareApiClient client, String resourceId)\n-            throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpBody resource = client.readFhirResource(resourceId);\n-\n-          if (resource == null) {\n-            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n-          }\n-          this.successfulStringGets.inc();\n-          return mapper.writeValueAsString(resource);\n-        }\n-      }\n-    }\n-  }\n-\n-  /** The type Write. */\n-  @AutoValue\n-  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n-\n-    /** The tag for the failed writes to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for the files that failed to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for temp files for import to FHIR store`. */\n-    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n-\n-    /** The enum Write method. */\n-    public enum WriteMethod {\n-      /**\n-       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n-       */\n-      EXECUTE_BUNDLE,\n-      /**\n-       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n-       * FHIR stores. <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n-       */\n-      IMPORT\n-    }\n-\n-    /** The type Result. */\n-    public static class Result implements POutput {\n-      private final Pipeline pipeline;\n-      private final PCollection<HealthcareIOError<String>> failedBodies;\n-      private final PCollection<HealthcareIOError<String>> failedFiles;\n-\n-      /**\n-       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n-       * pipeline\n-       *\n-       * @param failedBodies the failed inserts\n-       * @return the result\n-       */\n-      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n-        return new Result(pipeline, failedBodies, null);\n-      }\n-\n-      static Result in(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          PCollection<HealthcareIOError<String>> failedFiles) {\n-        return new Result(pipeline, failedBodies, failedFiles);\n-      }\n-\n-      /**\n-       * Gets failed bodies with err.\n-       *\n-       * @return the failed inserts with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n-        return this.failedBodies;\n-      }\n-\n-      /**\n-       * Gets failed file imports with err.\n-       *\n-       * @return the failed GCS uri with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n-        return this.failedFiles;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pipeline;\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-\n-      private Result(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n-        this.pipeline = pipeline;\n-        this.failedBodies = failedBodies;\n-        if (failedFiles == null) {\n-          failedFiles =\n-              (PCollection<HealthcareIOError<String>>)\n-                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-        }\n-        this.failedFiles = failedFiles;\n-      }\n+    public static Read readResources() {\n+        return new Read();\n     }\n \n     /**\n-     * Gets Fhir store.\n+     * Search resources from a Fhir store.\n      *\n-     * @return the Fhir store\n+     * @return the search\n+     * @see Search\n      */\n-    abstract ValueProvider<String> getFhirStore();\n+    public static Search searchResources(String fhirStore) {\n+        return new Search(fhirStore);\n+    }\n \n     /**\n-     * Gets write method.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the write method\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract WriteMethod getWriteMethod();\n+    public static Import importResources(\n+            String fhirStore,\n+            String tempDir,\n+            String deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets content structure.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the content structure\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+    public static Import importResources(\n+            ValueProvider<String> fhirStore,\n+            ValueProvider<String> tempDir,\n+            ValueProvider<String> deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets import gcs temp path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs temp path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n+    public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n+        return new Export(\n+                StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n+    }\n \n     /**\n-     * Gets import gcs dead letter path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs dead letter path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n-\n-    /** The type Builder. */\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-\n-      /**\n-       * Sets Fhir store.\n-       *\n-       * @param fhirStore the Fhir store\n-       * @return the Fhir store\n-       */\n-      abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n-\n-      /**\n-       * Sets write method.\n-       *\n-       * @param writeMethod the write method\n-       * @return the write method\n-       */\n-      abstract Builder setWriteMethod(WriteMethod writeMethod);\n-\n-      /**\n-       * Sets content structure.\n-       *\n-       * @param contentStructure the content structure\n-       * @return the content structure\n-       */\n-      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n-\n-      /**\n-       * Sets import gcs temp path.\n-       *\n-       * @param gcsTempPath the gcs temp path\n-       * @return the import gcs temp path\n-       */\n-      abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n-\n-      /**\n-       * Sets import gcs dead letter path.\n-       *\n-       * @param gcsDeadLetterPath the gcs dead letter path\n-       * @return the import gcs dead letter path\n-       */\n-      abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n-\n-      /**\n-       * Build write.\n-       *\n-       * @return the write\n-       */\n-      abstract Write build();\n-    }\n-\n-    private static Write.Builder write(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n+    public static Export exportResourcesToGcs(\n+            ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+        return new Export(fhirStore, exportGcsUriPrefix);\n     }\n \n     /**\n-     * Create Method creates a single FHIR resource. @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @param gcsTempPath the gcs temp path\n-     * @param gcsDeadLetterPath the gcs dead letter path\n-     * @param contentStructure the content structure\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsTempPath,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> gcsTempPath,\n-        ValueProvider<String> gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(gcsTempPath)\n-          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n-          .build();\n+    public static Deidentify deidentify(\n+            String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n+        return new Deidentify(\n+                StaticValueProvider.of(sourceFhirStore),\n+                StaticValueProvider.of(destinationFhirStore),\n+                StaticValueProvider.of(deidConfig));\n     }\n \n     /**\n-     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write executeBundles(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n+    public static Deidentify deidentify(\n+            ValueProvider<String> sourceFhirStore,\n+            ValueProvider<String> destinationFhirStore,\n+            ValueProvider<DeidentifyConfig> deidConfig) {\n+        return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n     }\n \n     /**\n-     * Execute bundles write.\n-     *\n-     * @param fhirStore the fhir store\n-     * @return the write\n+     * The type Read.\n      */\n-    public static Write executeBundles(ValueProvider<String> fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n-    }\n+    public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n-\n-    @Override\n-    public Result expand(PCollection<String> input) {\n-      PCollection<HealthcareIOError<String>> failedBundles;\n-      PCollection<HealthcareIOError<String>> failedImports;\n-      switch (this.getWriteMethod()) {\n-        case IMPORT:\n-          LOG.warn(\n-              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n-                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n-          ValueProvider<String> deadPath =\n-              getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n-          FhirIO.Import.ContentStructure contentStructure =\n-              getContentStructure().orElseThrow(IllegalArgumentException::new);\n-          ValueProvider<String> tempPath =\n-              getImportGcsTempPath()\n-                  .orElse(\n-                      StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n-        case EXECUTE_BUNDLE:\n-        default:\n-          failedBundles =\n-              input\n-                  .apply(\n-                      \"Execute FHIR Bundles\",\n-                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n-                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-      return Result.in(input.getPipeline(), failedBundles);\n-    }\n-  }\n-\n-  /**\n-   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n-   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n-   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n-   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n-   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n-   */\n-  public static class Import extends Write {\n-\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> deadLetterGcsPath;\n-    private final ContentStructure contentStructure;\n-    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n-    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n-    private ValueProvider<String> tempGcsPath;\n-\n-    /*\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n-     */\n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> tempGcsPath,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = fhirStore;\n-      this.tempGcsPath = tempGcsPath;\n-      this.deadLetterGcsPath = deadLetterGcsPath;\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+        /**\n+         * Instantiates a new Read.\n+         */\n+        public Read() {\n+        }\n+\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedReads;\n+            /**\n+             * The Pct.\n+             */\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the read result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Read.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                                    + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedReads =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed reads.\n+             *\n+             * @return the failed reads\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedReads() {\n+                return failedReads;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n+\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Read.Result expand(PCollection<String> input) {\n+            return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+        }\n+\n+        /**\n+         * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+         * store, and fetches the actual {@link String} object based on the id in the notification and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class FetchResourceJsonString\n+                extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+            /**\n+             * Instantiates a new Fetch Fhir message DoFn.\n+             */\n+            public FetchResourceJsonString() {\n+            }\n+\n+            @Override\n+            public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+                return new FhirIO.Read.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new ReadResourceFn())\n+                                        .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for fetching messages from the Fhir store with error handling.\n+             */\n+            static class ReadResourceFn extends DoFn<String, String> {\n+\n+                private Counter failedMessageGets =\n+                        Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+                private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+                private final Counter successfulStringGets =\n+                        Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+                private HealthcareApiClient client;\n+                private ObjectMapper mapper;\n+\n+                /**\n+                 * Instantiates a new Hl 7 v 2 message get fn.\n+                 */\n+                ReadResourceFn() {\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                    this.mapper = new ObjectMapper();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    String resourceId = context.element();\n+                    try {\n+                        context.output(fetchResource(this.client, resourceId));\n+                    } catch (Exception e) {\n+                        failedMessageGets.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+                    }\n+                }\n+\n+                private String fetchResource(HealthcareApiClient client, String resourceId)\n+                        throws IOException, IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n \n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this(fhirStore, null, deadLetterGcsPath, contentStructure);\n+                    HttpBody resource = client.readFhirResource(resourceId);\n+\n+                    if (resource == null) {\n+                        throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+                    }\n+                    this.successfulStringGets.inc();\n+                    return mapper.writeValueAsString(resource);\n+                }\n+            }\n+        }\n     }\n+\n     /**\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n+     * The type Write.\n      */\n-    Import(\n-        String fhirStore,\n-        String tempGcsPath,\n-        String deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-      this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-      this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+    @AutoValue\n+    public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n \n-    @Override\n-    ValueProvider<String> getFhirStore() {\n-      return fhirStore;\n-    }\n+        /**\n+         * The tag for the failed writes to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for the files that failed to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for temp files for import to FHIR store`.\n+         */\n+        public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {\n+        };\n \n-    @Override\n-    WriteMethod getWriteMethod() {\n-      return WriteMethod.IMPORT;\n-    }\n+        /**\n+         * The enum Write method.\n+         */\n+        public enum WriteMethod {\n+            /**\n+             * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+             */\n+            EXECUTE_BUNDLE,\n+            /**\n+             * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+             * FHIR stores. <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+             */\n+            IMPORT\n+        }\n \n-    @Override\n-    Optional<ContentStructure> getContentStructure() {\n-      return Optional.of(contentStructure);\n-    }\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput {\n+            private final Pipeline pipeline;\n+            private final PCollection<HealthcareIOError<String>> failedBodies;\n+            private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+            /**\n+             * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+             * pipeline\n+             *\n+             * @param failedBodies the failed inserts\n+             * @return the result\n+             */\n+            static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+                return new Result(pipeline, failedBodies, null);\n+            }\n+\n+            static Result in(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    PCollection<HealthcareIOError<String>> failedFiles) {\n+                return new Result(pipeline, failedBodies, failedFiles);\n+            }\n+\n+            /**\n+             * Gets failed bodies with err.\n+             *\n+             * @return the failed inserts with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+                return this.failedBodies;\n+            }\n+\n+            /**\n+             * Gets failed file imports with err.\n+             *\n+             * @return the failed GCS uri with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+                return this.failedFiles;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pipeline;\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+\n+            private Result(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+                this.pipeline = pipeline;\n+                this.failedBodies = failedBodies;\n+                if (failedFiles == null) {\n+                    failedFiles =\n+                            (PCollection<HealthcareIOError<String>>)\n+                                    pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+                }\n+                this.failedFiles = failedFiles;\n+            }\n+        }\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsTempPath() {\n-      return Optional.of(tempGcsPath);\n-    }\n+        /**\n+         * Gets Fhir store.\n+         *\n+         * @return the Fhir store\n+         */\n+        abstract ValueProvider<String> getFhirStore();\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n-      return Optional.of(deadLetterGcsPath);\n-    }\n+        /**\n+         * Gets write method.\n+         *\n+         * @return the write method\n+         */\n+        abstract WriteMethod getWriteMethod();\n \n-    @Override\n-    public Write.Result expand(PCollection<String> input) {\n-      checkState(\n-          input.isBounded() == IsBounded.BOUNDED,\n-          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n-              + \"intended for batch use only.\");\n-\n-      // fall back on pipeline's temp location.\n-      ValueProvider<String> tempPath =\n-          getImportGcsTempPath()\n-              .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-      // Write bundles of String to GCS\n-      PCollectionTuple writeTmpFileResults =\n-          input.apply(\n-              \"Write nd json to GCS\",\n-              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n-                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n-\n-      PCollection<HealthcareIOError<String>> failedBodies =\n-          writeTmpFileResults\n-              .get(Write.FAILED_BODY)\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      int numShards = 100;\n-      PCollection<HealthcareIOError<String>> failedFiles =\n-          writeTmpFileResults\n-              .get(Write.TEMP_FILES)\n-              .apply(\n-                  \"Shard files\", // to paralelize group into batches\n-                  WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n-              .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n-              .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n-              .setCoder(\n-                  KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n-              .apply(\n-                  \"Import Batches\",\n-                  ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-\n-      input\n-          .getPipeline()\n-          .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n-          .apply(\n-              \"Resolve SubDirs\",\n-              MapElements.into(TypeDescriptors.strings())\n-                  .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n-          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n-          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n-          .apply(\n-              \"Match tempGcsPath\",\n-              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n-          .apply(\n-              \"Delete tempGcsPath\",\n-              ParDo.of(\n-                  new DoFn<Metadata, Void>() {\n-                    @ProcessElement\n-                    public void delete(@Element Metadata path, ProcessContext context) {\n-                      // Wait til window closes for failedBodies and failedFiles to ensure we are\n-                      // done processing\n-                      // anything under tempGcsPath because it has been successfully imported to\n-                      // FHIR store or\n-                      // copies have been moved to the dead letter path.\n-                      // Clean up all of tempGcsPath. This will handle removing phantom temporary\n-                      // objects from\n-                      // failed / rescheduled ImportFn::importBatch.\n-                      try {\n-                        FileSystems.delete(\n-                            Collections.singleton(path.resourceId()),\n-                            StandardMoveOptions.IGNORE_MISSING_FILES);\n-                      } catch (IOException e) {\n-                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n-                      }\n-                    }\n-                  }))\n-          .setCoder(VoidCoder.of());\n+        /**\n+         * Gets content structure.\n+         *\n+         * @return the content structure\n+         */\n+        abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n \n-      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n-    }\n+        /**\n+         * Gets import gcs temp path.\n+         *\n+         * @return the import gcs temp path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n \n-    /** The Write bundles to new line delimited json files. */\n-    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n-\n-      private final ValueProvider<String> fhirStore;\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ObjectMapper mapper;\n-      private ResourceId resourceId;\n-      private WritableByteChannel ndJsonChannel;\n-      private BoundedWindow window;\n-\n-      private transient HealthcareApiClient client;\n-      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n-\n-      WriteBundlesToFilesFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-      }\n-\n-      /**\n-       * Instantiates a new Import fn.\n-       *\n-       * @param fhirStore the fhir store\n-       * @param tempGcsPath the temp gcs path\n-       * @param deadLetterGcsPath the dead letter gcs path\n-       */\n-      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n-        this.fhirStore = StaticValueProvider.of(fhirStore);\n-        this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-        this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      }\n-\n-      /**\n-       * Init client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Init batch.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @StartBundle\n-      public void initFile() throws IOException {\n-        // Write each bundle to newline delimited JSON file.\n-        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n-        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n-        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n-        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n-        if (mapper == null) {\n-          this.mapper = new ObjectMapper();\n-        }\n-      }\n-\n-      /**\n-       * Add to batch.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @ProcessElement\n-      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n-        this.window = window;\n-        String httpBody = context.element();\n-        try {\n-          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n-          Object data = this.mapper.readValue(httpBody, Object.class);\n-          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n-          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n-        } catch (JsonProcessingException e) {\n-          String resource =\n-              String.format(\n-                  \"Failed to parse payload: %s as json at: %s : %s.\"\n-                      + \"Dropping message from batch import.\",\n-                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n-          LOG.warn(resource);\n-          context.output(\n-              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        /**\n+         * Gets import gcs dead letter path.\n+         *\n+         * @return the import gcs dead letter path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n+\n+        /**\n+         * The type Builder.\n+         */\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+\n+            /**\n+             * Sets Fhir store.\n+             *\n+             * @param fhirStore the Fhir store\n+             * @return the Fhir store\n+             */\n+            abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n+\n+            /**\n+             * Sets write method.\n+             *\n+             * @param writeMethod the write method\n+             * @return the write method\n+             */\n+            abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+            /**\n+             * Sets content structure.\n+             *\n+             * @param contentStructure the content structure\n+             * @return the content structure\n+             */\n+            abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+            /**\n+             * Sets import gcs temp path.\n+             *\n+             * @param gcsTempPath the gcs temp path\n+             * @return the import gcs temp path\n+             */\n+            abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n+\n+            /**\n+             * Sets import gcs dead letter path.\n+             *\n+             * @param gcsDeadLetterPath the gcs dead letter path\n+             * @return the import gcs dead letter path\n+             */\n+            abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n+\n+            /**\n+             * Build write.\n+             *\n+             * @return the write\n+             */\n+            abstract Write build();\n         }\n-      }\n-\n-      /**\n-       * Close file.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @FinishBundle\n-      public void closeFile(FinishBundleContext context) throws IOException {\n-        // Write the file with all elements in this bundle to GCS.\n-        ndJsonChannel.close();\n-        context.output(resourceId, window.maxTimestamp(), window);\n-      }\n-    }\n \n-    /** Import batches of new line delimited json files to FHIR Store. */\n-    static class ImportFn\n-        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n-\n-      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ResourceId tempDir;\n-      private final ContentStructure contentStructure;\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> fhirStore;\n-\n-      ImportFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath,\n-          @Nullable ContentStructure contentStructure) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-        if (contentStructure == null) {\n-          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-        } else {\n-          this.contentStructure = contentStructure;\n+        private static Write.Builder write(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n         }\n-      }\n-\n-      @Setup\n-      public void init() throws IOException {\n-        tempDir =\n-            FileSystems.matchNewResource(tempGcsPath.get(), true)\n-                .resolve(\n-                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n-                    StandardResolveOptions.RESOLVE_DIRECTORY);\n-        client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n-       * GCS URI.\n-       */\n-      @ProcessElement\n-      public void importBatch(\n-          @Element KV<Integer, Iterable<ResourceId>> element,\n-          OutputReceiver<HealthcareIOError<String>> output)\n-          throws IOException {\n-        Iterable<ResourceId> batch = element.getValue();\n-        List<ResourceId> tempDestinations = new ArrayList<>();\n-        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n-        assert batch != null;\n-        for (ResourceId file : batch) {\n-          tempDestinations.add(\n-              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n-          deadLetterDestinations.add(\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n-                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+\n+        /**\n+         * Create Method creates a single FHIR resource. @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+         *\n+         * @param fhirStore         the hl 7 v 2 store\n+         * @param gcsTempPath       the gcs temp path\n+         * @param gcsDeadLetterPath the gcs dead letter path\n+         * @param contentStructure  the content structure\n+         * @return the write\n+         */\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsTempPath,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        // Ignore missing files since this might be a retry, which means files\n-        // should have been copied over.\n-        FileSystems.copy(\n-            ImmutableList.copyOf(batch),\n-            tempDestinations,\n-            StandardMoveOptions.IGNORE_MISSING_FILES);\n-        // Check whether any temporary files are not present.\n-        boolean hasMissingFile =\n-            FileSystems.matchResources(tempDestinations).stream()\n-                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n-        if (hasMissingFile) {\n-          throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n-        try {\n-          // Blocking fhirStores.import request.\n-          assert contentStructure != null;\n-          Operation operation =\n-              client.importFhirResource(\n-                  fhirStore.get(), importUri.toString(), contentStructure.name());\n-          client.pollOperation(operation, 500L);\n-          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n-          // needed.\n-          FileSystems.delete(tempDestinations);\n-        } catch (IOException | InterruptedException e) {\n-          ResourceId deadLetterResourceId =\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n-          LOG.warn(\n-              String.format(\n-                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n-                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n-          FileSystems.rename(tempDestinations, deadLetterDestinations);\n-          output.output(HealthcareIOError.of(importUri.toString(), e));\n-        } finally {\n-          // If we've reached this point files have either been successfully import to FHIR store\n-          // or moved to Dead Letter Queue.\n-          // Clean up original files for this batch on GCS.\n-          FileSystems.delete(ImmutableList.copyOf(batch));\n+\n+        public static Write fhirStoresImport(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> gcsTempPath,\n+                ValueProvider<String> gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(gcsTempPath)\n+                    .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+                    .build();\n         }\n-      }\n-    }\n \n-    /** The enum Content structure. */\n-    public enum ContentStructure {\n-      /** If the content structure is not specified, the default value BUNDLE will be used. */\n-      CONTENT_STRUCTURE_UNSPECIFIED,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a bundle, which contains one or more resources. Set the bundle type to history to import\n-       * resource versions.\n-       */\n-      BUNDLE,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a single resource.\n-       */\n-      RESOURCE,\n-      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n-      BUNDLE_PRETTY,\n-      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n-      RESOURCE_PRETTY\n-    }\n-  }\n+        /**\n+         * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+         *\n+         * @param fhirStore the hl 7 v 2 store\n+         * @return the write\n+         */\n+        public static Write executeBundles(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-  /** The type Execute bundles. */\n-  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Execute bundles write.\n+         *\n+         * @param fhirStore the fhir store\n+         * @return the write\n+         */\n+        public static Write executeBundles(ValueProvider<String> fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-    /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    ExecuteBundles(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+        @Override\n+        public Result expand(PCollection<String> input) {\n+            PCollection<HealthcareIOError<String>> failedBundles;\n+            PCollection<HealthcareIOError<String>> failedImports;\n+            switch (this.getWriteMethod()) {\n+                case IMPORT:\n+                    LOG.warn(\n+                            \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                                    + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+                    ValueProvider<String> deadPath =\n+                            getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+                    FhirIO.Import.ContentStructure contentStructure =\n+                            getContentStructure().orElseThrow(IllegalArgumentException::new);\n+                    ValueProvider<String> tempPath =\n+                            getImportGcsTempPath()\n+                                    .orElse(\n+                                            StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+                    return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+                case EXECUTE_BUNDLE:\n+                default:\n+                    failedBundles =\n+                            input\n+                                    .apply(\n+                                            \"Execute FHIR Bundles\",\n+                                            ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                                    .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+            return Result.in(input.getPipeline(), failedBundles);\n+        }\n     }\n \n     /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n+     * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+     * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+     * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+     * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+     * as transactions which is safer practice for a use on a \"live\" FHIR store.\n      */\n-    ExecuteBundles(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Import extends Write {\n \n-    @Override\n-    public FhirIO.Write.Result expand(PCollection<String> input) {\n-      return Write.Result.in(\n-          input.getPipeline(),\n-          input\n-              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-    }\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> deadLetterGcsPath;\n+        private final ContentStructure contentStructure;\n+        private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+        private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+        private ValueProvider<String> tempGcsPath;\n+\n+        /*\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore the fhir store\n+         * @param tempGcsPath the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure the content structure\n+         */\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> tempGcsPath,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = fhirStore;\n+            this.tempGcsPath = tempGcsPath;\n+            this.deadLetterGcsPath = deadLetterGcsPath;\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    /** The type Write Fhir fn. */\n-    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n-\n-      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n-      private transient HealthcareApiClient client;\n-      private final ObjectMapper mapper = new ObjectMapper();\n-      /** The Fhir store. */\n-      private final ValueProvider<String> fhirStore;\n-\n-      /**\n-       * Instantiates a new Write Fhir fn.\n-       *\n-       * @param fhirStore the Fhir store\n-       */\n-      ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      /**\n-       * Initialize healthcare client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Execute Bundles.\n-       *\n-       * @param context the context\n-       */\n-      @ProcessElement\n-      public void executeBundles(ProcessContext context) {\n-        String body = context.element();\n-        try {\n-          // Validate that data was set to valid JSON.\n-          mapper.readTree(body);\n-          client.executeFhirBundle(fhirStore.get(), body);\n-        } catch (IOException | HealthcareHttpException e) {\n-          failedBundles.inc();\n-          context.output(HealthcareIOError.of(body, e));\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this(fhirStore, null, deadLetterGcsPath, contentStructure);\n         }\n-      }\n-    }\n-  }\n \n-  /** Export FHIR resources from a FHIR store to new line delimited json files on GCS. */\n-  public static class Export extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> exportGcsUriPrefix;\n+        /**\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore         the fhir store\n+         * @param tempGcsPath       the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure  the content structure\n+         */\n+        Import(\n+                String fhirStore,\n+                String tempGcsPath,\n+                String deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+            this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+            this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-      this.fhirStore = fhirStore;\n-      this.exportGcsUriPrefix = exportGcsUriPrefix;\n-    }\n+        @Override\n+        ValueProvider<String> getFhirStore() {\n+            return fhirStore;\n+        }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleExportOperations\",\n-              ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n-          .apply(FileIO.matchAll())\n-          .apply(FileIO.readMatches())\n-          .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n-    }\n+        @Override\n+        WriteMethod getWriteMethod() {\n+            return WriteMethod.IMPORT;\n+        }\n \n-    /** A function that schedules an export operation and monitors the status. */\n-    public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> exportGcsUriPrefix;\n-\n-      public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n-        this.exportGcsUriPrefix = exportGcsUriPrefix;\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void exportResourcesToGcs(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String fhirStore = context.element();\n-        String gcsPrefix = this.exportGcsUriPrefix.get();\n-        Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new RuntimeException(\n-              String.format(\"Export operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ContentStructure> getContentStructure() {\n+            return Optional.of(contentStructure);\n         }\n-        context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n-      }\n-    }\n-  }\n-\n-  /** Deidentify FHIR resources from a FHIR store to a destination FHIR store. */\n-  public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> sourceFhirStore;\n-    private final ValueProvider<String> destinationFhirStore;\n-    private final ValueProvider<DeidentifyConfig> deidConfig;\n-\n-    public Deidentify(\n-        ValueProvider<String> sourceFhirStore,\n-        ValueProvider<String> destinationFhirStore,\n-        ValueProvider<DeidentifyConfig> deidConfig) {\n-      this.sourceFhirStore = sourceFhirStore;\n-      this.destinationFhirStore = destinationFhirStore;\n-      this.deidConfig = deidConfig;\n-    }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .getPipeline()\n-          .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleDeidentifyFhirStoreOperations\",\n-              ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n-    }\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsTempPath() {\n+            return Optional.of(tempGcsPath);\n+        }\n \n-    /** A function that schedules a deidentify operation and monitors the status. */\n-    public static class DeidentifyFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> destinationFhirStore;\n-      private static final Gson gson = new Gson();\n-      private final String deidConfigJson;\n-\n-      public DeidentifyFn(\n-          ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n-        this.destinationFhirStore = destinationFhirStore;\n-        this.deidConfigJson = gson.toJson(deidConfig.get());\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void deidentify(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String sourceFhirStore = context.element();\n-        String destinationFhirStore = this.destinationFhirStore.get();\n-        DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n-        Operation operation =\n-            client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new IOException(\n-              String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n+            return Optional.of(deadLetterGcsPath);\n         }\n-        context.output(destinationFhirStore);\n-      }\n-    }\n-  }\n \n-  /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+        @Override\n+        public Write.Result expand(PCollection<String> input) {\n+            checkState(\n+                    input.isBounded() == IsBounded.BOUNDED,\n+                    \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+                            + \"intended for batch use only.\");\n+\n+            // fall back on pipeline's temp location.\n+            ValueProvider<String> tempPath =\n+                    getImportGcsTempPath()\n+                            .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+            // Write bundles of String to GCS\n+            PCollectionTuple writeTmpFileResults =\n+                    input.apply(\n+                            \"Write nd json to GCS\",\n+                            ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                                    .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+            PCollection<HealthcareIOError<String>> failedBodies =\n+                    writeTmpFileResults\n+                            .get(Write.FAILED_BODY)\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            int numShards = 100;\n+            PCollection<HealthcareIOError<String>> failedFiles =\n+                    writeTmpFileResults\n+                            .get(Write.TEMP_FILES)\n+                            .apply(\n+                                    \"Shard files\", // to paralelize group into batches\n+                                    WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n+                            .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n+                            .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+                            .setCoder(\n+                                    KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n+                            .apply(\n+                                    \"Import Batches\",\n+                                    ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+            input\n+                    .getPipeline()\n+                    .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"Resolve SubDirs\",\n+                            MapElements.into(TypeDescriptors.strings())\n+                                    .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n+                    .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+                    .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+                    .apply(\n+                            \"Match tempGcsPath\",\n+                            FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+                    .apply(\n+                            \"Delete tempGcsPath\",\n+                            ParDo.of(\n+                                    new DoFn<Metadata, Void>() {\n+                                        @ProcessElement\n+                                        public void delete(@Element Metadata path, ProcessContext context) {\n+                                            // Wait til window closes for failedBodies and failedFiles to ensure we are\n+                                            // done processing\n+                                            // anything under tempGcsPath because it has been successfully imported to\n+                                            // FHIR store or\n+                                            // copies have been moved to the dead letter path.\n+                                            // Clean up all of tempGcsPath. This will handle removing phantom temporary\n+                                            // objects from\n+                                            // failed / rescheduled ImportFn::importBatch.\n+                                            try {\n+                                                FileSystems.delete(\n+                                                        Collections.singleton(path.resourceId()),\n+                                                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                                            } catch (IOException e) {\n+                                                LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                                            }\n+                                        }\n+                                    }))\n+                    .setCoder(VoidCoder.of());\n+\n+            return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+        }\n+\n+        /**\n+         * The Write bundles to new line delimited json files.\n+         */\n+        static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+            private final ValueProvider<String> fhirStore;\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ObjectMapper mapper;\n+            private ResourceId resourceId;\n+            private WritableByteChannel ndJsonChannel;\n+            private BoundedWindow window;\n+\n+            private transient HealthcareApiClient client;\n+            private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+            WriteBundlesToFilesFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+            }\n+\n+            /**\n+             * Instantiates a new Import fn.\n+             *\n+             * @param fhirStore         the fhir store\n+             * @param tempGcsPath       the temp gcs path\n+             * @param deadLetterGcsPath the dead letter gcs path\n+             */\n+            WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+                this.fhirStore = StaticValueProvider.of(fhirStore);\n+                this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+                this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            }\n+\n+            /**\n+             * Init client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Init batch.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @StartBundle\n+            public void initFile() throws IOException {\n+                // Write each bundle to newline delimited JSON file.\n+                String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+                ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n+                this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+                this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+                if (mapper == null) {\n+                    this.mapper = new ObjectMapper();\n+                }\n+            }\n+\n+            /**\n+             * Add to batch.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @ProcessElement\n+            public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+                this.window = window;\n+                String httpBody = context.element();\n+                try {\n+                    // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+                    Object data = this.mapper.readValue(httpBody, Object.class);\n+                    String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+                    this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+                } catch (JsonProcessingException e) {\n+                    String resource =\n+                            String.format(\n+                                    \"Failed to parse payload: %s as json at: %s : %s.\"\n+                                            + \"Dropping message from batch import.\",\n+                                    httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+                    LOG.warn(resource);\n+                    context.output(\n+                            Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+                }\n+            }\n+\n+            /**\n+             * Close file.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @FinishBundle\n+            public void closeFile(FinishBundleContext context) throws IOException {\n+                // Write the file with all elements in this bundle to GCS.\n+                ndJsonChannel.close();\n+                context.output(resourceId, window.maxTimestamp(), window);\n+            }\n+        }\n \n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Import batches of new line delimited json files to FHIR Store.\n+         */\n+        static class ImportFn\n+                extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+            private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ResourceId tempDir;\n+            private final ContentStructure contentStructure;\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> fhirStore;\n+\n+            ImportFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath,\n+                    @Nullable ContentStructure contentStructure) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+                if (contentStructure == null) {\n+                    this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+                } else {\n+                    this.contentStructure = contentStructure;\n+                }\n+            }\n+\n+            @Setup\n+            public void init() throws IOException {\n+                tempDir =\n+                        FileSystems.matchNewResource(tempGcsPath.get(), true)\n+                                .resolve(\n+                                        String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                                        StandardResolveOptions.RESOLVE_DIRECTORY);\n+                client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+             * GCS URI.\n+             */\n+            @ProcessElement\n+            public void importBatch(\n+                    @Element KV<Integer, Iterable<ResourceId>> element,\n+                    OutputReceiver<HealthcareIOError<String>> output)\n+                    throws IOException {\n+                Iterable<ResourceId> batch = element.getValue();\n+                List<ResourceId> tempDestinations = new ArrayList<>();\n+                List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+                assert batch != null;\n+                for (ResourceId file : batch) {\n+                    tempDestinations.add(\n+                            tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                    deadLetterDestinations.add(\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n+                                    .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                }\n+                // Ignore missing files since this might be a retry, which means files\n+                // should have been copied over.\n+                FileSystems.copy(\n+                        ImmutableList.copyOf(batch),\n+                        tempDestinations,\n+                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                // Check whether any temporary files are not present.\n+                boolean hasMissingFile =\n+                        FileSystems.matchResources(tempDestinations).stream()\n+                                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n+                if (hasMissingFile) {\n+                    throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+                }\n+                ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+                try {\n+                    // Blocking fhirStores.import request.\n+                    assert contentStructure != null;\n+                    Operation operation =\n+                            client.importFhirResource(\n+                                    fhirStore.get(), importUri.toString(), contentStructure.name());\n+                    client.pollOperation(operation, 500L);\n+                    // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+                    // needed.\n+                    FileSystems.delete(tempDestinations);\n+                } catch (IOException | InterruptedException e) {\n+                    ResourceId deadLetterResourceId =\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n+                    LOG.warn(\n+                            String.format(\n+                                    \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                                    importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+                    FileSystems.rename(tempDestinations, deadLetterDestinations);\n+                    output.output(HealthcareIOError.of(importUri.toString(), e));\n+                } finally {\n+                    // If we've reached this point files have either been successfully import to FHIR store\n+                    // or moved to Dead Letter Queue.\n+                    // Clean up original files for this batch on GCS.\n+                    FileSystems.delete(ImmutableList.copyOf(batch));\n+                }\n+            }\n+        }\n+\n+        /**\n+         * The enum Content structure.\n+         */\n+        public enum ContentStructure {\n+            /**\n+             * If the content structure is not specified, the default value BUNDLE will be used.\n+             */\n+            CONTENT_STRUCTURE_UNSPECIFIED,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a bundle, which contains one or more resources. Set the bundle type to history to import\n+             * resource versions.\n+             */\n+            BUNDLE,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a single resource.\n+             */\n+            RESOURCE,\n+            /**\n+             * The entire file is one JSON bundle. The JSON can span multiple lines.\n+             */\n+            BUNDLE_PRETTY,\n+            /**\n+             * The entire file is one JSON resource. The JSON can span multiple lines.\n+             */\n+            RESOURCE_PRETTY\n+        }\n+    }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * The type Execute bundles.\n      */\n-    Search(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+    public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+        private final ValueProvider<String> fhirStore;\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        @Override\n+        public FhirIO.Write.Result expand(PCollection<String> input) {\n+            return Write.Result.in(\n+                    input.getPipeline(),\n+                    input\n+                            .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+\n+        /**\n+         * The type Write Fhir fn.\n+         */\n+        static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+            private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+            private transient HealthcareApiClient client;\n+            private final ObjectMapper mapper = new ObjectMapper();\n+            /**\n+             * The Fhir store.\n+             */\n+            private final ValueProvider<String> fhirStore;\n+\n+            /**\n+             * Instantiates a new Write Fhir fn.\n+             *\n+             * @param fhirStore the Fhir store\n+             */\n+            ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            /**\n+             * Initialize healthcare client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Execute Bundles.\n+             *\n+             * @param context the context\n+             */\n+            @ProcessElement\n+            public void executeBundles(ProcessContext context) {\n+                String body = context.element();\n+                try {\n+                    // Validate that data was set to valid JSON.\n+                    mapper.readTree(body);\n+                    client.executeFhirBundle(fhirStore.get(), body);\n+                } catch (IOException | HealthcareHttpException e) {\n+                    failedBundles.inc();\n+                    context.output(HealthcareIOError.of(body, e));\n+                }\n+            }\n+        }\n     }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * Export FHIR resources from a FHIR store to new line delimited json files on GCS.\n      */\n-    Search(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Export extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> exportGcsUriPrefix;\n+\n+        public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+            this.fhirStore = fhirStore;\n+            this.exportGcsUriPrefix = exportGcsUriPrefix;\n+        }\n \n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedSearches;\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the search result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-                .keySet()\n-                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Search.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n-                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleExportOperations\",\n+                            ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n+                    .apply(FileIO.matchAll())\n+                    .apply(FileIO.readMatches())\n+                    .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n+        }\n+\n+        /**\n+         * A function that schedules an export operation and monitors the status.\n+         */\n+        public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> exportGcsUriPrefix;\n+\n+            public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n+                this.exportGcsUriPrefix = exportGcsUriPrefix;\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void exportResourcesToGcs(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String fhirStore = context.element();\n+                String gcsPrefix = this.exportGcsUriPrefix.get();\n+                Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new RuntimeException(\n+                            String.format(\"Export operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n+            }\n         }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedSearches =\n-                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed searches.\n-       *\n-       * @return the failed searches\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n-        return failedSearches;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-              String transformName, PInput input, PTransform<?, ?> transform) {}\n     }\n \n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-            new TupleTag<HealthcareIOError<String>>() {};\n+    /**\n+     * Deidentify FHIR resources from a FHIR store to a destination FHIR store.\n+     */\n+    public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> sourceFhirStore;\n+        private final ValueProvider<String> destinationFhirStore;\n+        private final ValueProvider<DeidentifyConfig> deidConfig;\n+\n+        public Deidentify(\n+                ValueProvider<String> sourceFhirStore,\n+                ValueProvider<String> destinationFhirStore,\n+                ValueProvider<DeidentifyConfig> deidConfig) {\n+            this.sourceFhirStore = sourceFhirStore;\n+            this.destinationFhirStore = destinationFhirStore;\n+            this.deidConfig = deidConfig;\n+        }\n \n-    @Override\n-    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n-      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .getPipeline()\n+                    .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleDeidentifyFhirStoreOperations\",\n+                            ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n+        }\n+\n+        /**\n+         * A function that schedules a deidentify operation and monitors the status.\n+         */\n+        public static class DeidentifyFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> destinationFhirStore;\n+            private static final Gson gson = new Gson();\n+            private final String deidConfigJson;\n+\n+            public DeidentifyFn(\n+                    ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n+                this.destinationFhirStore = destinationFhirStore;\n+                this.deidConfigJson = gson.toJson(deidConfig.get());\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void deidentify(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String sourceFhirStore = context.element();\n+                String destinationFhirStore = this.destinationFhirStore.get();\n+                DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n+                Operation operation =\n+                        client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new IOException(\n+                            String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(destinationFhirStore);\n+            }\n+        }\n     }\n \n     /**\n-     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n-     * and search parameters, and fetches all matching resources based on the search criteria and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n-     *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of failed searches from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * The type Search.\n      */\n-    static class SearchResourcesJsonString\n-            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-\n-      private final ValueProvider<String> fhirStore;\n-\n-      /** Instantiates a new Search Fhir resources DoFn. */\n-      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      @Override\n-      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n-        return new FhirIO.Search.Result(\n-                resourceIds.apply(\n-                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n-                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for searching messages from the Fhir store with error handling. */\n-      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n-\n-        private Counter failedSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n-        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n-        private final Counter successfulSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n-        private HealthcareApiClient client;\n+    public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n         private final ValueProvider<String> fhirStore;\n \n-        /** Instantiates a new Fhir resources search fn. */\n-        SearchResourcesFn(ValueProvider<String> fhirStore) {\n-          this.fhirStore = fhirStore;\n+        Search(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        Search(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedSearches;\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the search result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Search.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                                    + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedSearches =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed searches.\n+             *\n+             * @return the failed searches\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+                return failedSearches;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n         }\n \n         /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n+         * The tag for the main output of Fhir Messages.\n          */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+            return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n         }\n \n         /**\n-         * Process element.\n+         * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n          *\n-         * @param context the context\n+         * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+         * and search parameters, and fetches all matching resources based on the search criteria and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of failed searches from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n          */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          KV<String, Map<String, String>> elementValues = context.element();\n-          try {\n-            context.output(searchResources(\n-                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n-          } catch (Exception e) {\n-            failedSearches.inc();\n-            LOG.warn(\n-                    String.format(\n-                            \"Error search FHIR messages writing to Dead Letter \"\n-                                    + \"Queue. Cause: %s Stack Trace: %s\",\n-                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n-          }\n-        }\n-\n-        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n-                                       @Nullable Map<String, String> parameters)\n-                throws IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n-                  new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n-                          client, fhirStore, resourceType, parameters);\n-          JsonArray result = new JsonArray();\n-          while (iter.hasNext()) {\n-            result.addAll(iter.next());\n-          }\n-          this.successfulSearches.inc();\n-          return result.toString();\n+        static class SearchResourcesJsonString\n+                extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+            private final ValueProvider<String> fhirStore;\n+\n+            public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            @Override\n+            public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+                return new FhirIO.Search.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                        .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for searching messages from the Fhir store with error handling.\n+             */\n+            static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+                private Counter failedSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+                private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+                private final Counter successfulSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+                private HealthcareApiClient client;\n+                private final ValueProvider<String> fhirStore;\n+\n+                /**\n+                 * Instantiates a new Fhir resources search fn.\n+                 */\n+                SearchResourcesFn(ValueProvider<String> fhirStore) {\n+                    this.fhirStore = fhirStore;\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    KV<String, Map<String, String>> elementValues = context.element();\n+                    try {\n+                        context.output(searchResources(\n+                                this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+                    } catch (Exception e) {\n+                        failedSearches.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error search FHIR messages writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+                    }\n+                }\n+\n+                private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                               @Nullable Map<String, String> parameters)\n+                        throws IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                            new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                                    client, fhirStore, resourceType, parameters);\n+                    JsonArray result = new JsonArray();\n+                    while (iter.hasNext()) {\n+                        result.addAll(iter.next());\n+                    }\n+                    this.successfulSearches.inc();\n+                    return result.toString();\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODYwMw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529808603", "bodyText": "Please only catch the exceptions you expect to handle.", "author": "lastomato", "createdAt": "2020-11-24T18:58:13Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -1388,4 +1410,208 @@ public void deidentify(ProcessContext context)\n       }\n     }\n   }\n+\n+  /** The type Search. */\n+  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n+    private final ValueProvider<String> fhirStore;\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(String fhirStore) {\n+      this.fhirStore = StaticValueProvider.of(fhirStore);\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedSearches;\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the search result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+                .keySet()\n+                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Search.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedSearches =\n+                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed searches.\n+       *\n+       * @return the failed searches\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+        return failedSearches;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+              String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+            new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+    }\n+\n+    /**\n+     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+     * and search parameters, and fetches all matching resources based on the search criteria and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of failed searches from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    static class SearchResourcesJsonString\n+            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+      private final ValueProvider<String> fhirStore;\n+\n+      /** Instantiates a new Search Fhir resources DoFn. */\n+      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      @Override\n+      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+        return new FhirIO.Search.Result(\n+                resourceIds.apply(\n+                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for searching messages from the Fhir store with error handling. */\n+      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+        private Counter failedSearches =\n+                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+        private final Counter successfulSearches =\n+                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+        private HealthcareApiClient client;\n+        private final ValueProvider<String> fhirStore;\n+\n+        /** Instantiates a new Fhir resources search fn. */\n+        SearchResourcesFn(ValueProvider<String> fhirStore) {\n+          this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          KV<String, Map<String, String>> elementValues = context.element();\n+          try {\n+            context.output(searchResources(\n+                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+          } catch (Exception e) {", "originalCommit": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzNjczMA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r529836730", "bodyText": "Would that mean that unhandled exceptions / errors won't be logged?", "author": "janeliulwq", "createdAt": "2020-11-24T19:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNzY5Nw==", "url": "https://github.com/apache/beam/pull/13395#discussion_r530527697", "bodyText": "They will be handled by code that knows how to handle them. For example, the code here probably should not be responsible for an OutOfMemoryError.", "author": "lastomato", "createdAt": "2020-11-25T17:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MjkxOQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r530582919", "bodyText": "Ah, makes sense, done. Sorry Java newbie here!", "author": "janeliulwq", "createdAt": "2020-11-25T18:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwODYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 9c0d0e409d..257d9f4a5c 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -212,1406 +214,1476 @@ import org.slf4j.LoggerFactory;\n  * </pre>\n  */\n @SuppressWarnings({\n-  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+        \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n })\n public class FhirIO {\n \n-  /**\n-   * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n-   * notifications)\n-   *\n-   * @return the read\n-   * @see Read\n-   */\n-  public static Read readResources() {\n-    return new Read();\n-  }\n-\n-  /**\n-   * Search resources from a PCollection\n-   *\n-   * @return the search\n-   * @see Search\n-   */\n-  public static Search searchResources(String fhirStore) {\n-    return new Search(fhirStore);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      String fhirStore,\n-      String tempDir,\n-      String deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Import resources. Intended for use on empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store\n-   * @param tempDir the temp dir\n-   * @param deadLetterDir the dead letter dir\n-   * @param contentStructure the content structure\n-   * @return the import\n-   * @see Import\n-   */\n-  public static Import importResources(\n-      ValueProvider<String> fhirStore,\n-      ValueProvider<String> tempDir,\n-      ValueProvider<String> deadLetterDir,\n-      FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-    return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n-    return new Export(\n-        StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n-  }\n-\n-  /**\n-   * Export resources to GCS. Intended for use on non-empty FHIR stores\n-   *\n-   * @param fhirStore the fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param exportGcsUriPrefix the destination GCS dir, in the format:\n-   *     gs://YOUR_BUCKET_NAME/path/to/a/dir\n-   * @return the export\n-   * @see Export\n-   */\n-  public static Export exportResourcesToGcs(\n-      ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-    return new Export(fhirStore, exportGcsUriPrefix);\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n-    return new Deidentify(\n-        StaticValueProvider.of(sourceFhirStore),\n-        StaticValueProvider.of(destinationFhirStore),\n-        StaticValueProvider.of(deidConfig));\n-  }\n-\n-  /**\n-   * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n-   *\n-   * @param sourceFhirStore the source fhir store, in the format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n-   *     format:\n-   *     projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n-   * @param deidConfig the DeidentifyConfig\n-   * @return the deidentify\n-   * @see Deidentify\n-   */\n-  public static Deidentify deidentify(\n-      ValueProvider<String> sourceFhirStore,\n-      ValueProvider<String> destinationFhirStore,\n-      ValueProvider<DeidentifyConfig> deidConfig) {\n-    return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n-  }\n-\n-  /** The type Read. */\n-  public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n-\n-    /** Instantiates a new Read. */\n-    public Read() {}\n-\n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedReads;\n-      /** The Pct. */\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the read result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-            .keySet()\n-            .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Read.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-              \"The PCollection tuple must have the FhirIO.Read.OUT \"\n-                  + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n-        }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedReads =\n-            pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed reads.\n-       *\n-       * @return the failed reads\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedReads() {\n-        return failedReads;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-    }\n-\n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-\n-    @Override\n-    public FhirIO.Read.Result expand(PCollection<String> input) {\n-      return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n-    }\n-\n     /**\n-     * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n-     * store, and fetches the actual {@link String} object based on the id in the notification and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n+     * Read resources from a PCollection of resource IDs (e.g. when subscribing the pubsub\n+     * notifications)\n      *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * @return the read\n+     * @see Read\n      */\n-    static class FetchResourceJsonString\n-        extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n-\n-      /** Instantiates a new Fetch Fhir message DoFn. */\n-      public FetchResourceJsonString() {}\n-\n-      @Override\n-      public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n-        return new FhirIO.Read.Result(\n-            resourceIds.apply(\n-                ParDo.of(new ReadResourceFn())\n-                    .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for fetching messages from the Fhir store with error handling. */\n-      static class ReadResourceFn extends DoFn<String, String> {\n-\n-        private Counter failedMessageGets =\n-            Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n-        private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n-        private final Counter successfulStringGets =\n-            Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n-        private HealthcareApiClient client;\n-        private ObjectMapper mapper;\n-\n-        /** Instantiates a new Hl 7 v 2 message get fn. */\n-        ReadResourceFn() {}\n-\n-        /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n-         */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n-          this.mapper = new ObjectMapper();\n-        }\n-\n-        /**\n-         * Process element.\n-         *\n-         * @param context the context\n-         */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          String resourceId = context.element();\n-          try {\n-            context.output(fetchResource(this.client, resourceId));\n-          } catch (Exception e) {\n-            failedMessageGets.inc();\n-            LOG.warn(\n-                String.format(\n-                    \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n-                        + \"Queue. Cause: %s Stack Trace: %s\",\n-                    resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n-          }\n-        }\n-\n-        private String fetchResource(HealthcareApiClient client, String resourceId)\n-            throws IOException, IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpBody resource = client.readFhirResource(resourceId);\n-\n-          if (resource == null) {\n-            throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n-          }\n-          this.successfulStringGets.inc();\n-          return mapper.writeValueAsString(resource);\n-        }\n-      }\n-    }\n-  }\n-\n-  /** The type Write. */\n-  @AutoValue\n-  public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n-\n-    /** The tag for the failed writes to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for the files that failed to FHIR store`. */\n-    public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n-        new TupleTag<HealthcareIOError<String>>() {};\n-    /** The tag for temp files for import to FHIR store`. */\n-    public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {};\n-\n-    /** The enum Write method. */\n-    public enum WriteMethod {\n-      /**\n-       * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n-       */\n-      EXECUTE_BUNDLE,\n-      /**\n-       * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n-       * FHIR stores. <a\n-       * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n-       */\n-      IMPORT\n-    }\n-\n-    /** The type Result. */\n-    public static class Result implements POutput {\n-      private final Pipeline pipeline;\n-      private final PCollection<HealthcareIOError<String>> failedBodies;\n-      private final PCollection<HealthcareIOError<String>> failedFiles;\n-\n-      /**\n-       * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n-       * pipeline\n-       *\n-       * @param failedBodies the failed inserts\n-       * @return the result\n-       */\n-      static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n-        return new Result(pipeline, failedBodies, null);\n-      }\n-\n-      static Result in(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          PCollection<HealthcareIOError<String>> failedFiles) {\n-        return new Result(pipeline, failedBodies, failedFiles);\n-      }\n-\n-      /**\n-       * Gets failed bodies with err.\n-       *\n-       * @return the failed inserts with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedBodies() {\n-        return this.failedBodies;\n-      }\n-\n-      /**\n-       * Gets failed file imports with err.\n-       *\n-       * @return the failed GCS uri with err\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedFiles() {\n-        return this.failedFiles;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pipeline;\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-          String transformName, PInput input, PTransform<?, ?> transform) {}\n-\n-      private Result(\n-          Pipeline pipeline,\n-          PCollection<HealthcareIOError<String>> failedBodies,\n-          @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n-        this.pipeline = pipeline;\n-        this.failedBodies = failedBodies;\n-        if (failedFiles == null) {\n-          failedFiles =\n-              (PCollection<HealthcareIOError<String>>)\n-                  pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-        }\n-        this.failedFiles = failedFiles;\n-      }\n+    public static Read readResources() {\n+        return new Read();\n     }\n \n     /**\n-     * Gets Fhir store.\n+     * Search resources from a Fhir store.\n      *\n-     * @return the Fhir store\n+     * @return the search\n+     * @see Search\n      */\n-    abstract ValueProvider<String> getFhirStore();\n+    public static Search searchResources(String fhirStore) {\n+        return new Search(fhirStore);\n+    }\n \n     /**\n-     * Gets write method.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the write method\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract WriteMethod getWriteMethod();\n+    public static Import importResources(\n+            String fhirStore,\n+            String tempDir,\n+            String deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets content structure.\n+     * Import resources. Intended for use on empty FHIR stores\n      *\n-     * @return the content structure\n+     * @param fhirStore        the fhir store\n+     * @param tempDir          the temp dir\n+     * @param deadLetterDir    the dead letter dir\n+     * @param contentStructure the content structure\n+     * @return the import\n+     * @see Import\n      */\n-    abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n+    public static Import importResources(\n+            ValueProvider<String> fhirStore,\n+            ValueProvider<String> tempDir,\n+            ValueProvider<String> deadLetterDir,\n+            FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+        return new Import(fhirStore, tempDir, deadLetterDir, contentStructure);\n+    }\n \n     /**\n-     * Gets import gcs temp path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs temp path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n+    public static Export exportResourcesToGcs(String fhirStore, String exportGcsUriPrefix) {\n+        return new Export(\n+                StaticValueProvider.of(fhirStore), StaticValueProvider.of(exportGcsUriPrefix));\n+    }\n \n     /**\n-     * Gets import gcs dead letter path.\n+     * Export resources to GCS. Intended for use on non-empty FHIR stores\n      *\n-     * @return the import gcs dead letter path\n+     * @param fhirStore          the fhir store, in the format:\n+     *                           projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param exportGcsUriPrefix the destination GCS dir, in the format:\n+     *                           gs://YOUR_BUCKET_NAME/path/to/a/dir\n+     * @return the export\n+     * @see Export\n      */\n-    abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n-\n-    /** The type Builder. */\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-\n-      /**\n-       * Sets Fhir store.\n-       *\n-       * @param fhirStore the Fhir store\n-       * @return the Fhir store\n-       */\n-      abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n-\n-      /**\n-       * Sets write method.\n-       *\n-       * @param writeMethod the write method\n-       * @return the write method\n-       */\n-      abstract Builder setWriteMethod(WriteMethod writeMethod);\n-\n-      /**\n-       * Sets content structure.\n-       *\n-       * @param contentStructure the content structure\n-       * @return the content structure\n-       */\n-      abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n-\n-      /**\n-       * Sets import gcs temp path.\n-       *\n-       * @param gcsTempPath the gcs temp path\n-       * @return the import gcs temp path\n-       */\n-      abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n-\n-      /**\n-       * Sets import gcs dead letter path.\n-       *\n-       * @param gcsDeadLetterPath the gcs dead letter path\n-       * @return the import gcs dead letter path\n-       */\n-      abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n-\n-      /**\n-       * Build write.\n-       *\n-       * @return the write\n-       */\n-      abstract Write build();\n-    }\n-\n-    private static Write.Builder write(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n+    public static Export exportResourcesToGcs(\n+            ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+        return new Export(fhirStore, exportGcsUriPrefix);\n     }\n \n     /**\n-     * Create Method creates a single FHIR resource. @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @param gcsTempPath the gcs temp path\n-     * @param gcsDeadLetterPath the gcs dead letter path\n-     * @param contentStructure the content structure\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsTempPath,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        String fhirStore,\n-        String gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n-          .build();\n-    }\n-\n-    public static Write fhirStoresImport(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> gcsTempPath,\n-        ValueProvider<String> gcsDeadLetterPath,\n-        FhirIO.Import.@Nullable ContentStructure contentStructure) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(Write.WriteMethod.IMPORT)\n-          .setContentStructure(contentStructure)\n-          .setImportGcsTempPath(gcsTempPath)\n-          .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n-          .build();\n+    public static Deidentify deidentify(\n+            String sourceFhirStore, String destinationFhirStore, DeidentifyConfig deidConfig) {\n+        return new Deidentify(\n+                StaticValueProvider.of(sourceFhirStore),\n+                StaticValueProvider.of(destinationFhirStore),\n+                StaticValueProvider.of(deidConfig));\n     }\n \n     /**\n-     * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n-     * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+     * Deidentify FHIR resources. Intended for use on non-empty FHIR stores\n      *\n-     * @param fhirStore the hl 7 v 2 store\n-     * @return the write\n+     * @param sourceFhirStore      the source fhir store, in the format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param destinationFhirStore the destination fhir store to write de-identified resources, in the\n+     *                             format:\n+     *                             projects/project_id/locations/location_id/datasets/dataset_id/fhirStores/fhir_store_id\n+     * @param deidConfig           the DeidentifyConfig\n+     * @return the deidentify\n+     * @see Deidentify\n      */\n-    public static Write executeBundles(String fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(StaticValueProvider.of(fhirStore))\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n+    public static Deidentify deidentify(\n+            ValueProvider<String> sourceFhirStore,\n+            ValueProvider<String> destinationFhirStore,\n+            ValueProvider<DeidentifyConfig> deidConfig) {\n+        return new Deidentify(sourceFhirStore, destinationFhirStore, deidConfig);\n     }\n \n     /**\n-     * Execute bundles write.\n-     *\n-     * @param fhirStore the fhir store\n-     * @return the write\n+     * The type Read.\n      */\n-    public static Write executeBundles(ValueProvider<String> fhirStore) {\n-      return new AutoValue_FhirIO_Write.Builder()\n-          .setFhirStore(fhirStore)\n-          .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n-          .build();\n-    }\n+    public static class Read extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Read.class);\n \n-    private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n-\n-    @Override\n-    public Result expand(PCollection<String> input) {\n-      PCollection<HealthcareIOError<String>> failedBundles;\n-      PCollection<HealthcareIOError<String>> failedImports;\n-      switch (this.getWriteMethod()) {\n-        case IMPORT:\n-          LOG.warn(\n-              \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n-                  + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n-          ValueProvider<String> deadPath =\n-              getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n-          FhirIO.Import.ContentStructure contentStructure =\n-              getContentStructure().orElseThrow(IllegalArgumentException::new);\n-          ValueProvider<String> tempPath =\n-              getImportGcsTempPath()\n-                  .orElse(\n-                      StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-          return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n-        case EXECUTE_BUNDLE:\n-        default:\n-          failedBundles =\n-              input\n-                  .apply(\n-                      \"Execute FHIR Bundles\",\n-                      ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n-                  .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-      return Result.in(input.getPipeline(), failedBundles);\n-    }\n-  }\n-\n-  /**\n-   * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n-   * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n-   * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n-   * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n-   * as transactions which is safer practice for a use on a \"live\" FHIR store.\n-   */\n-  public static class Import extends Write {\n-\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> deadLetterGcsPath;\n-    private final ContentStructure contentStructure;\n-    private static final int DEFAULT_FILES_PER_BATCH = 10000;\n-    private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n-    private ValueProvider<String> tempGcsPath;\n-\n-    /*\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n-     */\n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> tempGcsPath,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = fhirStore;\n-      this.tempGcsPath = tempGcsPath;\n-      this.deadLetterGcsPath = deadLetterGcsPath;\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+        /**\n+         * Instantiates a new Read.\n+         */\n+        public Read() {\n+        }\n+\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedReads;\n+            /**\n+             * The Pct.\n+             */\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Read.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the read result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Read.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Read.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Read.OUT \"\n+                                    + \"and FhirIO.Read.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedReads =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed reads.\n+             *\n+             * @return the failed reads\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedReads() {\n+                return failedReads;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+        }\n+\n+        /**\n+         * The tag for the main output of Fhir Messages.\n+         */\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Read.Result expand(PCollection<String> input) {\n+            return input.apply(\"Fetch Fhir messages\", new FetchResourceJsonString());\n+        }\n+\n+        /**\n+         * DoFn to fetch a resource from an Google Cloud Healthcare FHIR store based on resourceID\n+         *\n+         * <p>This DoFn consumes a {@link PCollection} of notifications {@link String}s from the FHIR\n+         * store, and fetches the actual {@link String} object based on the id in the notification and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Read#OUT} - Contains all {@link PCollection} records successfully read\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Read#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of message IDs which failed to be fetched from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n+         */\n+        static class FetchResourceJsonString\n+                extends PTransform<PCollection<String>, FhirIO.Read.Result> {\n+\n+            /**\n+             * Instantiates a new Fetch Fhir message DoFn.\n+             */\n+            public FetchResourceJsonString() {\n+            }\n+\n+            @Override\n+            public FhirIO.Read.Result expand(PCollection<String> resourceIds) {\n+                return new FhirIO.Read.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new ReadResourceFn())\n+                                        .withOutputTags(FhirIO.Read.OUT, TupleTagList.of(FhirIO.Read.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for fetching messages from the Fhir store with error handling.\n+             */\n+            static class ReadResourceFn extends DoFn<String, String> {\n+\n+                private Counter failedMessageGets =\n+                        Metrics.counter(ReadResourceFn.class, \"failed-message-reads\");\n+                private static final Logger LOG = LoggerFactory.getLogger(ReadResourceFn.class);\n+                private final Counter successfulStringGets =\n+                        Metrics.counter(ReadResourceFn.class, \"successful-hl7v2-message-gets\");\n+                private HealthcareApiClient client;\n+                private ObjectMapper mapper;\n+\n+                /**\n+                 * Instantiates a new Hl 7 v 2 message get fn.\n+                 */\n+                ReadResourceFn() {\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                    this.mapper = new ObjectMapper();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    String resourceId = context.element();\n+                    try {\n+                        context.output(fetchResource(this.client, resourceId));\n+                    } catch (Exception e) {\n+                        failedMessageGets.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error fetching Fhir message with ID %s writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        resourceId, e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Read.DEAD_LETTER, HealthcareIOError.of(resourceId, e));\n+                    }\n+                }\n+\n+                private String fetchResource(HealthcareApiClient client, String resourceId)\n+                        throws IOException, IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n \n-    Import(\n-        ValueProvider<String> fhirStore,\n-        ValueProvider<String> deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this(fhirStore, null, deadLetterGcsPath, contentStructure);\n+                    HttpBody resource = client.readFhirResource(resourceId);\n+\n+                    if (resource == null) {\n+                        throw new IOException(String.format(\"GET request for %s returned null\", resourceId));\n+                    }\n+                    this.successfulStringGets.inc();\n+                    return mapper.writeValueAsString(resource);\n+                }\n+            }\n+        }\n     }\n+\n     /**\n-     * Instantiates a new Import.\n-     *\n-     * @param fhirStore the fhir store\n-     * @param tempGcsPath the temp gcs path\n-     * @param deadLetterGcsPath the dead letter gcs path\n-     * @param contentStructure the content structure\n+     * The type Write.\n      */\n-    Import(\n-        String fhirStore,\n-        String tempGcsPath,\n-        String deadLetterGcsPath,\n-        @Nullable ContentStructure contentStructure) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-      this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-      this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      if (contentStructure == null) {\n-        this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-      } else {\n-        this.contentStructure = contentStructure;\n-      }\n-    }\n+    @AutoValue\n+    public abstract static class Write extends PTransform<PCollection<String>, Write.Result> {\n \n-    @Override\n-    ValueProvider<String> getFhirStore() {\n-      return fhirStore;\n-    }\n+        /**\n+         * The tag for the failed writes to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_BODY =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for the files that failed to FHIR store`.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> FAILED_FILES =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+        /**\n+         * The tag for temp files for import to FHIR store`.\n+         */\n+        public static final TupleTag<ResourceId> TEMP_FILES = new TupleTag<ResourceId>() {\n+        };\n \n-    @Override\n-    WriteMethod getWriteMethod() {\n-      return WriteMethod.IMPORT;\n-    }\n+        /**\n+         * The enum Write method.\n+         */\n+        public enum WriteMethod {\n+            /**\n+             * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+             */\n+            EXECUTE_BUNDLE,\n+            /**\n+             * Import Method bulk imports resources from GCS. This is ideal for initial loads to empty\n+             * FHIR stores. <a\n+             * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores/import></a>.\n+             */\n+            IMPORT\n+        }\n \n-    @Override\n-    Optional<ContentStructure> getContentStructure() {\n-      return Optional.of(contentStructure);\n-    }\n+        /**\n+         * The type Result.\n+         */\n+        public static class Result implements POutput {\n+            private final Pipeline pipeline;\n+            private final PCollection<HealthcareIOError<String>> failedBodies;\n+            private final PCollection<HealthcareIOError<String>> failedFiles;\n+\n+            /**\n+             * Creates a {@link FhirIO.Write.Result} in the given {@link Pipeline}. @param pipeline the\n+             * pipeline\n+             *\n+             * @param failedBodies the failed inserts\n+             * @return the result\n+             */\n+            static Result in(Pipeline pipeline, PCollection<HealthcareIOError<String>> failedBodies) {\n+                return new Result(pipeline, failedBodies, null);\n+            }\n+\n+            static Result in(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    PCollection<HealthcareIOError<String>> failedFiles) {\n+                return new Result(pipeline, failedBodies, failedFiles);\n+            }\n+\n+            /**\n+             * Gets failed bodies with err.\n+             *\n+             * @return the failed inserts with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedBodies() {\n+                return this.failedBodies;\n+            }\n+\n+            /**\n+             * Gets failed file imports with err.\n+             *\n+             * @return the failed GCS uri with err\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedFiles() {\n+                return this.failedFiles;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pipeline;\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(Write.FAILED_BODY, failedBodies, Write.FAILED_FILES, failedFiles);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n+\n+            private Result(\n+                    Pipeline pipeline,\n+                    PCollection<HealthcareIOError<String>> failedBodies,\n+                    @Nullable PCollection<HealthcareIOError<String>> failedFiles) {\n+                this.pipeline = pipeline;\n+                this.failedBodies = failedBodies;\n+                if (failedFiles == null) {\n+                    failedFiles =\n+                            (PCollection<HealthcareIOError<String>>)\n+                                    pipeline.apply(Create.empty(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+                }\n+                this.failedFiles = failedFiles;\n+            }\n+        }\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsTempPath() {\n-      return Optional.of(tempGcsPath);\n-    }\n+        /**\n+         * Gets Fhir store.\n+         *\n+         * @return the Fhir store\n+         */\n+        abstract ValueProvider<String> getFhirStore();\n \n-    @Override\n-    Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n-      return Optional.of(deadLetterGcsPath);\n-    }\n+        /**\n+         * Gets write method.\n+         *\n+         * @return the write method\n+         */\n+        abstract WriteMethod getWriteMethod();\n \n-    @Override\n-    public Write.Result expand(PCollection<String> input) {\n-      checkState(\n-          input.isBounded() == IsBounded.BOUNDED,\n-          \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n-              + \"intended for batch use only.\");\n-\n-      // fall back on pipeline's temp location.\n-      ValueProvider<String> tempPath =\n-          getImportGcsTempPath()\n-              .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n-\n-      // Write bundles of String to GCS\n-      PCollectionTuple writeTmpFileResults =\n-          input.apply(\n-              \"Write nd json to GCS\",\n-              ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n-                  .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n-\n-      PCollection<HealthcareIOError<String>> failedBodies =\n-          writeTmpFileResults\n-              .get(Write.FAILED_BODY)\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      int numShards = 100;\n-      PCollection<HealthcareIOError<String>> failedFiles =\n-          writeTmpFileResults\n-              .get(Write.TEMP_FILES)\n-              .apply(\n-                  \"Shard files\", // to paralelize group into batches\n-                  WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n-              .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n-              .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n-              .setCoder(\n-                  KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n-              .apply(\n-                  \"Import Batches\",\n-                  ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-\n-      input\n-          .getPipeline()\n-          .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n-          .apply(\n-              \"Resolve SubDirs\",\n-              MapElements.into(TypeDescriptors.strings())\n-                  .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n-          .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n-          .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n-          .apply(\n-              \"Match tempGcsPath\",\n-              FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n-          .apply(\n-              \"Delete tempGcsPath\",\n-              ParDo.of(\n-                  new DoFn<Metadata, Void>() {\n-                    @ProcessElement\n-                    public void delete(@Element Metadata path, ProcessContext context) {\n-                      // Wait til window closes for failedBodies and failedFiles to ensure we are\n-                      // done processing\n-                      // anything under tempGcsPath because it has been successfully imported to\n-                      // FHIR store or\n-                      // copies have been moved to the dead letter path.\n-                      // Clean up all of tempGcsPath. This will handle removing phantom temporary\n-                      // objects from\n-                      // failed / rescheduled ImportFn::importBatch.\n-                      try {\n-                        FileSystems.delete(\n-                            Collections.singleton(path.resourceId()),\n-                            StandardMoveOptions.IGNORE_MISSING_FILES);\n-                      } catch (IOException e) {\n-                        LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n-                      }\n-                    }\n-                  }))\n-          .setCoder(VoidCoder.of());\n+        /**\n+         * Gets content structure.\n+         *\n+         * @return the content structure\n+         */\n+        abstract Optional<FhirIO.Import.ContentStructure> getContentStructure();\n \n-      return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n-    }\n+        /**\n+         * Gets import gcs temp path.\n+         *\n+         * @return the import gcs temp path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsTempPath();\n \n-    /** The Write bundles to new line delimited json files. */\n-    static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n-\n-      private final ValueProvider<String> fhirStore;\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ObjectMapper mapper;\n-      private ResourceId resourceId;\n-      private WritableByteChannel ndJsonChannel;\n-      private BoundedWindow window;\n-\n-      private transient HealthcareApiClient client;\n-      private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n-\n-      WriteBundlesToFilesFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-      }\n-\n-      /**\n-       * Instantiates a new Import fn.\n-       *\n-       * @param fhirStore the fhir store\n-       * @param tempGcsPath the temp gcs path\n-       * @param deadLetterGcsPath the dead letter gcs path\n-       */\n-      WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n-        this.fhirStore = StaticValueProvider.of(fhirStore);\n-        this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n-        this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n-      }\n-\n-      /**\n-       * Init client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Init batch.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @StartBundle\n-      public void initFile() throws IOException {\n-        // Write each bundle to newline delimited JSON file.\n-        String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n-        ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n-        this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n-        this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n-        if (mapper == null) {\n-          this.mapper = new ObjectMapper();\n-        }\n-      }\n-\n-      /**\n-       * Add to batch.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @ProcessElement\n-      public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n-        this.window = window;\n-        String httpBody = context.element();\n-        try {\n-          // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n-          Object data = this.mapper.readValue(httpBody, Object.class);\n-          String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n-          this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n-        } catch (JsonProcessingException e) {\n-          String resource =\n-              String.format(\n-                  \"Failed to parse payload: %s as json at: %s : %s.\"\n-                      + \"Dropping message from batch import.\",\n-                  httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n-          LOG.warn(resource);\n-          context.output(\n-              Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+        /**\n+         * Gets import gcs dead letter path.\n+         *\n+         * @return the import gcs dead letter path\n+         */\n+        abstract Optional<ValueProvider<String>> getImportGcsDeadLetterPath();\n+\n+        /**\n+         * The type Builder.\n+         */\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+\n+            /**\n+             * Sets Fhir store.\n+             *\n+             * @param fhirStore the Fhir store\n+             * @return the Fhir store\n+             */\n+            abstract Builder setFhirStore(ValueProvider<String> fhirStore);\n+\n+            /**\n+             * Sets write method.\n+             *\n+             * @param writeMethod the write method\n+             * @return the write method\n+             */\n+            abstract Builder setWriteMethod(WriteMethod writeMethod);\n+\n+            /**\n+             * Sets content structure.\n+             *\n+             * @param contentStructure the content structure\n+             * @return the content structure\n+             */\n+            abstract Builder setContentStructure(FhirIO.Import.ContentStructure contentStructure);\n+\n+            /**\n+             * Sets import gcs temp path.\n+             *\n+             * @param gcsTempPath the gcs temp path\n+             * @return the import gcs temp path\n+             */\n+            abstract Builder setImportGcsTempPath(ValueProvider<String> gcsTempPath);\n+\n+            /**\n+             * Sets import gcs dead letter path.\n+             *\n+             * @param gcsDeadLetterPath the gcs dead letter path\n+             * @return the import gcs dead letter path\n+             */\n+            abstract Builder setImportGcsDeadLetterPath(ValueProvider<String> gcsDeadLetterPath);\n+\n+            /**\n+             * Build write.\n+             *\n+             * @return the write\n+             */\n+            abstract Write build();\n         }\n-      }\n-\n-      /**\n-       * Close file.\n-       *\n-       * @param context the context\n-       * @throws IOException the io exception\n-       */\n-      @FinishBundle\n-      public void closeFile(FinishBundleContext context) throws IOException {\n-        // Write the file with all elements in this bundle to GCS.\n-        ndJsonChannel.close();\n-        context.output(resourceId, window.maxTimestamp(), window);\n-      }\n-    }\n \n-    /** Import batches of new line delimited json files to FHIR Store. */\n-    static class ImportFn\n-        extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n-\n-      private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n-      private final ValueProvider<String> tempGcsPath;\n-      private final ValueProvider<String> deadLetterGcsPath;\n-      private ResourceId tempDir;\n-      private final ContentStructure contentStructure;\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> fhirStore;\n-\n-      ImportFn(\n-          ValueProvider<String> fhirStore,\n-          ValueProvider<String> tempGcsPath,\n-          ValueProvider<String> deadLetterGcsPath,\n-          @Nullable ContentStructure contentStructure) {\n-        this.fhirStore = fhirStore;\n-        this.tempGcsPath = tempGcsPath;\n-        this.deadLetterGcsPath = deadLetterGcsPath;\n-        if (contentStructure == null) {\n-          this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n-        } else {\n-          this.contentStructure = contentStructure;\n+        private static Write.Builder write(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder().setFhirStore(StaticValueProvider.of(fhirStore));\n         }\n-      }\n-\n-      @Setup\n-      public void init() throws IOException {\n-        tempDir =\n-            FileSystems.matchNewResource(tempGcsPath.get(), true)\n-                .resolve(\n-                    String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n-                    StandardResolveOptions.RESOLVE_DIRECTORY);\n-        client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Move files to a temporary subdir (to provide common prefix) to execute import with single\n-       * GCS URI.\n-       */\n-      @ProcessElement\n-      public void importBatch(\n-          @Element KV<Integer, Iterable<ResourceId>> element,\n-          OutputReceiver<HealthcareIOError<String>> output)\n-          throws IOException {\n-        Iterable<ResourceId> batch = element.getValue();\n-        List<ResourceId> tempDestinations = new ArrayList<>();\n-        List<ResourceId> deadLetterDestinations = new ArrayList<>();\n-        assert batch != null;\n-        for (ResourceId file : batch) {\n-          tempDestinations.add(\n-              tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n-          deadLetterDestinations.add(\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n-                  .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+\n+        /**\n+         * Create Method creates a single FHIR resource. @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/create></a>\n+         *\n+         * @param fhirStore         the hl 7 v 2 store\n+         * @param gcsTempPath       the gcs temp path\n+         * @param gcsDeadLetterPath the gcs dead letter path\n+         * @param contentStructure  the content structure\n+         * @return the write\n+         */\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsTempPath,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(StaticValueProvider.of(gcsTempPath))\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        // Ignore missing files since this might be a retry, which means files\n-        // should have been copied over.\n-        FileSystems.copy(\n-            ImmutableList.copyOf(batch),\n-            tempDestinations,\n-            StandardMoveOptions.IGNORE_MISSING_FILES);\n-        // Check whether any temporary files are not present.\n-        boolean hasMissingFile =\n-            FileSystems.matchResources(tempDestinations).stream()\n-                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n-        if (hasMissingFile) {\n-          throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+\n+        public static Write fhirStoresImport(\n+                String fhirStore,\n+                String gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsDeadLetterPath(StaticValueProvider.of(gcsDeadLetterPath))\n+                    .build();\n         }\n-        ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n-        try {\n-          // Blocking fhirStores.import request.\n-          assert contentStructure != null;\n-          Operation operation =\n-              client.importFhirResource(\n-                  fhirStore.get(), importUri.toString(), contentStructure.name());\n-          client.pollOperation(operation, 500L);\n-          // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n-          // needed.\n-          FileSystems.delete(tempDestinations);\n-        } catch (IOException | InterruptedException e) {\n-          ResourceId deadLetterResourceId =\n-              FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n-          LOG.warn(\n-              String.format(\n-                  \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n-                  importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n-          FileSystems.rename(tempDestinations, deadLetterDestinations);\n-          output.output(HealthcareIOError.of(importUri.toString(), e));\n-        } finally {\n-          // If we've reached this point files have either been successfully import to FHIR store\n-          // or moved to Dead Letter Queue.\n-          // Clean up original files for this batch on GCS.\n-          FileSystems.delete(ImmutableList.copyOf(batch));\n+\n+        public static Write fhirStoresImport(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> gcsTempPath,\n+                ValueProvider<String> gcsDeadLetterPath,\n+                FhirIO.Import.@Nullable ContentStructure contentStructure) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(Write.WriteMethod.IMPORT)\n+                    .setContentStructure(contentStructure)\n+                    .setImportGcsTempPath(gcsTempPath)\n+                    .setImportGcsDeadLetterPath(gcsDeadLetterPath)\n+                    .build();\n         }\n-      }\n-    }\n \n-    /** The enum Content structure. */\n-    public enum ContentStructure {\n-      /** If the content structure is not specified, the default value BUNDLE will be used. */\n-      CONTENT_STRUCTURE_UNSPECIFIED,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a bundle, which contains one or more resources. Set the bundle type to history to import\n-       * resource versions.\n-       */\n-      BUNDLE,\n-      /**\n-       * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n-       * a single resource.\n-       */\n-      RESOURCE,\n-      /** The entire file is one JSON bundle. The JSON can span multiple lines. */\n-      BUNDLE_PRETTY,\n-      /** The entire file is one JSON resource. The JSON can span multiple lines. */\n-      RESOURCE_PRETTY\n-    }\n-  }\n+        /**\n+         * Execute Bundle Method executes a batch of requests as a single transaction @see <a\n+         * href=https://cloud.google.com/healthcare/docs/reference/rest/v1beta1/projects.locations.datasets.fhirStores.fhir/executeBundle></a>.\n+         *\n+         * @param fhirStore the hl 7 v 2 store\n+         * @return the write\n+         */\n+        public static Write executeBundles(String fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(StaticValueProvider.of(fhirStore))\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-  /** The type Execute bundles. */\n-  public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Execute bundles write.\n+         *\n+         * @param fhirStore the fhir store\n+         * @return the write\n+         */\n+        public static Write executeBundles(ValueProvider<String> fhirStore) {\n+            return new AutoValue_FhirIO_Write.Builder()\n+                    .setFhirStore(fhirStore)\n+                    .setWriteMethod(WriteMethod.EXECUTE_BUNDLE)\n+                    .build();\n+        }\n \n-    /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n-    ExecuteBundles(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+        private static final Logger LOG = LoggerFactory.getLogger(Write.class);\n+\n+        @Override\n+        public Result expand(PCollection<String> input) {\n+            PCollection<HealthcareIOError<String>> failedBundles;\n+            PCollection<HealthcareIOError<String>> failedImports;\n+            switch (this.getWriteMethod()) {\n+                case IMPORT:\n+                    LOG.warn(\n+                            \"Make sure the Cloud Healthcare Service Agent has permissions when using import:\"\n+                                    + \" https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#fhir_store_cloud_storage_permissions\");\n+                    ValueProvider<String> deadPath =\n+                            getImportGcsDeadLetterPath().orElseThrow(IllegalArgumentException::new);\n+                    FhirIO.Import.ContentStructure contentStructure =\n+                            getContentStructure().orElseThrow(IllegalArgumentException::new);\n+                    ValueProvider<String> tempPath =\n+                            getImportGcsTempPath()\n+                                    .orElse(\n+                                            StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+                    return input.apply(new Import(getFhirStore(), tempPath, deadPath, contentStructure));\n+                case EXECUTE_BUNDLE:\n+                default:\n+                    failedBundles =\n+                            input\n+                                    .apply(\n+                                            \"Execute FHIR Bundles\",\n+                                            ParDo.of(new ExecuteBundles.ExecuteBundlesFn(this.getFhirStore())))\n+                                    .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+            return Result.in(input.getPipeline(), failedBundles);\n+        }\n     }\n \n     /**\n-     * Instantiates a new Execute bundles.\n-     *\n-     * @param fhirStore the fhir store\n+     * Writes each bundle of elements to a new-line delimited JSON file on GCS and issues a\n+     * fhirStores.import Request for that file. This is intended for batch use only to facilitate\n+     * large backfills to empty FHIR stores and should not be used with unbounded PCollections. If\n+     * your use case is streaming checkout using {@link ExecuteBundles} to more safely execute bundles\n+     * as transactions which is safer practice for a use on a \"live\" FHIR store.\n      */\n-    ExecuteBundles(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Import extends Write {\n \n-    @Override\n-    public FhirIO.Write.Result expand(PCollection<String> input) {\n-      return Write.Result.in(\n-          input.getPipeline(),\n-          input\n-              .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n-              .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n-    }\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> deadLetterGcsPath;\n+        private final ContentStructure contentStructure;\n+        private static final int DEFAULT_FILES_PER_BATCH = 10000;\n+        private static final Logger LOG = LoggerFactory.getLogger(Import.class);\n+        private ValueProvider<String> tempGcsPath;\n+\n+        /*\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore the fhir store\n+         * @param tempGcsPath the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure the content structure\n+         */\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> tempGcsPath,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = fhirStore;\n+            this.tempGcsPath = tempGcsPath;\n+            this.deadLetterGcsPath = deadLetterGcsPath;\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    /** The type Write Fhir fn. */\n-    static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n-\n-      private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n-      private transient HealthcareApiClient client;\n-      private final ObjectMapper mapper = new ObjectMapper();\n-      /** The Fhir store. */\n-      private final ValueProvider<String> fhirStore;\n-\n-      /**\n-       * Instantiates a new Write Fhir fn.\n-       *\n-       * @param fhirStore the Fhir store\n-       */\n-      ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      /**\n-       * Initialize healthcare client.\n-       *\n-       * @throws IOException the io exception\n-       */\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      /**\n-       * Execute Bundles.\n-       *\n-       * @param context the context\n-       */\n-      @ProcessElement\n-      public void executeBundles(ProcessContext context) {\n-        String body = context.element();\n-        try {\n-          // Validate that data was set to valid JSON.\n-          mapper.readTree(body);\n-          client.executeFhirBundle(fhirStore.get(), body);\n-        } catch (IOException | HealthcareHttpException e) {\n-          failedBundles.inc();\n-          context.output(HealthcareIOError.of(body, e));\n+        Import(\n+                ValueProvider<String> fhirStore,\n+                ValueProvider<String> deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this(fhirStore, null, deadLetterGcsPath, contentStructure);\n         }\n-      }\n-    }\n-  }\n \n-  /** Export FHIR resources from a FHIR store to new line delimited json files on GCS. */\n-  public static class Export extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> fhirStore;\n-    private final ValueProvider<String> exportGcsUriPrefix;\n+        /**\n+         * Instantiates a new Import.\n+         *\n+         * @param fhirStore         the fhir store\n+         * @param tempGcsPath       the temp gcs path\n+         * @param deadLetterGcsPath the dead letter gcs path\n+         * @param contentStructure  the content structure\n+         */\n+        Import(\n+                String fhirStore,\n+                String tempGcsPath,\n+                String deadLetterGcsPath,\n+                @Nullable ContentStructure contentStructure) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+            this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+            this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            if (contentStructure == null) {\n+                this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+            } else {\n+                this.contentStructure = contentStructure;\n+            }\n+        }\n \n-    public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n-      this.fhirStore = fhirStore;\n-      this.exportGcsUriPrefix = exportGcsUriPrefix;\n-    }\n+        @Override\n+        ValueProvider<String> getFhirStore() {\n+            return fhirStore;\n+        }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleExportOperations\",\n-              ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n-          .apply(FileIO.matchAll())\n-          .apply(FileIO.readMatches())\n-          .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n-    }\n+        @Override\n+        WriteMethod getWriteMethod() {\n+            return WriteMethod.IMPORT;\n+        }\n \n-    /** A function that schedules an export operation and monitors the status. */\n-    public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> exportGcsUriPrefix;\n-\n-      public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n-        this.exportGcsUriPrefix = exportGcsUriPrefix;\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void exportResourcesToGcs(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String fhirStore = context.element();\n-        String gcsPrefix = this.exportGcsUriPrefix.get();\n-        Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new RuntimeException(\n-              String.format(\"Export operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ContentStructure> getContentStructure() {\n+            return Optional.of(contentStructure);\n         }\n-        context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n-      }\n-    }\n-  }\n-\n-  /** Deidentify FHIR resources from a FHIR store to a destination FHIR store. */\n-  public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n-    private final ValueProvider<String> sourceFhirStore;\n-    private final ValueProvider<String> destinationFhirStore;\n-    private final ValueProvider<DeidentifyConfig> deidConfig;\n-\n-    public Deidentify(\n-        ValueProvider<String> sourceFhirStore,\n-        ValueProvider<String> destinationFhirStore,\n-        ValueProvider<DeidentifyConfig> deidConfig) {\n-      this.sourceFhirStore = sourceFhirStore;\n-      this.destinationFhirStore = destinationFhirStore;\n-      this.deidConfig = deidConfig;\n-    }\n \n-    @Override\n-    public PCollection<String> expand(PBegin input) {\n-      return input\n-          .getPipeline()\n-          .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n-          .apply(\n-              \"ScheduleDeidentifyFhirStoreOperations\",\n-              ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n-    }\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsTempPath() {\n+            return Optional.of(tempGcsPath);\n+        }\n \n-    /** A function that schedules a deidentify operation and monitors the status. */\n-    public static class DeidentifyFn extends DoFn<String, String> {\n-      private HealthcareApiClient client;\n-      private final ValueProvider<String> destinationFhirStore;\n-      private static final Gson gson = new Gson();\n-      private final String deidConfigJson;\n-\n-      public DeidentifyFn(\n-          ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n-        this.destinationFhirStore = destinationFhirStore;\n-        this.deidConfigJson = gson.toJson(deidConfig.get());\n-      }\n-\n-      @Setup\n-      public void initClient() throws IOException {\n-        this.client = new HttpHealthcareApiClient();\n-      }\n-\n-      @ProcessElement\n-      public void deidentify(ProcessContext context)\n-          throws IOException, InterruptedException, HealthcareHttpException {\n-        String sourceFhirStore = context.element();\n-        String destinationFhirStore = this.destinationFhirStore.get();\n-        DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n-        Operation operation =\n-            client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n-        operation = client.pollOperation(operation, 1000L);\n-        if (operation.getError() != null) {\n-          throw new IOException(\n-              String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+        @Override\n+        Optional<ValueProvider<String>> getImportGcsDeadLetterPath() {\n+            return Optional.of(deadLetterGcsPath);\n         }\n-        context.output(destinationFhirStore);\n-      }\n-    }\n-  }\n \n-  /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+        @Override\n+        public Write.Result expand(PCollection<String> input) {\n+            checkState(\n+                    input.isBounded() == IsBounded.BOUNDED,\n+                    \"FhirIO.Import should only be used on unbounded PCollections as it is\"\n+                            + \"intended for batch use only.\");\n+\n+            // fall back on pipeline's temp location.\n+            ValueProvider<String> tempPath =\n+                    getImportGcsTempPath()\n+                            .orElse(StaticValueProvider.of(input.getPipeline().getOptions().getTempLocation()));\n+\n+            // Write bundles of String to GCS\n+            PCollectionTuple writeTmpFileResults =\n+                    input.apply(\n+                            \"Write nd json to GCS\",\n+                            ParDo.of(new WriteBundlesToFilesFn(fhirStore, tempPath, deadLetterGcsPath))\n+                                    .withOutputTags(Write.TEMP_FILES, TupleTagList.of(Write.FAILED_BODY)));\n+\n+            PCollection<HealthcareIOError<String>> failedBodies =\n+                    writeTmpFileResults\n+                            .get(Write.FAILED_BODY)\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            int numShards = 100;\n+            PCollection<HealthcareIOError<String>> failedFiles =\n+                    writeTmpFileResults\n+                            .get(Write.TEMP_FILES)\n+                            .apply(\n+                                    \"Shard files\", // to paralelize group into batches\n+                                    WithKeys.of(elm -> ThreadLocalRandom.current().nextInt(0, numShards)))\n+                            .setCoder(KvCoder.of(TextualIntegerCoder.of(), ResourceIdCoder.of()))\n+                            .apply(\"Assemble File Batches\", GroupIntoBatches.ofSize(DEFAULT_FILES_PER_BATCH))\n+                            .setCoder(\n+                                    KvCoder.of(TextualIntegerCoder.of(), IterableCoder.of(ResourceIdCoder.of())))\n+                            .apply(\n+                                    \"Import Batches\",\n+                                    ParDo.of(new ImportFn(fhirStore, tempPath, deadLetterGcsPath, contentStructure)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+\n+            input\n+                    .getPipeline()\n+                    .apply(\"Instantiate Temp Path\", Create.ofProvider(tempPath, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"Resolve SubDirs\",\n+                            MapElements.into(TypeDescriptors.strings())\n+                                    .via((String path) -> path.endsWith(\"/\") ? path + \"*\" : path + \"/*\"))\n+                    .apply(\"Wait On File Writing\", Wait.on(failedBodies))\n+                    .apply(\"Wait On FHIR Importing\", Wait.on(failedFiles))\n+                    .apply(\n+                            \"Match tempGcsPath\",\n+                            FileIO.matchAll().withEmptyMatchTreatment(EmptyMatchTreatment.ALLOW))\n+                    .apply(\n+                            \"Delete tempGcsPath\",\n+                            ParDo.of(\n+                                    new DoFn<Metadata, Void>() {\n+                                        @ProcessElement\n+                                        public void delete(@Element Metadata path, ProcessContext context) {\n+                                            // Wait til window closes for failedBodies and failedFiles to ensure we are\n+                                            // done processing\n+                                            // anything under tempGcsPath because it has been successfully imported to\n+                                            // FHIR store or\n+                                            // copies have been moved to the dead letter path.\n+                                            // Clean up all of tempGcsPath. This will handle removing phantom temporary\n+                                            // objects from\n+                                            // failed / rescheduled ImportFn::importBatch.\n+                                            try {\n+                                                FileSystems.delete(\n+                                                        Collections.singleton(path.resourceId()),\n+                                                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                                            } catch (IOException e) {\n+                                                LOG.error(\"error cleaning up tempGcsDir: %s\", e);\n+                                            }\n+                                        }\n+                                    }))\n+                    .setCoder(VoidCoder.of());\n+\n+            return Write.Result.in(input.getPipeline(), failedBodies, failedFiles);\n+        }\n+\n+        /**\n+         * The Write bundles to new line delimited json files.\n+         */\n+        static class WriteBundlesToFilesFn extends DoFn<String, ResourceId> {\n+\n+            private final ValueProvider<String> fhirStore;\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ObjectMapper mapper;\n+            private ResourceId resourceId;\n+            private WritableByteChannel ndJsonChannel;\n+            private BoundedWindow window;\n+\n+            private transient HealthcareApiClient client;\n+            private static final Logger LOG = LoggerFactory.getLogger(WriteBundlesToFilesFn.class);\n+\n+            WriteBundlesToFilesFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+            }\n+\n+            /**\n+             * Instantiates a new Import fn.\n+             *\n+             * @param fhirStore         the fhir store\n+             * @param tempGcsPath       the temp gcs path\n+             * @param deadLetterGcsPath the dead letter gcs path\n+             */\n+            WriteBundlesToFilesFn(String fhirStore, String tempGcsPath, String deadLetterGcsPath) {\n+                this.fhirStore = StaticValueProvider.of(fhirStore);\n+                this.tempGcsPath = StaticValueProvider.of(tempGcsPath);\n+                this.deadLetterGcsPath = StaticValueProvider.of(deadLetterGcsPath);\n+            }\n+\n+            /**\n+             * Init client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Init batch.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @StartBundle\n+            public void initFile() throws IOException {\n+                // Write each bundle to newline delimited JSON file.\n+                String filename = String.format(\"fhirImportBatch-%s.ndjson\", UUID.randomUUID().toString());\n+                ResourceId tempDir = FileSystems.matchNewResource(this.tempGcsPath.get(), true);\n+                this.resourceId = tempDir.resolve(filename, StandardResolveOptions.RESOLVE_FILE);\n+                this.ndJsonChannel = FileSystems.create(resourceId, \"application/ld+json\");\n+                if (mapper == null) {\n+                    this.mapper = new ObjectMapper();\n+                }\n+            }\n+\n+            /**\n+             * Add to batch.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @ProcessElement\n+            public void addToFile(ProcessContext context, BoundedWindow window) throws IOException {\n+                this.window = window;\n+                String httpBody = context.element();\n+                try {\n+                    // This will error if not valid JSON an convert Pretty JSON to raw JSON.\n+                    Object data = this.mapper.readValue(httpBody, Object.class);\n+                    String ndJson = this.mapper.writeValueAsString(data) + \"\\n\";\n+                    this.ndJsonChannel.write(ByteBuffer.wrap(ndJson.getBytes(StandardCharsets.UTF_8)));\n+                } catch (JsonProcessingException e) {\n+                    String resource =\n+                            String.format(\n+                                    \"Failed to parse payload: %s as json at: %s : %s.\"\n+                                            + \"Dropping message from batch import.\",\n+                                    httpBody.toString(), e.getLocation().getCharOffset(), e.getMessage());\n+                    LOG.warn(resource);\n+                    context.output(\n+                            Write.FAILED_BODY, HealthcareIOError.of(httpBody, new IOException(resource)));\n+                }\n+            }\n+\n+            /**\n+             * Close file.\n+             *\n+             * @param context the context\n+             * @throws IOException the io exception\n+             */\n+            @FinishBundle\n+            public void closeFile(FinishBundleContext context) throws IOException {\n+                // Write the file with all elements in this bundle to GCS.\n+                ndJsonChannel.close();\n+                context.output(resourceId, window.maxTimestamp(), window);\n+            }\n+        }\n \n-    private final ValueProvider<String> fhirStore;\n+        /**\n+         * Import batches of new line delimited json files to FHIR Store.\n+         */\n+        static class ImportFn\n+                extends DoFn<KV<Integer, Iterable<ResourceId>>, HealthcareIOError<String>> {\n+\n+            private static final Logger LOG = LoggerFactory.getLogger(ImportFn.class);\n+            private final ValueProvider<String> tempGcsPath;\n+            private final ValueProvider<String> deadLetterGcsPath;\n+            private ResourceId tempDir;\n+            private final ContentStructure contentStructure;\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> fhirStore;\n+\n+            ImportFn(\n+                    ValueProvider<String> fhirStore,\n+                    ValueProvider<String> tempGcsPath,\n+                    ValueProvider<String> deadLetterGcsPath,\n+                    @Nullable ContentStructure contentStructure) {\n+                this.fhirStore = fhirStore;\n+                this.tempGcsPath = tempGcsPath;\n+                this.deadLetterGcsPath = deadLetterGcsPath;\n+                if (contentStructure == null) {\n+                    this.contentStructure = ContentStructure.CONTENT_STRUCTURE_UNSPECIFIED;\n+                } else {\n+                    this.contentStructure = contentStructure;\n+                }\n+            }\n+\n+            @Setup\n+            public void init() throws IOException {\n+                tempDir =\n+                        FileSystems.matchNewResource(tempGcsPath.get(), true)\n+                                .resolve(\n+                                        String.format(\"tmp-%s\", UUID.randomUUID().toString()),\n+                                        StandardResolveOptions.RESOLVE_DIRECTORY);\n+                client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Move files to a temporary subdir (to provide common prefix) to execute import with single\n+             * GCS URI.\n+             */\n+            @ProcessElement\n+            public void importBatch(\n+                    @Element KV<Integer, Iterable<ResourceId>> element,\n+                    OutputReceiver<HealthcareIOError<String>> output)\n+                    throws IOException {\n+                Iterable<ResourceId> batch = element.getValue();\n+                List<ResourceId> tempDestinations = new ArrayList<>();\n+                List<ResourceId> deadLetterDestinations = new ArrayList<>();\n+                assert batch != null;\n+                for (ResourceId file : batch) {\n+                    tempDestinations.add(\n+                            tempDir.resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                    deadLetterDestinations.add(\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true)\n+                                    .resolve(file.getFilename(), StandardResolveOptions.RESOLVE_FILE));\n+                }\n+                // Ignore missing files since this might be a retry, which means files\n+                // should have been copied over.\n+                FileSystems.copy(\n+                        ImmutableList.copyOf(batch),\n+                        tempDestinations,\n+                        StandardMoveOptions.IGNORE_MISSING_FILES);\n+                // Check whether any temporary files are not present.\n+                boolean hasMissingFile =\n+                        FileSystems.matchResources(tempDestinations).stream()\n+                                .anyMatch((MatchResult r) -> r.status() != Status.OK);\n+                if (hasMissingFile) {\n+                    throw new IllegalStateException(\"Not all temporary files are present for importing.\");\n+                }\n+                ResourceId importUri = tempDir.resolve(\"*\", StandardResolveOptions.RESOLVE_FILE);\n+                try {\n+                    // Blocking fhirStores.import request.\n+                    assert contentStructure != null;\n+                    Operation operation =\n+                            client.importFhirResource(\n+                                    fhirStore.get(), importUri.toString(), contentStructure.name());\n+                    client.pollOperation(operation, 500L);\n+                    // Clean up temp files on GCS as they we successfully imported to FHIR store and no longer\n+                    // needed.\n+                    FileSystems.delete(tempDestinations);\n+                } catch (IOException | InterruptedException e) {\n+                    ResourceId deadLetterResourceId =\n+                            FileSystems.matchNewResource(deadLetterGcsPath.get(), true);\n+                    LOG.warn(\n+                            String.format(\n+                                    \"Failed to import %s with error: %s. Moving to deadletter path %s\",\n+                                    importUri.toString(), e.getMessage(), deadLetterResourceId.toString()));\n+                    FileSystems.rename(tempDestinations, deadLetterDestinations);\n+                    output.output(HealthcareIOError.of(importUri.toString(), e));\n+                } finally {\n+                    // If we've reached this point files have either been successfully import to FHIR store\n+                    // or moved to Dead Letter Queue.\n+                    // Clean up original files for this batch on GCS.\n+                    FileSystems.delete(ImmutableList.copyOf(batch));\n+                }\n+            }\n+        }\n+\n+        /**\n+         * The enum Content structure.\n+         */\n+        public enum ContentStructure {\n+            /**\n+             * If the content structure is not specified, the default value BUNDLE will be used.\n+             */\n+            CONTENT_STRUCTURE_UNSPECIFIED,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a bundle, which contains one or more resources. Set the bundle type to history to import\n+             * resource versions.\n+             */\n+            BUNDLE,\n+            /**\n+             * The source file contains one or more lines of newline-delimited JSON (ndjson). Each line is\n+             * a single resource.\n+             */\n+            RESOURCE,\n+            /**\n+             * The entire file is one JSON bundle. The JSON can span multiple lines.\n+             */\n+            BUNDLE_PRETTY,\n+            /**\n+             * The entire file is one JSON resource. The JSON can span multiple lines.\n+             */\n+            RESOURCE_PRETTY\n+        }\n+    }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * The type Execute bundles.\n      */\n-    Search(ValueProvider<String> fhirStore) {\n-      this.fhirStore = fhirStore;\n+    public static class ExecuteBundles extends PTransform<PCollection<String>, Write.Result> {\n+        private final ValueProvider<String> fhirStore;\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiates a new Execute bundles.\n+         *\n+         * @param fhirStore the fhir store\n+         */\n+        ExecuteBundles(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        @Override\n+        public FhirIO.Write.Result expand(PCollection<String> input) {\n+            return Write.Result.in(\n+                    input.getPipeline(),\n+                    input\n+                            .apply(ParDo.of(new ExecuteBundlesFn(fhirStore)))\n+                            .setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of())));\n+        }\n+\n+        /**\n+         * The type Write Fhir fn.\n+         */\n+        static class ExecuteBundlesFn extends DoFn<String, HealthcareIOError<String>> {\n+\n+            private Counter failedBundles = Metrics.counter(ExecuteBundlesFn.class, \"failed-bundles\");\n+            private transient HealthcareApiClient client;\n+            private final ObjectMapper mapper = new ObjectMapper();\n+            /**\n+             * The Fhir store.\n+             */\n+            private final ValueProvider<String> fhirStore;\n+\n+            /**\n+             * Instantiates a new Write Fhir fn.\n+             *\n+             * @param fhirStore the Fhir store\n+             */\n+            ExecuteBundlesFn(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            /**\n+             * Initialize healthcare client.\n+             *\n+             * @throws IOException the io exception\n+             */\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            /**\n+             * Execute Bundles.\n+             *\n+             * @param context the context\n+             */\n+            @ProcessElement\n+            public void executeBundles(ProcessContext context) {\n+                String body = context.element();\n+                try {\n+                    // Validate that data was set to valid JSON.\n+                    mapper.readTree(body);\n+                    client.executeFhirBundle(fhirStore.get(), body);\n+                } catch (IOException | HealthcareHttpException e) {\n+                    failedBundles.inc();\n+                    context.output(HealthcareIOError.of(body, e));\n+                }\n+            }\n+        }\n     }\n \n     /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n+     * Export FHIR resources from a FHIR store to new line delimited json files on GCS.\n      */\n-    Search(String fhirStore) {\n-      this.fhirStore = StaticValueProvider.of(fhirStore);\n-    }\n+    public static class Export extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> fhirStore;\n+        private final ValueProvider<String> exportGcsUriPrefix;\n+\n+        public Export(ValueProvider<String> fhirStore, ValueProvider<String> exportGcsUriPrefix) {\n+            this.fhirStore = fhirStore;\n+            this.exportGcsUriPrefix = exportGcsUriPrefix;\n+        }\n \n-    /** The type Result. */\n-    public static class Result implements POutput, PInput {\n-      private PCollection<String> resources;\n-\n-      private PCollection<HealthcareIOError<String>> failedSearches;\n-      PCollectionTuple pct;\n-\n-      /**\n-       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n-       *\n-       * @param pct the pct\n-       * @return the search result\n-       * @throws IllegalArgumentException the illegal argument exception\n-       */\n-      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n-        if (pct.getAll()\n-                .keySet()\n-                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n-          return new FhirIO.Search.Result(pct);\n-        } else {\n-          throw new IllegalArgumentException(\n-                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n-                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .apply(Create.ofProvider(fhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleExportOperations\",\n+                            ParDo.of(new ExportResourcesToGcsFn(this.exportGcsUriPrefix)))\n+                    .apply(FileIO.matchAll())\n+                    .apply(FileIO.readMatches())\n+                    .apply(\"ReadResourcesFromFiles\", TextIO.readFiles());\n+        }\n+\n+        /**\n+         * A function that schedules an export operation and monitors the status.\n+         */\n+        public static class ExportResourcesToGcsFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> exportGcsUriPrefix;\n+\n+            public ExportResourcesToGcsFn(ValueProvider<String> exportGcsUriPrefix) {\n+                this.exportGcsUriPrefix = exportGcsUriPrefix;\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void exportResourcesToGcs(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String fhirStore = context.element();\n+                String gcsPrefix = this.exportGcsUriPrefix.get();\n+                Operation operation = client.exportFhirResourceToGcs(fhirStore, gcsPrefix);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new RuntimeException(\n+                            String.format(\"Export operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(String.format(\"%s/*\", gcsPrefix.replaceAll(\"/+$\", \"\")));\n+            }\n         }\n-      }\n-\n-      private Result(PCollectionTuple pct) {\n-        this.pct = pct;\n-        this.resources = pct.get(OUT);\n-        this.failedSearches =\n-                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n-      }\n-\n-      /**\n-       * Gets failed searches.\n-       *\n-       * @return the failed searches\n-       */\n-      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n-        return failedSearches;\n-      }\n-\n-      /**\n-       * Gets resources.\n-       *\n-       * @return the resources\n-       */\n-      public PCollection<String> getResources() {\n-        return resources;\n-      }\n-\n-      @Override\n-      public Pipeline getPipeline() {\n-        return this.pct.getPipeline();\n-      }\n-\n-      @Override\n-      public Map<TupleTag<?>, PValue> expand() {\n-        return ImmutableMap.of(OUT, resources);\n-      }\n-\n-      @Override\n-      public void finishSpecifyingOutput(\n-              String transformName, PInput input, PTransform<?, ?> transform) {}\n     }\n \n-    /** The tag for the main output of Fhir Messages. */\n-    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n-    /** The tag for the deadletter output of Fhir Messages. */\n-    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n-            new TupleTag<HealthcareIOError<String>>() {};\n+    /**\n+     * Deidentify FHIR resources from a FHIR store to a destination FHIR store.\n+     */\n+    public static class Deidentify extends PTransform<PBegin, PCollection<String>> {\n+        private final ValueProvider<String> sourceFhirStore;\n+        private final ValueProvider<String> destinationFhirStore;\n+        private final ValueProvider<DeidentifyConfig> deidConfig;\n+\n+        public Deidentify(\n+                ValueProvider<String> sourceFhirStore,\n+                ValueProvider<String> destinationFhirStore,\n+                ValueProvider<DeidentifyConfig> deidConfig) {\n+            this.sourceFhirStore = sourceFhirStore;\n+            this.destinationFhirStore = destinationFhirStore;\n+            this.deidConfig = deidConfig;\n+        }\n \n-    @Override\n-    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n-      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+        @Override\n+        public PCollection<String> expand(PBegin input) {\n+            return input\n+                    .getPipeline()\n+                    .apply(Create.ofProvider(sourceFhirStore, StringUtf8Coder.of()))\n+                    .apply(\n+                            \"ScheduleDeidentifyFhirStoreOperations\",\n+                            ParDo.of(new DeidentifyFn(destinationFhirStore, deidConfig)));\n+        }\n+\n+        /**\n+         * A function that schedules a deidentify operation and monitors the status.\n+         */\n+        public static class DeidentifyFn extends DoFn<String, String> {\n+            private HealthcareApiClient client;\n+            private final ValueProvider<String> destinationFhirStore;\n+            private static final Gson gson = new Gson();\n+            private final String deidConfigJson;\n+\n+            public DeidentifyFn(\n+                    ValueProvider<String> destinationFhirStore, ValueProvider<DeidentifyConfig> deidConfig) {\n+                this.destinationFhirStore = destinationFhirStore;\n+                this.deidConfigJson = gson.toJson(deidConfig.get());\n+            }\n+\n+            @Setup\n+            public void initClient() throws IOException {\n+                this.client = new HttpHealthcareApiClient();\n+            }\n+\n+            @ProcessElement\n+            public void deidentify(ProcessContext context)\n+                    throws IOException, InterruptedException, HealthcareHttpException {\n+                String sourceFhirStore = context.element();\n+                String destinationFhirStore = this.destinationFhirStore.get();\n+                DeidentifyConfig deidConfig = gson.fromJson(this.deidConfigJson, DeidentifyConfig.class);\n+                Operation operation =\n+                        client.deidentifyFhirStore(sourceFhirStore, destinationFhirStore, deidConfig);\n+                operation = client.pollOperation(operation, 1000L);\n+                if (operation.getError() != null) {\n+                    throw new IOException(\n+                            String.format(\"DeidentifyFhirStore operation (%s) failed.\", operation.getName()));\n+                }\n+                context.output(destinationFhirStore);\n+            }\n+        }\n     }\n \n     /**\n-     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n-     *\n-     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n-     * and search parameters, and fetches all matching resources based on the search criteria and\n-     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n-     * PCollection}*.\n-     *\n-     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n-     *\n-     * <ul>\n-     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n-     *       from the Fhir store.\n-     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n-     *       HealthcareIOError}* of failed searches from the Fhir store, with\n-     *       error message and stacktrace.\n-     * </ul>\n+     * The type Search.\n      */\n-    static class SearchResourcesJsonString\n-            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n-\n-      private final ValueProvider<String> fhirStore;\n-\n-      /** Instantiates a new Search Fhir resources DoFn. */\n-      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n-        this.fhirStore = fhirStore;\n-      }\n-\n-      @Override\n-      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n-        return new FhirIO.Search.Result(\n-                resourceIds.apply(\n-                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n-                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n-      }\n-\n-      /** DoFn for searching messages from the Fhir store with error handling. */\n-      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n-\n-        private Counter failedSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n-        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n-        private final Counter successfulSearches =\n-                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n-        private HealthcareApiClient client;\n+    public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+        private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n         private final ValueProvider<String> fhirStore;\n \n-        /** Instantiates a new Fhir resources search fn. */\n-        SearchResourcesFn(ValueProvider<String> fhirStore) {\n-          this.fhirStore = fhirStore;\n+        Search(ValueProvider<String> fhirStore) {\n+            this.fhirStore = fhirStore;\n+        }\n+\n+        Search(String fhirStore) {\n+            this.fhirStore = StaticValueProvider.of(fhirStore);\n+        }\n+\n+        public static class Result implements POutput, PInput {\n+            private PCollection<String> resources;\n+\n+            private PCollection<HealthcareIOError<String>> failedSearches;\n+            PCollectionTuple pct;\n+\n+            /**\n+             * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+             *\n+             * @param pct the pct\n+             * @return the search result\n+             * @throws IllegalArgumentException the illegal argument exception\n+             */\n+            static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+                if (pct.getAll()\n+                        .keySet()\n+                        .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+                    return new FhirIO.Search.Result(pct);\n+                } else {\n+                    throw new IllegalArgumentException(\n+                            \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                                    + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+                }\n+            }\n+\n+            private Result(PCollectionTuple pct) {\n+                this.pct = pct;\n+                this.resources = pct.get(OUT);\n+                this.failedSearches =\n+                        pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+            }\n+\n+            /**\n+             * Gets failed searches.\n+             *\n+             * @return the failed searches\n+             */\n+            public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+                return failedSearches;\n+            }\n+\n+            /**\n+             * Gets resources.\n+             *\n+             * @return the resources\n+             */\n+            public PCollection<String> getResources() {\n+                return resources;\n+            }\n+\n+            @Override\n+            public Pipeline getPipeline() {\n+                return this.pct.getPipeline();\n+            }\n+\n+            @Override\n+            public Map<TupleTag<?>, PValue> expand() {\n+                return ImmutableMap.of(OUT, resources);\n+            }\n+\n+            @Override\n+            public void finishSpecifyingOutput(\n+                    String transformName, PInput input, PTransform<?, ?> transform) {\n+            }\n         }\n \n         /**\n-         * Instantiate healthcare client.\n-         *\n-         * @throws IOException the io exception\n+         * The tag for the main output of Fhir Messages.\n          */\n-        @Setup\n-        public void instantiateHealthcareClient() throws IOException {\n-          this.client = new HttpHealthcareApiClient();\n+        public static final TupleTag<String> OUT = new TupleTag<String>() {\n+        };\n+        /**\n+         * The tag for the deadletter output of Fhir Messages.\n+         */\n+        public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+                new TupleTag<HealthcareIOError<String>>() {\n+                };\n+\n+        @Override\n+        public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+            return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n         }\n \n         /**\n-         * Process element.\n+         * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n          *\n-         * @param context the context\n+         * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+         * and search parameters, and fetches all matching resources based on the search criteria and\n+         * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+         * PCollection}*.\n+         *\n+         * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+         *\n+         * <ul>\n+         *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+         *       from the Fhir store.\n+         *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+         *       HealthcareIOError}* of failed searches from the Fhir store, with\n+         *       error message and stacktrace.\n+         * </ul>\n          */\n-        @ProcessElement\n-        public void processElement(ProcessContext context) {\n-          KV<String, Map<String, String>> elementValues = context.element();\n-          try {\n-            context.output(searchResources(\n-                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n-          } catch (Exception e) {\n-            failedSearches.inc();\n-            LOG.warn(\n-                    String.format(\n-                            \"Error search FHIR messages writing to Dead Letter \"\n-                                    + \"Queue. Cause: %s Stack Trace: %s\",\n-                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n-            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n-          }\n-        }\n-\n-        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n-                                       @Nullable Map<String, String> parameters)\n-                throws IllegalArgumentException {\n-          long startTime = System.currentTimeMillis();\n-\n-          HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n-                  new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n-                          client, fhirStore, resourceType, parameters);\n-          JsonArray result = new JsonArray();\n-          while (iter.hasNext()) {\n-            result.addAll(iter.next());\n-          }\n-          this.successfulSearches.inc();\n-          return result.toString();\n+        static class SearchResourcesJsonString\n+                extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+            private final ValueProvider<String> fhirStore;\n+\n+            public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+                this.fhirStore = fhirStore;\n+            }\n+\n+            @Override\n+            public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+                return new FhirIO.Search.Result(\n+                        resourceIds.apply(\n+                                ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                        .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+            }\n+\n+            /**\n+             * DoFn for searching messages from the Fhir store with error handling.\n+             */\n+            static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+                private Counter failedSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+                private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+                private final Counter successfulSearches =\n+                        Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+                private HealthcareApiClient client;\n+                private final ValueProvider<String> fhirStore;\n+\n+                /**\n+                 * Instantiates a new Fhir resources search fn.\n+                 */\n+                SearchResourcesFn(ValueProvider<String> fhirStore) {\n+                    this.fhirStore = fhirStore;\n+                }\n+\n+                /**\n+                 * Instantiate healthcare client.\n+                 *\n+                 * @throws IOException the io exception\n+                 */\n+                @Setup\n+                public void instantiateHealthcareClient() throws IOException {\n+                    this.client = new HttpHealthcareApiClient();\n+                }\n+\n+                /**\n+                 * Process element.\n+                 *\n+                 * @param context the context\n+                 */\n+                @ProcessElement\n+                public void processElement(ProcessContext context) {\n+                    KV<String, Map<String, String>> elementValues = context.element();\n+                    try {\n+                        context.output(searchResources(\n+                                this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+                    } catch (Exception e) {\n+                        failedSearches.inc();\n+                        LOG.warn(\n+                                String.format(\n+                                        \"Error search FHIR messages writing to Dead Letter \"\n+                                                + \"Queue. Cause: %s Stack Trace: %s\",\n+                                        e.getMessage(), Throwables.getStackTraceAsString(e)));\n+                        context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+                    }\n+                }\n+\n+                private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                               @Nullable Map<String, String> parameters)\n+                        throws IllegalArgumentException {\n+                    long startTime = System.currentTimeMillis();\n+\n+                    HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                            new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                                    client, fhirStore, resourceType, parameters);\n+                    JsonArray result = new JsonArray();\n+                    while (iter.hasNext()) {\n+                        result.addAll(iter.next());\n+                    }\n+                    this.successfulSearches.inc();\n+                    return result.toString();\n+                }\n+            }\n         }\n-      }\n     }\n-  }\n }\n"}}, {"oid": "4f064d194901704793a0c364e8bda0a3ccb44a9d", "url": "https://github.com/apache/beam/commit/4f064d194901704793a0c364e8bda0a3ccb44a9d", "message": "Reformatting and comments", "committedDate": "2020-11-24T19:47:22Z", "type": "commit"}, {"oid": "58fee42168b6bf1f3b573ce843637a745e6f2897", "url": "https://github.com/apache/beam/commit/58fee42168b6bf1f3b573ce843637a745e6f2897", "message": "Reformatting and comments", "committedDate": "2020-11-25T18:49:53Z", "type": "commit"}, {"oid": "c7fdba8e85f8edaafd80d9f0292311f8b8982d42", "url": "https://github.com/apache/beam/commit/c7fdba8e85f8edaafd80d9f0292311f8b8982d42", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-11-25T18:50:59Z", "type": "commit"}, {"oid": "c27ab33750edd54818d6293ff19d7a5f0cbc9ddf", "url": "https://github.com/apache/beam/commit/c27ab33750edd54818d6293ff19d7a5f0cbc9ddf", "message": "Merge branch 'master' into master", "committedDate": "2020-11-30T19:11:54Z", "type": "commit"}, {"oid": "f5ac2a19bcc94982d5813d6d03c318bb82a5228e", "url": "https://github.com/apache/beam/commit/f5ac2a19bcc94982d5813d6d03c318bb82a5228e", "message": "Fix library import errors from the newly merged DICOM code", "committedDate": "2020-11-30T20:20:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIzMzU5NQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r534233595", "bodyText": "Note that this test has failed (https://ci-beam.apache.org/job/beam_PreCommit_Java_Commit/14889/testReport/junit/org.apache.beam.sdk.io.gcp.healthcare/FhirIOTest/test_FhirIO_failedSearches/) - please fix", "author": "pabloem", "createdAt": "2020-12-02T14:58:58Z", "path": "sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIOTest.java", "diffHunk": "@@ -58,6 +56,25 @@ public void test_FhirIO_failedReads() {\n     pipeline.run();\n   }\n \n+  @Test\n+  public void test_FhirIO_failedSearches() {", "originalCommit": "f5ac2a19bcc94982d5813d6d03c318bb82a5228e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2Mzg4OQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r534563889", "bodyText": "Done, looks like it's passing now (I'm not sure why Java PreCommit is marked as failed but there's no test failures when I open the details page, only warnings?)", "author": "janeliulwq", "createdAt": "2020-12-02T23:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIzMzU5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "5c18a993aa9e300411eb72b4e21b9672027462b5", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIOTest.java b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIOTest.java\nindex ad071a4f00..809ab406f1 100644\n--- a/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIOTest.java\n+++ b/sdks/java/io/google-cloud-platform/src/test/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIOTest.java\n\n@@ -60,15 +59,15 @@ public class FhirIOTest {\n   public void test_FhirIO_failedSearches() {\n     List<KV<String, Map<String, String>>> input = Arrays.asList(KV.of(\"resource-type-1\", null));\n     FhirIO.Search.Result searchResult =\n-            pipeline.apply(Create.of(input)).apply(FhirIO.searchResources(\"bad-store\"));\n+        pipeline.apply(Create.of(input)).apply(FhirIO.searchResources(\"bad-store\"));\n \n     PCollection<HealthcareIOError<String>> failed = searchResult.getFailedSearches();\n \n     PCollection<String> resources = searchResult.getResources();\n \n     PCollection<String> failedMsgIds =\n-            failed.apply(\n-                    MapElements.into(TypeDescriptors.strings()).via(HealthcareIOError::getDataResource));\n+        failed.apply(\n+            MapElements.into(TypeDescriptors.strings()).via(HealthcareIOError::getDataResource));\n \n     PAssert.that(failedMsgIds).containsInAnyOrder(Arrays.asList(\"bad-store\"));\n     PAssert.that(resources).empty();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MTkzMQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r534341931", "bodyText": "I had recommended using async calls. In this case, I see that the calls happen within the iterator. I think this is fine as it is. I have a question though:\nUsually, will one element often produce one result from the iterator? Or usually more than one? I see that in lines 1608:1609, for the first iteration, there will be two calls to Fhir (one in hasNext, and one in next). Is it possible to try to reduce this to one?\nI expect your connector to have a bottleneck on IO. I would recommend you add a distribution-type metric to track time spent on IO.", "author": "pabloem", "createdAt": "2020-12-02T17:17:24Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java", "diffHunk": "@@ -1388,4 +1410,208 @@ public void deidentify(ProcessContext context)\n       }\n     }\n   }\n+\n+  /** The type Search. */\n+  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+    private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n+\n+    private final ValueProvider<String> fhirStore;\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(ValueProvider<String> fhirStore) {\n+      this.fhirStore = fhirStore;\n+    }\n+\n+    /**\n+     * Instantiates a new Search.\n+     *\n+     * @param fhirStore the fhir store\n+     */\n+    Search(String fhirStore) {\n+      this.fhirStore = StaticValueProvider.of(fhirStore);\n+    }\n+\n+    /** The type Result. */\n+    public static class Result implements POutput, PInput {\n+      private PCollection<String> resources;\n+\n+      private PCollection<HealthcareIOError<String>> failedSearches;\n+      PCollectionTuple pct;\n+\n+      /**\n+       * Create FhirIO.Search.Result form PCollectionTuple with OUT and DEAD_LETTER tags.\n+       *\n+       * @param pct the pct\n+       * @return the search result\n+       * @throws IllegalArgumentException the illegal argument exception\n+       */\n+      static FhirIO.Search.Result of(PCollectionTuple pct) throws IllegalArgumentException {\n+        if (pct.getAll()\n+                .keySet()\n+                .containsAll((Collection<?>) TupleTagList.of(OUT).and(DEAD_LETTER))) {\n+          return new FhirIO.Search.Result(pct);\n+        } else {\n+          throw new IllegalArgumentException(\n+                  \"The PCollection tuple must have the FhirIO.Search.OUT \"\n+                          + \"and FhirIO.Search.DEAD_LETTER tuple tags\");\n+        }\n+      }\n+\n+      private Result(PCollectionTuple pct) {\n+        this.pct = pct;\n+        this.resources = pct.get(OUT);\n+        this.failedSearches =\n+                pct.get(DEAD_LETTER).setCoder(HealthcareIOErrorCoder.of(StringUtf8Coder.of()));\n+      }\n+\n+      /**\n+       * Gets failed searches.\n+       *\n+       * @return the failed searches\n+       */\n+      public PCollection<HealthcareIOError<String>> getFailedSearches() {\n+        return failedSearches;\n+      }\n+\n+      /**\n+       * Gets resources.\n+       *\n+       * @return the resources\n+       */\n+      public PCollection<String> getResources() {\n+        return resources;\n+      }\n+\n+      @Override\n+      public Pipeline getPipeline() {\n+        return this.pct.getPipeline();\n+      }\n+\n+      @Override\n+      public Map<TupleTag<?>, PValue> expand() {\n+        return ImmutableMap.of(OUT, resources);\n+      }\n+\n+      @Override\n+      public void finishSpecifyingOutput(\n+              String transformName, PInput input, PTransform<?, ?> transform) {}\n+    }\n+\n+    /** The tag for the main output of Fhir Messages. */\n+    public static final TupleTag<String> OUT = new TupleTag<String>() {};\n+    /** The tag for the deadletter output of Fhir Messages. */\n+    public static final TupleTag<HealthcareIOError<String>> DEAD_LETTER =\n+            new TupleTag<HealthcareIOError<String>>() {};\n+\n+    @Override\n+    public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> input) {\n+      return input.apply(\"Fetch Fhir messages\", new SearchResourcesJsonString(this.fhirStore));\n+    }\n+\n+    /**\n+     * DoFn to fetch resources from an Google Cloud Healthcare FHIR store based on search request\n+     *\n+     * <p>This DoFn consumes a {@link PCollection} of search requests consisting of resource type\n+     * and search parameters, and fetches all matching resources based on the search criteria and\n+     * will output a {@link PCollectionTuple} which contains the output and dead-letter {@link\n+     * PCollection}*.\n+     *\n+     * <p>The {@link PCollectionTuple} output will contain the following {@link PCollection}:\n+     *\n+     * <ul>\n+     *   <li>{@link FhirIO.Search#OUT} - Contains all {@link PCollection} records successfully search\n+     *       from the Fhir store.\n+     *   <li>{@link FhirIO.Search#DEAD_LETTER} - Contains all {@link PCollection} of {@link\n+     *       HealthcareIOError}* of failed searches from the Fhir store, with\n+     *       error message and stacktrace.\n+     * </ul>\n+     */\n+    static class SearchResourcesJsonString\n+            extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+\n+      private final ValueProvider<String> fhirStore;\n+\n+      /** Instantiates a new Search Fhir resources DoFn. */\n+      public SearchResourcesJsonString(ValueProvider<String> fhirStore) {\n+        this.fhirStore = fhirStore;\n+      }\n+\n+      @Override\n+      public FhirIO.Search.Result expand(PCollection<KV<String, Map<String, String>>> resourceIds) {\n+        return new FhirIO.Search.Result(\n+                resourceIds.apply(\n+                        ParDo.of(new SearchResourcesFn(this.fhirStore))\n+                                .withOutputTags(FhirIO.Search.OUT, TupleTagList.of(FhirIO.Search.DEAD_LETTER))));\n+      }\n+\n+      /** DoFn for searching messages from the Fhir store with error handling. */\n+      static class SearchResourcesFn extends DoFn<KV<String, Map<String, String>>, String> {\n+\n+        private Counter failedSearches =\n+                Metrics.counter(SearchResourcesFn.class, \"failed-fhir-searches\");\n+        private static final Logger LOG = LoggerFactory.getLogger(SearchResourcesFn.class);\n+        private final Counter successfulSearches =\n+                Metrics.counter(SearchResourcesFn.class, \"successful-fhir-searches\");\n+        private HealthcareApiClient client;\n+        private final ValueProvider<String> fhirStore;\n+\n+        /** Instantiates a new Fhir resources search fn. */\n+        SearchResourcesFn(ValueProvider<String> fhirStore) {\n+          this.fhirStore = fhirStore;\n+        }\n+\n+        /**\n+         * Instantiate healthcare client.\n+         *\n+         * @throws IOException the io exception\n+         */\n+        @Setup\n+        public void instantiateHealthcareClient() throws IOException {\n+          this.client = new HttpHealthcareApiClient();\n+        }\n+\n+        /**\n+         * Process element.\n+         *\n+         * @param context the context\n+         */\n+        @ProcessElement\n+        public void processElement(ProcessContext context) {\n+          KV<String, Map<String, String>> elementValues = context.element();\n+          try {\n+            context.output(searchResources(\n+                    this.client, this.fhirStore.toString(), elementValues.getKey(), elementValues.getValue()));\n+          } catch (Exception e) {\n+            failedSearches.inc();\n+            LOG.warn(\n+                    String.format(\n+                            \"Error search FHIR messages writing to Dead Letter \"\n+                                    + \"Queue. Cause: %s Stack Trace: %s\",\n+                            e.getMessage(), Throwables.getStackTraceAsString(e)));\n+            context.output(FhirIO.Search.DEAD_LETTER, HealthcareIOError.of(this.fhirStore.toString(), e));\n+          }\n+        }\n+\n+        private String searchResources(HealthcareApiClient client, String fhirStore, String resourceType,\n+                                       @Nullable Map<String, String> parameters)\n+                throws IllegalArgumentException {\n+          long startTime = System.currentTimeMillis();\n+\n+          HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator iter =\n+                  new HttpHealthcareApiClient.FhirResourcePages.FhirResourcePagesIterator(\n+                          client, fhirStore, resourceType, parameters);\n+          JsonArray result = new JsonArray();\n+          while (iter.hasNext()) {\n+            result.addAll(iter.next());\n+          }\n+          this.successfulSearches.inc();\n+          return result.toString();", "originalCommit": "ba1ef19f6215ca496fae9003b17b55f027bf9e35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2MzkwMA==", "url": "https://github.com/apache/beam/pull/13395#discussion_r534563900", "bodyText": "I think for our use case, usually only one result will be produced from the iterator. Definitely makes sense to avoid one of the two calls, done.\nI assume you are talking about adding metrics on our end, but lmk if I misunderstood and there's anything to be added here. Thanks!", "author": "janeliulwq", "createdAt": "2020-12-02T23:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MTkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1Nzg2NQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r535357865", "bodyText": "in this case I mean something like:\nprivate Distribution searchLatency =\n            Metrics.distribution(SearchResourcesFn.class, \"search-latency-or-something-ms\");\n.....\n    long startTime = System.currentTimeMillis();\n    ...\n    result.addAll(iter.next());\n    while (iter.hasNext()) {\n      result.addAll(iter.next());\n    }\n    searchLatency.update(System.currentTimeMillis() - startTime);  // Report latency to Dataflow monitoring for later inspection", "author": "pabloem", "createdAt": "2020-12-03T15:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MTkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3MTgzOQ==", "url": "https://github.com/apache/beam/pull/13395#discussion_r535371839", "bodyText": "Ah got it, thank you for the pointers! Done.", "author": "janeliulwq", "createdAt": "2020-12-03T16:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MTkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5c18a993aa9e300411eb72b4e21b9672027462b5", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\nindex 9c0d0e409d..6d5af808dc 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/healthcare/FhirIO.java\n\n@@ -1412,30 +1408,20 @@ public class FhirIO {\n   }\n \n   /** The type Search. */\n-  public static class Search extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n+  public static class Search\n+      extends PTransform<PCollection<KV<String, Map<String, String>>>, FhirIO.Search.Result> {\n     private static final Logger LOG = LoggerFactory.getLogger(Search.class);\n \n     private final ValueProvider<String> fhirStore;\n \n-    /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n     Search(ValueProvider<String> fhirStore) {\n       this.fhirStore = fhirStore;\n     }\n \n-    /**\n-     * Instantiates a new Search.\n-     *\n-     * @param fhirStore the fhir store\n-     */\n     Search(String fhirStore) {\n       this.fhirStore = StaticValueProvider.of(fhirStore);\n     }\n \n-    /** The type Result. */\n     public static class Result implements POutput, PInput {\n       private PCollection<String> resources;\n \n"}}, {"oid": "5c18a993aa9e300411eb72b4e21b9672027462b5", "url": "https://github.com/apache/beam/commit/5c18a993aa9e300411eb72b4e21b9672027462b5", "message": "Spotless + failing tests", "committedDate": "2020-12-02T21:30:35Z", "type": "commit"}, {"oid": "b72cee03db9faf40d16e544a5596fd0da15d6af1", "url": "https://github.com/apache/beam/commit/b72cee03db9faf40d16e544a5596fd0da15d6af1", "message": "Spotless + failing tests", "committedDate": "2020-12-02T22:53:03Z", "type": "commit"}, {"oid": "7a37060d628795e293f89207a6fb2e647bc41608", "url": "https://github.com/apache/beam/commit/7a37060d628795e293f89207a6fb2e647bc41608", "message": "Merge branch 'master' of https://github.com/janeliulwq/beam", "committedDate": "2020-12-02T22:59:10Z", "type": "commit"}, {"oid": "66fe586e34580be8ab9707687cba54aaaf84d8dd", "url": "https://github.com/apache/beam/commit/66fe586e34580be8ab9707687cba54aaaf84d8dd", "message": "Add distribution metric for latency", "committedDate": "2020-12-03T16:09:49Z", "type": "commit"}, {"oid": "08da34baa66a2ab9718e8f174db0a6c10c9e0991", "url": "https://github.com/apache/beam/commit/08da34baa66a2ab9718e8f174db0a6c10c9e0991", "message": "Reformatted", "committedDate": "2020-12-03T19:45:32Z", "type": "commit"}, {"oid": "065bc7679d822229b00347b53720e8d393ab5d9d", "url": "https://github.com/apache/beam/commit/065bc7679d822229b00347b53720e8d393ab5d9d", "message": "Revert star imports", "committedDate": "2020-12-04T21:18:28Z", "type": "commit"}, {"oid": "376e0d5b3c57ec5e37bf73cf6bf4622eae8f3b32", "url": "https://github.com/apache/beam/commit/376e0d5b3c57ec5e37bf73cf6bf4622eae8f3b32", "message": "Reapply spotless", "committedDate": "2020-12-04T21:20:35Z", "type": "commit"}, {"oid": "94c80052f6ddc5896b78faf20734fd631773acf1", "url": "https://github.com/apache/beam/commit/94c80052f6ddc5896b78faf20734fd631773acf1", "message": "Use vendored guava", "committedDate": "2020-12-04T22:27:30Z", "type": "commit"}, {"oid": "4218b7d1f791e205eb53a60b204a7c46ccaec961", "url": "https://github.com/apache/beam/commit/4218b7d1f791e205eb53a60b204a7c46ccaec961", "message": "Switch FhirSearchIT from streaming pipeline to batch", "committedDate": "2020-12-08T18:49:06Z", "type": "commit"}, {"oid": "958ab09132b1f93f65e925f217c38a7859b86131", "url": "https://github.com/apache/beam/commit/958ab09132b1f93f65e925f217c38a7859b86131", "message": "Limit # of searches during test", "committedDate": "2020-12-08T21:01:01Z", "type": "commit"}]}